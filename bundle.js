/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js!./src/styles.css":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/styles.css ***!
  \**************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/getUrl.js */ \"./node_modules/css-loader/dist/runtime/getUrl.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);\n// Imports\n\n\n\nvar ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(/*! data:image/svg+xml;charset=UTF-8,%3csvg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 24 24%27 fill=%27none%27 stroke=%27%23999%27 stroke-width=%272%27 stroke-linecap=%27round%27 stroke-linejoin=%27round%27%3e%3cpolyline points=%276 9 12 15 18 9%27%3e%3c/polyline%3e%3c/svg%3e */ \"data:image/svg+xml;charset=UTF-8,%3csvg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 24 24%27 fill=%27none%27 stroke=%27%23999%27 stroke-width=%272%27 stroke-linecap=%27round%27 stroke-linejoin=%27round%27%3e%3cpolyline points=%276 9 12 15 18 9%27%3e%3c/polyline%3e%3c/svg%3e\"), __webpack_require__.b);\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\nvar ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `\n* {\n  box-sizing: border-box;\n  margin: 0;\n  padding: 0;\n  outline: none;\n}\n\n/* Alternatively, target specific elements */\nbutton:focus, a:focus, input:focus, select:focus, textarea:focus {\n  outline: none;\n}\n\nhtml, body {\n  margin: 0;\n  padding: 0;\n  background: #000;\n  color: #fff;\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n  overflow-x: hidden;\n  height: 100%;\n}\n\n/* Header */\n.header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: 16px;\n  height: 64px;\n  min-height: 64px; /* Enforce minimum height */\n  background: #000;\n  position: sticky;\n  top: 0;\n  z-index: 100;\n}\n\n.logo-container {\n  display: flex;\n  align-items: center;\n  cursor: pointer;\n  flex-shrink: 0; /* Prevent logo from shrinking */\n  min-width: 32px; /* Ensure minimum width */\n}\n\n/* Ensure logo SVG maintains size */\n.logo-container svg {\n  width: 32px;\n  height: 32px;\n  min-width: 32px;\n  min-height: 32px;\n}\n\n.search-input {\n  font-family: 'Menlo', 'Monaco', 'Courier New', monospace;\n  margin-left: 10px;\n  background: transparent;\n  border: 1px solid #2d2d2d;\n  color: #555;\n  padding: 8px 16px;\n  flex-grow: 1;\n  margin-right: 16px;\n  font-size: 12px;\n  border-radius: 35px;\n  outline: none;\n  max-width: calc(100% - 200px);\n  min-width: 116px;\n}\n\n.search-input:focus {\n  color: rgb(217, 217, 217);\n  border-color: #363636;\n}\n\n.zoom-controls {\n  display: flex;\n  gap: 4px;\n}\n\n.zoom-btn {\n  background: transparent;\n  border: none;\n  color: #666666;\n  width: 28px;\n  height: 28px;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  font-size: 14px;\n  cursor: pointer;\n  user-select: none;\n  transition: color 0.2s;\n}\n\n.zoom-btn:hover {\n  color: #fff;\n}\n\n.create-shape-btn{\n  background-color: rgb(26, 26, 26);\n  color: rgb(255, 255, 255);\n  border: none;\n  border-radius: 30px;\n  margin-right: 8px;\n  padding: 8px 16px;\n  font-size: 14px;\n  font-family: 'Menlo', 'Monaco', 'Courier New', monospace;\n  cursor: pointer;\n  display: flex;\n  align-items: center;\n  gap: 6px;\n  transition: background-color 0.2s;\n}\n\n.create-shape-btn:hover {\n  background-color: rgb(42, 42, 42);\n}\n\n.create-shape-btn svg {\n  width: 14px;\n  height: 14px;\n}\n\n.category-pills-container {\n  display: flex !important;\n  flex-wrap: nowrap !important; /* Prevent wrapping to new lines */\n  overflow-x: auto !important; /* Enable horizontal scrolling */\n  padding: 16px !important;\n  gap: 8px !important;\n  justify-content: flex-start !important; /* Start from left */\n  scrollbar-width: none; /* Hide scrollbar for Firefox */\n  -ms-overflow-style: none; /* Hide scrollbar for IE and Edge */\n}\n\n/* Hide scrollbar for Chrome, Safari and Opera */\n.category-pills-container::-webkit-scrollbar {\n  display: none;\n}\n\n/* Ensure consistent size for category pills to fit properly */\n.category-pill {\n  flex: 0 0 auto !important; /* Don't allow pills to grow or shrink */\n  white-space: nowrap !important; /* Prevent text wrapping */\n}\n\n/* Add these to your styles.css */\n.grid {\n  display: grid;\n  grid-template-columns: repeat(4, 1fr); /* Default, changed by JS */\n  gap: 20px !important; /* Increase gap between grid items */\n  padding: 20px !important;\n}\n\n\n\n.shape-container {\n  aspect-ratio: 1;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  cursor: pointer;\n  overflow: hidden;\n  background: #000;\n  transition: background 0.2s ease;\n}\n\n.shape-container.highlight {\n  background: #222;\n  animation: pulse 1s ease-out;\n}\n\n@keyframes pulse {\n  0% { background: #333; }\n  100% { background: #111; }\n}\n\n/* SVG styling */\nsvg {\n  display: block;\n  width: 100%;\n  height: 100%;\n}\n\n.shape-container.error {\n  opacity: 0.3;\n}\n\n/* Editor styling */\n.editor {\n  height: calc(100vh - 42px);\n  padding: 0;\n  transition: opacity 0.3s ease-in-out;\n}\n\n.control-button:hover {\n  background-color: #282828;\n}\n\n.transition-overlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background-color: black;\n  opacity: 0.5;\n  z-index: 1000;\n  pointer-events: none;\n  transition: opacity 0.3s ease;\n}\n\n/* Model Export */\n\n/* Export modal styles */\n.modal {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background-color: rgba(0, 0, 0, 0.7);\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  z-index: 1000;\n  backdrop-filter: blur(3px);\n}\n\n.modal-content {\n  background-color: #1A1A1A;\n  border-radius: 8px;\n  padding: 24px;\n  width: 420px;\n  max-width: 90%;\n  color: #e0e0e0;\n  font-family: 'Menlo', 'Monaco', 'Courier New', monospace;\n  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);\n}\n\n.modal-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: 16px;\n  padding-bottom: 12px;\n}\n\n.modal-header h3 {\n  margin: 0;\n  font-size: 18px;\n  font-weight: normal;\n  color: #e0e0e0;\n}\n\n.close-button {\n  background-color: transparent;\n  border: none;\n  cursor: pointer;\n  padding: 4px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  opacity: 0.7;\n  transition: opacity 0.2s;\n}\n\n.close-button:hover {\n  opacity: 1;\n}\n\n.form-group {\n  margin-bottom: 16px;\n}\n\n.form-group label {\n  display: block;\n  margin-bottom: 8px;\n  font-size: 12px;\n  color: #999;\n  text-transform: uppercase;\n  letter-spacing: 0.5px;\n}\n\n.form-group select {\n  width: 100%;\n  background-color: #000;\n  color: #e0e0e0;\n  border: 1px solid #333;\n  border-radius: 4px;\n  padding: 8px;\n  font-family: 'Menlo', 'Monaco', 'Courier New', monospace;\n  font-size: 12px;\n  appearance: none;\n  background-image: url(${___CSS_LOADER_URL_REPLACEMENT_0___});\n  background-repeat: no-repeat;\n  background-position: right 8px center;\n  background-size: 16px;\n  transition: border-color 0.2s;\n}\n\n.form-group select:focus {\n  outline: none;\n  border-color: #444;\n}\n\n.form-group select option {\n  background-color: #000;\n  color: #e0e0e0;\n}\n\n.form-group select option:disabled {\n  color: #666;\n}\n\nbutton[type=\"submit\"] {\n  background-color: #333;\n  color: #e0e0e0;\n  border: none;\n  border-radius: 30px;\n  padding: 8px 16px;\n  cursor: pointer;\n  font-family: 'Menlo', 'Monaco', 'Courier New', monospace;\n  font-size: 12px;\n  min-width: 100px;\n  transition: background-color 0.2s;\n}\n\nbutton[type=\"submit\"]:hover {\n  background-color: #444;\n}\n\n/* Animation for modal appearance */\n@keyframes fadeIn {\n  from { opacity: 0; }\n  to { opacity: 1; }\n}\n\n\n.modal {\n  animation: fadeIn 0.2s ease-out;\n}\n\n/* Make highlight more visible */\n.shape-container.highlight {\n  background: #333;\n  box-shadow: 0 0 15px rgba(255, 255, 255, 0.2);\n  z-index: 10;\n  position: relative;\n}\n\n.editor-layout {\n  display: grid;\n  grid-template-columns: 3fr 1fr;\n  grid-template-rows: auto 1fr;\n  grid-template-areas:\n    \"nav nav\"\n    \"preview params\";\n  height: 100%;\n}\n\n.editor-layout {\n  overflow: hidden;\n}\n\n#grid.editor {\n  height: 100vh; /* Already in your CSS */\n  overflow: hidden;\n}\n\n.nav-bar {\n  grid-area: nav;\n  background: #000;\n  display: flex;\n  align-items: center;\n  height: 32px;\n}\n\n.back-btn {\n  background: transparent;\n  width: 16px;\n  height: 16px;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  font-size: 14px;\n  cursor: pointer;\n  transition: color 0.2s;\n}\n\n.back-btn:hover {\n  color: white;\n}\n\n\n\n/* Bookmark & Back button styling */\n.bookmark-btn,\n.back-btn,\n.icon-button {\n  position: relative;\n  background: transparent;\n  color: #666666;\n  width: 30px;\n  height: 30px;\n  border-radius: 50%;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  cursor: pointer;\n  transition: color 0.2s;\n}\n\n.bookmark-btn svg path,\n.icon-button svg path,\n.back-btn svg path {\n  transition: stroke 0.2s;\n}\n\n.bookmark-btn:hover,\n.icon-button:hover,\n.back-btn:hover {\n  color: white; /* This will be inherited by stroke if using \\`currentColor\\` */\n}\n\n.bookmark-btn:hover svg path,\n.icon-button:hover svg path,\n.back-btn:hover svg path {\n  stroke: white; /* Ensure the stroke changes */\n}\n\n\n\n/* Favorites overlay styling */\n.favorites-overlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background-color: rgba(0, 0, 0, 1.0);\n  z-index: 1000;\n  display: none;\n  justify-content: center;\n  align-items: center;\n  padding: 24px;\n}\n\n.favorites-content {\n  border-radius: 8px;\n  width: 90%;\n  max-width: 800px;\n  max-height: 80vh;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n}\n\n.favorites-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: 16px 20px;\n}\n\n#favoritesGrid {\n  display: grid;\n  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));\n  gap: 16px;\n  padding: 20px;\n  overflow-y: auto;\n  max-height: calc(80vh - 70px);\n}\n\n.shape-thumbnail {\n  aspect-ratio: 1;\n  background-color: #1a1a1a;\n  border-radius: 4px;\n  cursor: pointer;\n  position: relative;\n  transition: background-color 0.2s;\n  overflow: hidden;\n}\n\n.shape-thumbnail:hover {\n  background-color: #292929;\n}\n\n.shape-preview {\n  width: 100%;\n  height: 100%;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n\n\n/* Credit display styling */\n.credit-display {\n  display: flex;\n  align-items: center;\n  padding: 6px 12px;\n  background-color: rgba(26, 26, 26, 0.8);\n  border-radius: 20px;\n  cursor: pointer;\n  transition: background-color 0.2s ease;\n}\n\n.credit-display:hover {\n  background-color: rgba(42, 42, 42, 0.8);\n}\n\n.credit-amount {\n  color: #ffffff;\n  font-weight: bold;\n}\n\n.credit-text {\n  color: #aaaaaa;\n}\n\n/* Credit modal styling */\n.credit-package {\n  background-color: #1a1a1a;\n  border-radius: 6px;\n  padding: 16px;\n  display: flex;\n  flex-direction: column;\n  cursor: pointer;\n  transition: transform 0.2s ease, background-color 0.2s ease;\n  position: relative;\n}\n\n.credit-package:hover {\n  background-color: #222;\n  transform: translateY(-2px);\n}\n\n.credit-package .package-name {\n  font-size: 16px;\n  font-weight: bold;\n  color: #e0e0e0;\n  margin-bottom: 8px;\n}\n\n.credit-package .credit-amount {\n  font-size: 24px;\n  font-weight: bold;\n  margin-bottom: 8px;\n}\n\n.credit-package .price {\n  font-size: 18px;\n  color: #e0e0e0;\n}\n\n.credit-package .tag {\n  position: absolute;\n  top: -8px;\n  right: 8px;\n  font-size: 10px;\n  padding: 2px 6px;\n  border-radius: 10px;\n  font-weight: bold;\n}\n\n.credit-package .tag.popular {\n  background-color: #2a7de1;\n  color: #fff;\n}\n\n.credit-package .tag.best-value {\n  background-color: #e12a7d;\n  color: #fff;\n}\n\n/* Transaction table styling */\n.transaction-table {\n  width: 100%;\n  border-collapse: collapse;\n  font-size: 12px;\n}\n\n.transaction-table th {\n  text-align: left;\n  padding: 8px;\n  color: #888;\n}\n\n.transaction-table td {\n  padding: 8px;\n  color: #ccc;\n}\n\n.transaction-table td.amount-positive {\n  color: #4CAF50;\n  font-weight: bold;\n}\n\n.transaction-table td.amount-negative {\n  color: #ff5555;\n  font-weight: bold;\n}\n\n/* Toast notifications */\n.toast {\n  position: fixed;\n  bottom: 16px;\n  left: 50%;\n  transform: translateX(-50%);\n  padding: 12px 18px;\n  border-radius: 4px;\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);\n  z-index: 5000;\n  font-family: 'Menlo', 'Monaco', 'Courier New', monospace;\n  font-size: 14px;\n  transition: opacity 0.5s ease;\n}\n\n.toast.success {\n  background-color: #4CAF50;\n  color: #fff;\n}\n\n.toast.error {\n  background-color: #ff5555;\n  color: #fff;\n}\n\n.toast.warning {\n  background-color: #ff9800;\n  color: #fff;\n}\n\n/* Footer Styles for single row layout */\n.footer {\n  background-color: #000000;\n  padding: 16px 24px;\n  margin-top: auto;\n  border-top: 1px solid #333;\n}\n\n.donation-container {\n  padding-top: 10px;\n  text-align: center;\n  max-width: 1200px;\n  margin: 0 auto;\n}\n\n.donation-title {\n  display: inline-block;\n  font-size: 14px;\n  font-weight: 200;\n  color: #e0e0e0;\n  font-family: 'Menlo', 'Monaco', 'Courier New', monospace;\n  margin-bottom: 16px;\n  text-align: center;\n}\n\n/* Single row layout */\n.donation-row {\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  justify-content: center;\n  background-color: #000000;\n  border-radius: 6px;\n  padding: 12px 16px;\n  flex-wrap: wrap;\n  gap: 8px 0;\n}\n\n.donation-item {\n  display: flex;\n  align-items: center;\n  font-family: 'Menlo', 'Monaco', 'Courier New', monospace;\n  font-size: 13px;\n  padding: 0 8px;\n  flex: 1;\n  min-width: 200px;\n  max-width: 100%;\n}\n\n.donation-separator {\n  width: 1px;\n  height: 20px;\n  background-color: #333;\n  margin: 0 12px;\n  display: none;\n}\n\n.donation-type {\n  color: #999;\n  margin-right: 8px;\n  flex-shrink: 0;\n  min-width: 40px;\n}\n\n.address {\n  color: #ddd;\n  word-break: break-all;\n  margin-right: 8px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n\n.copy-btn {\n  background: transparent;\n  border: none;\n  color: #666;\n  cursor: pointer;\n  padding: 4px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  margin-left: auto;\n  transition: color 0.2s;\n  flex-shrink: 0;\n}\n\n.copy-btn:hover {\n  color: #fff;\n}\n\n.copy-btn.copied {\n  color: #8eff8e;\n}\n\n/* Responsive adjustments */\n@media (min-width: 768px) {\n  .donation-separator {\n    display: block;\n  }\n  \n  .donation-item {\n    flex: 1;\n    min-width: 0;\n  }\n}\n\n@media (max-width: 767px) {\n  .donation-row {\n    flex-direction: column;\n    align-items: flex-start;\n    padding: 8px 12px;\n  }\n  \n  .donation-item {\n    width: 100%;\n    padding: 6px 4px;\n  }\n  \n  .donation-type {\n    min-width: 40px;\n  }\n}`, \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://generative-shapes/./src/styles.css?./node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};\n\n//# sourceURL=webpack://generative-shapes/./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/getUrl.js":
/*!********************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/getUrl.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function (url, options) {\n  if (!options) {\n    options = {};\n  }\n  if (!url) {\n    return url;\n  }\n  url = String(url.__esModule ? url.default : url);\n\n  // If url is already wrapped in quotes, remove them\n  if (/^['\"].*['\"]$/.test(url)) {\n    url = url.slice(1, -1);\n  }\n  if (options.hash) {\n    url += options.hash;\n  }\n\n  // Should url be wrapped?\n  // See https://drafts.csswg.org/css-values-3/#urls\n  if (/[\"'() \\t\\n]|(%20)/.test(url) || options.needQuotes) {\n    return \"\\\"\".concat(url.replace(/\"/g, '\\\\\"').replace(/\\n/g, \"\\\\n\"), \"\\\"\");\n  }\n  return url;\n};\n\n//# sourceURL=webpack://generative-shapes/./node_modules/css-loader/dist/runtime/getUrl.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function (i) {\n  return i[1];\n};\n\n//# sourceURL=webpack://generative-shapes/./node_modules/css-loader/dist/runtime/noSourceMaps.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar stylesInDOM = [];\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n}\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n    identifiers.push(identifier);\n  }\n  return identifiers;\n}\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n  return updater;\n}\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n    var newLastIdentifiers = modulesToDom(newList, options);\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n      var _index = getIndexByIdentifier(_identifier);\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://generative-shapes/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar memo = {};\n\n/* istanbul ignore next  */\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target);\n\n    // Special case to return head of iframe instead of iframe itself\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n    memo[target] = styleTarget;\n  }\n  return memo[target];\n}\n\n/* istanbul ignore next  */\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n  target.appendChild(style);\n}\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack://generative-shapes/./node_modules/style-loader/dist/runtime/insertBySelector.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack://generative-shapes/./node_modules/style-loader/dist/runtime/insertStyleElement.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack://generative-shapes/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n  var needLayer = typeof obj.layer !== \"undefined\";\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n  css += obj.css;\n  if (needLayer) {\n    css += \"}\";\n  }\n  if (obj.media) {\n    css += \"}\";\n  }\n  if (obj.supports) {\n    css += \"}\";\n  }\n  var sourceMap = obj.sourceMap;\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  }\n\n  // For old IE\n  /* istanbul ignore if  */\n  options.styleTagTransform(css, styleElement, options.options);\n}\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n  styleElement.parentNode.removeChild(styleElement);\n}\n\n/* istanbul ignore next  */\nfunction domAPI(options) {\n  if (typeof document === \"undefined\") {\n    return {\n      update: function update() {},\n      remove: function remove() {}\n    };\n  }\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\nmodule.exports = domAPI;\n\n//# sourceURL=webpack://generative-shapes/./node_modules/style-loader/dist/runtime/styleDomAPI.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack://generative-shapes/./node_modules/style-loader/dist/runtime/styleTagTransform.js?");

/***/ }),

/***/ "./src/CreditIntegration.js":
/*!**********************************!*\
  !*** ./src/CreditIntegration.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   integrateCreditSystem: () => (/* binding */ integrateCreditSystem)\n/* harmony export */ });\n/* harmony import */ var _CreditService_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CreditService.js */ \"./src/CreditService.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, \"catch\": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\n// CreditIntegration.js - Complete working version\n\n\n// Function to integrate credits with the ShapeApp\nfunction integrateCreditSystem(app) {\n  app.creditService = new _CreditService_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](app);\n\n  // Modify shape generator to check credits before generating shapes\n  modifyShapeGenerator(app);\n\n  // Modify shape exporter to check credits before exporting shapes\n  modifyShapeExporter(app);\n\n  // Modify shape exporter to check credits before editing shapes\n  modifyUserShapesManager(app);\n  console.log('Credit system fully integrated');\n  return app.creditService;\n}\n\n/**\n * Modify ShapeGenerator to check credits before generating shapes\n */\nfunction modifyShapeGenerator(app) {\n  // Need to check if app.generator exists and has the expected methods\n  if (!app.generator) {\n    console.error('Shape generator not found');\n    return;\n  }\n\n  // Check for generateShape method\n  if (typeof app.generator.generateShape !== 'function') {\n    console.error('generateShape method not found');\n    return;\n  }\n\n  // Store original method\n  var originalGenerateShape = app.generator.generateShape;\n\n  // Replace with version that checks credits before generating shapes\n  app.generator.generateShape = /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var description,\n      hasImages,\n      operationType,\n      requiredCredits,\n      hasEnoughCredits,\n      hasClassName,\n      hasGeneratedCode,\n      isSuccess,\n      referenceId,\n      toast,\n      _args = arguments;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          console.log('Credit-modified generateShape called');\n          _context.prev = 1;\n          // Determine cost based on complexity\n          description = this.currentDescription || '';\n          hasImages = this.attachedImagesData && this.attachedImagesData.length > 0; // Choose operation type based on complexity\n          operationType = 'generateBasicShape';\n          if (hasImages || description.length > 200) {\n            operationType = 'generateComplexShape';\n          }\n\n          // If creditService is not properly initialized, proceed without checking\n          if (!(!app.creditService || !app.creditService.creditCosts)) {\n            _context.next = 9;\n            break;\n          }\n          console.error('Credit service not properly initialized, proceeding without credit check');\n          return _context.abrupt(\"return\", originalGenerateShape.apply(this, _args));\n        case 9:\n          requiredCredits = app.creditService.creditCosts[operationType];\n          console.log(\"Shape generation requires \".concat(requiredCredits, \" credits. Type: \").concat(operationType));\n\n          // Check if user has enough credits\n          _context.next = 13;\n          return app.creditService.checkCreditBalance(operationType);\n        case 13:\n          hasEnoughCredits = _context.sent;\n          if (hasEnoughCredits) {\n            _context.next = 18;\n            break;\n          }\n          // Show insufficient credits modal\n          app.creditService.showInsufficientCreditsModal(operationType, requiredCredits);\n          console.log('Insufficient credits for shape generation');\n          return _context.abrupt(\"return\", {\n            success: false,\n            error: 'Insufficient credits'\n          });\n        case 18:\n          // Call original generate shape method\n          console.log('Calling original generateShape method');\n          _context.next = 21;\n          return originalGenerateShape.apply(this, _args);\n        case 21:\n          console.log('Original generateShape completed');\n\n          // Get current values of key properties to check success\n          hasClassName = !!this.currentClassName;\n          hasGeneratedCode = !!this.currentGeneratedCode;\n          console.log('Checking success indicators:', {\n            hasClassName: hasClassName,\n            hasGeneratedCode: hasGeneratedCode\n          });\n\n          // Consider generation successful if we have both a class name and generated code\n          isSuccess = hasClassName && hasGeneratedCode;\n          if (!isSuccess) {\n            _context.next = 49;\n            break;\n          }\n          // Deduct credits\n          console.log('Shape generation appears successful based on properties, deducting credits');\n\n          // Get reference ID if available\n          referenceId = this.currentClassName || null;\n          _context.next = 31;\n          return app.creditService.deductCredits(operationType, \"Generated shape: \".concat(description.substring(0, 50)).concat(description.length > 50 ? '...' : ''), referenceId);\n        case 31:\n          // Show a success notification\n          toast = document.createElement('div');\n          toast.textContent = \"Used \".concat(requiredCredits, \" credits to generate shape\");\n          toast.className = 'toast success';\n          toast.style.position = 'fixed';\n          toast.style.bottom = '16px';\n          toast.style.left = '50%';\n          toast.style.transform = 'translateX(-50%)';\n          toast.style.backgroundColor = '#4CAF50';\n          toast.style.color = 'white';\n          toast.style.padding = '12px 18px';\n          toast.style.borderRadius = '4px';\n          toast.style.zIndex = '9999';\n          toast.style.fontSize = '14px';\n          toast.style.boxShadow = '0 2px 8px rgba(0,0,0,0.2)';\n          document.body.appendChild(toast);\n          setTimeout(function () {\n            toast.style.opacity = '0';\n            toast.style.transition = 'opacity 0.5s ease';\n            setTimeout(function () {\n              return toast.remove();\n            }, 500);\n          }, 3000);\n          _context.next = 50;\n          break;\n        case 49:\n          console.log('Generation failed, not deducting credits');\n        case 50:\n          return _context.abrupt(\"return\", undefined);\n        case 53:\n          _context.prev = 53;\n          _context.t0 = _context[\"catch\"](1);\n          console.error('Error in credit-modified generateShape:', _context.t0);\n          return _context.abrupt(\"return\", {\n            success: false,\n            error: _context.t0.message || 'Generation failed'\n          });\n        case 57:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee, this, [[1, 53]]);\n  }));\n  console.log('Successfully modified generateShape to check and deduct credits');\n}\n\n/**\n * Modify user shapes manager to check credits for edit operations\n */\nfunction modifyUserShapesManager(app) {\n  if (!app.userShapesManager || _typeof(app.userShapesManager) !== 'object') {\n    console.warn('User shapes manager not found');\n    return;\n  }\n\n  // Check if editUserShape exists and hasn't been modified yet\n  if (typeof app.userShapesManager.editUserShape === 'function' && !app.userShapesManager.editUserShape._isModifiedForCredits) {\n    // Store original method\n    var originalEditUserShape = app.userShapesManager.editUserShape;\n\n    // Replace with version that only checks credit balance but doesn't deduct\n    app.userShapesManager.editUserShape = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(shape) {\n        var operationType, requiredCredits, hasEnoughCredits;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!(!app.auth || !app.auth.isAuthenticated())) {\n                _context2.next = 3;\n                break;\n              }\n              // Show auth modal\n              if (app.auth && app.auth.showAuthModal) {\n                app.auth.showAuthModal('signin', null, 'edit shapes');\n              }\n              return _context2.abrupt(\"return\");\n            case 3:\n              // Check if user has enough credits but DON'T deduct them yet\n              operationType = 'editShape';\n              requiredCredits = app.creditService.creditCosts[operationType];\n              _context2.next = 7;\n              return app.creditService.checkCreditBalance(operationType);\n            case 7:\n              hasEnoughCredits = _context2.sent;\n              if (hasEnoughCredits) {\n                _context2.next = 11;\n                break;\n              }\n              // Show insufficient credits modal\n              app.creditService.showInsufficientCreditsModal(operationType, requiredCredits);\n              return _context2.abrupt(\"return\");\n            case 11:\n              _context2.next = 13;\n              return originalEditUserShape.call(this, shape);\n            case 13:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      return function (_x) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n\n    // Mark as modified to prevent double-wrapping\n    app.userShapesManager.editUserShape._isModifiedForCredits = true;\n    console.log('Modified editUserShape to check credit balance only');\n  }\n\n  // Now modify the sendEditRequest method in ShapeGenerator\n  if (app.generator && typeof app.generator.sendEditRequest === 'function' && !app.generator.sendEditRequest._isModifiedForCredits) {\n    // Store original method\n    var originalSendEditRequest = app.generator.sendEditRequest;\n\n    // Replace with version that deducts credits only on successful API response\n    app.generator.sendEditRequest = /*#__PURE__*/function () {\n      var _ref3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(code, className, editPrompt) {\n        var originalGeneratedCode, operationType, requiredCredits, toast;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              // We already checked credit balance in editUserShape, so we don't need to check again\n              // Store original code to compare later\n              originalGeneratedCode = this.currentGeneratedCode;\n              _context3.prev = 1;\n              _context3.next = 4;\n              return originalSendEditRequest.call(this, code, className, editPrompt);\n            case 4:\n              if (!(this.currentGeneratedCode && this.currentGeneratedCode !== originalGeneratedCode)) {\n                _context3.next = 27;\n                break;\n              }\n              console.log('Shape edit successful, deducting credits now');\n\n              // Deduct credits only after successful API call\n              operationType = 'editShape';\n              requiredCredits = app.creditService.creditCosts[operationType];\n              _context3.next = 10;\n              return app.creditService.deductCredits(operationType, \"Edited shape: \".concat(className, \" with prompt: \").concat(editPrompt.substring(0, 50)).concat(editPrompt.length > 50 ? '...' : ''), null);\n            case 10:\n              // Show success toast for credits\n              toast = document.createElement('div');\n              toast.textContent = \"Used \".concat(requiredCredits, \" credits to update shape\");\n              toast.style.position = 'fixed';\n              toast.style.bottom = '16px';\n              toast.style.left = '50%';\n              toast.style.transform = 'translateX(-50%)';\n              toast.style.backgroundColor = '#4CAF50';\n              toast.style.color = 'white';\n              toast.style.padding = '12px 18px';\n              toast.style.borderRadius = '4px';\n              toast.style.zIndex = '9999';\n              toast.style.fontSize = '14px';\n              toast.style.boxShadow = '0 2px 8px rgba(0,0,0,0.2)';\n              document.body.appendChild(toast);\n              setTimeout(function () {\n                toast.style.opacity = '0';\n                toast.style.transition = 'opacity 0.5s ease';\n                setTimeout(function () {\n                  return toast.remove();\n                }, 500);\n              }, 3000);\n              _context3.next = 28;\n              break;\n            case 27:\n              console.log('Shape edit did not result in code change, not deducting credits');\n            case 28:\n              _context3.next = 33;\n              break;\n            case 30:\n              _context3.prev = 30;\n              _context3.t0 = _context3[\"catch\"](1);\n              console.error('Error in sendEditRequest:', _context3.t0);\n              // Don't deduct credits if there was an error\n            case 33:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this, [[1, 30]]);\n      }));\n      return function (_x2, _x3, _x4) {\n        return _ref3.apply(this, arguments);\n      };\n    }();\n\n    // Mark as modified to prevent double-wrapping\n    app.generator.sendEditRequest._isModifiedForCredits = true;\n    console.log('Modified generator.sendEditRequest to deduct credits only after successful API call');\n  }\n}\n\n/**\n * Modify the shape exporter to check credits before exporting shapes\n */\nfunction modifyShapeExporter(app) {\n  // Look for the ShapeExporter class\n  var exporter = null;\n\n  // Try to find ShapeExporter instance\n  if (app.editor && app.editor.exporter instanceof Object) {\n    exporter = app.editor.exporter;\n    console.log('Found exporter in app.editor.exporter');\n  }\n\n  // If exporter not found, exit\n  if (!exporter) {\n    console.warn('Shape exporter not found - credit check for exports disabled');\n    return;\n  }\n\n  // Check for the exportShapeWithOptions method\n  if (typeof exporter.exportShapeWithOptions !== 'function') {\n    console.warn('exportShapeWithOptions method not found - credit check for exports disabled');\n    return;\n  }\n\n  // Skip if already modified\n  if (exporter.exportShapeWithOptions._isModifiedForCredits) {\n    console.log('Exporter already modified for credits');\n    return;\n  }\n\n  // Store original method\n  var originalExportMethod = exporter.exportShapeWithOptions;\n\n  // Replace with version that checks credits\n  exporter.exportShapeWithOptions = /*#__PURE__*/function () {\n    var _ref4 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(format, dimensions, background) {\n      var operationType, requiredCredits, hasEnoughCredits, originalResult, shapeName, formatDesc, dimensionDesc, toast;\n      return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n        while (1) switch (_context4.prev = _context4.next) {\n          case 0:\n            if (!(!app.auth || !app.auth.isAuthenticated())) {\n              _context4.next = 3;\n              break;\n            }\n            // Show auth modal\n            if (app.auth && app.auth.showAuthModal) {\n              app.auth.showAuthModal('signin', null, 'export shapes');\n            }\n            return _context4.abrupt(\"return\", null);\n          case 3:\n            // Determine operation type\n            operationType = 'exportShape';\n            requiredCredits = app.creditService.creditCosts[operationType]; // Check if user has enough credits\n            _context4.next = 7;\n            return app.creditService.checkCreditBalance(operationType);\n          case 7:\n            hasEnoughCredits = _context4.sent;\n            if (hasEnoughCredits) {\n              _context4.next = 11;\n              break;\n            }\n            // Show insufficient credits modal\n            app.creditService.showInsufficientCreditsModal(operationType, requiredCredits);\n            return _context4.abrupt(\"return\", null);\n          case 11:\n            // Proceed with original export\n            originalResult = originalExportMethod.call(this, format, dimensions, background); // If export was successful, deduct credits\n            if (!(originalResult !== false)) {\n              _context4.next = 34;\n              break;\n            }\n            shapeName = app.selectedShape || 'shape';\n            formatDesc = format === 'svg' ? 'SVG' : 'PNG';\n            dimensionDesc = \"\".concat(dimensions.width, \"x\").concat(dimensions.height);\n            _context4.next = 18;\n            return app.creditService.deductCredits(operationType, \"Exported \".concat(shapeName, \" as \").concat(formatDesc, \" (\").concat(dimensionDesc, \")\"), null);\n          case 18:\n            // Show a small success notification\n            toast = document.createElement('div');\n            toast.textContent = \"Used \".concat(requiredCredits, \" credits to export shape\");\n            toast.className = 'toast success';\n            toast.style.bottom = '16px';\n            toast.style.position = 'fixed';\n            toast.style.left = '50%';\n            toast.style.transform = 'translateX(-50%)';\n            toast.style.backgroundColor = '#4CAF50';\n            toast.style.color = 'white';\n            toast.style.padding = '12px 18px';\n            toast.style.borderRadius = '4px';\n            toast.style.zIndex = '9999';\n            toast.style.fontSize = '14px';\n            toast.style.boxShadow = '0 2px 8px rgba(0,0,0,0.2)';\n            document.body.appendChild(toast);\n            setTimeout(function () {\n              toast.style.opacity = '0';\n              toast.style.transition = 'opacity 0.5s ease';\n              setTimeout(function () {\n                return toast.remove();\n              }, 500);\n            }, 3000);\n          case 34:\n            return _context4.abrupt(\"return\", originalResult);\n          case 35:\n          case \"end\":\n            return _context4.stop();\n        }\n      }, _callee4, this);\n    }));\n    return function (_x5, _x6, _x7) {\n      return _ref4.apply(this, arguments);\n    };\n  }();\n\n  // Mark as modified to prevent double-wrapping\n  exporter.exportShapeWithOptions._isModifiedForCredits = true;\n  console.log('Successfully modified exportShapeWithOptions to check credits');\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (integrateCreditSystem);\n\n//# sourceURL=webpack://generative-shapes/./src/CreditIntegration.js?");

/***/ }),

/***/ "./src/CreditService.js":
/*!******************************!*\
  !*** ./src/CreditService.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, \"catch\": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n// CreditService.js - Manages user credits and transactions\nvar CreditService = /*#__PURE__*/function () {\n  function CreditService(app) {\n    var _this = this;\n    _classCallCheck(this, CreditService);\n    this.app = app;\n    this.supabase = null;\n    this.userCredits = 0;\n    this.isLoading = false;\n    this.creditListeners = [];\n\n    // Credit costs for different operations\n    this.creditCosts = {\n      generateBasicShape: 12,\n      generateComplexShape: 30,\n      editShape: 5,\n      exportShape: 2,\n      saveShape: 0\n    };\n\n    // Credit to dollar conversion rate (100 credits = $1)\n    this.creditToDollarRate = 100;\n\n    // Bind methods\n    this.initialize = this.initialize.bind(this);\n    this.getUserCredits = this.getUserCredits.bind(this);\n    this.checkCreditBalance = this.checkCreditBalance.bind(this);\n    this.deductCredits = this.deductCredits.bind(this);\n    this.addCredits = this.addCredits.bind(this);\n    this.showPurchaseModal = this.showPurchaseModal.bind(this);\n    this.addCreditDisplay = this.addCreditDisplay.bind(this);\n    this.refreshCreditDisplay = this.refreshCreditDisplay.bind(this);\n    this.getCreditTransactions = this.getCreditTransactions.bind(this);\n    this.formatCreditAmount = this.formatCreditAmount.bind(this);\n    this.showInsufficientCreditsModal = this.showInsufficientCreditsModal.bind(this);\n\n    // Initialize when auth is ready\n    if (app.auth && app.auth.supabase) {\n      this.supabase = app.auth.supabase;\n      this.initialize();\n    } else {\n      // Wait for auth to be initialized\n      var checkAuth = setInterval(function () {\n        if (app.auth && app.auth.supabase) {\n          _this.supabase = app.auth.supabase;\n          _this.initialize();\n          clearInterval(checkAuth);\n        }\n      }, 100);\n    }\n  }\n\n  /**\n   * Initialize credit system\n   */\n  return _createClass(CreditService, [{\n    key: \"initialize\",\n    value: function initialize() {\n      var _this2 = this;\n      // Add the credit display to the header if authenticated\n      if (this.app.auth.isAuthenticated()) {\n        this.getUserCredits().then(function () {\n          _this2.addCreditDisplay();\n        });\n      }\n\n      // Add auth state listener to add/remove credit display based on auth state\n      this.app.auth.addAuthStateListener(function (isAuthenticated) {\n        if (isAuthenticated) {\n          _this2.getUserCredits().then(function () {\n            _this2.addCreditDisplay();\n          });\n        } else {\n          var creditDisplay = document.getElementById('credit-display');\n          if (creditDisplay) {\n            creditDisplay.remove();\n          }\n          _this2.userCredits = 0;\n        }\n      });\n\n      // Modify the shape generator to check credits before generating shapes\n      this.modifyShapeGenerator();\n    }\n\n    /**\n     * Get user credits from the database\n     */\n  }, {\n    key: \"getUserCredits\",\n    value: (function () {\n      var _getUserCredits = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _yield$this$supabase$, data, error;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!(!this.supabase || !this.app.auth.isAuthenticated())) {\n                _context.next = 3;\n                break;\n              }\n              console.log('Not authenticated or Supabase not available');\n              return _context.abrupt(\"return\", {\n                success: false,\n                credits: 0\n              });\n            case 3:\n              _context.prev = 3;\n              this.isLoading = true;\n\n              // Fetch credit balance for the current user\n              _context.next = 7;\n              return this.supabase.from('user_credits').select('balance').single();\n            case 7:\n              _yield$this$supabase$ = _context.sent;\n              data = _yield$this$supabase$.data;\n              error = _yield$this$supabase$.error;\n              if (!error) {\n                _context.next = 12;\n                break;\n              }\n              throw error;\n            case 12:\n              // Update local credit balance\n              this.userCredits = data ? data.balance : 0;\n              this.isLoading = false;\n\n              // Notify all listeners\n              this.notifyCreditListeners();\n              return _context.abrupt(\"return\", {\n                success: true,\n                credits: this.userCredits\n              });\n            case 18:\n              _context.prev = 18;\n              _context.t0 = _context[\"catch\"](3);\n              console.error('Error getting user credits:', _context.t0);\n              this.isLoading = false;\n              return _context.abrupt(\"return\", {\n                success: false,\n                error: _context.t0.message,\n                credits: 0\n              });\n            case 23:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[3, 18]]);\n      }));\n      function getUserCredits() {\n        return _getUserCredits.apply(this, arguments);\n      }\n      return getUserCredits;\n    }()\n    /**\n     * Add a credit listener\n     * @param {Function} listener - Callback function for credit changes\n     */\n    )\n  }, {\n    key: \"addCreditListener\",\n    value: function addCreditListener(listener) {\n      var _this3 = this;\n      if (typeof listener === 'function') {\n        this.creditListeners.push(listener);\n        // Immediately call with current credit balance\n        listener(this.userCredits);\n      }\n\n      // Return function to remove listener\n      return function () {\n        _this3.creditListeners = _this3.creditListeners.filter(function (l) {\n          return l !== listener;\n        });\n      };\n    }\n\n    /**\n     * Notify all credit listeners of balance change\n     */\n  }, {\n    key: \"notifyCreditListeners\",\n    value: function notifyCreditListeners() {\n      var _this4 = this;\n      this.creditListeners.forEach(function (listener) {\n        try {\n          listener(_this4.userCredits);\n        } catch (error) {\n          console.error('Error in credit listener:', error);\n        }\n      });\n\n      // Also refresh the credit display\n      this.refreshCreditDisplay();\n    }\n\n    /**\n     * Check if user has enough credits for an operation\n     * @param {string} operationType - Type of operation\n     * @returns {Promise<boolean>} - True if user has enough credits\n     */\n  }, {\n    key: \"checkCreditBalance\",\n    value: (function () {\n      var _checkCreditBalance = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(operationType) {\n        var cost;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (this.app.auth.isAuthenticated()) {\n                _context2.next = 3;\n                break;\n              }\n              console.log('User not authenticated, cannot check credits');\n              return _context2.abrupt(\"return\", false);\n            case 3:\n              // Get credit cost for operation\n              cost = this.creditCosts[operationType] || 0; // Refresh credit balance\n              _context2.next = 6;\n              return this.getUserCredits();\n            case 6:\n              return _context2.abrupt(\"return\", this.userCredits >= cost);\n            case 7:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function checkCreditBalance(_x) {\n        return _checkCreditBalance.apply(this, arguments);\n      }\n      return checkCreditBalance;\n    }()\n    /**\n     * Deduct credits for an operation\n     * @param {string} operationType - Type of operation\n     * @param {string} description - Description of the transaction\n     * @param {string} referenceId - Optional reference ID (e.g., shape ID)\n     * @returns {Promise<boolean>} - True if deduction successful\n     */\n    )\n  }, {\n    key: \"deductCredits\",\n    value: (function () {\n      var _deductCredits = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(operationType) {\n        var description,\n          referenceId,\n          cost,\n          _yield$this$supabase$2,\n          data,\n          error,\n          success,\n          _args3 = arguments;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              description = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : null;\n              referenceId = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : null;\n              if (this.app.auth.isAuthenticated()) {\n                _context3.next = 5;\n                break;\n              }\n              console.log('User not authenticated, cannot deduct credits');\n              return _context3.abrupt(\"return\", false);\n            case 5:\n              // Get credit cost for operation\n              cost = this.creditCosts[operationType] || 0; // Skip if no cost\n              if (!(cost === 0)) {\n                _context3.next = 8;\n                break;\n              }\n              return _context3.abrupt(\"return\", true);\n            case 8:\n              _context3.prev = 8;\n              _context3.next = 11;\n              return this.supabase.rpc('deduct_user_credits', {\n                p_user_id: this.app.auth.getCurrentUser().id,\n                p_amount: cost,\n                p_transaction_type: operationType,\n                p_description: description || \"Credits for \".concat(operationType),\n                p_reference_id: referenceId\n              });\n            case 11:\n              _yield$this$supabase$2 = _context3.sent;\n              data = _yield$this$supabase$2.data;\n              error = _yield$this$supabase$2.error;\n              if (!error) {\n                _context3.next = 16;\n                break;\n              }\n              throw error;\n            case 16:\n              // Check result (function returns boolean)\n              success = data === true;\n              if (success) {\n                // Update local credit balance\n                this.userCredits -= cost;\n                this.notifyCreditListeners();\n                console.log(\"Successfully deducted \".concat(cost, \" credits for \").concat(operationType));\n              } else {\n                console.warn(\"Failed to deduct credits for \".concat(operationType));\n              }\n              return _context3.abrupt(\"return\", success);\n            case 21:\n              _context3.prev = 21;\n              _context3.t0 = _context3[\"catch\"](8);\n              console.error('Error deducting credits:', _context3.t0);\n              return _context3.abrupt(\"return\", false);\n            case 25:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this, [[8, 21]]);\n      }));\n      function deductCredits(_x2) {\n        return _deductCredits.apply(this, arguments);\n      }\n      return deductCredits;\n    }()\n    /**\n     * Add credits to user account\n     * @param {number} amount - Amount of credits to add\n     * @param {string} transactionType - Type of transaction\n     * @param {string} description - Description of the transaction\n     * @param {string} referenceId - Optional reference ID (e.g., payment ID)\n     * @returns {Promise<boolean>} - True if addition successful\n     */\n    )\n  }, {\n    key: \"addCredits\",\n    value: (function () {\n      var _addCredits = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(amount, transactionType) {\n        var description,\n          referenceId,\n          _yield$this$supabase$3,\n          error,\n          _args4 = arguments;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              description = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : null;\n              referenceId = _args4.length > 3 && _args4[3] !== undefined ? _args4[3] : null;\n              if (this.app.auth.isAuthenticated()) {\n                _context4.next = 5;\n                break;\n              }\n              console.log('User not authenticated, cannot add credits');\n              return _context4.abrupt(\"return\", false);\n            case 5:\n              _context4.prev = 5;\n              _context4.next = 8;\n              return this.supabase.rpc('add_user_credits', {\n                p_user_id: this.app.auth.getCurrentUser().id,\n                p_amount: amount,\n                p_transaction_type: transactionType,\n                p_description: description || \"Added \".concat(amount, \" credits\"),\n                p_reference_id: referenceId\n              });\n            case 8:\n              _yield$this$supabase$3 = _context4.sent;\n              error = _yield$this$supabase$3.error;\n              if (!error) {\n                _context4.next = 12;\n                break;\n              }\n              throw error;\n            case 12:\n              _context4.next = 14;\n              return this.getUserCredits();\n            case 14:\n              console.log(\"Successfully added \".concat(amount, \" credits\"));\n              return _context4.abrupt(\"return\", true);\n            case 18:\n              _context4.prev = 18;\n              _context4.t0 = _context4[\"catch\"](5);\n              console.error('Error adding credits:', _context4.t0);\n              return _context4.abrupt(\"return\", false);\n            case 22:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this, [[5, 18]]);\n      }));\n      function addCredits(_x3, _x4) {\n        return _addCredits.apply(this, arguments);\n      }\n      return addCredits;\n    }()\n    /**\n     * Get credit transactions for the current user\n     * @param {number} limit - Maximum number of transactions to return\n     * @returns {Promise<Object>} - Transaction data\n     */\n    )\n  }, {\n    key: \"getCreditTransactions\",\n    value: (function () {\n      var _getCreditTransactions = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var limit,\n          _yield$this$supabase$4,\n          data,\n          error,\n          _args5 = arguments;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              limit = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : 10;\n              if (this.app.auth.isAuthenticated()) {\n                _context5.next = 4;\n                break;\n              }\n              console.log('User not authenticated, cannot get transactions');\n              return _context5.abrupt(\"return\", {\n                success: false,\n                transactions: []\n              });\n            case 4:\n              _context5.prev = 4;\n              _context5.next = 7;\n              return this.supabase.from('credit_transactions').select('*').order('created_at', {\n                ascending: false\n              }).limit(limit);\n            case 7:\n              _yield$this$supabase$4 = _context5.sent;\n              data = _yield$this$supabase$4.data;\n              error = _yield$this$supabase$4.error;\n              if (!error) {\n                _context5.next = 12;\n                break;\n              }\n              throw error;\n            case 12:\n              return _context5.abrupt(\"return\", {\n                success: true,\n                transactions: data || []\n              });\n            case 15:\n              _context5.prev = 15;\n              _context5.t0 = _context5[\"catch\"](4);\n              console.error('Error getting credit transactions:', _context5.t0);\n              return _context5.abrupt(\"return\", {\n                success: false,\n                error: _context5.t0.message,\n                transactions: []\n              });\n            case 19:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this, [[4, 15]]);\n      }));\n      function getCreditTransactions() {\n        return _getCreditTransactions.apply(this, arguments);\n      }\n      return getCreditTransactions;\n    }()\n    /**\n     * Format credit amount with dollar value\n     * @param {number} credits - Number of credits\n     * @returns {string} - Formatted string with dollar value\n     */\n    )\n  }, {\n    key: \"formatCreditAmount\",\n    value: function formatCreditAmount(credits) {\n      var dollarValue = (credits / this.creditToDollarRate).toFixed(2);\n      return \"\".concat(credits, \" credits ($\").concat(dollarValue, \")\");\n    }\n\n    /**\n     * Add credit display to the header\n     */\n  }, {\n    key: \"addCreditDisplay\",\n    value: function addCreditDisplay() {\n      var _this5 = this;\n      // Check if credit display already exists\n      if (document.getElementById('credit-display')) {\n        this.refreshCreditDisplay();\n        return;\n      }\n\n      // Find the header actions container\n      var header = document.getElementById('main-header');\n      if (!header) return;\n      var actionsContainer = header.querySelector('.header-actions');\n      if (!actionsContainer) {\n        actionsContainer = document.createElement('div');\n        actionsContainer.className = 'header-actions';\n        actionsContainer.style.display = 'flex';\n        actionsContainer.style.gap = '8px';\n        header.appendChild(actionsContainer);\n      }\n\n      // Create credit display container\n      var creditDisplay = document.createElement('div');\n      creditDisplay.id = 'credit-display';\n      creditDisplay.className = 'credit-display';\n      creditDisplay.style.display = 'flex';\n      creditDisplay.style.alignItems = 'center';\n      creditDisplay.style.padding = '6px 12px';\n      creditDisplay.style.marginLeft = '8px';\n      creditDisplay.style.backgroundColor = 'black';\n      creditDisplay.style.borderRadius = '20px';\n      creditDisplay.style.cursor = 'pointer';\n      creditDisplay.style.fontSize = '14px';\n      creditDisplay.style.fontFamily = \"'Menlo', 'Monaco', 'Courier New', monospace\";\n      creditDisplay.style.transition = 'background-color 0.2s ease';\n\n      // Add hover effects\n      creditDisplay.addEventListener('mouseover', function () {\n        creditDisplay.style.backgroundColor = 'rgba(42, 42, 42, 0.8)';\n      });\n      creditDisplay.addEventListener('mouseout', function () {\n        creditDisplay.style.backgroundColor = 'black';\n      });\n\n      // Show purchase modal when clicked\n      creditDisplay.addEventListener('click', function () {\n        _this5.showPurchaseModal();\n      });\n\n      // Credit amount\n      var creditAmount = document.createElement('span');\n      creditAmount.className = 'credit-amount';\n      creditAmount.textContent = this.userCredits.toString();\n      creditAmount.style.color = '#ffffff';\n      creditAmount.style.fontWeight = 'bold';\n\n      // \"credits\" text\n      var creditText = document.createElement('span');\n      creditText.textContent = 'credits';\n      creditText.style.color = '#aaaaaa';\n      creditText.style.marginLeft = '6px';\n\n      // Add contents to credit display\n      creditDisplay.appendChild(creditAmount);\n      creditDisplay.appendChild(creditText);\n\n      // Find where to insert in the header\n      var authContainer = document.getElementById('auth-container');\n      if (authContainer) {\n        // Insert before the auth container\n        actionsContainer.insertBefore(creditDisplay, authContainer);\n      } else {\n        // Append to the end\n        actionsContainer.appendChild(creditDisplay);\n      }\n    }\n\n    /**\n     * Refresh credit display with current balance\n     */\n  }, {\n    key: \"refreshCreditDisplay\",\n    value: function refreshCreditDisplay() {\n      var creditAmount = document.querySelector('.credit-amount');\n      if (creditAmount) {\n        creditAmount.textContent = this.userCredits.toString();\n\n        // Change color based on balance\n        if (this.userCredits <= 10) {\n          creditAmount.style.color = '#ff5555'; // Red for low balance\n        } else if (this.userCredits <= 50) {\n          creditAmount.style.color = '#ffaa55'; // Orange for medium balance\n        } else {\n          creditAmount.style.color = '#ffffff'; // White for normal balance\n        }\n      }\n    }\n\n    /**\n    * Show purchase modal for buying credits - minimalist version\n    */\n    /**\n     * Show improved purchase modal for buying credits\n     * With white selection border for selected packages and visible buy button\n     */\n  }, {\n    key: \"showPurchaseModal\",\n    value: function showPurchaseModal() {\n      var _this6 = this;\n      // Remove any existing modal\n      var existingModal = document.getElementById('credit-purchase-modal');\n      if (existingModal) {\n        existingModal.remove();\n      }\n\n      // Create modal container\n      var modal = document.createElement('div');\n      modal.id = 'credit-purchase-modal';\n      modal.className = 'modal';\n      modal.style.position = 'fixed';\n      modal.style.top = '0';\n      modal.style.left = '0';\n      modal.style.width = '100%';\n      modal.style.height = '100%';\n      modal.style.backgroundColor = 'rgba(0, 0, 0, 0.85)';\n      modal.style.display = 'flex';\n      modal.style.justifyContent = 'center';\n      modal.style.alignItems = 'center';\n      modal.style.zIndex = '2000';\n      modal.style.backdropFilter = 'blur(5px)';\n\n      // Create modal content\n      var modalContent = document.createElement('div');\n      modalContent.className = 'modal-content';\n      modalContent.style.backgroundColor = '#000';\n      modalContent.style.borderRadius = '8px';\n      modalContent.style.padding = '24px';\n      modalContent.style.width = '450px';\n      modalContent.style.maxWidth = '90%';\n      modalContent.style.color = '#999';\n      modalContent.style.fontFamily = \"'Menlo', 'Monaco', 'Courier New', monospace\";\n\n      // Create modal header\n      var modalHeader = document.createElement('div');\n      modalHeader.className = 'modal-header';\n      modalHeader.style.display = 'flex';\n      modalHeader.style.justifyContent = 'space-between';\n      modalHeader.style.alignItems = 'center';\n      modalHeader.style.marginBottom = '20px';\n      modalHeader.style.position = 'relative';\n      var headerLeft = document.createElement('div');\n      headerLeft.style.display = 'flex';\n      headerLeft.style.alignItems = 'center';\n      headerLeft.style.gap = '8px';\n      var modalTitle = document.createElement('h3');\n      modalTitle.textContent = 'Purchase Credits';\n      modalTitle.style.margin = '0';\n      modalTitle.style.fontSize = '20px';\n      modalTitle.style.fontWeight = 'normal';\n      modalTitle.style.color = '#fff';\n\n      // Create info button\n      var infoButton = document.createElement('button');\n      infoButton.className = 'info-button';\n      infoButton.textContent = '?';\n      infoButton.style.width = '18px';\n      infoButton.style.height = '18px';\n      infoButton.style.borderRadius = '50%';\n      infoButton.style.backgroundColor = '#222';\n      infoButton.style.color = '#999';\n      infoButton.style.border = 'none';\n      infoButton.style.display = 'flex';\n      infoButton.style.alignItems = 'center';\n      infoButton.style.justifyContent = 'center';\n      infoButton.style.fontSize = '12px';\n      infoButton.style.cursor = 'pointer';\n      infoButton.style.marginLeft = '8px';\n      infoButton.title = \"View credit rates\";\n      var infoPopupOpen = false;\n      infoButton.addEventListener('click', function (e) {\n        e.stopPropagation();\n        if (infoPopupOpen) {\n          var _infoPopup = document.getElementById('info-popup');\n          if (_infoPopup) _infoPopup.remove();\n          infoPopupOpen = false;\n          return;\n        }\n\n        // Create info popup\n        var infoPopup = document.createElement('div');\n        infoPopup.id = 'info-popup';\n        infoPopup.style.position = 'absolute';\n        infoPopup.style.top = '30px';\n        infoPopup.style.right = '30px';\n        infoPopup.style.backgroundColor = '#111';\n        infoPopup.style.border = '1px solid #333';\n        infoPopup.style.borderRadius = '6px';\n        infoPopup.style.padding = '12px';\n        infoPopup.style.zIndex = '30';\n        infoPopup.style.width = '280px';\n        infoPopup.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.3)';\n\n        // Add heading\n        var infoHeading = document.createElement('div');\n        infoHeading.style.display = 'flex';\n        infoHeading.style.justifyContent = 'space-between';\n        infoHeading.style.marginBottom = '10px';\n        var infoTitle = document.createElement('span');\n        infoTitle.textContent = 'Credit Rates';\n        infoTitle.style.color = '#aaa';\n        infoTitle.style.fontWeight = 'bold';\n        infoTitle.style.fontSize = '12px';\n        var closeInfo = document.createElement('button');\n        closeInfo.textContent = '';\n        closeInfo.style.backgroundColor = 'transparent';\n        closeInfo.style.border = 'none';\n        closeInfo.style.color = '#777';\n        closeInfo.style.cursor = 'pointer';\n        closeInfo.style.fontSize = '16px';\n        closeInfo.style.padding = '0';\n        closeInfo.style.marginTop = '-5px';\n        closeInfo.addEventListener('click', function () {\n          infoPopup.remove();\n          infoPopupOpen = false;\n        });\n        infoHeading.appendChild(infoTitle);\n        infoHeading.appendChild(closeInfo);\n\n        // Create rates table\n        var ratesTable = document.createElement('table');\n        ratesTable.style.width = '100%';\n        ratesTable.style.fontSize = '11px';\n        ratesTable.style.borderCollapse = 'collapse';\n        var rates = [{\n          name: 'Basic Shape:',\n          value: '12 credits ($0.12)'\n        }, {\n          name: 'Complex Shape:',\n          value: '30 credits ($0.30)'\n        }, {\n          name: 'Editing:',\n          value: '5 credits ($0.05)'\n        }, {\n          name: 'Export:',\n          value: '2 credits ($0.02)'\n        }];\n        rates.forEach(function (rate) {\n          var row = document.createElement('tr');\n          var nameCell = document.createElement('td');\n          nameCell.textContent = rate.name;\n          nameCell.style.padding = '4px 0';\n          nameCell.style.color = '#888';\n          var valueCell = document.createElement('td');\n          valueCell.textContent = rate.value;\n          valueCell.style.padding = '4px 0';\n          valueCell.style.textAlign = 'right';\n          valueCell.style.color = '#aaa';\n          row.appendChild(nameCell);\n          row.appendChild(valueCell);\n          ratesTable.appendChild(row);\n        });\n        infoPopup.appendChild(infoHeading);\n        infoPopup.appendChild(ratesTable);\n        modalHeader.appendChild(infoPopup);\n        infoPopupOpen = true;\n\n        // Close when clicking outside\n        document.addEventListener('click', function closeInfoPopup(e) {\n          if (!infoPopup.contains(e.target) && e.target !== infoButton) {\n            infoPopup.remove();\n            infoPopupOpen = false;\n            document.removeEventListener('click', closeInfoPopup);\n          }\n        });\n      });\n      headerLeft.appendChild(modalTitle);\n      headerLeft.appendChild(infoButton);\n      var closeButton = document.createElement('button');\n      closeButton.className = 'close-button';\n      closeButton.innerHTML = \"<svg width=\\\"14\\\" height=\\\"14\\\" viewBox=\\\"0 0 14 14\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n    <path d=\\\"M1 1L13 13M1 13L13 1\\\" stroke=\\\"#fff\\\" stroke-width=\\\"1.5\\\" stroke-linecap=\\\"round\\\"/>\\n  </svg>\";\n      closeButton.style.backgroundColor = 'transparent';\n      closeButton.style.border = 'none';\n      closeButton.style.cursor = 'pointer';\n      closeButton.style.padding = '4px';\n      closeButton.style.display = 'flex';\n      closeButton.style.alignItems = 'center';\n      closeButton.style.justifyContent = 'center';\n      closeButton.onclick = function () {\n        return modal.remove();\n      };\n      modalHeader.appendChild(headerLeft);\n      modalHeader.appendChild(closeButton);\n\n      // Current credit balance\n      var currentBalance = document.createElement('div');\n      currentBalance.style.display = 'flex';\n      currentBalance.style.alignItems = 'center';\n      currentBalance.style.justifyContent = 'space-between';\n      currentBalance.style.padding = '16px';\n      currentBalance.style.backgroundColor = '#111';\n      currentBalance.style.borderRadius = '8px';\n      currentBalance.style.marginBottom = '24px';\n      var balanceLabel = document.createElement('span');\n      balanceLabel.textContent = 'Current Balance:';\n      balanceLabel.style.color = '#888';\n      balanceLabel.style.fontSize = '14px';\n      var balanceValue = document.createElement('span');\n      balanceValue.textContent = \"\".concat(this.userCredits, \" credits\");\n      balanceValue.style.color = '#fff';\n      balanceValue.style.fontWeight = 'bold';\n      balanceValue.style.fontSize = '16px';\n      currentBalance.appendChild(balanceLabel);\n      currentBalance.appendChild(balanceValue);\n\n      // Credit packages section\n      var packagesTitle = document.createElement('div');\n      packagesTitle.textContent = 'Select a Credit Package';\n      packagesTitle.style.fontSize = '16px';\n      packagesTitle.style.marginTop = '10px';\n      packagesTitle.style.marginBottom = '16px';\n      packagesTitle.style.color = '#eee';\n\n      // Credit packages grid\n      var packagesGrid = document.createElement('div');\n      packagesGrid.style.display = 'grid';\n      packagesGrid.style.gridTemplateColumns = 'repeat(2, 1fr)';\n      packagesGrid.style.gap = '12px';\n      packagesGrid.style.marginBottom = '24px';\n\n      // Package options\n      var creditPackages = [{\n        id: 'basic',\n        credits: 100,\n        price: 1.00,\n        name: 'Basic'\n      }, {\n        id: 'standard',\n        credits: 500,\n        price: 4.00,\n        name: 'Standard',\n        tag: 'Popular',\n        discount: 20\n      }, {\n        id: 'pro',\n        credits: 1000,\n        price: 7.00,\n        name: 'Pro',\n        discount: 30\n      }, {\n        id: 'ultimate',\n        credits: 5000,\n        price: 29.00,\n        name: 'Ultimate',\n        discount: 42,\n        tag: 'Best Value'\n      }];\n\n      // Create Buy button container\n      var buyButtonContainer = document.createElement('div');\n      buyButtonContainer.style.marginBottom = '24px';\n      buyButtonContainer.style.display = 'flex';\n      buyButtonContainer.style.justifyContent = 'center';\n\n      // Create Buy button (defined before package cards logic but added to DOM later)\n      var buyButton = document.createElement('button');\n      buyButton.id = 'purchase-button';\n      buyButton.textContent = 'Select a package to continue';\n      buyButton.style.width = '100%';\n      buyButton.style.backgroundColor = '#333333';\n      buyButton.style.color = '#FFFFFF';\n      buyButton.style.border = 'none';\n      buyButton.style.borderRadius = '30px';\n      buyButton.style.padding = '14px 24px';\n      buyButton.style.fontSize = '16px';\n      buyButton.style.fontWeight = 'bold';\n      buyButton.style.cursor = 'not-allowed';\n      buyButton.style.opacity = '0.5';\n      buyButton.style.transition = 'background-color 0.2s ease, transform 0.2s ease, opacity 0.2s ease';\n      buyButton.disabled = true;\n\n      // Add hover effect for when button is enabled\n      buyButton.addEventListener('mouseover', function () {\n        if (!buyButton.disabled) {\n          buyButton.style.transform = 'translateY(-2px)';\n          buyButton.style.boxShadow = '0 4px 12px rgba(255, 255, 255, 0.2)';\n        }\n      });\n      buyButton.addEventListener('mouseout', function () {\n        buyButton.style.transform = 'translateY(0)';\n        buyButton.style.boxShadow = 'none';\n      });\n\n      // Add click handler for purchase\n      buyButton.addEventListener('click', function () {\n        if (selectedPackageId) {\n          var selectedPackage = creditPackages.find(function (pkg) {\n            return pkg.id === selectedPackageId;\n          });\n          if (selectedPackage) {\n            _this6.handlePurchase(selectedPackage);\n          }\n        }\n      });\n\n      // Add the button to its container\n      buyButtonContainer.appendChild(buyButton);\n\n      // Track selected package\n      var selectedPackageId = null;\n      creditPackages.forEach(function (pkg) {\n        var packageCard = document.createElement('div');\n        packageCard.className = 'credit-package';\n        packageCard.dataset.packageId = pkg.id;\n        packageCard.style.backgroundColor = '#111';\n        packageCard.style.borderRadius = '8px';\n        packageCard.style.padding = '16px';\n        packageCard.style.display = 'flex';\n        packageCard.style.flexDirection = 'column';\n        packageCard.style.cursor = 'pointer';\n        packageCard.style.transition = 'background-color 0.2s ease, transform 0.2s ease, border-color 0.2s ease';\n        packageCard.style.position = 'relative';\n        packageCard.style.border = '2px solid transparent';\n\n        // Add hover effects\n        packageCard.addEventListener('mouseover', function () {\n          if (selectedPackageId !== pkg.id) {\n            packageCard.style.backgroundColor = '#181818';\n            packageCard.style.transform = 'translateY(-2px)';\n          }\n        });\n        packageCard.addEventListener('mouseout', function () {\n          if (selectedPackageId !== pkg.id) {\n            packageCard.style.backgroundColor = '#111';\n            packageCard.style.transform = 'translateY(0)';\n          }\n        });\n\n        // Package name container\n        var nameContainer = document.createElement('div');\n        nameContainer.style.display = 'flex';\n        nameContainer.style.justifyContent = 'space-between';\n        nameContainer.style.alignItems = 'center';\n        nameContainer.style.marginBottom = '10px';\n        var packageName = document.createElement('span');\n        packageName.textContent = pkg.name;\n        packageName.style.fontSize = '14px';\n        packageName.style.color = '#fff';\n        packageName.style.fontWeight = 'medium';\n        nameContainer.appendChild(packageName);\n\n        // Add tag if present\n        if (pkg.tag) {\n          var tag = document.createElement('span');\n          tag.textContent = pkg.tag;\n          tag.style.fontSize = '10px';\n          tag.style.padding = '3px 8px';\n          tag.style.backgroundColor = pkg.tag === 'Popular' ? '#2a7de1' : '#e12a7d';\n          tag.style.color = '#fff';\n          tag.style.borderRadius = '12px';\n          tag.style.marginLeft = '8px';\n          nameContainer.appendChild(tag);\n        }\n\n        // Credit amount\n        var creditAmount = document.createElement('div');\n        creditAmount.textContent = \"\".concat(pkg.credits, \" credits\");\n        creditAmount.style.fontSize = '20px';\n        creditAmount.style.marginBottom = '10px';\n        creditAmount.style.color = '#fff';\n        creditAmount.style.fontWeight = 'bold';\n\n        // Price display - simplified\n        var priceContainer = document.createElement('div');\n        priceContainer.style.display = 'flex';\n        priceContainer.style.alignItems = 'center';\n        priceContainer.style.marginTop = 'auto';\n        var price = document.createElement('span');\n        price.textContent = \"$\".concat(pkg.price.toFixed(2));\n        price.style.fontSize = '16px';\n        price.style.color = '#999';\n        priceContainer.appendChild(price);\n\n        // Add discount if present\n        if (pkg.discount) {\n          var discountTag = document.createElement('span');\n          discountTag.textContent = \"Save \".concat(pkg.discount, \"%\");\n          discountTag.style.fontSize = '12px';\n          discountTag.style.color = '#4CAF50';\n          discountTag.style.marginLeft = '8px';\n          priceContainer.appendChild(discountTag);\n        }\n\n        // Assemble package card\n        packageCard.appendChild(nameContainer);\n        packageCard.appendChild(creditAmount);\n        packageCard.appendChild(priceContainer);\n\n        // Function to update package selection\n        var updateSelectedPackage = function updateSelectedPackage(packageId) {\n          // Update global selectedPackageId\n          selectedPackageId = packageId;\n\n          // Update all package cards\n          document.querySelectorAll('.credit-package').forEach(function (card) {\n            var cardId = card.dataset.packageId;\n            if (cardId === packageId) {\n              // Selected state - using white border instead of green\n              card.style.backgroundColor = '#1A1A1A';\n              card.style.borderColor = '#FFFFFF';\n              card.style.transform = 'translateY(-2px)';\n            } else {\n              // Unselected state\n              card.style.backgroundColor = '#111';\n              card.style.borderColor = 'transparent';\n              card.style.transform = 'translateY(0)';\n            }\n          });\n\n          // Update buy button text and state\n          var selectedPackage = creditPackages.find(function (p) {\n            return p.id === packageId;\n          });\n          if (selectedPackage) {\n            buyButton.textContent = \"Buy \".concat(selectedPackage.name, \" Package for $\").concat(selectedPackage.price.toFixed(2));\n            buyButton.disabled = false;\n            buyButton.style.opacity = '1';\n            buyButton.style.cursor = 'pointer';\n            buyButton.style.backgroundColor = '#FFFFFF';\n            buyButton.style.color = '#000000';\n          } else {\n            buyButton.textContent = 'Select a package to continue';\n            buyButton.disabled = true;\n            buyButton.style.opacity = '0.5';\n            buyButton.style.cursor = 'not-allowed';\n            buyButton.style.backgroundColor = '#333333';\n            buyButton.style.color = '#FFFFFF';\n          }\n        };\n\n        // Add click handler for selection\n        packageCard.addEventListener('click', function () {\n          updateSelectedPackage(pkg.id);\n        });\n        packagesGrid.appendChild(packageCard);\n      });\n\n      // Transaction history section\n      var historyTitle = document.createElement('div');\n      historyTitle.textContent = 'Recent Transactions';\n      historyTitle.style.fontSize = '14px';\n      historyTitle.style.marginTop = '10px';\n      historyTitle.style.marginBottom = '10px';\n      historyTitle.style.color = '#888';\n\n      // Create a transaction container\n      var transactionContainer = document.createElement('div');\n      transactionContainer.style.backgroundColor = '#111';\n      transactionContainer.style.borderRadius = '8px';\n      transactionContainer.style.overflow = 'hidden';\n      transactionContainer.style.marginBottom = '16px';\n\n      // Create a table for transactions\n      var transactionTable = document.createElement('table');\n      transactionTable.style.width = '100%';\n      transactionTable.style.borderCollapse = 'collapse';\n      transactionTable.style.fontSize = '12px';\n\n      // Table header\n      var tableHeader = document.createElement('tr');\n      tableHeader.innerHTML = \"\\n    <th style=\\\"text-align: left; padding: 8px 12px; color: #888; border-bottom: 1px solid #222;\\\">Date</th>\\n    <th style=\\\"text-align: left; padding: 8px 12px; color: #888; border-bottom: 1px solid #222;\\\">Type</th>\\n    <th style=\\\"text-align: right; padding: 8px 12px; color: #888; border-bottom: 1px solid #222;\\\">Amount</th>\\n  \";\n      transactionTable.appendChild(tableHeader);\n      transactionContainer.appendChild(transactionTable);\n\n      // Loading indicator for transactions\n      var loadingRow = document.createElement('tr');\n      var loadingCell = document.createElement('td');\n      loadingCell.colSpan = 3;\n      loadingCell.textContent = 'Loading transactions...';\n      loadingCell.style.textAlign = 'center';\n      loadingCell.style.padding = '16px';\n      loadingCell.style.color = '#777';\n      loadingRow.appendChild(loadingCell);\n      transactionTable.appendChild(loadingRow);\n\n      // Assemble the modal in correct order\n      modalContent.appendChild(modalHeader);\n      modalContent.appendChild(currentBalance);\n      modalContent.appendChild(packagesTitle);\n      modalContent.appendChild(packagesGrid);\n      // Now add the buy button container AFTER the package grid\n      modalContent.appendChild(buyButtonContainer);\n      modalContent.appendChild(historyTitle);\n      modalContent.appendChild(transactionContainer);\n      modal.appendChild(modalContent);\n      document.body.appendChild(modal);\n\n      // Add Escape key handler\n      var _handleEscape = function handleEscape(e) {\n        if (e.key === 'Escape') {\n          modal.remove();\n          document.removeEventListener('keydown', _handleEscape);\n        }\n      };\n      document.addEventListener('keydown', _handleEscape);\n\n      // Load transaction history\n      this.loadRecentTransactions(transactionTable, 3);\n    }\n\n    /**\n     * Load recent transactions into the transaction table\n     * @param {HTMLElement} table - The table element to populate\n     * @param {number} limit - Maximum number of transactions to show\n     */\n  }, {\n    key: \"loadRecentTransactions\",\n    value: (function () {\n      var _loadRecentTransactions = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(table) {\n        var limit,\n          _yield$this$getCredit,\n          success,\n          transactions,\n          noDataRow,\n          noDataCell,\n          errorRow,\n          errorCell,\n          _args6 = arguments;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              limit = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : 3;\n              _context6.prev = 1;\n              _context6.next = 4;\n              return this.getCreditTransactions(limit);\n            case 4:\n              _yield$this$getCredit = _context6.sent;\n              success = _yield$this$getCredit.success;\n              transactions = _yield$this$getCredit.transactions;\n              // Remove loading row\n              table.querySelector('tr:nth-child(2)').remove();\n              if (!(!success || transactions.length === 0)) {\n                _context6.next = 19;\n                break;\n              }\n              noDataRow = document.createElement('tr');\n              noDataCell = document.createElement('td');\n              noDataCell.colSpan = 3;\n              noDataCell.textContent = 'No transaction history';\n              noDataCell.style.textAlign = 'center';\n              noDataCell.style.padding = '16px';\n              noDataCell.style.color = '#777';\n              noDataRow.appendChild(noDataCell);\n              table.appendChild(noDataRow);\n              return _context6.abrupt(\"return\");\n            case 19:\n              // Add transaction rows\n              transactions.forEach(function (transaction) {\n                // Format date\n                var date = new Date(transaction.created_at);\n                var formattedDate = \"\".concat(date.getMonth() + 1, \"/\").concat(date.getDate(), \"/\").concat(date.getFullYear());\n\n                // Format type - convert from snake_case to readable format\n                var type = transaction.transaction_type.replace(/_/g, ' ');\n\n                // Format amount with color\n                var amount = transaction.amount;\n                var amountColor = amount > 0 ? '#4CAF50' : '#ff5555';\n                var formattedAmount = amount > 0 ? \"+\".concat(amount) : amount.toString();\n                var row = document.createElement('tr');\n                row.style.borderBottom = '1px solid #222';\n                var dateCell = document.createElement('td');\n                dateCell.textContent = formattedDate;\n                dateCell.style.padding = '8px 12px';\n                dateCell.style.color = '#888';\n                var typeCell = document.createElement('td');\n                typeCell.textContent = type;\n                typeCell.style.padding = '8px 12px';\n                typeCell.style.color = '#888';\n                var amountCell = document.createElement('td');\n                amountCell.textContent = formattedAmount;\n                amountCell.style.padding = '8px 12px';\n                amountCell.style.textAlign = 'right';\n                amountCell.style.color = amountColor;\n                row.appendChild(dateCell);\n                row.appendChild(typeCell);\n                row.appendChild(amountCell);\n                table.appendChild(row);\n              });\n              _context6.next = 35;\n              break;\n            case 22:\n              _context6.prev = 22;\n              _context6.t0 = _context6[\"catch\"](1);\n              console.error('Error loading transaction history:', _context6.t0);\n\n              // Show error message\n              table.querySelector('tr:nth-child(2)').remove();\n              errorRow = document.createElement('tr');\n              errorCell = document.createElement('td');\n              errorCell.colSpan = 3;\n              errorCell.textContent = 'Error loading transactions';\n              errorCell.style.textAlign = 'center';\n              errorCell.style.padding = '16px';\n              errorCell.style.color = '#ff5555';\n              errorRow.appendChild(errorCell);\n              table.appendChild(errorRow);\n            case 35:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this, [[1, 22]]);\n      }));\n      function loadRecentTransactions(_x5) {\n        return _loadRecentTransactions.apply(this, arguments);\n      }\n      return loadRecentTransactions;\n    }()\n    /**\n     * Load transaction history into the provided container\n     */\n    )\n  }, {\n    key: \"loadTransactionHistory\",\n    value: (function () {\n      var _loadTransactionHistory = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7(container) {\n        var _yield$this$getCredit2, success, transactions, table, thead, tbody;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              if (container) {\n                _context7.next = 2;\n                break;\n              }\n              return _context7.abrupt(\"return\");\n            case 2:\n              _context7.prev = 2;\n              _context7.next = 5;\n              return this.getCreditTransactions(5);\n            case 5:\n              _yield$this$getCredit2 = _context7.sent;\n              success = _yield$this$getCredit2.success;\n              transactions = _yield$this$getCredit2.transactions;\n              // Clear container\n              container.innerHTML = '';\n              if (!(!success || transactions.length === 0)) {\n                _context7.next = 12;\n                break;\n              }\n              container.innerHTML = '<div style=\"text-align: center; color: #888; padding: 16px;\">No transactions found</div>';\n              return _context7.abrupt(\"return\");\n            case 12:\n              // Create table for transactions\n              table = document.createElement('table');\n              table.style.width = '100%';\n              table.style.borderCollapse = 'collapse';\n              table.style.fontSize = '12px';\n\n              // Table header\n              thead = document.createElement('thead');\n              thead.innerHTML = \"\\n        <tr>\\n          <th style=\\\"text-align: left; padding: 8px; color: #888;\\\">Date</th>\\n          <th style=\\\"text-align: left; padding: 8px; color: #888;\\\">Type</th>\\n          <th style=\\\"text-align: right; padding: 8px; color: #888;\\\">Amount</th>\\n        </tr>\\n      \";\n\n              // Table body\n              tbody = document.createElement('tbody');\n              transactions.forEach(function (transaction) {\n                // Format date\n                var date = new Date(transaction.created_at);\n                var formattedDate = \"\".concat(date.getMonth() + 1, \"/\").concat(date.getDate(), \"/\").concat(date.getFullYear());\n\n                // Format type\n                var type = transaction.transaction_type.replace(/_/g, ' ');\n                type = type.charAt(0).toUpperCase() + type.slice(1);\n\n                // Format amount - positive or negative\n                var amount = transaction.amount;\n                var formattedAmount = amount > 0 ? \"+\".concat(amount) : amount.toString();\n                var amountColor = amount > 0 ? '#4CAF50' : '#ff5555';\n                var row = document.createElement('tr');\n                row.innerHTML = \"\\n          <td style=\\\"padding: 8px; color: #ccc;\\\">\".concat(formattedDate, \"</td>\\n          <td style=\\\"padding: 8px; color: #ccc;\\\">\").concat(type, \"</td>\\n          <td style=\\\"padding: 8px; text-align: right; color: \").concat(amountColor, \"; font-weight: bold;\\\">\").concat(formattedAmount, \"</td>\\n        \");\n                tbody.appendChild(row);\n              });\n              table.appendChild(thead);\n              table.appendChild(tbody);\n              container.appendChild(table);\n              _context7.next = 29;\n              break;\n            case 25:\n              _context7.prev = 25;\n              _context7.t0 = _context7[\"catch\"](2);\n              console.error('Error loading transaction history:', _context7.t0);\n              container.innerHTML = '<div style=\"text-align: center; color: #ff5555; padding: 16px;\">Error loading transactions</div>';\n            case 29:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this, [[2, 25]]);\n      }));\n      function loadTransactionHistory(_x6) {\n        return _loadTransactionHistory.apply(this, arguments);\n      }\n      return loadTransactionHistory;\n    }()\n    /**\n     * Handle purchase of credit package\n     * @param {Object} package - Credit package selected\n     */\n    // async handlePurchase(packageInfo) {\n    //   // In a real app, you would integrate with a payment processor like Stripe\n    //   // For this demo, we'll simulate a successful purchase\n    //   // 1. Integrate with a payment processor like Stripe\n    //   // 2. Verify the payment was successful\n    //   // 3. Record the payment in your database\n    //   try {\n    //     // Show loading overlay\n    //     const loadingOverlay = document.createElement('div');\n    //     loadingOverlay.style.position = 'fixed';\n    //     loadingOverlay.style.top = '0';\n    //     loadingOverlay.style.left = '0';\n    //     loadingOverlay.style.width = '100%';\n    //     loadingOverlay.style.height = '100%';\n    //     loadingOverlay.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';\n    //     loadingOverlay.style.display = 'flex';\n    //     loadingOverlay.style.flexDirection = 'column';\n    //     loadingOverlay.style.justifyContent = 'center';\n    //     loadingOverlay.style.alignItems = 'center';\n    //     loadingOverlay.style.zIndex = '3000';\n    //     const loadingText = document.createElement('div');\n    //     loadingText.textContent = 'Processing payment...';\n    //     loadingText.style.color = '#fff';\n    //     loadingText.style.fontSize = '18px';\n    //     loadingText.style.marginBottom = '16px';\n    //     const spinner = document.createElement('div');\n    //     spinner.style.border = '4px solid rgba(255, 255, 255, 0.3)';\n    //     spinner.style.borderTop = '4px solid #fff';\n    //     spinner.style.borderRadius = '50%';\n    //     spinner.style.width = '40px';\n    //     spinner.style.height = '40px';\n    //     spinner.style.animation = 'spin 1s linear infinite';\n    //     // Add keyframe animation for spinner\n    //     const style = document.createElement('style');\n    //     style.textContent = `\n    //       @keyframes spin {\n    //         0% { transform: rotate(0deg); }\n    //         100% { transform: rotate(360deg); }\n    //       }\n    //     `;\n    //     document.head.appendChild(style);\n    //     loadingOverlay.appendChild(loadingText);\n    //     loadingOverlay.appendChild(spinner);\n    //     document.body.appendChild(loadingOverlay);\n    //     // Simulate payment processing delay\n    //     await new Promise(resolve => setTimeout(resolve, 1500));\n    //     // Generate a mock payment reference\n    //     const paymentRef = 'PAY-' + Math.random().toString(36).substring(2, 10).toUpperCase();\n    //     // Add credits to user account\n    //     const result = await this.addCredits(\n    //       packageInfo.credits,\n    //       'purchase',\n    //       `Purchased ${packageInfo.name} package (${packageInfo.credits} credits)`,\n    //       paymentRef\n    //     );\n    //     // Remove loading overlay\n    //     loadingOverlay.remove();\n    //     if (result) {\n    //       // Close purchase modal\n    //       const modal = document.getElementById('credit-purchase-modal');\n    //       if (modal) modal.remove();\n    //       // Show success message\n    //       this.showToast(`Successfully purchased ${packageInfo.credits} credits!`, 'success');\n    //     } else {\n    //       throw new Error('Failed to process payment');\n    //     }\n    //   } catch (error) {\n    //     console.error('Purchase error:', error);\n    //     // Remove loading overlay if it exists\n    //     const loadingOverlay = document.querySelector('div[style*=\"zIndex: 3000\"]');\n    //     if (loadingOverlay) loadingOverlay.remove();\n    //     // Show error message\n    //     this.showToast(`Error processing payment: ${error.message}`, 'error');\n    //   }\n    // }\n    /**\n    * Handle purchase of credit package using Stripe Checkout via Supabase Edge Functions\n    * @param {Object} packageInfo - Credit package selected\n    */\n    )\n  }, {\n    key: \"handlePurchase\",\n    value: (function () {\n      var _handlePurchase = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8(packageInfo) {\n        var loadingOverlay, stripe, sessionData, result, _loadingOverlay;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              _context8.prev = 0;\n              // Show loading overlay while we initialize\n              loadingOverlay = this.createLoadingOverlay('Initializing payment...');\n              document.body.appendChild(loadingOverlay);\n\n              // 1. Load Stripe.js if not already loaded\n              if (window.Stripe) {\n                _context8.next = 6;\n                break;\n              }\n              _context8.next = 6;\n              return this.loadStripeJs();\n            case 6:\n              // 2. Initialize Stripe with the test publishable key\n              stripe = Stripe('pk_test_51R1kMPLF0vUkU48xOxllf1a4Zw4EgSOgsKtDsKXqP1XPqulHsex3B81o1tze5iB752MFq36KoDwLHNs5mWD6Evdn0069s2J6SK'); // 3. Create a checkout session via Supabase Edge Function\n              _context8.next = 9;\n              return this.createCheckoutSession(packageInfo);\n            case 9:\n              sessionData = _context8.sent;\n              // Remove loading overlay\n              loadingOverlay.remove();\n\n              // 4. Redirect to Stripe Checkout\n              _context8.next = 13;\n              return stripe.redirectToCheckout({\n                sessionId: sessionData.id\n              });\n            case 13:\n              result = _context8.sent;\n              if (!result.error) {\n                _context8.next = 16;\n                break;\n              }\n              throw new Error(result.error.message);\n            case 16:\n              _context8.next = 24;\n              break;\n            case 18:\n              _context8.prev = 18;\n              _context8.t0 = _context8[\"catch\"](0);\n              console.error('Purchase error:', _context8.t0);\n\n              // Remove loading overlay if it exists\n              _loadingOverlay = document.querySelector('div[style*=\"zIndex: 3000\"]');\n              if (_loadingOverlay) _loadingOverlay.remove();\n\n              // Show error message\n              this.showToast(\"Error processing payment: \".concat(_context8.t0.message), 'error');\n            case 24:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8, this, [[0, 18]]);\n      }));\n      function handlePurchase(_x7) {\n        return _handlePurchase.apply(this, arguments);\n      }\n      return handlePurchase;\n    }()\n    /**\n     * Load the Stripe.js library\n     * @returns {Promise} Resolves when Stripe is loaded\n     */\n    )\n  }, {\n    key: \"loadStripeJs\",\n    value: function loadStripeJs() {\n      return new Promise(function (resolve, reject) {\n        var script = document.createElement('script');\n        script.src = 'https://js.stripe.com/v3/';\n        script.onload = resolve;\n        script.onerror = function () {\n          return reject(new Error('Failed to load Stripe.js'));\n        };\n        document.head.appendChild(script);\n      });\n    }\n\n    /**\n     * Create a checkout session with Stripe via Supabase Edge Function\n     * @param {Object} packageInfo - Credit package selected\n     * @returns {Promise<Object>} Session data with ID\n     */\n  }, {\n    key: \"createCheckoutSession\",\n    value: (function () {\n      var _createCheckoutSession = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee9(packageInfo) {\n        var _this$app$auth$supaba, _this$app$auth$getCur, userId, user, response, errorData;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              _context9.prev = 0;\n              // Get the current user ID if authenticated\n              userId = null;\n              if (this.app.auth && this.app.auth.getCurrentUser) {\n                user = this.app.auth.getCurrentUser();\n                userId = user === null || user === void 0 ? void 0 : user.id;\n              }\n              if (userId) {\n                _context9.next = 5;\n                break;\n              }\n              throw new Error('You must be signed in to purchase credits');\n            case 5:\n              console.log('Creating checkout session for package:', packageInfo);\n\n              // Call the Supabase Edge Function\n              _context9.next = 8;\n              return fetch('https://avufsgjwbzjinyccruqc.supabase.co/functions/v1/create-checkout-session', {\n                method: 'POST',\n                headers: {\n                  'Content-Type': 'application/json',\n                  'Authorization': \"Bearer \".concat(((_this$app$auth$supaba = this.app.auth.supabase.auth.getSession()) === null || _this$app$auth$supaba === void 0 ? void 0 : _this$app$auth$supaba.access_token) || '')\n                },\n                body: JSON.stringify({\n                  packageId: packageInfo.name,\n                  credits: packageInfo.credits,\n                  price: packageInfo.price,\n                  userId: userId,\n                  email: ((_this$app$auth$getCur = this.app.auth.getCurrentUser()) === null || _this$app$auth$getCur === void 0 ? void 0 : _this$app$auth$getCur.email) || '' // Add email for better tracking\n                })\n              });\n            case 8:\n              response = _context9.sent;\n              if (response.ok) {\n                _context9.next = 14;\n                break;\n              }\n              _context9.next = 12;\n              return response.json();\n            case 12:\n              errorData = _context9.sent;\n              throw new Error(errorData.error || 'Failed to create checkout session');\n            case 14:\n              _context9.next = 16;\n              return response.json();\n            case 16:\n              return _context9.abrupt(\"return\", _context9.sent);\n            case 19:\n              _context9.prev = 19;\n              _context9.t0 = _context9[\"catch\"](0);\n              console.error('Error creating checkout session:', _context9.t0);\n              throw new Error('Failed to initialize payment. Please try again.');\n            case 23:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee9, this, [[0, 19]]);\n      }));\n      function createCheckoutSession(_x8) {\n        return _createCheckoutSession.apply(this, arguments);\n      }\n      return createCheckoutSession;\n    }()\n    /**\n     * Create a loading overlay\n     * @param {string} message - The message to display\n     * @returns {HTMLElement} The loading overlay element\n     */\n    )\n  }, {\n    key: \"createLoadingOverlay\",\n    value: function createLoadingOverlay(message) {\n      var loadingOverlay = document.createElement('div');\n      loadingOverlay.style.position = 'fixed';\n      loadingOverlay.style.top = '0';\n      loadingOverlay.style.left = '0';\n      loadingOverlay.style.width = '100%';\n      loadingOverlay.style.height = '100%';\n      loadingOverlay.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';\n      loadingOverlay.style.display = 'flex';\n      loadingOverlay.style.flexDirection = 'column';\n      loadingOverlay.style.justifyContent = 'center';\n      loadingOverlay.style.alignItems = 'center';\n      loadingOverlay.style.zIndex = '3000';\n      var loadingText = document.createElement('div');\n      loadingText.textContent = message;\n      loadingText.style.color = '#fff';\n      loadingText.style.fontSize = '18px';\n      loadingText.style.marginBottom = '16px';\n      var spinner = document.createElement('div');\n      spinner.style.border = '4px solid rgba(255, 255, 255, 0.3)';\n      spinner.style.borderTop = '4px solid #fff';\n      spinner.style.borderRadius = '50%';\n      spinner.style.width = '40px';\n      spinner.style.height = '40px';\n      spinner.style.animation = 'spin 1s linear infinite';\n\n      // Add keyframe animation for spinner if not already added\n      if (!document.getElementById('spinner-animation')) {\n        var style = document.createElement('style');\n        style.id = 'spinner-animation';\n        style.textContent = \"\\n      @keyframes spin {\\n        0% { transform: rotate(0deg); }\\n        100% { transform: rotate(360deg); }\\n      }\\n    \";\n        document.head.appendChild(style);\n      }\n      loadingOverlay.appendChild(loadingText);\n      loadingOverlay.appendChild(spinner);\n      return loadingOverlay;\n    }\n\n    /**\n     * Show toast message\n     * @param {string} message - Message to display\n     * @param {string} type - Type of toast (success, error, warning)\n     */\n  }, {\n    key: \"showToast\",\n    value: function showToast(message) {\n      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'success';\n      // Create toast container\n      var toast = document.createElement('div');\n      toast.className = 'toast';\n      toast.style.position = 'fixed';\n      toast.style.bottom = '16px';\n      toast.style.left = '50%';\n      toast.style.transform = 'translateX(-50%)';\n      toast.style.backgroundColor = type === 'success' ? '#4CAF50' : type === 'warning' ? '#ff9800' : '#ff5555';\n      toast.style.color = '#fff';\n      toast.style.padding = '12px 18px';\n      toast.style.borderRadius = '4px';\n      toast.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.2)';\n      toast.style.zIndex = '5000';\n      toast.style.fontFamily = \"'Menlo', 'Monaco', 'Courier New', monospace\";\n      toast.style.fontSize = '14px';\n      toast.textContent = message;\n\n      // Add to document\n      document.body.appendChild(toast);\n\n      // Remove after delay\n      setTimeout(function () {\n        toast.style.opacity = '0';\n        toast.style.transition = 'opacity 0.5s ease';\n        setTimeout(function () {\n          return toast.remove();\n        }, 500);\n      }, 3000);\n    }\n\n    /**\n     * Show insufficient credits modal with options to purchase more\n     * @param {string} operationType - Type of operation that requires credits\n     * @param {number} requiredCredits - Number of credits required\n     */\n  }, {\n    key: \"showInsufficientCreditsModal\",\n    value: function showInsufficientCreditsModal(operationType, requiredCredits) {\n      var _this7 = this;\n      // Remove any existing modal\n      var existingModal = document.getElementById('insufficient-credits-modal');\n      if (existingModal) {\n        existingModal.remove();\n      }\n\n      // Create modal container\n      var modal = document.createElement('div');\n      modal.id = 'insufficient-credits-modal';\n      modal.className = 'modal';\n      modal.style.position = 'fixed';\n      modal.style.top = '0';\n      modal.style.left = '0';\n      modal.style.width = '100%';\n      modal.style.height = '100%';\n      modal.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';\n      modal.style.display = 'flex';\n      modal.style.justifyContent = 'center';\n      modal.style.alignItems = 'center';\n      modal.style.zIndex = '2000';\n      modal.style.backdropFilter = 'blur(5px)';\n\n      // Create modal content\n      var modalContent = document.createElement('div');\n      modalContent.className = 'modal-content';\n      modalContent.style.backgroundColor = '#000';\n      modalContent.style.borderRadius = '8px';\n      modalContent.style.padding = '24px';\n      modalContent.style.width = '400px';\n      modalContent.style.maxWidth = '90%';\n      modalContent.style.color = '#e0e0e0';\n      modalContent.style.fontFamily = \"'Menlo', 'Monaco', 'Courier New', monospace\";\n\n      // Create modal header\n      var modalHeader = document.createElement('div');\n      modalHeader.className = 'modal-header';\n      modalHeader.style.display = 'flex';\n      modalHeader.style.justifyContent = 'space-between';\n      modalHeader.style.alignItems = 'center';\n      modalHeader.style.marginBottom = '16px';\n      var modalTitle = document.createElement('h3');\n      modalTitle.textContent = 'Insufficient Credits';\n      modalTitle.style.margin = '0';\n      modalTitle.style.fontSize = '20px';\n      modalTitle.style.fontWeight = 'normal';\n      modalTitle.style.color = '#ff5555';\n      var closeButton = document.createElement('button');\n      closeButton.className = 'close-button';\n      closeButton.innerHTML = \"\\n      <svg width=\\\"14\\\" height=\\\"14\\\" viewBox=\\\"0 0 14 14\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n        <path d=\\\"M1 1L13 13M1 13L13 1\\\" stroke=\\\"#e0e0e0\\\" stroke-width=\\\"1.5\\\" stroke-linecap=\\\"round\\\"/>\\n      </svg>\\n    \";\n      closeButton.style.backgroundColor = 'transparent';\n      closeButton.style.border = 'none';\n      closeButton.style.cursor = 'pointer';\n      closeButton.style.padding = '4px';\n      closeButton.style.display = 'flex';\n      closeButton.style.alignItems = 'center';\n      closeButton.style.justifyContent = 'center';\n      closeButton.onclick = function () {\n        return modal.remove();\n      };\n      modalHeader.appendChild(modalTitle);\n      modalHeader.appendChild(closeButton);\n\n      // Message\n      var message = document.createElement('p');\n      message.innerHTML = \"You need <strong>\".concat(requiredCredits, \" credits</strong> to \").concat(operationType.replace(/([A-Z])/g, ' $1').toLowerCase(), \", but you have <strong>\").concat(this.userCredits, \" credits</strong>.\");\n      message.style.marginBottom = '32px';\n      message.style.lineHeight = '1.5';\n      message.style.fontSize = '14px';\n      message.style.textAlign = 'cen';\n\n      // Credit packages\n      var packageOptions = document.createElement('div');\n      packageOptions.style.display = 'flex';\n      packageOptions.style.flexDirection = 'column';\n      packageOptions.style.gap = '12px';\n      packageOptions.style.marginBottom = '20px';\n\n      // Find the smallest package that covers the required credits\n      var neededCredits = requiredCredits - this.userCredits;\n\n      // Package options\n      var creditPackages = [{\n        credits: 100,\n        price: 1.00,\n        name: 'Basic'\n      }, {\n        credits: 500,\n        price: 4.00,\n        name: 'Standard'\n      }, {\n        credits: 1000,\n        price: 7.00,\n        name: 'Pro'\n      }];\n\n      // Find recommended package\n      var recommendedPackage = creditPackages[0];\n      for (var _i = 0, _creditPackages = creditPackages; _i < _creditPackages.length; _i++) {\n        var pkg = _creditPackages[_i];\n        if (pkg.credits >= neededCredits) {\n          recommendedPackage = pkg;\n          break;\n        }\n      }\n\n      // Create button for recommended package\n      var recommendedButton = document.createElement('button');\n      recommendedButton.textContent = \"Purchase \".concat(recommendedPackage.credits, \" credits for $\").concat(recommendedPackage.price.toFixed(2));\n      recommendedButton.style.backgroundColor = '#fff';\n      recommendedButton.style.color = '#000';\n      recommendedButton.style.border = 'none';\n      recommendedButton.style.borderRadius = '25px';\n      recommendedButton.style.padding = '12px 16px';\n      recommendedButton.style.fontSize = '16px';\n      recommendedButton.style.cursor = 'pointer';\n      recommendedButton.style.fontFamily = \"'Menlo', 'Monaco', 'Courier New', monospace\";\n      recommendedButton.style.display = 'flex';\n      recommendedButton.style.alignItems = 'center';\n      recommendedButton.style.justifyContent = 'center';\n      recommendedButton.style.position = 'relative';\n\n      // Handle purchase\n      recommendedButton.addEventListener('click', function () {\n        modal.remove();\n        _this7.handlePurchase(recommendedPackage);\n      });\n\n      // Button to see all options\n      var seeAllButton = document.createElement('button');\n      seeAllButton.textContent = 'See all purchase options';\n      seeAllButton.style.backgroundColor = '#333';\n      seeAllButton.style.color = '#fff';\n      seeAllButton.style.border = 'none';\n      seeAllButton.style.borderRadius = '25px';\n      seeAllButton.style.padding = '12px 16px';\n      seeAllButton.style.fontSize = '14px';\n      seeAllButton.style.cursor = 'pointer';\n      seeAllButton.style.fontFamily = \"'Menlo', 'Monaco', 'Courier New', monospace\";\n\n      // Handle see all options\n      seeAllButton.addEventListener('click', function () {\n        modal.remove();\n        _this7.showPurchaseModal();\n      });\n\n      // Add to container\n      packageOptions.appendChild(recommendedButton);\n      packageOptions.appendChild(seeAllButton);\n\n      // Assemble modal\n      modalContent.appendChild(modalHeader);\n      modalContent.appendChild(message);\n      modalContent.appendChild(packageOptions);\n      modal.appendChild(modalContent);\n      document.body.appendChild(modal);\n\n      // Add Escape key handler\n      var _handleEscape2 = function handleEscape(e) {\n        if (e.key === 'Escape') {\n          modal.remove();\n          document.removeEventListener('keydown', _handleEscape2);\n        }\n      };\n      document.addEventListener('keydown', _handleEscape2);\n    }\n\n    /**\n     * Modify the shape generator to check credits before generating shapes\n     */\n  }, {\n    key: \"modifyShapeGenerator\",\n    value: function modifyShapeGenerator() {\n      if (!this.app.generator || !this.app.generator.generateShape) {\n        console.error('Shape generator not found or missing generateShape method');\n        return;\n      }\n\n      // Skip if already modified\n      if (this.app.generator.generateShape._isModifiedForCredits) {\n        return;\n      }\n\n      // Store original method\n      var originalGenerateShape = this.app.generator.generateShape;\n\n      // Replace with version that checks credits\n      this.app.generator.generateShape = /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n        var operationType, requiredCredits, hasEnoughCredits, result, description;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              if (!(!this.controller.auth || !this.controller.auth.isAuthenticated())) {\n                _context10.next = 3;\n                break;\n              }\n              // Show auth modal\n              if (this.controller.auth && this.controller.auth.showAuthModal) {\n                this.controller.auth.showAuthModal('signin', null, 'generate shapes');\n              }\n              return _context10.abrupt(\"return\");\n            case 3:\n              // Determine cost based on complexity (description length, attached images)\n              operationType = 'generateBasicShape';\n              requiredCredits = this.controller.creditService.creditCosts[operationType]; // Check if user has enough credits\n              _context10.next = 7;\n              return this.controller.creditService.checkCreditBalance(operationType);\n            case 7:\n              hasEnoughCredits = _context10.sent;\n              if (hasEnoughCredits) {\n                _context10.next = 11;\n                break;\n              }\n              // Show insufficient credits modal\n              this.controller.creditService.showInsufficientCreditsModal(operationType, requiredCredits);\n              return _context10.abrupt(\"return\");\n            case 11:\n              _context10.next = 13;\n              return originalGenerateShape.call(this);\n            case 13:\n              result = _context10.sent;\n              if (!(result && !result.error)) {\n                _context10.next = 18;\n                break;\n              }\n              description = this.currentDescription || 'New shape';\n              _context10.next = 18;\n              return this.controller.creditService.deductCredits(operationType, \"Generated shape: \".concat(description.substring(0, 50), \"...\"));\n            case 18:\n              return _context10.abrupt(\"return\", result);\n            case 19:\n            case \"end\":\n              return _context10.stop();\n          }\n        }, _callee10, this);\n      }));\n\n      // Mark as modified to prevent double-wrapping\n      this.app.generator.generateShape._isModifiedForCredits = true;\n      console.log('Modified shape generator to check credits');\n    }\n  }]);\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CreditService);\n\n//# sourceURL=webpack://generative-shapes/./src/CreditService.js?");

/***/ }),

/***/ "./src/Integration.js":
/*!****************************!*\
  !*** ./src/Integration.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   setupIntegrations: () => (/* binding */ setupIntegrations)\n/* harmony export */ });\n/* harmony import */ var _authIntegration_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./authIntegration.js */ \"./src/authIntegration.js\");\n/* harmony import */ var _UserShapesIntegration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./UserShapesIntegration.js */ \"./src/UserShapesIntegration.js\");\n/* harmony import */ var _CreditIntegration_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CreditIntegration.js */ \"./src/CreditIntegration.js\");\n// Integration.js - Import all integration modules\n\n\n\n\n\n// Main integration function that will set up all features\nfunction setupIntegrations(app) {\n  // First integrate auth\n  var auth = (0,_authIntegration_js__WEBPACK_IMPORTED_MODULE_0__.integrateAuth)(app);\n\n  // Then integrate user shapes\n  var userShapes = (0,_UserShapesIntegration_js__WEBPACK_IMPORTED_MODULE_1__.integrateUserShapes)(app);\n\n  // Finally integrate credit system\n  var creditService = (0,_CreditIntegration_js__WEBPACK_IMPORTED_MODULE_2__.integrateCreditSystem)(app);\n  return {\n    auth: auth,\n    userShapes: userShapes,\n    creditService: creditService\n  };\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (setupIntegrations);\n\n//# sourceURL=webpack://generative-shapes/./src/Integration.js?");

/***/ }),

/***/ "./src/ShapeAnimationManager.js":
/*!**************************************!*\
  !*** ./src/ShapeAnimationManager.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n// ShapeAnimationManager.js\n//\n// This class handles all animation logic for shapes, including:\n// - Animation state management\n// - Parameter interpolation\n// - Animation loops\n// - Hover effects\nvar ShapeAnimationManager = /*#__PURE__*/function () {\n  function ShapeAnimationManager(app) {\n    _classCallCheck(this, ShapeAnimationManager);\n    this.app = app;\n    this.animationState = {};\n    this.animationFrameId = null;\n    this.currentlyHoveredId = null;\n    this.globalAnimationTime = 0;\n    this.ANIMATION_DENSITY = 0.1; // Only ~10% of shapes animate at once\n    this.animationEnabled = true;\n\n    // Bind methods\n    this.startAnimationLoop = this.startAnimationLoop.bind(this);\n    this.updateShapeAnimation = this.updateShapeAnimation.bind(this);\n    this.setupShapeHoverEvents = this.setupShapeHoverEvents.bind(this);\n  }\n\n  /**\n   * Initialize animation state for a shape\n   */\n  return _createClass(ShapeAnimationManager, [{\n    key: \"initAnimationState\",\n    value: function initAnimationState(shapeName, shapeId) {\n      if (!this.animationEnabled) return null;\n\n      // Get the shape class\n      var ShapeClass = this.app.shapes[shapeName];\n      if (!ShapeClass) return null;\n      try {\n        // Create a shape instance to get default parameters\n        var shapeInstance = new ShapeClass();\n\n        // Get parameters for this shape type\n        var classParameters = ShapeClass.parameters || {};\n        var allParameters = _objectSpread(_objectSpread({}, this.app.Shape.parameters), classParameters);\n\n        // Create animation state object\n        var state = {\n          shapeName: shapeName,\n          isAnimating: false,\n          shouldAnimate: false,\n          transitionTime: 3.0,\n          progress: 0,\n          hovering: false,\n          returningToDefault: false,\n          stopAfterDefault: false,\n          currentParams: {},\n          targetParams: {},\n          initialParams: {},\n          defaultParams: {}\n        };\n\n        // Set up parameters\n        Object.entries(allParameters).forEach(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n            param = _ref2[0],\n            config = _ref2[1];\n          if (typeof shapeInstance[param] === 'number' || config.options) {\n            state.currentParams[param] = shapeInstance[param];\n            state.targetParams[param] = shapeInstance[param];\n            state.initialParams[param] = shapeInstance[param];\n            state.defaultParams[param] = shapeInstance[param];\n          }\n        });\n        return state;\n      } catch (error) {\n        console.error(\"Error initializing animation state for shape \".concat(shapeName, \":\"), error);\n        return null;\n      }\n    }\n\n    /**\n     * Check if a parameter should not be interpolated on hover\n     */\n  }, {\n    key: \"isNonInterpolatedParam\",\n    value: function isNonInterpolatedParam(param) {\n      // Convert parameter name to lowercase for case-insensitive matching\n      var paramLower = param.toLowerCase();\n\n      // Exact matches for parameters that should never be interpolated during hover\n      // These are structural parameters that would cause layout shifts\n      var exactNoInterpolateParams = ['rows', 'columns', 'randomlayout', 'count', 'resolution', 'value', 'arms'];\n      if (exactNoInterpolateParams.includes(paramLower) || paramLower.includes('linecount')) {\n        return true;\n      }\n\n      // Special case: these parameters should be interpolated despite containing excluded keywords\n      var specialInterpolateParams = ['cornerradius', 'gapsize'];\n      if (specialInterpolateParams.includes(paramLower)) {\n        return false;\n      }\n\n      // General exclusions\n      return paramLower.includes('radius') || paramLower.includes('size') || paramLower.includes('thickness') || paramLower.includes('segments');\n    }\n\n    /**\n     * Set a new target state for shape interpolation\n     */\n  }, {\n    key: \"setNewTargetState\",\n    value: function setNewTargetState(shapeName, shapeId) {\n      var _this = this;\n      var moreRandomness = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      if (!this.animationEnabled) return;\n\n      // Initialize animation state if it doesn't exist\n      if (!this.animationState[shapeId]) {\n        this.animationState[shapeId] = this.initAnimationState(shapeName, shapeId);\n        if (!this.animationState[shapeId]) return;\n      }\n      var state = this.animationState[shapeId];\n\n      // Cancel the return animation if we're hovering again\n      if (state.returningToDefault && state.hovering) {\n        state.returningToDefault = false;\n        state.stopAfterDefault = false;\n      }\n\n      // Get the shape class\n      var ShapeClass = this.app.shapes[shapeName];\n      if (!ShapeClass) return;\n      try {\n        // Get parameters for this shape type\n        var classParameters = ShapeClass.parameters || {};\n        var allParameters = _objectSpread(_objectSpread({}, this.app.Shape.parameters), classParameters);\n\n        // Save current params as initial for smooth transition\n        Object.keys(state.currentParams).forEach(function (param) {\n          state.initialParams[param] = state.currentParams[param];\n        });\n\n        // Set new random target values for each parameter\n        Object.entries(allParameters).forEach(function (_ref3) {\n          var _ref4 = _slicedToArray(_ref3, 2),\n            param = _ref4[0],\n            config = _ref4[1];\n          // Special handling for boolean parameters or parameters with options\n          if (config.options) {\n            // Keep options parameters stable during animation to prevent structure changes\n            state.targetParams[param] = state.currentParams[param];\n          }\n          // Only animate numeric parameters with min/max\n          else if (typeof state.currentParams[param] === 'number' && config.min !== undefined && config.max !== undefined) {\n            if (state.hovering && _this.isNonInterpolatedParam(param)) {\n              // Keep the current value for these parameters during hover\n              state.targetParams[param] = state.currentParams[param];\n            } else {\n              // For other parameters or non-hover animations, generate a new random target value\n              var min = config.min;\n              var max = config.max;\n\n              // More dramatic changes for hover animations if requested\n              if (moreRandomness && state.hovering) {\n                // Generate a more extreme value - closer to min or max\n                var extremeness = 0.7; // How close to push toward min/max\n                var randomChoice = Math.random();\n                if (randomChoice < 0.5) {\n                  // Push toward min\n                  state.targetParams[param] = min + (max - min) * (1 - extremeness) * Math.random();\n                } else {\n                  // Push toward max\n                  state.targetParams[param] = max - (max - min) * (1 - extremeness) * Math.random();\n                }\n              } else {\n                // Normal random value\n                state.targetParams[param] = min + Math.random() * (max - min);\n              }\n            }\n          }\n        });\n\n        // Reset progress and mark as animating\n        state.progress = 0;\n        state.isAnimating = true;\n\n        // Set transition time - faster for hovered shapes\n        state.transitionTime = state.hovering ? 0.3 : 2.0;\n\n        // Store animation type for easing selection\n        state.animationType = state.hovering ? 'hoverIn' : state.returningToDefault ? 'hoverOut' : 'randomAnimation';\n      } catch (error) {\n        console.error(\"Error setting target state for shape \".concat(shapeName, \":\"), error);\n        if (this.animationState[shapeId]) {\n          this.animationState[shapeId].isAnimating = false;\n          this.animationState[shapeId].shouldAnimate = false;\n        }\n      }\n    }\n\n    /**\n     * Get all visible shapes on screen\n     */\n  }, {\n    key: \"getVisibleShapes\",\n    value: function getVisibleShapes() {\n      var shapes = Array.from(document.querySelectorAll('.shape-container'));\n      return shapes.filter(function (shape) {\n        var rect = shape.getBoundingClientRect();\n        return rect.top < window.innerHeight && rect.bottom > 0;\n      });\n    }\n\n    /**\n     * Start the animation loop for shapes\n     */\n  }, {\n    key: \"startAnimationLoop\",\n    value: function startAnimationLoop() {\n      var _this2 = this;\n      if (!this.animationEnabled) return;\n\n      // Cancel any existing animation frame\n      if (this.animationFrameId) {\n        cancelAnimationFrame(this.animationFrameId);\n      }\n\n      // Keep track of the last time for smooth animation\n      var lastTime = performance.now();\n\n      // The animation loop\n      var _animate = function animate(currentTime) {\n        // Exit if animation was disabled\n        if (!_this2.animationEnabled) return;\n\n        // Calculate time delta in seconds\n        var deltaTime = (currentTime - lastTime) / 1000;\n        lastTime = currentTime;\n\n        // Update global animation time\n        _this2.globalAnimationTime += deltaTime;\n\n        // Skip if in editor mode\n        if (!_this2.app.selectedShape) {\n          try {\n            // Get visible shapes\n            var visibleShapes = _this2.getVisibleShapes();\n\n            // Update each visible shape's animation state\n            visibleShapes.forEach(function (shape) {\n              try {\n                var shapeId = shape.id;\n                var shapeName = shape.dataset.shapeName;\n\n                // Update the shape animation\n                _this2.updateShapeAnimation(shape, deltaTime);\n              } catch (error) {\n                console.error(\"Error animating shape:\", error);\n              }\n            });\n          } catch (error) {\n            console.error(\"Animation loop error:\", error);\n          }\n        }\n\n        // Continue the animation loop\n        _this2.animationFrameId = requestAnimationFrame(_animate);\n      };\n\n      // Start the animation\n      this.animationFrameId = requestAnimationFrame(_animate);\n    }\n\n    /**\n     * Update animation state and render the shape\n     */\n  }, {\n    key: \"updateShapeAnimation\",\n    value: function updateShapeAnimation(shapeContainer, deltaTime) {\n      if (!this.animationEnabled) return;\n      var shapeId = shapeContainer.id;\n      var shapeName = shapeContainer.dataset.shapeName;\n\n      // Skip if no animation state\n      if (!this.animationState[shapeId]) {\n        // Initialize state on first update\n        this.animationState[shapeId] = this.initAnimationState(shapeName, shapeId);\n        if (!this.animationState[shapeId]) return;\n      }\n      var state = this.animationState[shapeId];\n\n      // Skip if not animating or shouldn't be animating\n      if (!state.isAnimating || !state.shouldAnimate && !state.hovering && !state.returningToDefault) return;\n\n      // Get the shape class\n      var ShapeClass = this.app.shapes[shapeName];\n      if (!ShapeClass) return;\n      try {\n        // Update progress\n        state.progress += deltaTime / state.transitionTime;\n\n        // When animation completes\n        if (state.progress >= 1) {\n          this.handleAnimationComplete(state, shapeName, shapeId);\n        } else {\n          this.interpolateParameters(state, ShapeClass);\n        }\n\n        // Update the shape in the DOM with the current parameters\n        this.renderInterpolatedShape(shapeName, shapeId, state.currentParams);\n      } catch (error) {\n        console.error(\"Error updating animation for shape \".concat(shapeName, \":\"), error);\n        this.handleAnimationError(state, shapeContainer, shapeName);\n      }\n    }\n\n    /**\n     * Handle animation completion\n     */\n  }, {\n    key: \"handleAnimationComplete\",\n    value: function handleAnimationComplete(state, shapeName, shapeId) {\n      // Set current parameters to target\n      Object.keys(state.targetParams).forEach(function (param) {\n        state.currentParams[param] = state.targetParams[param];\n      });\n\n      // Check if we were returning to default state\n      if (state.returningToDefault) {\n        // Clear the returning flag\n        state.returningToDefault = false;\n\n        // If we should stop animation after returning to default\n        if (state.stopAfterDefault) {\n          state.isAnimating = false;\n          state.stopAfterDefault = false;\n        } else {\n          state.isAnimating = false; // Always stop after returning to default\n        }\n      }\n      // Single hover animation complete - stop animating\n      else if (state.hovering && state.singleHoverAnimation) {\n        state.isAnimating = false; // Stop after one transition\n      }\n      // Normal animation completion\n      else if (state.hovering || state.shouldAnimate) {\n        // Only start new animation if it's not a single hover animation\n        if (!state.singleHoverAnimation) {\n          this.setNewTargetState(shapeName, shapeId);\n        } else {\n          state.isAnimating = false; // Stop after one hover animation\n        }\n      } else {\n        // Otherwise, stop animating\n        state.isAnimating = false;\n      }\n    }\n\n    /**\n     * Handle animation errors gracefully\n     */\n  }, {\n    key: \"handleAnimationError\",\n    value: function handleAnimationError(state, shapeContainer, shapeName) {\n      // Mark animation as failed so we stop trying\n      state.isAnimating = false;\n      state.shouldAnimate = false;\n      state.returningToDefault = false;\n\n      // Try to render the shape with default parameters\n      try {\n        var ShapeClass = this.app.shapes[shapeName];\n        if (!ShapeClass) return;\n        var shapeInstance = new ShapeClass();\n        var shapeContent = shapeInstance.generateShape();\n        var svg = shapeContainer.querySelector('svg');\n        if (svg) {\n          var wrapperGroup = svg.querySelector('g');\n          if (wrapperGroup) {\n            wrapperGroup.innerHTML = shapeContent;\n          }\n        }\n      } catch (fallbackError) {\n        console.error(\"Fallback rendering also failed for \".concat(shapeName, \":\"), fallbackError);\n      }\n    }\n\n    /**\n     * Interpolate between initial and target parameters\n     */\n  }, {\n    key: \"interpolateParameters\",\n    value: function interpolateParameters(state, ShapeClass) {\n      var _this3 = this;\n      // Calculate interpolated values for each parameter\n      Object.keys(state.targetParams).forEach(function (param) {\n        // Get parameter configuration\n        var classParameters = ShapeClass.parameters || {};\n        var allParameters = _objectSpread(_objectSpread({}, _this3.app.Shape.parameters), classParameters);\n        var paramConfig = allParameters[param];\n\n        // Special handling based on parameter type and animation state\n        if (paramConfig && paramConfig.options) {\n          // Don't interpolate options parameters, switch immediately\n          state.currentParams[param] = state.initialParams[param];\n        }\n        // Special handling for structural parameters during hover\n        else if (!state.returningToDefault && _this3.isNonInterpolatedParam(param) && state.hovering) {\n          // Keep structural parameters fixed during hover\n          if (param.toLowerCase().includes('rows') || param.toLowerCase().includes('columns') || param.toLowerCase().includes('count')) {\n            state.currentParams[param] = Math.round(state.initialParams[param]);\n          } else {\n            state.currentParams[param] = state.initialParams[param];\n          }\n        }\n        // Allow all parameters to interpolate when returning to default\n        else {\n          // Use smooth interpolation curve for natural movement\n          var t = _this3.smoothStep(state.progress, state.animationType || 'default');\n\n          // For integer parameters, round the result\n          if (param.toLowerCase().includes('rows') || param.toLowerCase().includes('columns') || param.toLowerCase().includes('count')) {\n            state.currentParams[param] = Math.round(_this3.lerp(state.initialParams[param], state.targetParams[param], t));\n          } else {\n            // Normal interpolation for other params\n            state.currentParams[param] = _this3.lerp(state.initialParams[param], state.targetParams[param], t);\n          }\n        }\n      });\n    }\n\n    /**\n     * Render a shape with interpolated parameters\n     */\n  }, {\n    key: \"renderInterpolatedShape\",\n    value: function renderInterpolatedShape(shapeName, shapeId, params) {\n      if (!this.animationEnabled) return;\n      try {\n        var ShapeClass = this.app.shapes[shapeName];\n        if (!ShapeClass) return;\n\n        // Create new shape instance with interpolated parameters\n        var interpolatedParams = _objectSpread(_objectSpread({}, params), {}, {\n          seed: 42\n        });\n\n        // For BrickWall and similar shapes with structure-dependent params, ensure integer values\n        if (shapeName === ' ' || shapeName.includes('Grid') || shapeName.includes('Pattern')) {\n          // Ensure rows and columns are integers\n          if (interpolatedParams.rows !== undefined) {\n            interpolatedParams.rows = Math.round(interpolatedParams.rows);\n          }\n          if (interpolatedParams.columns !== undefined) {\n            interpolatedParams.columns = Math.round(interpolatedParams.columns);\n          }\n\n          // Handle any count parameters\n          Object.keys(interpolatedParams).forEach(function (param) {\n            if (param.toLowerCase().includes('count')) {\n              interpolatedParams[param] = Math.round(interpolatedParams[param]);\n            }\n          });\n        }\n        var shapeInstance = new ShapeClass(interpolatedParams);\n\n        // Generate shape content\n        var shapeContent = shapeInstance.generateShape();\n\n        // Find shape container and SVG wrapper group\n        var shapeContainer = document.getElementById(shapeId);\n        if (!shapeContainer) return;\n        var svg = shapeContainer.querySelector('svg');\n        if (!svg) return;\n        var wrapperGroup = svg.querySelector('g');\n        if (!wrapperGroup) return;\n\n        // Update content\n        wrapperGroup.innerHTML = shapeContent;\n      } catch (error) {\n        console.error(\"Error rendering interpolated shape \".concat(shapeName, \":\"), error);\n        try {\n          // Fallback to default shape if animation fails\n          var _ShapeClass = this.app.shapes[shapeName];\n          if (!_ShapeClass) return;\n          var _shapeInstance = new _ShapeClass();\n          var _shapeContent = _shapeInstance.generateShape();\n          var _shapeContainer = document.getElementById(shapeId);\n          if (!_shapeContainer) return;\n          var _svg = _shapeContainer.querySelector('svg');\n          if (!_svg) return;\n          var _wrapperGroup = _svg.querySelector('g');\n          if (!_wrapperGroup) return;\n\n          // Update with default content\n          _wrapperGroup.innerHTML = _shapeContent;\n        } catch (fallbackError) {\n          console.error(\"Fallback rendering also failed for \".concat(shapeName, \":\"), fallbackError);\n        }\n      }\n    }\n\n    /**\n     * Setup hover events for a shape\n     */\n  }, {\n    key: \"setupShapeHoverEvents\",\n    value: function setupShapeHoverEvents(shapeContainer, shapeName, shapeId) {\n      var _this4 = this;\n      if (!this.animationEnabled) return;\n      shapeContainer.addEventListener('mouseenter', function () {\n        // Mark as currently hovered\n        _this4.currentlyHoveredId = shapeId;\n\n        // Initialize animation state if needed\n        if (!_this4.animationState[shapeId]) {\n          _this4.animationState[shapeId] = _this4.initAnimationState(shapeName, shapeId);\n        }\n        var state = _this4.animationState[shapeId];\n        if (!state) return;\n\n        // Important: Cancel any ongoing return-to-default animation\n        if (state.returningToDefault) {\n          state.returningToDefault = false;\n          state.stopAfterDefault = false;\n        }\n\n        // Set hover state\n        state.hovering = true;\n\n        // Fast hover transition\n        state.transitionTime = 0.3;\n\n        // Important: Set a flag to ensure we only do ONE animation\n        state.singleHoverAnimation = true;\n\n        // Save current params as initial for smooth transition\n        Object.keys(state.currentParams).forEach(function (param) {\n          state.initialParams[param] = state.currentParams[param];\n        });\n\n        // Start a single animation with more dramatic parameter changes\n        _this4.setNewTargetState(shapeName, shapeId, true);\n      });\n      shapeContainer.addEventListener('mouseleave', function () {\n        // Clear current hover state\n        if (_this4.currentlyHoveredId === shapeId) {\n          _this4.currentlyHoveredId = null;\n        }\n        var state = _this4.animationState[shapeId];\n        if (!state) return;\n\n        // Update animation state\n        state.hovering = false;\n\n        // Clear the single hover animation flag\n        state.singleHoverAnimation = false;\n\n        // Save current params as initial for smooth transition back\n        Object.keys(state.currentParams).forEach(function (param) {\n          state.initialParams[param] = state.currentParams[param];\n        });\n\n        // When mouse leaves, set target parameters to default values\n        Object.keys(state.defaultParams).forEach(function (param) {\n          state.targetParams[param] = state.defaultParams[param];\n        });\n\n        // Reset progress to start the transition back to default\n        state.progress = 0;\n        state.isAnimating = true;\n\n        // Special flag to indicate we're returning to default state\n        state.returningToDefault = true;\n\n        // Fast return transition\n        state.transitionTime = 0.25;\n\n        // Always stop after returning to default\n        state.stopAfterDefault = true;\n      });\n    }\n\n    /**\n     * Easing functions for animations\n     */\n  }, {\n    key: \"easeOutQuad\",\n    value: function easeOutQuad(t) {\n      return t * (2 - t);\n    }\n  }, {\n    key: \"easeInQuad\",\n    value: function easeInQuad(t) {\n      return t * t;\n    }\n  }, {\n    key: \"easeInOutQuad\",\n    value: function easeInOutQuad(t) {\n      return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n    }\n  }, {\n    key: \"easeInOutCubic\",\n    value: function easeInOutCubic(t) {\n      return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n    }\n  }, {\n    key: \"easeOutBack\",\n    value: function easeOutBack(t) {\n      var c1 = 1.70158;\n      var c3 = c1 + 1;\n      return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);\n    }\n\n    /**\n     * Linear interpolation function\n     */\n  }, {\n    key: \"lerp\",\n    value: function lerp(a, b, t) {\n      return a + (b - a) * t;\n    }\n\n    /**\n     * Smooth step function for more natural animation\n     */\n  }, {\n    key: \"smoothStep\",\n    value: function smoothStep(t) {\n      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';\n      // Clamp t to 0...1 range\n      t = Math.min(Math.max(t, 0), 1);\n\n      // Select easing based on animation type\n      switch (type) {\n        case 'hoverIn':\n          return 1 - Math.pow(1 - t, 4);\n        case 'hoverOut':\n          return 1 - Math.pow(1 - t, 4);\n        case 'randomAnimation':\n          return this.easeInOutCubic(t);\n        default:\n          return this.easeOutQuad(t);\n      }\n    }\n\n    /**\n     * Cleanup animation resources\n     */\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      if (this.animationFrameId) {\n        cancelAnimationFrame(this.animationFrameId);\n        this.animationFrameId = null;\n      }\n      this.animationState = {};\n    }\n  }]);\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ShapeAnimationManager);\n\n//# sourceURL=webpack://generative-shapes/./src/ShapeAnimationManager.js?");

/***/ }),

/***/ "./src/ShapeEditor.js":
/*!****************************!*\
  !*** ./src/ShapeEditor.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _ShapeStyleController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ShapeStyleController */ \"./src/ShapeStyleController.js\");\n/* harmony import */ var _ShapeEditorUI__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ShapeEditorUI */ \"./src/ShapeEditorUI.js\");\n/* harmony import */ var _ShapeParameterControls__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ShapeParameterControls */ \"./src/ShapeParameterControls.js\");\n/* harmony import */ var _ShapeExporter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ShapeExporter */ \"./src/ShapeExporter.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n\n\n// import ShaderManager from './ShaderManager'; \n// import shaderSourceRegistry from './loadShaders';\nvar ShapeEditor = /*#__PURE__*/function () {\n  function ShapeEditor(controller) {\n    _classCallCheck(this, ShapeEditor);\n    this.controller = controller;\n    this.editorOpen = false;\n    this.currentShape = null;\n    this.parameters = {};\n\n    // Store original parameters for resets\n    this.originalParameters = {};\n\n    // Setup shaders\n    this.shaderManager = null;\n    // this.availableShaderSources = shaderSourceRegistry;\n    // this.availableShaders = Object.keys(this.availableShaderSources).map(name => ({ name: name }));\n    this.activeShaderName = null;\n    this.shaderMode = 'background';\n    this.shaderUpdateInterval = null;\n\n    // Bind methods\n    this.showEditor = this.showEditor.bind(this);\n    this.hideEditor = this.hideEditor.bind(this);\n    this.updateShape = this.updateShape.bind(this);\n    this.handleKeyDown = this.handleKeyDown.bind(this);\n\n    // Initialize sub-modules\n    this.styleController = new _ShapeStyleController__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this);\n    this.ui = new _ShapeEditorUI__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this);\n    this.parameterControls = new _ShapeParameterControls__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this);\n    this.exporter = new _ShapeExporter__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this);\n  }\n  return _createClass(ShapeEditor, [{\n    key: \"prepareForEditorOpen\",\n    value: function prepareForEditorOpen(shapeName) {\n      // Clean up any leftover style rows or preset rows\n      document.querySelectorAll('.preset-row, .style-row').forEach(function (row) {\n        return row.remove();\n      });\n\n      // Check if there's loaded shape data from database\n      var loadedStyleParams = null;\n      if (window.loadingShapeData && window.loadingShapeData.styleParams) {\n        loadedStyleParams = window.loadingShapeData.styleParams;\n        console.log('Found loaded style parameters', loadedStyleParams);\n      }\n\n      // Reset the style controller to default style\n      if (this.styleController) {\n        // First reset to default style\n        this.styleController.resetToDefaultStyle();\n\n        // Apply loaded style params if available\n        if (loadedStyleParams) {\n          this.styleController.styleParams = _objectSpread(_objectSpread({}, this.styleController.styleParams), loadedStyleParams);\n          console.log('Applied loaded style parameters');\n        }\n        // Otherwise load any saved style for this specific shape\n        else if (shapeName) {\n          this.styleController.loadStyleSettings(shapeName);\n        }\n      }\n    }\n\n    /**\n     * Show the shape editor for a specific shape\n     * @param {string} shapeName - The name of the shape to edit\n     * @param {object} initialParams - Optional initial parameters (from hover state)\n     */\n  }, {\n    key: \"showEditor\",\n    value: function showEditor(shapeName) {\n      var _this = this;\n      var initialParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      console.log(\"Opening editor for shape: \".concat(shapeName));\n      if (!shapeName) return;\n\n      // Make sure the bottom area fits with standalone webapp mode in Safari\n      this.ui.setupMobileMeta();\n      this.prepareForEditorOpen(shapeName);\n      this.editorOpen = true;\n      this.currentShape = shapeName;\n\n      // Save the current grid state before showing the editor\n      this.controller.saveGridState();\n      var gridContainer = document.getElementById('grid');\n      if (!gridContainer) return;\n\n      // Hide main header (search and zoom controls)\n      var header = document.getElementById('main-header');\n      if (header) header.style.display = 'none';\n\n      // Hide category filters when in editor mode\n      var filterContainer = document.getElementById('category-filters-container');\n      if (filterContainer) {\n        // Store the parent before removing\n        this.filterContainerParent = filterContainer.parentNode;\n        // Save the reference for later restoration\n        this.savedFilterContainer = filterContainer;\n        // Remove from DOM completely\n        filterContainer.parentNode.removeChild(filterContainer);\n      }\n\n      // Clear grid and set class\n      gridContainer.innerHTML = '';\n      gridContainer.className = 'editor';\n\n      // Disable body scrolling\n      document.body.style.overflow = 'hidden';\n      document.body.style.position = 'fixed';\n      document.body.style.width = '100%';\n      document.body.style.height = '100%';\n      try {\n        // Get shape class and parameters\n        var ShapeClass = this.controller.shapes[shapeName];\n        if (!ShapeClass) throw new Error(\"Shape class not found: \".concat(shapeName));\n        var classParameters = ShapeClass.parameters || {};\n        var allParameters = _objectSpread(_objectSpread({}, this.controller.Shape.parameters), classParameters);\n\n        // Create shape instance with default parameters\n        var shapeInstance = new ShapeClass();\n        this.parameters = {};\n\n        // Set initial parameters from instance\n        Object.keys(allParameters).forEach(function (param) {\n          _this.parameters[param] = shapeInstance[param];\n        });\n\n        // Get loaded parameters from window.loadingShapeData\n        var loadedParams = null;\n        var shapeId = null;\n        if (window.loadingShapeData && window.loadingShapeData.styleParams) {\n          // Apply database style parameters to style controller\n          if (this.styleController) {\n            this.styleController.styleParams = _objectSpread(_objectSpread({}, this.styleController.styleParams), window.loadingShapeData.styleParams);\n            console.log('Applied style parameters from database');\n          }\n          if (this.controller.analytics) {\n            this.controller.analytics.viewShape(shapeName);\n          }\n\n          // Clear the loading data to prevent reusing it\n          window.loadingShapeData = null;\n        }\n\n        // Apply parameters in priority order:\n        // 1. Loaded parameters from database (highest priority)\n        // 2. Provided initialParams from hover state\n        // 3. Default instance parameters (lowest priority)\n\n        if (loadedParams && Object.keys(loadedParams).length > 0) {\n          console.log('Applying loaded parameters from database');\n\n          // Apply parameters from loaded data\n          Object.keys(loadedParams).forEach(function (param) {\n            if (_this.parameters.hasOwnProperty(param)) {\n              var paramValue = loadedParams[param];\n              // Handle both simple values and objects with 'value' property\n              _this.parameters[param] = paramValue.value !== undefined ? paramValue.value : paramValue;\n            }\n          });\n        } else if (initialParams && Object.keys(initialParams).length > 0) {\n          console.log('Applying provided hover parameters in editor');\n\n          // Apply parameters from hover state\n          Object.keys(initialParams).forEach(function (param) {\n            if (_this.parameters.hasOwnProperty(param)) {\n              _this.parameters[param] = initialParams[param];\n            }\n          });\n        }\n\n        // Store original parameters for reset\n        this.originalParameters = _objectSpread({}, this.parameters);\n\n        // Create the editor layout and controls\n        var editorLayout = this.ui.createEditorLayout();\n\n        // Create the preview area with SVG\n        var previewArea = editorLayout.querySelector('.preview-area');\n        var previewSvg = this.ui.createPreviewSVG();\n        previewArea.appendChild(previewSvg);\n\n        // Create parameter controls\n        var parametersContainer = editorLayout.querySelector('#parameters');\n        this.parameterControls.createControls(allParameters, parametersContainer);\n        this.styleController.createStyleControls(parametersContainer);\n\n        // ---> ADD SHADER CONTROLS <---\n        if (this.shaderManager && this.shaderManager.gl) {\n          var compiledShaders = Object.keys(this.shaderManager.programs).map(function (name) {\n            return {\n              name: name\n            };\n          });\n          // Add shader controls to the parameters area\n          this.ui.createShaderControls(parametersContainer,\n          // Add to the same container as other params\n          compiledShaders, this.activeShaderName,\n          // Initially null or a default\n          this.ui.shaderMode // Use the UI's mode state\n          );\n        }\n        // ---> END ADD SHADER CONTROLS <---\n\n        // Create control buttons\n        var controlsContainer = editorLayout.querySelector('.controls-container');\n        this.ui.createControlButtons(controlsContainer);\n\n        // Initial shape rendering\n        this.updateShape();\n\n        // Add to grid container\n        gridContainer.appendChild(editorLayout);\n\n        // --- Initialize ShaderManager ---\n        //   if (!this.shaderManager) {\n        //     console.log(\"Initializing ShaderManager...\");\n        //     // Remember to set preserveDrawingBuffer: true if using toDataURL frequently\n        //     this.shaderManager = new ShaderManager('shader-canvas'); // Pass ID\n        //  }\n\n        // --- Load and Compile Shaders from Registry ---\n        //  if (this.shaderManager && this.shaderManager.gl) { // Check if manager/context is valid\n        //      console.log(\"Loading and compiling shaders from registry...\");\n        //      this.shaderManager.loadAndCompileShaders(this.availableShaderSources);\n\n        //       // Initial resize check after adding to DOM and compiling\n        //      const previewArea = editorLayout.querySelector('.preview-area');\n        //      if (previewArea && this.shaderManager.canvas.parentElement) {\n        //          this.shaderManager.resizeCanvas(previewArea.clientWidth, previewArea.clientHeight);\n        //      } else {\n        //          // Fallback if parent isn't ready immediately (might need slight delay)\n        //          setTimeout(() => {\n        //             if(previewArea && this.shaderManager.canvas.parentElement) {\n        //                this.shaderManager.resizeCanvas(previewArea.clientWidth, previewArea.clientHeight);\n        //             }\n        //          }, 0);\n        //      }\n\n        //  } else {\n        //      console.error(\"ShaderManager or WebGL context not available for compiling shaders.\");\n        //      // Handle error appropriately - maybe disable shader functionality\n        //  }\n\n        // ---> SET INITIAL SHADER STATE AND VISUALS <---\n        // Optionally set a default shader here if desired:\n        //  this.setActiveShader('sky');\n        // Or just ensure the visuals are updated based on the current (likely null) state:\n        //  this.updateShaderDisplayMode();\n        // ---> END INITIAL SHADER STATE <---\n\n        // Add keyboard handler for ESC to go back\n        document.addEventListener('keydown', this.handleKeyDown);\n\n        // Initialize history for the new shape\n        if (this.controller.history) {\n          this.controller.history.initShapeHistory(shapeName);\n\n          // Set the current shape ID for database operations if available\n          if (shapeId && this.controller.history.currentShapeId === null) {\n            this.controller.history.currentShapeId = shapeId;\n            console.log(\"Set shape ID for history: \".concat(shapeId));\n          }\n\n          // Save initial state if parameters are available\n          if (Object.keys(this.parameters).length > 0) {\n            this.controller.history.saveState(true); // true = silent/initial save\n          }\n        }\n      } catch (error) {\n        console.error(\"Error showing shape editor for \".concat(shapeName, \":\"), error);\n        this.ui.showErrorView(gridContainer, shapeName);\n      }\n    }\n\n    /**\n     * Update the shape display\n     */\n  }, {\n    key: \"updateShape\",\n    value: function updateShape() {\n      if (!this.currentShape) return;\n      try {\n        var ShapeClass = this.controller.shapes[this.currentShape];\n        if (!ShapeClass) return;\n\n        // Keep controller's parameters in sync with editor's\n        if (this.controller.parameters) {\n          this.controller.parameters = _objectSpread({}, this.parameters);\n        }\n\n        // Create a new shape with current parameters\n        var shape = new ShapeClass(this.parameters);\n        var group = document.getElementById('shape');\n        if (group) {\n          var shapeContent = shape.generateShape();\n          if (shapeContent) {\n            group.innerHTML = shapeContent;\n          }\n        }\n        if (this.styleController) {\n          this.styleController.updateShapeStyle();\n        }\n      } catch (err) {\n        console.error('Error updating shape:', err);\n      }\n    }\n\n    // Inside ShapeEditor.js class\n\n    /**\n     * Updates the UI display based on the current shader and mode.\n     */\n  }, {\n    key: \"updateShaderDisplayMode\",\n    value: function updateShaderDisplayMode() {\n      if (!this.ui || !this.shaderManager) return;\n      var isActive = !!this.activeShaderName && !!this.shaderManager.activeProgramInfo;\n      var mode = this.ui.shaderMode; // Get mode from UI state\n      var dataURL = null;\n\n      // For 'fill' mode, we need the current canvas content as a Data URL\n      // IMPORTANT: Requires { preserveDrawingBuffer: true } when creating WebGL context\n      // This can impact performance. Only get it when needed.\n      if (isActive && mode === 'fill') {\n        // Ensure the shader has rendered at least once *before* getting the URL\n        // This might need refinement - perhaps update pattern periodically in render loop?\n        // For simplicity now, we get it when mode changes or shader activates.\n        this.shaderManager.render(); // Render one frame\n        dataURL = this.shaderManager.getCanvasDataURL('image/png'); // Or 'image/webp' for potential smaller size\n        if (!dataURL) {\n          console.warn(\"Could not get Data URL for shader fill. Is preserveDrawingBuffer set to true?\");\n        }\n      }\n\n      // Tell the UI to update the canvas visibility, z-index, and pattern (if fill mode)\n      this.ui.updateShaderVisuals(isActive, mode, dataURL);\n\n      // Trigger a re-render of the shape style in case fill was changed/disabled\n      // This ensures SVG fill/stroke are correct when switching modes.\n      if (this.styleController) {\n        this.styleController.updateShapeStyle();\n      }\n    }\n\n    // Inside ShapeEditor.js class\n\n    // ---> NEW METHOD to handle setting the active shader <---\n  }, {\n    key: \"setActiveShader\",\n    value: function setActiveShader(name) {\n      if (!this.shaderManager) return false;\n      var success = this.shaderManager.setActiveShader(name);\n      if (success) {\n        this.activeShaderName = name;\n        console.log(\"ShapeEditor: Set active shader to \".concat(name));\n        // Start animation loop (handled inside shaderManager.setActiveShader)\n      } else {\n        this.activeShaderName = null;\n        console.log(\"ShapeEditor: Deactivated shader.\");\n        // Stop animation loop (handled inside shaderManager.setActiveShader)\n      }\n\n      // ---> UPDATE VISUALS <---\n      this.updateShaderDisplayMode();\n\n      // Optionally save this preference?\n      // TODO: Save activeShaderName perhaps in localStorage or history\n\n      return success;\n    }\n    // ---> END NEW METHOD <---\n\n    /**\n     * Hide the editor and return to the grid\n     */\n  }, {\n    key: \"hideEditor\",\n    value: function hideEditor() {\n      this.cleanupEditor();\n\n      // Restore body scrolling\n      document.body.style.overflow = '';\n      document.body.style.position = '';\n      document.body.style.width = '';\n      document.body.style.height = '';\n\n      // Reset viewport meta tag to original\n      var viewportMeta = document.querySelector('meta[name=\"viewport\"]');\n      if (viewportMeta) {\n        viewportMeta.setAttribute('content', 'width=device-width, initial-scale=1.0');\n      }\n      this.editorOpen = false;\n      this.currentShape = null;\n      document.removeEventListener('keydown', this.handleKeyDown);\n      this.parameters = {};\n      this.controller.returnToGrid();\n    }\n\n    /**\n     * Handle key down events in the editor\n     */\n  }, {\n    key: \"handleKeyDown\",\n    value: function handleKeyDown(e) {\n      // Check if export modal is open\n      var exportModal = document.getElementById('export-modal');\n      if (e.key === 'Escape' && !exportModal) {\n        // Only close the editor if the modal is not open\n        this.hideEditor();\n      }\n    }\n\n    /**\n     * Randomize the current shape\n     */\n  }, {\n    key: \"randomizeShape\",\n    value: function randomizeShape() {\n      var _this2 = this;\n      if (!this.currentShape) return;\n      var shapeName = this.currentShape;\n      var ShapeClass = this.controller.shapes[shapeName];\n      if (!ShapeClass) return;\n      var classParameters = ShapeClass.parameters || {};\n      var allParameters = _objectSpread(_objectSpread({}, this.controller.Shape.parameters), classParameters);\n      Object.entries(allParameters).forEach(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n          param = _ref2[0],\n          config = _ref2[1];\n        if (config.options) {\n          var randomIndex = Math.floor(Math.random() * config.options.length);\n          _this2.parameters[param] = config.options[randomIndex];\n        } else if (config.min !== undefined && config.max !== undefined) {\n          var randomValue = config.min + Math.random() * (config.max - config.min);\n          _this2.parameters[param] = Number.isInteger(config[\"default\"]) ? Math.round(randomValue) : parseFloat(randomValue.toFixed(2));\n        }\n      });\n      this.updateShape();\n      if (this.controller.history) {\n        this.controller.history.saveState();\n      }\n      this.parameterControls.updateParameterControls();\n    }\n\n    /**\n     * Clean up on editor close\n     */\n  }, {\n    key: \"cleanupEditor\",\n    value: function cleanupEditor() {\n      this.parameters = {};\n\n      // Clean up style controls\n      if (this.styleController) {\n        // Save style settings before closing\n        this.styleController.saveStyleSettings(this.currentShape);\n      }\n\n      // Remove event listeners\n      document.removeEventListener('keydown', this.handleKeyDown);\n    }\n\n    /**\n     * Copy SVG to clipboard\n     */\n  }, {\n    key: \"copySvgToClipboard\",\n    value: function copySvgToClipboard() {\n      var svg = document.getElementById('preview-svg');\n      if (!svg) return;\n      var svgData = new XMLSerializer().serializeToString(svg);\n      navigator.clipboard.writeText(svgData).then(function () {\n        var copyBtn = document.getElementById('copyBtn');\n        if (copyBtn) {\n          var originalHTML = copyBtn.innerHTML;\n          copyBtn.innerHTML = \"Copied\";\n          setTimeout(function () {\n            copyBtn.innerHTML = originalHTML;\n          }, 1500);\n        }\n      })[\"catch\"](function (err) {\n        console.error('Error copying SVG to clipboard:', err);\n      });\n    }\n\n    /**\n     * Show export modal to set export options\n     */\n  }, {\n    key: \"showExportModal\",\n    value: function showExportModal() {\n      this.exporter.showExportModal();\n    }\n  }]);\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ShapeEditor);\n\n//# sourceURL=webpack://generative-shapes/./src/ShapeEditor.js?");

/***/ }),

/***/ "./src/ShapeEditorUI.js":
/*!******************************!*\
  !*** ./src/ShapeEditorUI.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n/**\n * ShapeEditorUI.js\n * Handles all UI-related functionality for the ShapeEditor component\n */\nvar ShapeEditorUI = /*#__PURE__*/function () {\n  function ShapeEditorUI(editor) {\n    _classCallCheck(this, ShapeEditorUI);\n    this.editor = editor;\n    this.shaderMode = 'background';\n\n    // One-time style injection for the editor UI\n    this.injectStyles();\n  }\n\n  /**\n   * Inject global styles for the editor UI\n   */\n  return _createClass(ShapeEditorUI, [{\n    key: \"injectStyles\",\n    value: function injectStyles() {\n      var style = document.createElement('style');\n      style.textContent = \"\\n  /* Slider track */\\n  .param-slider {\\n    -webkit-appearance: none;\\n    appearance: none;\\n    width: 100%;\\n    height: 30px;              /* Increased height for better touch target */\\n    background: transparent;   /* Hide the default track */\\n    position: relative;\\n    cursor: pointer;\\n    min-width: 120px;\\n  }\\n\\n  /* Create a 1px track using a pseudo-element */\\n  .param-slider::before {\\n    content: \\\"\\\";\\n    position: absolute;\\n    top: 50%;\\n    left: 0;\\n    right: 0;\\n    height: 2px;              /* Slightly thicker for visibility */\\n    background: #333;\\n    transform: translateY(-50%);\\n  }\\n\\n  .param-slider::-webkit-slider-thumb {\\n    -webkit-appearance: none;\\n    appearance: none;\\n    width: 20px;              /* Larger thumb for touch */\\n    height: 20px;             /* Larger thumb for touch */\\n    background: #e0e0e0;\\n    border-radius: 50%;\\n    position: relative;\\n    z-index: 1;\\n  }\\n\\n  .param-slider::-moz-range-thumb {\\n    width: 20px;              /* Larger thumb for touch */\\n    height: 20px;             /* Larger thumb for touch */\\n    background: #e0e0e0;\\n    border: none;\\n    border-radius: 50%;\\n    cursor: pointer;\\n  }\\n\\n  /* Bottom buttons hover states */\\n  .control-button:hover {\\n    background-color: #282828 !important;\\n  }\\n\\n  /* Editor layout - prevents scrolling */\\n  .editor-layout {\\n    display: flex;\\n    flex-direction: column;\\n    height: 100vh;\\n    max-height: 100vh;\\n    overflow: hidden; /* Keep hidden to prevent body scroll */\\n    position: fixed;\\n    top: 0;\\n    left: 0;\\n    right: 0;\\n    bottom: 0;\\n    width: 100%;\\n    background-color: #000;\\n    box-sizing: border-box;\\n  }\\n\\n  /* Navigation bar */\\n  .nav-bar {\\n    flex: 0 0 auto;\\n    z-index: 10;\\n    padding-top: env(safe-area-inset-top);\\n    padding-left: env(safe-area-inset-left);\\n    padding-right: env(safe-area-inset-right);\\n    /* Your existing nav bar styles (padding, display, etc.) */\\n    display: flex;\\n    align-items: center;\\n    padding: 8px 12px; /* Keep original padding */\\n    padding-top: calc(8px + env(safe-area-inset-top)); /* Combine original + safe area */\\n    margin-top: 12px; /* Keep original margin */\\n  }\\n\\n  /* Preview area - minimum 50% viewport height */\\n  .preview-area {\\n        overflow: hidden;\\n        display: flex;\\n        justify-content: center;\\n        align-items: center;\\n        position: relative;\\n        padding-left: env(safe-area-inset-left);\\n        padding-right: env(safe-area-inset-right);\\n        background-color: #000; /* Ensure background */\\n      }\\n\\n  /* Parameter controls */\\n  .params-area {\\n      overflow-y: auto;\\n      overflow-x: hidden;\\n      padding: 0 16px; /* Original horizontal padding */\\n      -webkit-overflow-scrolling: touch;\\n\\n      /* === ADD PADDING BOTTOM FOR FIXED FOOTER === */\\n      /* Estimate controls-area height (~70-80px) + safe area */\\n      /* Controls area padding (16+16=32) + button height/padding (~36px) + buffer = ~80px */\\n      padding-bottom: calc(80px + env(safe-area-inset-bottom));\\n\\n      /* Adjust side padding for safe areas */\\n      padding-left: calc(16px + env(safe-area-inset-left));\\n      padding-right: calc(16px + env(safe-area-inset-right));\\n      margin-bottom: 36px;\\n    }\\n  \\n  .parameters-container {\\n\\n        display: flex;\\n        flex-wrap: wrap;\\n        margin: 0 auto;\\n        max-heigh: 120px;\\n        max-width: 795px;\\n        gap: 12px;\\n        padding-bottom: 16px; /* Internal padding at the end of content */\\n      }\\n  \\n  .control-row {\\n    flex: 1;\\n    min-width: 245px;\\n    \\n    /* Adjust for mobile */\\n    @media (max-width: 768px) {\\n      min-width: 100%;\\n    }\\n  }\\n  \\n  .param-name {\\n    letter-spacing: 1px;\\n    color: #555;\\n    font-size: 10px;\\n    margin-bottom: 6px;\\n    display: block;\\n    text-transform: uppercase;\\n    letter-spacing: 0.5px;\\n  }\\n\\n  /* Controls area with responsive layout */\\n  .controls-area {\\n        position: fixed;\\n        bottom: 0;\\n        left: 0;\\n        right: 0;\\n        width: 100%;\\n        flex: none; /* Keep outside flex flow of editor-layout */\\n        padding: 16px 12px;\\n        background-color: #000;\\n        z-index: 1000;\\n        /* box-sizing: border-box; Added globally */\\n        display: flex;\\n        justify-content: center;\\n        align-items: center;\\n        border-top: 1px solid #222;\\n\\n        /* Safe Area padding INSIDE the bar */\\n        padding-bottom: calc(16px + env(safe-area-inset-bottom));\\n        padding-left: calc(12px + env(safe-area-inset-left));\\n        padding-right: calc(12px + env(safe-area-inset-right));\\n      }\\n  \\n  .controls-container {\\n        display: flex;\\n        flex-wrap: wrap;\\n        gap: 8px;\\n        justify-content: center;\\n        max-width: 800px;\\n        width: 100%;\\n      }\\n  \\n  /* On small screens, make buttons horizontally scrollable */\\n  @media (max-width: 800px) { /* Or your preferred mobile breakpoint */\\n        .controls-area {\\n          overflow-x: auto;\\n          overflow-y: hidden;\\n          -webkit-overflow-scrolling: touch;\\n        }\\n\\n        .controls-container {\\n          flex-wrap: nowrap;\\n          justify-content: flex-start;\\n          width: auto;\\n          max-width: none;\\n          padding-right: 12px; /* End padding for scroll */\\n        }\\n      }\\n  \\n  /* Style & preset controls */\\n  .style-row {\\n    padding: 12px 0;\\n  }\\n  \\n  \\n  /* Back button styling */\\n  .back-btn {\\n    background-color: #000;\\n    color: #666;\\n    border: none;\\n    border-radius: 50%;\\n    width: 30px;\\n    height: 30px;\\n    font-size: 14px;\\n    display: flex;\\n    align-items: center;\\n    justify-content: center;\\n    cursor: pointer;\\n    transition: color 0.2s;\\n  }\\n  \\n  .back-btn:hover {\\n    background-color: #000;\\n    color: #fff;\\n  }\\n\\n   /* Styles for Shader Controls */\\n  .shader-controls { border-top: 1px solid #222; padding-top: 12px; margin-top: 12px; }\\n  #shader-select { background-color: #111; color: #e0e0e0; border: 1px solid #333; border-radius: 4px; padding: 5px 8px; font-size: 12px; margin-bottom: 10px;}\\n  .shader-mode-container label { font-size: 12px; color: #bbb; }\\n  .shader-mode-container input[type=\\\"radio\\\"] { margin-right: 4px; accent-color: #555; /* Style radio button */ }\\n\\n  /* Styles for Shader Canvas */\\n  #shader-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; /* Default behind SVG */ display: none; /* Initially hidden */ }\\n\";\n      document.head.appendChild(style);\n    }\n\n    /**\n     * Setup mobile meta tags for proper viewport handling\n     */\n  }, {\n    key: \"setupMobileMeta\",\n    value: function setupMobileMeta() {\n      var metaTags = [{\n        name: 'viewport',\n        content: 'width=device-width, initial-scale=1.0, viewport-fit=cover'\n      }, {\n        name: 'apple-mobile-web-app-capable',\n        content: 'yes'\n      }, {\n        name: 'apple-mobile-web-app-status-bar-style',\n        content: 'black-translucent'\n      }];\n\n      // Add all needed meta tags\n      metaTags.forEach(function (meta) {\n        var metaTag = document.querySelector(\"meta[name=\\\"\".concat(meta.name, \"\\\"]\"));\n        if (metaTag) {\n          metaTag.setAttribute('content', meta.content);\n        } else {\n          metaTag = document.createElement('meta');\n          metaTag.name = meta.name;\n          metaTag.content = meta.content;\n          document.head.appendChild(metaTag);\n        }\n      });\n    }\n\n    /**\n     * Create the main editor layout\n     * @returns {HTMLElement} The created editor layout\n     */\n  }, {\n    key: \"createEditorLayout\",\n    value: function createEditorLayout() {\n      // Create editor layout with dark theme - use the CSS class for layout\n      var editorLayout = document.createElement('div');\n      editorLayout.className = 'editor-layout';\n      editorLayout.style.backgroundColor = '#000';\n      editorLayout.style.color = '#e0e0e0';\n\n      // Create navigation bar (top)\n      var navBar = document.createElement('div');\n      navBar.className = 'nav-bar';\n      navBar.title = this.editor.currentShape;\n      navBar.style.display = 'flex';\n      navBar.style.alignItems = 'center';\n      navBar.style.padding = '8px 12px';\n      navBar.style.marginTop = '12px';\n      var backButton = document.createElement('button');\n      backButton.className = 'back-btn';\n      backButton.title = 'Back to shapes';\n      backButton.style.backgroundColor = 'transparent';\n      backButton.addEventListener('click', this.editor.hideEditor);\n      backButton.style.alignItems = 'center';\n      backButton.style.justifyContent = 'center';\n      backButton.style.width = '30px';\n      backButton.style.height = '30px';\n      backButton.style.fontSize = '14px';\n      backButton.innerHTML = \"\\n<svg width=\\\"30\\\" height=\\\"30\\\" viewBox=\\\"0 0 30 30\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n<path d=\\\"M9 10L20 21\\\" stroke=\\\"#666666\\\" stroke-width=\\\"1.5\\\" stroke-linecap=\\\"round\\\"/>\\n<path d=\\\"M20 10L9 21\\\" stroke=\\\"#666666\\\" stroke-width=\\\"1.5\\\" stroke-linecap=\\\"round\\\"/>\\n</svg>\\n    \";\n      navBar.appendChild(backButton);\n\n      // Create preview area (with minimum height)\n      var previewArea = document.createElement('div');\n      previewArea.className = 'preview-area';\n      previewArea.style.backgroundColor = '#000'; // Darker background for contrast\n\n      // =====> CREATE THE SHADER CANVAS  <=====\n      var shaderCanvas = document.createElement('canvas');\n      shaderCanvas.id = 'shader-canvas'; // Crucial ID for ShaderManager\n      previewArea.appendChild(shaderCanvas); // Add it to the preview area\n\n      // Create parameters area (scrollable)\n      var paramsArea = document.createElement('div');\n      paramsArea.className = 'params-area';\n\n      // Create parameters container\n      var parametersContainer = document.createElement('div');\n      parametersContainer.id = 'parameters';\n      parametersContainer.className = 'parameters-container';\n      paramsArea.appendChild(parametersContainer);\n\n      // Create controls area (bottom buttons - horizontally scrollable)\n      var controlsArea = document.createElement('div');\n      controlsArea.className = 'controls-area';\n\n      // Container for horizontal scrolling\n      var controlsContainer = document.createElement('div');\n      controlsContainer.className = 'controls-container';\n      controlsArea.appendChild(controlsContainer);\n\n      // Assemble the editor in the new layout order\n      editorLayout.appendChild(navBar);\n      editorLayout.appendChild(previewArea);\n      editorLayout.appendChild(paramsArea);\n      editorLayout.appendChild(controlsArea);\n      return editorLayout;\n    }\n\n    /**\n     * Create the SVG preview element\n     * @returns {SVGElement} The created SVG element\n     */\n  }, {\n    key: \"createPreviewSVG\",\n    value: function createPreviewSVG() {\n      var previewSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n      previewSvg.id = 'preview-svg';\n      previewSvg.setAttribute('width', '100%');\n      previewSvg.setAttribute('height', '100%');\n      previewSvg.setAttribute('viewBox', '-110 -110 220 220');\n      previewSvg.setAttribute('preserveAspectRatio', 'xMidYMid meet');\n      previewSvg.style.position = 'relative'; // Ensure SVG is positioned correctly relative to canvas\n      previewSvg.style.zIndex = '1'; // Ensure SVG is above default canvas z-index (-1)\n\n      // --- Add <defs> for shader pattern ---\n      var defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');\n      var pattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');\n      pattern.id = 'shaderPattern'; // Static ID for pattern\n      pattern.setAttribute('patternUnits', 'userSpaceOnUse');\n      pattern.setAttribute('width', '220'); // Match viewBox size (adjust if needed)\n      pattern.setAttribute('height', '220');\n      pattern.setAttribute('x', '-110'); // Center pattern relative to viewBox\n      pattern.setAttribute('y', '-110');\n      var patternImage = document.createElementNS('http://www.w3.org/2000/svg', 'image');\n      patternImage.id = 'shaderPatternImage'; // ID to update href later\n      patternImage.setAttribute('href', ''); // Start empty\n      patternImage.setAttribute('x', '0'); // Image position within pattern\n      patternImage.setAttribute('y', '0');\n      patternImage.setAttribute('width', '220'); // Image size matches pattern\n      patternImage.setAttribute('height', '220');\n      pattern.appendChild(patternImage);\n      defs.appendChild(pattern);\n      previewSvg.appendChild(defs); // Add defs to SVG\n\n      // --- Create wrapper group for the actual shape ---\n      var wrapperGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n      wrapperGroup.id = 'shape'; // Where generated shape content goes\n      // wrapperGroup.setAttribute('transform', 'translate(0,0)'); // Default transform\n      previewSvg.appendChild(wrapperGroup);\n      return previewSvg;\n    }\n\n    /**\n     * Create the control buttons\n     * @param {HTMLElement} container - The container to add buttons to\n     */\n  }, {\n    key: \"createControlButtons\",\n    value: function createControlButtons(container) {\n      var _this = this;\n      var svgIcons = {\n        reset: \"<svg width=\\\"10\\\" height=\\\"10\\\" viewBox=\\\"0 0 10 10\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n  <path d=\\\"M1.5 1.5L8.5 8.5M1.5 8.5L8.5 1.5\\\" stroke=\\\"#D9D9D9\\\" stroke-width=\\\"1.5\\\" stroke-linecap=\\\"round\\\"/>\\n  </svg>\\n  \",\n        undo: \"<svg width=\\\"10\\\" height=\\\"10\\\" viewBox=\\\"-2.2 0 10 9\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n  <path d=\\\"M3.23077 6.5C2.95463 6.5 2.73077 6.72386 2.73077 7C2.73077 7.27614 2.95463 7.5 3.23077 7.5V6.5ZM2 2.5H4.5V1.5H2V2.5ZM4.5 6.5H3.23077V7.5H4.5V6.5ZM6.5 4.5C6.5 5.60457 5.60457 6.5 4.5 6.5V7.5C6.15685 7.5 7.5 6.15685 7.5 4.5H6.5ZM4.5 2.5C5.60457 2.5 6.5 3.39543 6.5 4.5H7.5C7.5 2.84315 6.15685 1.5 4.5 1.5V2.5Z\\\" fill=\\\"#D9D9D9\\\"/>\\n  <path d=\\\"M2.01346 3.58247C2.21007 3.73856 2.5 3.59855 2.5 3.34751V0.620284C2.5 0.369249 2.21007 0.229238 2.01346 0.385331L0.295933 1.74895C0.144652 1.86905 0.144652 2.09874 0.295933 2.21885L2.01346 3.58247Z\\\" fill=\\\"#D9D9D9\\\"/>\\n  </svg>\\n  \",\n        redo: \"<svg width=\\\"10\\\" height=\\\"10\\\" viewBox=\\\"-2.2 0 10 9\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n  <path d=\\\"M4.76923 6.5C5.04537 6.5 5.26923 6.72386 5.26923 7C5.26923 7.27614 5.04537 7.5 4.76923 7.5V6.5ZM6 2.5H3.5V1.5H6V2.5ZM3.5 6.5H4.76923V7.5H3.5V6.5ZM1.5 4.5C1.5 5.60457 2.39543 6.5 3.5 6.5V7.5C1.84315 7.5 0.5 6.15685 0.5 4.5H1.5ZM3.5 2.5C2.39543 2.5 1.5 3.39543 1.5 4.5H0.5C0.5 2.84315 1.84315 1.5 3.5 1.5V2.5Z\\\" fill=\\\"#D9D9D9\\\"/>\\n  <path d=\\\"M5.98654 3.58247C5.78993 3.73856 5.5 3.59855 5.5 3.34751V0.620284C5.5 0.369249 5.78993 0.229238 5.98654 0.385331L7.70407 1.74895C7.85535 1.86905 7.85535 2.09874 7.70407 2.21885L5.98654 3.58247Z\\\" fill=\\\"#D9D9D9\\\"/>\\n  </svg>\\n  \",\n        randomize: \"<svg width=\\\"11\\\" height=\\\"9\\\" viewBox=\\\"0 0 11 9\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n  <path d=\\\"M8.48654 8.58247C8.28993 8.73856 8 8.59855 8 8.34751V5.62028C8 5.36925 8.28993 5.22924 8.48654 5.38533L10.2041 6.74895C10.3553 6.86905 10.3553 7.09874 10.2041 7.21885L8.48654 8.58247Z\\\" fill=\\\"#D9D9D9\\\"/>\\n  <path d=\\\"M1 1.98438H1.44836C2.26415 1.98438 3.02862 2.3824 3.49644 3.05072L5.50356 5.91803C5.97138 6.58635 6.73585 6.98438 7.55164 6.98438H8\\\" stroke=\\\"#D9D9D9\\\" stroke-linecap=\\\"round\\\"/>\\n  <path d=\\\"M8.48654 0.386283C8.28993 0.23019 8 0.370201 8 0.621236V3.34847C8 3.5995 8.28993 3.73951 8.48654 3.58342L10.2041 2.2198C10.3553 2.0997 10.3553 1.87001 10.2041 1.7499L8.48654 0.386283Z\\\" fill=\\\"#D9D9D9\\\"/>\\n  <path d=\\\"M1 6.98438H1.44836C2.26415 6.98438 3.02862 6.58635 3.49644 5.91803L5.50356 3.05072C5.97138 2.3824 6.73585 1.98438 7.55164 1.98438H8\\\" stroke=\\\"#D9D9D9\\\" stroke-linecap=\\\"round\\\"/>\\n  </svg>\\n  \",\n        copy: \"<svg width=\\\"10\\\" height=\\\"9\\\" viewBox=\\\"0 0 10 9\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n  <rect x=\\\"1\\\" y=\\\"3\\\" width=\\\"5\\\" height=\\\"5\\\" rx=\\\"1\\\" stroke=\\\"#D9D9D9\\\"/>\\n  <path d=\\\"M6 6H8C8.55228 6 9 5.55228 9 5V2C9 1.44772 8.55228 1 8 1H5C4.44772 1 4 1.44772 4 2V3\\\" stroke=\\\"#D9D9D9\\\"/>\\n  </svg>\\n  \",\n        save: \"<svg width=\\\"8\\\" height=\\\"9\\\" viewBox=\\\"0 0 8 9\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n  <path d=\\\"M1 2V7.27068C1 7.358 1.10406 7.40337 1.16804 7.34396L3.43195 5.24176C3.47032 5.20613 3.52968 5.20613 3.56804 5.24176L5.83195 7.34396C5.89594 7.40337 6 7.358 6 7.27068V2C6 1.44772 5.55228 1 5 1H2C1.44772 1 1 1.44772 1 2Z\\\" stroke=\\\"#D9D9D9\\\"/>\\n  </svg>\\n  \",\n        \"export\": \"<svg width=\\\"8\\\" height=\\\"9\\\" viewBox=\\\"0 0 8 9\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n  <path d=\\\"M5.5 2.6L4.24 1.10667C4.12 0.964444 3.88 0.964444 3.76 1.10667L2.5 2.6\\\" stroke=\\\"#D9D9D9\\\" stroke-linecap=\\\"round\\\"/>\\n  <path d=\\\"M2.71429 5H2C1.44772 5 1 5.44772 1 6V7C1 7.55228 1.44772 8 2 8H6C6.55228 8 7 7.55228 7 7V6C7 5.44772 6.55228 5 6 5H5.28571\\\" stroke=\\\"#D9D9D9\\\"/>\\n  <path d=\\\"M4 5L4 2\\\" stroke=\\\"#D9D9D9\\\" stroke-linecap=\\\"round\\\"/>\\n  </svg>\\n  \"\n      };\n      var buttons = [{\n        id: 'undoBtn',\n        icon: svgIcons.undo,\n        text: 'Undo',\n        handler: function handler() {\n          return _this.editor.controller.history.undo();\n        }\n      }, {\n        id: 'redoBtn',\n        icon: svgIcons.redo,\n        text: 'Redo',\n        handler: function handler() {\n          return _this.editor.controller.history.redo();\n        }\n      }, {\n        id: 'randomizeBtn',\n        icon: svgIcons.randomize,\n        text: 'Random',\n        handler: function handler() {\n          return _this.editor.randomizeShape();\n        }\n      }, {\n        id: 'copyBtn',\n        icon: svgIcons.copy,\n        text: 'Copy',\n        handler: function handler() {\n          return _this.editor.copySvgToClipboard();\n        }\n      }, {\n        id: 'exportBtn',\n        icon: svgIcons[\"export\"],\n        text: 'Export',\n        handler: function handler() {\n          return _this.editor.showExportModal();\n        }\n      }];\n      buttons.forEach(function (button) {\n        var btn = document.createElement('button');\n        btn.id = button.id;\n        btn.className = 'control-button';\n\n        // Create container for SVG to control its size\n        var iconSpan = document.createElement('span');\n        iconSpan.innerHTML = button.icon;\n        iconSpan.style.display = 'flex';\n        iconSpan.style.alignItems = 'center';\n        iconSpan.style.justifyContent = 'center';\n        iconSpan.style.width = '14px';\n        iconSpan.style.height = '14px';\n\n        // Apply styles to the SVG elements to match design\n        var svgElements = iconSpan.querySelectorAll('svg');\n        svgElements.forEach(function (svg) {\n          svg.style.width = '14px';\n          svg.style.height = '14px';\n        });\n\n        // Clear the button and add the icon span and text separately\n        btn.innerHTML = '';\n        btn.appendChild(iconSpan);\n        var textSpan = document.createElement('span');\n        textSpan.textContent = button.text;\n        btn.appendChild(textSpan);\n\n        // Improved button styling for mobile\n        btn.style.backgroundColor = '#1A1A1A';\n        btn.style.color = '#D9D9D9';\n        btn.style.border = 'none';\n        btn.style.fontFamily = \"'Menlo', 'Monaco', 'Courier New', monospace\";\n        btn.style.borderRadius = '30px';\n        btn.style.padding = '12px 16px'; // Slightly taller for touch\n        btn.style.cursor = 'pointer';\n        btn.style.display = 'flex'; // Use regular flex for better centering\n        btn.style.alignItems = 'center';\n        btn.style.justifyContent = 'center';\n        btn.style.gap = '6px'; // Reduced gap between icon and text\n        btn.style.fontSize = '12px';\n        btn.style.minWidth = '90px'; // Slightly smaller for more buttons in view\n        btn.style.whiteSpace = 'nowrap'; // Prevent text wrapping\n\n        // Add touch-friendly active state for mobile\n        btn.addEventListener('touchstart', function () {\n          btn.style.backgroundColor = '#282828';\n          btn.style.transform = 'scale(0.98)';\n        });\n        btn.addEventListener('touchend', function () {\n          setTimeout(function () {\n            btn.style.backgroundColor = '#1A1A1A';\n            btn.style.transform = 'scale(1)';\n          }, 150);\n        });\n        btn.addEventListener('click', button.handler);\n        container.appendChild(btn);\n      });\n      if (this.editor.controller.history) {\n        this.editor.controller.history.updateButtonsState();\n      }\n    }\n\n    /**\n     * Show error view when editor fails to load\n     */\n  }, {\n    key: \"showErrorView\",\n    value: function showErrorView(container, shapeName) {\n      var errorLayout = document.createElement('div');\n      errorLayout.className = 'editor-layout error';\n      errorLayout.style.backgroundColor = '#111';\n      errorLayout.style.color = '#e0e0e0';\n      errorLayout.style.height = '100vh';\n      errorLayout.style.display = 'flex';\n      errorLayout.style.flexDirection = 'column';\n      errorLayout.style.alignItems = 'center';\n      errorLayout.style.justifyContent = 'center';\n      errorLayout.style.padding = '20px';\n      var errorMessage = document.createElement('div');\n      errorMessage.textContent = \"Error loading shape editor for: \".concat(shapeName);\n      errorMessage.style.color = '#ff5555';\n      errorMessage.style.marginBottom = '20px';\n      var backButton = document.createElement('button');\n      backButton.textContent = 'Back to Grid';\n      backButton.style.padding = '8px 16px';\n      backButton.style.backgroundColor = '#333';\n      backButton.style.color = '#fff';\n      backButton.style.border = 'none';\n      backButton.style.borderRadius = '4px';\n      backButton.style.cursor = 'pointer';\n      backButton.addEventListener('click', this.editor.hideEditor);\n      errorLayout.appendChild(errorMessage);\n      errorLayout.appendChild(backButton);\n      container.appendChild(errorLayout);\n      document.addEventListener('keydown', this.editor.handleKeyDown);\n    }\n\n    // =============================================\n    // == SHADER CONTROLS and VISUALS (Add these) ==\n    // =============================================\n\n    /**\n     * Create UI controls for selecting shaders and modes.\n     * @param {HTMLElement} container - The parent element for the controls.\n     * @param {Array<{name: string}>} shaderList - List of available shader names.\n     * @param {string|null} currentShader - The name of the currently active shader.\n     * @param {string} currentMode - The current shader mode ('background', 'fill').\n     */\n    // =============================================\n    // == SHADER CONTROLS and VISUALS (Add these) ==\n    // =============================================\n\n    /**\n     * Create UI controls for selecting shaders and modes.\n     * @param {HTMLElement} container - The parent element for the controls.\n     * @param {Array<{name: string}>} shaderList - List of available shader names.\n     * @param {string|null} currentShader - The name of the currently active shader.\n     * @param {string} currentMode - The current shader mode ('background', 'fill').\n     */\n    //   createShaderControls(container, shaderList, currentShader, currentMode) {\n    //     const shaderRow = document.createElement('div');\n    //     shaderRow.className = 'control-row shader-controls'; // Use class for styling\n\n    //     // --- Shader Selector ---\n    //     const selectorLabel = document.createElement('label');\n    //     selectorLabel.className = 'param-name'; // Use existing style\n    //     selectorLabel.textContent = 'Shader Effect';\n    //     selectorLabel.htmlFor = 'shader-select';\n    //     shaderRow.appendChild(selectorLabel);\n\n    //     const selector = document.createElement('select');\n    //     selector.id = 'shader-select';\n    //     selector.style.width = '100%'; // Make it full width of control row\n\n    //     const noneOption = document.createElement('option');\n    //     noneOption.value = '';\n    //     noneOption.textContent = 'None';\n    //     selector.appendChild(noneOption);\n\n    //     shaderList.forEach(shader => {\n    //         const option = document.createElement('option');\n    //         option.value = shader.name;\n    //         // Simple name for now, could use a mapping later for friendlier names\n    //         option.textContent = shader.name.replace(/_/g, ' ');\n    //         if (shader.name === currentShader) {\n    //             option.selected = true;\n    //         }\n    //         selector.appendChild(option);\n    //     });\n\n    //     selector.addEventListener('change', (e) => {\n    //         this.editor.setActiveShader(e.target.value || null);\n    //     });\n    //     shaderRow.appendChild(selector);\n\n    //     // --- Mode Selector (Background / Fill) ---\n    //     const modeLabel = document.createElement('label');\n    //     modeLabel.className = 'param-name';\n    //     modeLabel.textContent = 'Shader Mode';\n    //     modeLabel.style.marginTop = '10px'; // Add some space\n    //     shaderRow.appendChild(modeLabel);\n\n    //     const modeContainer = document.createElement('div');\n    //     modeContainer.className = 'shader-mode-container'; // Class for styling\n    //     modeContainer.style.display = 'flex';\n    //     modeContainer.style.gap = '15px'; // Space between radio buttons\n\n    //     const modes = ['background', 'fill']; // Available modes\n    //     modes.forEach(mode => {\n    //         const radioLabel = document.createElement('label');\n    //         radioLabel.style.display = 'flex';\n    //         radioLabel.style.alignItems = 'center';\n    //         radioLabel.style.cursor = 'pointer';\n\n    //         const radioInput = document.createElement('input');\n    //         radioInput.type = 'radio';\n    //         radioInput.name = 'shaderMode'; // Group radios together\n    //         radioInput.value = mode;\n    //         radioInput.checked = mode === currentMode;\n    //         radioInput.addEventListener('change', (e) => {\n    //             if (e.target.checked) {\n    //                 this.setShaderMode(e.target.value);\n    //             }\n    //         });\n\n    //         radioLabel.appendChild(radioInput);\n    //         // Capitalize mode name for display\n    //         radioLabel.appendChild(document.createTextNode(mode.charAt(0).toUpperCase() + mode.slice(1)));\n    //         modeContainer.appendChild(radioLabel);\n    //     });\n    //     shaderRow.appendChild(modeContainer);\n\n    //     // Append the whole shader control section to the main parameters container\n    //     container.appendChild(shaderRow);\n    // }\n\n    // /**\n    //  * Updates the internal shader mode and triggers a visual update.\n    //  * @param {string} mode - The new shader mode ('background', 'fill').\n    //  */\n    // setShaderMode(mode) {\n    //     console.log(\"Setting shader mode:\", mode);\n    //     this.shaderMode = mode;\n    //     this.editor.updateShaderDisplayMode(); // Tell ShapeEditor to update visuals\n    // }\n\n    // /**\n    //  * Updates the visual presentation based on the active shader and mode.\n    //  * Handles showing/hiding the canvas and applying the shader as background or fill.\n    //  * @param {boolean} isActive - Whether a shader is currently active.\n    //  * @param {string} mode - The current shader mode ('background', 'fill').\n    //  * @param {string|null} [dataURL=null] - The canvas data URL, needed for 'fill' mode.\n    //  */\n    // updateShaderVisuals(isActive, mode, dataURL = null) {\n    //     const canvas = document.getElementById('shader-canvas');\n    //     const svgShapeGroup = document.getElementById('shape'); // The <g> holding the shape\n    //     const patternImage = document.getElementById('shaderPatternImage'); // The <image> inside <defs><pattern>\n\n    //     if (!canvas || !svgShapeGroup || !patternImage) {\n    //         console.warn(\"Required elements for shader visuals (canvas, #shape, #shaderPatternImage) not found.\");\n    //         return;\n    //     }\n\n    //     // --- Reset styles first ---\n    //     canvas.style.display = 'none'; // Hide canvas by default\n    //     canvas.style.zIndex = '-1'; // Default behind SVG\n    //     // Clear any pattern fill potentially applied to the shape elements\n    //     const shapeElements = svgShapeGroup.querySelectorAll('path, rect, circle, ellipse, polygon, polyline');\n    //     shapeElements.forEach(el => {\n    //         // IMPORTANT: Only remove the fill *if* it was the shader pattern.\n    //         // Otherwise, respect the fill set by ShapeStyleController.\n    //         if (el.getAttribute('fill') === 'url(#shaderPattern)') {\n    //             // Revert to default/CSS or remove attribute? Removing might be safer.\n    //             // Let's try removing it, ShapeStyleController should re-apply its own fill.\n    //             el.removeAttribute('fill');\n    //         }\n    //     });\n    //     // --- End Reset ---\n\n    //     if (isActive) {\n    //         canvas.style.display = 'block'; // Show canvas if shader is active\n\n    //         if (mode === 'background') {\n    //             canvas.style.zIndex = '-1'; // Ensure canvas is behind SVG\n    //             // In this mode, ShapeStyleController should handle the SVG's fill/stroke.\n    //             // If the SVG fill is 'none' or semi-transparent, the canvas shows through.\n    //             // No direct style changes needed here for the SVG itself.\n    //              console.log(\"Shader mode: Background (Canvas behind SVG)\");\n\n    //         } else if (mode === 'fill') {\n    //             canvas.style.zIndex = '0'; // Canvas z-index doesn't matter much here\n    //             if (dataURL) {\n    //                 // 1. Update the href of the image inside the pattern def\n    //                 patternImage.setAttributeNS('http://www.w3.org/1999/xlink', 'href', dataURL); // Use xlink:href for broader compatibility\n\n    //                 // 2. Apply the pattern fill to the actual shape elements\n    //                 shapeElements.forEach(el => {\n    //                     el.setAttribute('fill', 'url(#shaderPattern)');\n    //                     // Optionally remove stroke when using fill pattern?\n    //                     // el.setAttribute('stroke', 'none');\n    //                 });\n    //                  console.log(\"Shader mode: Fill (Applied pattern to shape elements)\");\n\n    //                 // 3. TODO: Notify ShapeStyleController to disable its fill controls\n    //                 if (this.editor.styleController) {\n    //                    // this.editor.styleController.disableFillInput(true);\n    //                 }\n\n    //             } else {\n    //                 console.warn(\"Shader mode 'fill' requires a dataURL, but none was provided.\");\n    //             }\n    //         }\n    //     } else {\n    //          // Shader is inactive\n    //          console.log(\"Shader mode: Inactive\");\n    //          // TODO: Notify ShapeStyleController to re-enable its fill controls\n    //          if (this.editor.styleController) {\n    //             // this.editor.styleController.disableFillInput(false);\n    //          }\n    //     }\n\n    //      // Crucially, after potentially changing fill, re-apply the current StyleController style\n    //      // This ensures stroke/opacity etc. are still correct.\n    //      // However, avoid infinite loops. This might need careful handling.\n    //      // Let's rely on updateShape calling updateShapeStyle AFTER updateShaderDisplayMode.\n    //      // if (this.editor.styleController) {\n    //      //     this.editor.styleController.updateShapeStyle();\n    //      // }\n    // }\n  }]);\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ShapeEditorUI);\n\n//# sourceURL=webpack://generative-shapes/./src/ShapeEditorUI.js?");

/***/ }),

/***/ "./src/ShapeExporter.js":
/*!******************************!*\
  !*** ./src/ShapeExporter.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n/**\n * ShapeExporter.js\n * Handles export functionality for the ShapeEditor\n */\nvar ShapeExporter = /*#__PURE__*/function () {\n  function ShapeExporter(editor) {\n    _classCallCheck(this, ShapeExporter);\n    this.editor = editor;\n  }\n\n  /**\n   * Show export modal to set export options\n   */\n  return _createClass(ShapeExporter, [{\n    key: \"showExportModal\",\n    value: function showExportModal() {\n      var _this = this;\n      // Remove any existing modal\n      var existingModal = document.getElementById('export-modal');\n      if (existingModal) {\n        existingModal.remove();\n      }\n\n      // Create modal container\n      var modal = document.createElement('div');\n      modal.id = 'export-modal';\n      modal.className = 'modal';\n\n      // Create modal content\n      var modalContent = document.createElement('div');\n      modalContent.className = 'modal-content';\n      modalContent.style.backgroundColor = '#000';\n      modalContent.style.borderRadius = '8px';\n      modalContent.style.padding = '24px';\n      modalContent.style.width = '320px';\n      modalContent.style.maxWidth = '90%';\n      modalContent.style.color = '#e0e0e0';\n      modalContent.style.fontFamily = \"'Menlo', 'Monaco', 'Courier New', monospace\";\n\n      // Create modal header\n      var modalHeader = document.createElement('div');\n      modalHeader.className = 'modal-header';\n      modalHeader.style.display = 'flex';\n      modalHeader.style.justifyContent = 'space-between';\n      modalHeader.style.alignItems = 'center';\n      modalHeader.style.marginBottom = '16px';\n      var modalTitle = document.createElement('h3');\n      modalTitle.textContent = 'Export Shape';\n      modalTitle.style.margin = '0';\n      modalTitle.style.fontSize = '16px';\n      modalTitle.style.fontWeight = 'normal';\n      modalTitle.style.color = '#e0e0e0';\n      var closeButton = document.createElement('button');\n      closeButton.className = 'close-button';\n      closeButton.innerHTML = \"\\n      <svg width=\\\"14\\\" height=\\\"14\\\" viewBox=\\\"0 0 14 14\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n        <path d=\\\"M1 1L13 13M1 13L13 1\\\" stroke=\\\"#e0e0e0\\\" stroke-width=\\\"1.5\\\" stroke-linecap=\\\"round\\\"/>\\n      </svg>\\n    \";\n      closeButton.style.backgroundColor = 'transparent';\n      closeButton.style.border = 'none';\n      closeButton.style.cursor = 'pointer';\n      closeButton.style.padding = '4px';\n      closeButton.style.display = 'flex';\n      closeButton.style.alignItems = 'center';\n      closeButton.style.justifyContent = 'center';\n      closeButton.onclick = function () {\n        return modal.remove();\n      };\n      modalHeader.appendChild(modalTitle);\n      modalHeader.appendChild(closeButton);\n\n      // Create form\n      var form = document.createElement('form');\n      form.onsubmit = function (e) {\n        e.preventDefault();\n        _this.exportWithOptions();\n      };\n\n      // Format selection\n      var formatGroup = this.createFormGroup('Format');\n      var formatSelect = this.createSelect('format', [{\n        value: 'png',\n        label: 'PNG'\n      }, {\n        value: 'svg',\n        label: 'SVG'\n      }]);\n      formatSelect.value = 'png'; // Default to PNG\n      formatGroup.appendChild(formatSelect);\n\n      // Aspect ratio selection\n      var aspectGroup = this.createFormGroup('Aspect Ratio');\n      var aspectSelect = this.createSelect('aspect-ratio', [{\n        value: '1:1',\n        label: '1:1 (Square)'\n      }, {\n        value: '4:3',\n        label: '4:3'\n      }, {\n        value: '16:9',\n        label: '16:9'\n      }, {\n        value: '3:2',\n        label: '3:2'\n      }, {\n        value: '2:1',\n        label: '2:1'\n      }, {\n        value: '9:16',\n        label: '9:16 (Mobile Portrait)'\n      }, {\n        value: '18:9',\n        label: '18:9 (Mobile Landscape)'\n      }]);\n      aspectGroup.appendChild(aspectSelect);\n\n      // Resolution selection\n      var resolutionGroup = this.createFormGroup('Resolution');\n      var resolutionSelect = this.createSelect('resolution', [{\n        value: '800',\n        label: '800800 (Small)'\n      }, {\n        value: '1200',\n        label: '12001200 (Medium)'\n      }, {\n        value: '2400',\n        label: '24002400 (Large)'\n      }, {\n        value: '3600',\n        label: '36003600 (Very Large)'\n      }]);\n      resolutionSelect.value = '1200'; // Default to medium\n      resolutionGroup.appendChild(resolutionSelect);\n\n      // Background color option\n      var bgGroup = this.createFormGroup('Background');\n      var bgSelect = this.createSelect('background', [{\n        value: 'transparent',\n        label: 'Transparent (PNG only)'\n      }, {\n        value: 'black',\n        label: 'Black (Default)'\n      }]);\n\n      // Disable transparent option when SVG is selected\n      formatSelect.addEventListener('change', function (e) {\n        if (e.target.value === 'svg') {\n          if (bgSelect.value === 'transparent') {\n            bgSelect.value = 'black';\n          }\n\n          // Find and disable the transparent option\n          Array.from(bgSelect.options).forEach(function (option) {\n            if (option.value === 'transparent') {\n              option.disabled = true;\n            }\n          });\n        } else {\n          // Re-enable the transparent option\n          Array.from(bgSelect.options).forEach(function (option) {\n            if (option.value === 'transparent') {\n              option.disabled = false;\n            }\n          });\n        }\n      });\n      bgGroup.appendChild(bgSelect);\n\n      // Update resolution label based on aspect ratio\n      aspectSelect.addEventListener('change', function () {\n        _this.updateResolutionLabels(aspectSelect.value, resolutionSelect);\n      });\n\n      // Create submit button\n      var buttonGroup = document.createElement('div');\n      buttonGroup.style.marginTop = '24px';\n      buttonGroup.style.display = 'flex';\n      buttonGroup.style.justifyContent = 'center';\n      var submitButton = document.createElement('button');\n      submitButton.type = 'submit';\n      submitButton.textContent = 'Export';\n      submitButton.style.backgroundColor = '#333';\n      submitButton.style.color = '#e0e0e0';\n      submitButton.style.border = 'none';\n      submitButton.style.borderRadius = '30px';\n      submitButton.style.padding = '8px 16px';\n      submitButton.style.cursor = 'pointer';\n      submitButton.style.fontFamily = \"'Menlo', 'Monaco', 'Courier New', monospace\";\n      submitButton.style.fontSize = '12px';\n      submitButton.style.width = '100%';\n      submitButton.style.transition = 'background-color 0.2s';\n      submitButton.addEventListener('mouseover', function () {\n        submitButton.style.backgroundColor = '#444';\n      });\n      submitButton.addEventListener('mouseout', function () {\n        submitButton.style.backgroundColor = '#333';\n      });\n      buttonGroup.appendChild(submitButton);\n\n      // Assemble form\n      form.appendChild(formatGroup);\n      form.appendChild(aspectGroup);\n      form.appendChild(resolutionGroup);\n      form.appendChild(bgGroup);\n      form.appendChild(buttonGroup);\n\n      // Assemble modal\n      modalContent.appendChild(modalHeader);\n      modalContent.appendChild(form);\n      modal.appendChild(modalContent);\n\n      // Add modal to document\n      document.body.appendChild(modal);\n\n      // Initialize correct resolution labels\n      this.updateResolutionLabels(aspectSelect.value, resolutionSelect);\n      var _modalEscHandler = function modalEscHandler(e) {\n        if (e.key === 'Escape') {\n          modal.remove();\n          document.removeEventListener('keydown', _modalEscHandler);\n          e.stopPropagation();\n        }\n      };\n      document.addEventListener('keydown', _modalEscHandler);\n    }\n\n    /**\n     * Helper method to create form groups\n     */\n  }, {\n    key: \"createFormGroup\",\n    value: function createFormGroup(label) {\n      var group = document.createElement('div');\n      group.className = 'form-group';\n      group.style.marginBottom = '16px';\n      var labelElement = document.createElement('label');\n      labelElement.textContent = label;\n      labelElement.style.display = 'block';\n      labelElement.style.marginBottom = '8px';\n      labelElement.style.fontSize = '12px';\n      labelElement.style.color = '#999';\n      labelElement.style.textTransform = 'uppercase';\n      labelElement.style.letterSpacing = '0.5px';\n      group.appendChild(labelElement);\n      return group;\n    }\n\n    /**\n     * Helper method to create select elements\n     */\n  }, {\n    key: \"createSelect\",\n    value: function createSelect(id, options) {\n      var select = document.createElement('select');\n      select.id = id;\n      select.style.width = '100%';\n      select.style.backgroundColor = '#000';\n      select.style.color = '#e0e0e0';\n      select.style.border = '1px solid #333';\n      select.style.borderRadius = '4px';\n      select.style.padding = '8px';\n      select.style.fontFamily = \"'Menlo', 'Monaco', 'Courier New', monospace\";\n      select.style.fontSize = '12px';\n      select.style.appearance = 'none';\n      select.style.backgroundImage = \"url(\\\"data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23999' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e\\\")\";\n      select.style.backgroundRepeat = 'no-repeat';\n      select.style.backgroundPosition = 'right 8px center';\n      select.style.backgroundSize = '16px';\n      options.forEach(function (option) {\n        var optElement = document.createElement('option');\n        optElement.value = option.value;\n        optElement.textContent = option.label;\n        select.appendChild(optElement);\n      });\n      return select;\n    }\n\n    /**\n     * Update resolution labels based on aspect ratio\n     */\n  }, {\n    key: \"updateResolutionLabels\",\n    value: function updateResolutionLabels(aspectRatio, resolutionSelect) {\n      var _this2 = this;\n      var _aspectRatio$split$ma = aspectRatio.split(':').map(Number),\n        _aspectRatio$split$ma2 = _slicedToArray(_aspectRatio$split$ma, 2),\n        width = _aspectRatio$split$ma2[0],\n        height = _aspectRatio$split$ma2[1];\n      var baseResolutions = [800, 1200, 2400, 3600];\n      var labels = ['Small', 'Medium', 'Large', 'Very Large'];\n\n      // Remove existing options\n      while (resolutionSelect.firstChild) {\n        resolutionSelect.removeChild(resolutionSelect.firstChild);\n      }\n\n      // Add new options with updated labels\n      baseResolutions.forEach(function (res, index) {\n        var adjusted = _this2.calculateDimensions(res, width, height);\n        var option = document.createElement('option');\n        option.value = res;\n        option.textContent = \"\".concat(adjusted.width, \"\\xD7\").concat(adjusted.height, \" (\").concat(labels[index], \")\");\n        resolutionSelect.appendChild(option);\n      });\n    }\n\n    /**\n     * Calculate dimensions based on aspect ratio\n     */\n  }, {\n    key: \"calculateDimensions\",\n    value: function calculateDimensions(baseSize, width, height) {\n      if (width === height) {\n        return {\n          width: baseSize,\n          height: baseSize\n        };\n      }\n\n      // Calculate the longer side based on aspect ratio\n      if (width > height) {\n        var h = Math.round(baseSize * (height / width));\n        return {\n          width: baseSize,\n          height: h\n        };\n      } else {\n        var w = Math.round(baseSize * (width / height));\n        return {\n          width: w,\n          height: baseSize\n        };\n      }\n    }\n\n    /**\n     * Export with the selected options\n     */\n  }, {\n    key: \"exportWithOptions\",\n    value: function exportWithOptions() {\n      var formatSelect = document.getElementById('format');\n      var aspectSelect = document.getElementById('aspect-ratio');\n      var resolutionSelect = document.getElementById('resolution');\n      var bgSelect = document.getElementById('background');\n      if (!formatSelect || !aspectSelect || !resolutionSelect || !bgSelect) {\n        console.error('Could not find form elements');\n        return;\n      }\n      var format = formatSelect.value;\n      var aspectRatio = aspectSelect.value;\n      var baseSize = parseInt(resolutionSelect.value);\n      var background = bgSelect.value;\n\n      // Calculate dimensions\n      var _aspectRatio$split$ma3 = aspectRatio.split(':').map(Number),\n        _aspectRatio$split$ma4 = _slicedToArray(_aspectRatio$split$ma3, 2),\n        width = _aspectRatio$split$ma4[0],\n        height = _aspectRatio$split$ma4[1];\n      var dimensions = this.calculateDimensions(baseSize, width, height);\n\n      // Close the modal\n      var modal = document.getElementById('export-modal');\n      if (modal) {\n        modal.remove();\n      }\n\n      // Call export with the selected options\n      this.exportShapeWithOptions(format, dimensions, background);\n    }\n\n    /**\n     * Enhanced export method with options\n     */\n  }, {\n    key: \"exportShapeWithOptions\",\n    value: function exportShapeWithOptions(format, dimensions, background) {\n      var _this3 = this;\n      if (this.editor.controller.analytics) {\n        this.editor.controller.analytics.exportShape(this.editor.currentShape, format);\n      }\n      var svg = document.getElementById('preview-svg');\n      if (!svg) return;\n      var svgClone = svg.cloneNode(true);\n\n      // Create a clean SVG by setting explicit dimensions\n      svgClone.setAttribute('width', dimensions.width);\n      svgClone.setAttribute('height', dimensions.height);\n      if (this.editor.styleController) {\n        var wrapperGroup = svgClone.querySelector('g');\n        if (wrapperGroup) {\n          this.editor.styleController.applyStylesToSVG(wrapperGroup);\n        }\n      }\n\n      // Add background if specified and not transparent\n      if (background !== 'transparent' && format !== 'svg') {\n        var bgRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n        bgRect.setAttribute('width', '100%');\n        bgRect.setAttribute('height', '100%');\n        bgRect.setAttribute('fill', background);\n        svgClone.insertBefore(bgRect, svgClone.firstChild);\n      }\n      var svgData = new XMLSerializer().serializeToString(svgClone);\n      if (format === 'svg') {\n        var blob = new Blob([svgData], {\n          type: 'image/svg+xml'\n        });\n        this.downloadFile(blob, \"shape-\".concat(dimensions.width, \"x\").concat(dimensions.height, \".svg\"));\n      } else if (format === 'png') {\n        var canvas = document.createElement('canvas');\n        var ctx = canvas.getContext('2d');\n        canvas.width = dimensions.width;\n        canvas.height = dimensions.height;\n\n        // Set up the canvas\n        if (background === 'transparent') {\n          // For transparent background, we need to clear the canvas\n          ctx.clearRect(0, 0, canvas.width, canvas.height);\n        } else {\n          // For colored background\n          ctx.fillStyle = background;\n          ctx.fillRect(0, 0, canvas.width, canvas.height);\n        }\n\n        // Create SVG image\n        var img = new Image();\n        var svgBlob = new Blob([svgData], {\n          type: 'image/svg+xml'\n        });\n        var url = URL.createObjectURL(svgBlob);\n        img.onload = function () {\n          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n\n          // Use proper PNG encoding with transparency support\n          var exportOptions = background === 'transparent' ? {\n            type: 'image/png'\n          } : {\n            type: 'image/png',\n            quality: 1.0\n          };\n          canvas.toBlob(function (blob) {\n            _this3.downloadFile(blob, \"shape-\".concat(dimensions.width, \"x\").concat(dimensions.height, \".png\"));\n            URL.revokeObjectURL(url);\n          }, exportOptions.type, exportOptions.quality);\n        };\n        img.src = url;\n      }\n    }\n\n    /**\n     * Download file helper\n     */\n  }, {\n    key: \"downloadFile\",\n    value: function downloadFile(blob, filename) {\n      var url = URL.createObjectURL(blob);\n      var a = document.createElement('a');\n      a.href = url;\n      a.download = filename;\n      document.body.appendChild(a);\n      a.click();\n      document.body.removeChild(a);\n      URL.revokeObjectURL(url);\n    }\n  }]);\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ShapeExporter);\n\n//# sourceURL=webpack://generative-shapes/./src/ShapeExporter.js?");

/***/ }),

/***/ "./src/ShapeGenerator.js":
/*!*******************************!*\
  !*** ./src/ShapeGenerator.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _randomPrompts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./randomPrompts.js */ \"./src/randomPrompts.js\");\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, \"catch\": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n// ShapeGenerator.js\n\n\nvar ShapeGenerator = /*#__PURE__*/function () {\n  function ShapeGenerator(controller) {\n    _classCallCheck(this, ShapeGenerator);\n    this.controller = controller;\n    this.isGenerating = false;\n    // this.proxyUrl = 'http://127.0.0.1:54321/functions/v1/claude'; // URL to your proxy server\n    // this.proxyUrl = 'https://avufsgjwbzjinyccruqc.supabase.co/functions/v1/claude';\n    this.proxyUrl = 'https://avufsgjwbzjinyccruqc.supabase.co/functions/v1/gemini';\n    this.currentGeneratedCode = null;\n    this.currentClassName = null;\n    this.currentDescription = null;\n\n    // Bind methods\n    this.showCreateModal = this.showCreateModal.bind(this);\n    this.generateShape = this.generateShape.bind(this);\n    // this.checkProxyStatus = this.checkProxyStatus.bind(this);\n    this.showShapePreview = this.showShapePreview.bind(this);\n    this.confirmShape = this.confirmShape.bind(this);\n    this.editShape = this.editShape.bind(this);\n    this.regenerateShape = this.regenerateShape.bind(this);\n    this.saveFormState = this.saveFormState.bind(this);\n    this.loadFormState = this.loadFormState.bind(this);\n    this.createImagePreview = this.createImagePreview.bind(this);\n    this.attachedImagesData = [];\n\n    // Check if the proxy server is available\n    this.proxyAvailable = true;\n    this.checkProxyStatus();\n  }\n\n  // async checkProxyStatus() {\n  //   try {\n  //     // Skip the status check and assume the function is available\n  //     console.log('Skipping proxy status check, assuming Claude function is available');\n  //     this.proxyAvailable = true;\n  //     this.hasApiKey = true;\n  //   } catch (error) {\n  //     console.error('Error checking proxy status:', error);\n  //     this.proxyAvailable = false;\n  //     this.hasApiKey = false;\n  //   }\n  // }\n  return _createClass(ShapeGenerator, [{\n    key: \"checkProxyStatus\",\n    value: function () {\n      var _checkProxyStatus = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              // For now, just assume the Gemini endpoint is available\n              console.log('Assuming Gemini function endpoint is available at:', this.proxyUrl);\n              this.proxyAvailable = true;\n              // No need for this.hasApiKey check related to Claude proxy\n            case 2:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function checkProxyStatus() {\n        return _checkProxyStatus.apply(this, arguments);\n      }\n      return checkProxyStatus;\n    }()\n  }, {\n    key: \"createImagePreview\",\n    value: function createImagePreview(base64Data, fileName) {\n      var _this = this;\n      // Find or create the image preview container\n      var imagePreviewContainer = document.getElementById('image-preview-container');\n      if (!imagePreviewContainer) {\n        // Create the container if it doesn't exist\n        imagePreviewContainer = document.createElement('div');\n        imagePreviewContainer.id = 'image-preview-container';\n        imagePreviewContainer.style.marginTop = '10px';\n        imagePreviewContainer.style.display = 'flex';\n        imagePreviewContainer.style.flexWrap = 'wrap';\n        imagePreviewContainer.style.gap = '10px';\n\n        // Insert after description input\n        var descriptionGroup = document.querySelector('.form-group');\n        if (descriptionGroup) {\n          descriptionGroup.appendChild(imagePreviewContainer);\n        }\n      }\n\n      // Create preview item container\n      var previewItem = document.createElement('div');\n      previewItem.style.position = 'relative';\n      previewItem.style.width = '64px';\n      previewItem.style.height = '64px';\n      previewItem.style.marginTop = '8px';\n      previewItem.style.marginRight = '8px';\n      previewItem.style.marginBottom = '8px';\n\n      // Create the preview image\n      var previewImage = document.createElement('img');\n      previewImage.src = base64Data;\n      previewImage.alt = fileName || 'Uploaded image';\n      previewImage.style.width = '100%';\n      previewImage.style.height = '100%';\n      previewImage.style.objectFit = 'cover';\n      previewImage.style.borderRadius = '4px';\n\n      // Add remove button\n      var removeButton = document.createElement('button');\n      removeButton.innerHTML = \"\\n        <svg width=\\\"14\\\" height=\\\"14\\\" viewBox=\\\"0 0 24 24\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n          <circle cx=\\\"12\\\" cy=\\\"12\\\" r=\\\"11\\\" fill=\\\"#DD3C3C\\\" stroke=\\\"none\\\" />\\n          <path d=\\\"M8 8L16 16M8 16L16 8\\\" stroke=\\\"white\\\" stroke-width=\\\"2\\\" stroke-linecap=\\\"round\\\"/>\\n        </svg>\\n      \";\n      removeButton.style.backgroundColor = 'transparent';\n      removeButton.style.border = 'none';\n      removeButton.style.padding = '0';\n      removeButton.style.width = '20px';\n      removeButton.style.height = '20px';\n      removeButton.style.display = 'flex';\n      removeButton.style.alignItems = 'center';\n      removeButton.style.justifyContent = 'center';\n      removeButton.style.cursor = 'pointer';\n      removeButton.style.position = 'absolute';\n      removeButton.style.top = '-8px';\n      removeButton.style.right = '-8px';\n      removeButton.style.opacity = '0';\n      removeButton.style.transition = 'opacity 0.2s';\n      removeButton.style.filter = 'drop-shadow(0px 0px 1px rgba(0,0,0,0.5))';\n      removeButton.title = 'Remove image';\n\n      // Show remove button on hover\n      previewItem.addEventListener('mouseover', function () {\n        removeButton.style.opacity = '1';\n      });\n      previewItem.addEventListener('mouseout', function () {\n        removeButton.style.opacity = '0';\n      });\n\n      // Remove button hover effect\n      removeButton.addEventListener('mouseover', function () {\n        removeButton.style.transform = 'scale(1.1)';\n      });\n      removeButton.addEventListener('mouseout', function () {\n        removeButton.style.transform = 'scale(1)';\n      });\n\n      // Handle image removal\n      removeButton.addEventListener('click', function () {\n        // Find the index of this image in the array\n        var index = _this.attachedImagesData.findIndex(function (img) {\n          return img.data === base64Data;\n        });\n        if (index !== -1) {\n          // Remove from array\n          _this.attachedImagesData.splice(index, 1);\n          // Remove visual element\n          previewItem.remove();\n          // Save form state after removal\n          _this.saveFormState();\n        }\n      });\n\n      // Assemble the preview item\n      previewItem.appendChild(previewImage);\n      previewItem.appendChild(removeButton);\n      imagePreviewContainer.appendChild(previewItem);\n    }\n\n    // 3. Implement saveFormState and loadFormState methods\n  }, {\n    key: \"saveFormState\",\n    value: function saveFormState() {\n      try {\n        var _document$getElementB;\n        var formState = {\n          description: ((_document$getElementB = document.getElementById('description-input')) === null || _document$getElementB === void 0 ? void 0 : _document$getElementB.value) || '',\n          images: this.attachedImagesData || [],\n          timestamp: Date.now()\n        };\n\n        // Save canvas sketch if it exists\n        var canvas = document.getElementById('sketch-canvas');\n        if (canvas) {\n          try {\n            formState.canvasData = canvas.toDataURL('image/png');\n          } catch (err) {\n            console.warn('Could not save canvas data:', err);\n          }\n        }\n\n        // Save to localStorage\n        localStorage.setItem('shapeGeneratorFormState', JSON.stringify(formState));\n        return true;\n      } catch (error) {\n        console.error('Error saving form state:', error);\n        return false;\n      }\n    }\n  }, {\n    key: \"loadFormState\",\n    value: function loadFormState() {\n      var _this2 = this;\n      try {\n        var savedState = localStorage.getItem('shapeGeneratorFormState');\n        if (!savedState) return false;\n        var formState = JSON.parse(savedState);\n\n        // Check if state is too old (more than 24 hours)\n        if (Date.now() - formState.timestamp > 24 * 60 * 60 * 1000) {\n          localStorage.removeItem('shapeGeneratorFormState');\n          return false;\n        }\n\n        // Restore description\n        var descriptionInput = document.getElementById('description-input');\n        if (descriptionInput && formState.description) {\n          descriptionInput.value = formState.description;\n        }\n\n        // Restore attached images\n        if (formState.images && Array.isArray(formState.images) && formState.images.length > 0) {\n          this.attachedImagesData = formState.images;\n\n          // Create previews for all images\n          formState.images.forEach(function (img) {\n            _this2.createImagePreview(img.data, img.name);\n          });\n        }\n\n        // Restore canvas only if there's actual content (not a blank canvas)\n        if (formState.canvasData && this.isNonEmptyCanvas(formState.canvasData)) {\n          // Only then create and open the sketch area\n          setTimeout(function () {\n            var sketchBtn = document.querySelector('.option-button:nth-child(2)');\n            if (sketchBtn && !document.getElementById('sketch-area-container')) {\n              sketchBtn.click(); // Open the sketch area\n            }\n\n            // Now load the canvas data\n            setTimeout(function () {\n              var canvas = document.getElementById('sketch-canvas');\n              if (canvas) {\n                var ctx = canvas.getContext('2d');\n                var img = new Image();\n                img.onload = function () {\n                  ctx.clearRect(0, 0, canvas.width, canvas.height);\n                  ctx.drawImage(img, 0, 0);\n                };\n                img.src = formState.canvasData;\n              }\n            }, 100);\n          }, 200);\n        }\n\n        // Return true without showing a notification\n        return true;\n      } catch (error) {\n        console.error('Error loading form state:', error);\n        return false;\n      }\n    }\n\n    // Helper to check if canvas data actually contains a drawing\n  }, {\n    key: \"isNonEmptyCanvas\",\n    value: function isNonEmptyCanvas(dataUrl) {\n      // Quick check - if it's not a data URL for some reason\n      if (!dataUrl || !dataUrl.startsWith('data:image/')) {\n        return false;\n      }\n      try {\n        // Create a temporary canvas to test the image data\n        var tempCanvas = document.createElement('canvas');\n        var tempCtx = tempCanvas.getContext('2d');\n        tempCanvas.width = 450; // Match original canvas dimensions\n        tempCanvas.height = 300;\n\n        // Draw the image to the temp canvas\n        var img = new Image();\n        img.src = dataUrl;\n\n        // We're checking synchronously - this won't actually draw the image\n        // but we can compare the data URL of a blank canvas to see if it's different\n        tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);\n        var blankDataUrl = tempCanvas.toDataURL('image/png');\n\n        // If the URLs are different lengths or the saved one is much larger,\n        // it likely contains actual drawing data\n        return dataUrl.length > blankDataUrl.length + 1000;\n      } catch (e) {\n        console.warn('Error checking canvas data:', e);\n        return false;\n      }\n    }\n\n    /**\n    * Show the create shape modal with improved UI\n    */\n  }, {\n    key: \"showCreateModal\",\n    value: function showCreateModal() {\n      var _this3 = this;\n      // Check if the proxy is available first\n      if (!this.proxyAvailable) {\n        alert('Supabase Edge Function is not available. Please make sure it is running at http://127.0.0.1:54321/functions/v1/claude');\n        return;\n      }\n\n      // Remove any existing modal\n      var existingModal = document.getElementById('create-shape-modal');\n      if (existingModal) {\n        existingModal.remove();\n      }\n\n      // Detect if we're on mobile\n      var isMobile = window.innerWidth <= 768 || 'ontouchstart' in window;\n\n      // Create modal container\n      var modal = document.createElement('div');\n      modal.id = 'create-shape-modal';\n      modal.className = 'modal';\n      modal.style.position = 'fixed';\n      modal.style.top = '0';\n      modal.style.left = '0';\n      modal.style.width = '100%';\n      modal.style.height = '100%';\n      modal.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';\n      modal.style.display = 'flex';\n      modal.style.justifyContent = 'center';\n      modal.style.alignItems = 'center';\n      modal.style.zIndex = '2000';\n      modal.style.backdropFilter = 'blur(5px)';\n\n      // Create modal content with scrolling capability\n      var modalContent = document.createElement('div');\n      modalContent.className = 'modal-content';\n      modalContent.style.backgroundColor = '#000';\n      modalContent.style.borderRadius = '8px';\n      modalContent.style.padding = '20px';\n      modalContent.style.width = '500px';\n      modalContent.style.maxWidth = '90%';\n      modalContent.style.color = '#e0e0e0';\n      modalContent.style.fontFamily = \"'Menlo', 'Monaco', 'Courier New', monospace\";\n      modalContent.style.boxShadow = '0 8px 24px rgba(0, 0, 0, 0.3)';\n\n      // Make the modal content scrollable for mobile\n      if (isMobile) {\n        modalContent.style.maxHeight = '80vh';\n        modalContent.style.overflowY = 'auto';\n        modalContent.style.overflowX = 'hidden';\n        modalContent.style.top = '80px';\n        modalContent.style.position = 'absolute';\n      }\n\n      // Create modal header\n      var modalHeader = document.createElement('div');\n      modalHeader.className = 'modal-header';\n      modalHeader.style.display = 'flex';\n      modalHeader.style.justifyContent = 'space-between';\n      modalHeader.style.alignItems = 'center';\n      modalHeader.style.marginBottom = '12px';\n      modalHeader.style.position = 'sticky';\n      modalHeader.style.top = '0';\n      modalHeader.style.backgroundColor = '#000';\n      modalHeader.style.zIndex = '10';\n      modalHeader.style.padding = '5px 0';\n\n      // Simplified header title\n      var modalTitle = document.createElement('h3');\n      modalTitle.textContent = 'New Shape';\n      modalTitle.style.margin = '0';\n      modalTitle.style.fontSize = '18px';\n      modalTitle.style.fontWeight = 'normal';\n      modalTitle.style.color = '#e0e0e0';\n      var closeButton = document.createElement('button');\n      closeButton.className = 'close-button';\n      closeButton.innerHTML = \"\\n    <svg width=\\\"14\\\" height=\\\"14\\\" viewBox=\\\"0 0 14 14\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n      <path d=\\\"M1 1L13 13M1 13L13 1\\\" stroke=\\\"#e0e0e0\\\" stroke-width=\\\"1.5\\\" stroke-linecap=\\\"round\\\"/>\\n    </svg>\\n  \";\n      closeButton.style.backgroundColor = 'transparent';\n      closeButton.style.border = 'none';\n      closeButton.style.cursor = 'pointer';\n      closeButton.style.padding = '4px';\n      closeButton.style.display = 'flex';\n      closeButton.style.alignItems = 'center';\n      closeButton.style.justifyContent = 'center';\n      closeButton.style.opacity = '0.7';\n      closeButton.style.transition = 'opacity 0.2s';\n      closeButton.onclick = function () {\n        return modal.remove();\n      };\n      closeButton.addEventListener('mouseover', function () {\n        closeButton.style.opacity = '1';\n      });\n      closeButton.addEventListener('mouseout', function () {\n        closeButton.style.opacity = '0.7';\n      });\n      modalHeader.appendChild(modalTitle);\n      modalHeader.appendChild(closeButton);\n\n      // Create form\n      var form = document.createElement('form');\n      form.onsubmit = function (e) {\n        e.preventDefault();\n        _this3.generateShape();\n      };\n\n      // Description input with improved placeholder and focus state\n      var descriptionGroup = document.createElement('div');\n      descriptionGroup.className = 'form-group';\n      descriptionGroup.style.marginBottom = '14px';\n      var descriptionInput = document.createElement('textarea');\n      descriptionInput.id = 'description-input';\n      descriptionInput.placeholder = 'Describe the shape you want';\n      descriptionInput.required = true;\n      descriptionInput.style.width = '100%';\n      descriptionInput.style.backgroundColor = '#111';\n      descriptionInput.style.color = '#e0e0e0';\n      descriptionInput.style.borderRadius = '8px';\n      descriptionInput.style.padding = '12px';\n      descriptionInput.style.fontFamily = \"'Menlo', 'Monaco', 'Courier New', monospace\";\n      descriptionInput.style.fontSize = '12px';\n      descriptionInput.style.minHeight = '100px';\n      descriptionInput.style.resize = 'none';\n      descriptionInput.style.border = 'none';\n      descriptionGroup.appendChild(descriptionInput);\n\n      // Save input changes\n      descriptionInput.addEventListener('input', function () {\n        _this3.saveFormState();\n      });\n\n      // Create container for all buttons (options and submit)\n      var optionsContainer = document.createElement('div');\n      optionsContainer.id = 'options-container';\n      optionsContainer.style.display = 'flex';\n      optionsContainer.style.gap = '10px';\n      optionsContainer.style.marginTop = '20px';\n      optionsContainer.style.justifyContent = 'space-between';\n      optionsContainer.style.alignItems = 'center';\n      optionsContainer.style.flexWrap = 'wrap';\n\n      // Create the three option buttons\n      var createOptionButton = function createOptionButton(icon, text, onClick) {\n        var button = document.createElement('button');\n        button.type = 'button';\n        button.className = 'option-button';\n        button.innerHTML = \"\".concat(icon, \" <span>\").concat(text, \"</span>\");\n        button.style.display = 'flex';\n        button.style.alignItems = 'center';\n        button.style.gap = '8px';\n        button.style.backgroundColor = '#000';\n        button.style.color = '#8E8E8E';\n        button.style.border = '1px solid #222';\n        button.style.borderRadius = '25px';\n        button.style.padding = '6px 12px';\n        button.style.cursor = 'pointer';\n        button.style.fontSize = '12px';\n        button.style.transition = 'background-color 0.2s';\n        button.style.whiteSpace = 'nowrap';\n        button.style.fontFamily = \"'Menlo', 'Monaco', 'Courier New', monospace\";\n        button.addEventListener('mouseover', function () {\n          button.style.backgroundColor = '#222';\n        });\n        button.addEventListener('mouseout', function () {\n          button.style.backgroundColor = '#000';\n        });\n        if (onClick) {\n          button.addEventListener('click', onClick);\n        }\n        return button;\n      };\n\n      // Image/SVG button with multi-image support\n      var imageSvgIcon = \"<svg width=\\\"16\\\" height=\\\"16\\\" viewBox=\\\"0 0 12 12\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n    <path d=\\\"M6.6 4.88235L3.75798 7.39002C3.32017 7.77632 3.32017 8.45897 3.75798 8.84527V8.84527C4.1248 9.16894 4.6752 9.16894 5.04202 8.84527L9.35071 5.04349C10.2263 4.27089 10.2263 2.90558 9.35071 2.13298V2.13298C8.61706 1.48564 7.51627 1.48564 6.78262 2.13298L2.47393 5.93477C1.16051 7.09367 1.16051 9.14163 2.47393 10.3005V10.3005C3.57441 11.2715 5.22559 11.2715 6.32607 10.3005L9.9 7.14706\\\" stroke=\\\"#09E49E\\\" stroke-linecap=\\\"round\\\"/>\\n  </svg>\";\n      var imageSvgButton = createOptionButton(imageSvgIcon, 'Image', function () {\n        // Create a hidden file input that accepts multiple files\n        var fileInput = document.createElement('input');\n        fileInput.type = 'file';\n        fileInput.accept = 'image/*';\n        fileInput.multiple = true; // Allow multiple file selection\n        fileInput.style.display = 'none';\n        document.body.appendChild(fileInput);\n\n        // Trigger the file input click\n        fileInput.click();\n\n        // Handle file selection\n        fileInput.addEventListener('change', /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(e) {\n            var files, validImagesCount, _loop, _i, _Array$from, _descriptionInput;\n            return _regeneratorRuntime().wrap(function _callee2$(_context3) {\n              while (1) switch (_context3.prev = _context3.next) {\n                case 0:\n                  files = e.target.files;\n                  if (!(files && files.length > 0)) {\n                    _context3.next = 11;\n                    break;\n                  }\n                  // Track if we have any valid images\n                  validImagesCount = 0; // Process each selected file\n                  _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {\n                    var file, isSvg, reader, imageData, resizedImageData;\n                    return _regeneratorRuntime().wrap(function _loop$(_context2) {\n                      while (1) switch (_context2.prev = _context2.next) {\n                        case 0:\n                          file = _Array$from[_i];\n                          isSvg = file.type === 'image/svg+xml';\n                          _context2.prev = 2;\n                          reader = new FileReader();\n                          _context2.next = 6;\n                          return new Promise(function (resolve, reject) {\n                            reader.onload = function (event) {\n                              return resolve(event.target.result);\n                            };\n                            reader.onerror = function (error) {\n                              return reject(error);\n                            };\n                            reader.readAsDataURL(file);\n                          });\n                        case 6:\n                          imageData = _context2.sent;\n                          _context2.next = 9;\n                          return _this3.resizeImageToBase64(imageData, file.type, file.name);\n                        case 9:\n                          resizedImageData = _context2.sent;\n                          // Store the resized image data\n                          _this3.attachedImagesData.push(resizedImageData);\n                          validImagesCount++;\n\n                          // Create preview for image\n                          _this3.createImagePreview(resizedImageData.data, file.name);\n                          _context2.next = 19;\n                          break;\n                        case 15:\n                          _context2.prev = 15;\n                          _context2.t0 = _context2[\"catch\"](2);\n                          console.error('Error processing image file:', _context2.t0);\n                          console.log(\"Error processing image: \".concat(_context2.t0.message), 'error');\n                        case 19:\n                        case \"end\":\n                          return _context2.stop();\n                      }\n                    }, _loop, null, [[2, 15]]);\n                  });\n                  _i = 0, _Array$from = Array.from(files);\n                case 5:\n                  if (!(_i < _Array$from.length)) {\n                    _context3.next = 10;\n                    break;\n                  }\n                  return _context3.delegateYield(_loop(), \"t0\", 7);\n                case 7:\n                  _i++;\n                  _context3.next = 5;\n                  break;\n                case 10:\n                  // Save form state after adding all images\n                  if (validImagesCount > 0) {\n                    _this3.saveFormState();\n\n                    // Update description with a reference to the images if it's empty\n                    _descriptionInput = document.getElementById('description-input');\n                    if (_descriptionInput && !_descriptionInput.value.trim()) {\n                      _descriptionInput.value = validImagesCount > 1 ? \"Create a shape based on the attached images.\" : \"Create a shape based on the attached image.\";\n\n                      // Save form state again after updating description\n                      _this3.saveFormState();\n                    }\n                  }\n                case 11:\n                  // Remove the file input from the DOM\n                  document.body.removeChild(fileInput);\n                case 12:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }, _callee2);\n          }));\n          return function (_x) {\n            return _ref.apply(this, arguments);\n          };\n        }());\n      });\n\n      // Sketch button\n      var sketchIcon = \"<svg width=\\\"16\\\" height=\\\"16\\\" viewBox=\\\"0 0 12 12\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n    <path d=\\\"M1 7.69726C2.90476 5.24644 7.25 0.966961 8.39286 2.22738C9.82143 3.8029 2.60714 8.10714 4 9.5C5.39286 10.8929 9.19726 5.69726 10 6.5C10.8027 7.30274 7.5 10 8 10.5C8.5 11 9.5 10.5 10.5 9.5\\\" stroke=\\\"#24B0F7\\\" stroke-linecap=\\\"round\\\"/>\\n  </svg>\";\n      var sketchButton = createOptionButton(sketchIcon, 'Sketch', function () {\n        // Check if the sketch area already exists\n        var existingSketchArea = document.getElementById('sketch-area-container');\n        if (existingSketchArea) {\n          existingSketchArea.style.display = existingSketchArea.style.display === 'none' ? 'block' : 'none';\n          return;\n        }\n\n        // Create sketch area container\n        var sketchAreaContainer = document.createElement('div');\n        sketchAreaContainer.id = 'sketch-area-container';\n        sketchAreaContainer.style.marginTop = '15px';\n        sketchAreaContainer.style.marginBottom = '15px';\n        sketchAreaContainer.style.backgroundColor = '#000';\n        sketchAreaContainer.style.borderRadius = '8px';\n        sketchAreaContainer.style.overflow = 'hidden';\n\n        // Create actual canvas for drawing\n        var canvas = document.createElement('canvas');\n        canvas.id = 'sketch-canvas';\n        canvas.width = 450;\n        canvas.height = 300;\n        canvas.style.width = '100%';\n        canvas.style.height = 'auto';\n        canvas.style.display = 'block';\n        canvas.style.backgroundColor = '#000';\n\n        // Add canvas to container\n        sketchAreaContainer.appendChild(canvas);\n\n        // Add canvas controls\n        var canvasControls = document.createElement('div');\n        canvasControls.style.display = 'flex';\n        canvasControls.style.justifyContent = 'space-between';\n        canvasControls.style.padding = '8px';\n        var brushSizeLabel = document.createElement('span');\n        brushSizeLabel.textContent = 'Brush Size:';\n        brushSizeLabel.style.color = '#aaa';\n        brushSizeLabel.style.marginRight = '16px';\n        brushSizeLabel.style.fontSize = '12px';\n        var brushSizeSlider = document.createElement('input');\n        brushSizeSlider.type = 'range';\n        brushSizeSlider.min = '1';\n        brushSizeSlider.max = '20';\n        brushSizeSlider.value = '5';\n        brushSizeSlider.style.width = '100px';\n        brushSizeSlider.style.accentColor = '#fff';\n        brushSizeSlider.style.opacity = '0.7';\n        brushSizeSlider.style.height = '2px';\n        brushSizeSlider.style.background = '#555';\n\n        // Clear button (fixed)\n        var clearButton = document.createElement('button');\n        clearButton.textContent = 'Clear';\n        clearButton.type = 'button'; // Prevent form submission\n        clearButton.style.backgroundColor = 'transparent';\n        clearButton.style.color = '#fff';\n        clearButton.style.fontFamily = \"'Menlo', 'Monaco', 'Courier New', monospace\";\n        clearButton.style.border = 'none';\n        clearButton.style.padding = '4px 8px';\n        clearButton.style.cursor = 'pointer';\n        clearButton.style.fontSize = '12px';\n\n        // Hover effect for clear button\n        clearButton.addEventListener('mouseover', function () {\n          clearButton.style.textDecoration = 'underline';\n          clearButton.style.color = '#F6326D';\n        });\n        clearButton.addEventListener('mouseout', function () {\n          clearButton.style.textDecoration = 'none';\n          clearButton.style.color = '#fff';\n        });\n\n        // Add controls to container\n        var brushSizeContainer = document.createElement('div');\n        brushSizeContainer.style.display = 'flex';\n        brushSizeContainer.style.alignItems = 'center';\n        brushSizeContainer.appendChild(brushSizeLabel);\n        brushSizeContainer.appendChild(brushSizeSlider);\n        canvasControls.appendChild(brushSizeContainer);\n        canvasControls.appendChild(clearButton);\n        sketchAreaContainer.appendChild(canvasControls);\n\n        // Insert the sketch area into the form after the description input\n        form.insertBefore(sketchAreaContainer, optionsContainer.nextSibling);\n\n        // Set up canvas drawing functionality\n        var ctx = canvas.getContext('2d');\n        var isDrawing = false;\n        var lastX = 0;\n        var lastY = 0;\n\n        // Set initial canvas state\n        ctx.strokeStyle = '#ffffff';\n        ctx.lineJoin = 'round';\n        ctx.lineCap = 'round';\n        ctx.lineWidth = brushSizeSlider.value;\n\n        // Drawing event handlers\n        canvas.addEventListener('mousedown', function (e) {\n          isDrawing = true;\n          lastX = e.offsetX * (canvas.width / canvas.clientWidth);\n          lastY = e.offsetY * (canvas.height / canvas.clientHeight);\n        });\n        canvas.addEventListener('mousemove', function (e) {\n          if (!isDrawing) return;\n          var currX = e.offsetX * (canvas.width / canvas.clientWidth);\n          var currY = e.offsetY * (canvas.height / canvas.clientHeight);\n          ctx.beginPath();\n          ctx.moveTo(lastX, lastY);\n          ctx.lineTo(currX, currY);\n          ctx.stroke();\n          // Save canvas state after drawing\n          lastX = currX;\n          lastY = currY;\n          _this3.saveFormState();\n        });\n        canvas.addEventListener('mouseup', function () {\n          isDrawing = false;\n          _this3.saveFormState();\n        });\n        canvas.addEventListener('mouseout', function () {\n          isDrawing = false;\n          _this3.saveFormState();\n        });\n\n        // Touch support for mobile\n        canvas.addEventListener('touchstart', function (e) {\n          e.preventDefault();\n          var touch = e.touches[0];\n          var rect = canvas.getBoundingClientRect();\n          var touchX = (touch.clientX - rect.left) * (canvas.width / canvas.clientWidth);\n          var touchY = (touch.clientY - rect.top) * (canvas.height / canvas.clientHeight);\n          lastX = touchX;\n          lastY = touchY;\n          isDrawing = true;\n        });\n        canvas.addEventListener('touchmove', function (e) {\n          e.preventDefault();\n          if (!isDrawing) return;\n          var touch = e.touches[0];\n          var rect = canvas.getBoundingClientRect();\n          var touchX = (touch.clientX - rect.left) * (canvas.width / canvas.clientWidth);\n          var touchY = (touch.clientY - rect.top) * (canvas.height / canvas.clientHeight);\n          ctx.beginPath();\n          ctx.moveTo(lastX, lastY);\n          ctx.lineTo(touchX, touchY);\n          ctx.stroke();\n          // Save canvas state after drawing\n          lastX = touchX;\n          lastY = touchY;\n          _this3.saveFormState();\n        });\n        canvas.addEventListener('touchend', function (e) {\n          e.preventDefault();\n          isDrawing = false;\n          _this3.saveFormState();\n        });\n        brushSizeSlider.addEventListener('input', function () {\n          ctx.lineWidth = brushSizeSlider.value;\n        });\n\n        // Fixed Clear button - prevent form submission\n        clearButton.addEventListener('click', function (e) {\n          e.preventDefault(); // Prevent default action\n          e.stopPropagation(); // Stop event propagation\n          ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n          // Save the cleared canvas state\n          _this3.saveFormState();\n        });\n      });\n\n      // Surprise me button\n      var surpriseIcon = \"<svg width=\\\"16\\\" height=\\\"16\\\" viewBox=\\\"0 0 12 12\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n      <path d=\\\"M2.78135 0.760342C2.6847 0.499157 2.31528 0.499157 2.21863 0.760342L1.87264 1.69539C1.84225 1.77751 1.77751 1.84225 1.69539 1.87264L0.760342 2.21863C0.499157 2.31528 0.499157 2.6847 0.760342 2.78135L1.69539 3.12735C1.77751 3.15773 1.84225 3.22247 1.87264 3.30459L2.21863 4.23964C2.31528 4.50082 2.6847 4.50082 2.78135 4.23964L3.12735 3.30459C3.15773 3.22247 3.22247 3.15773 3.30459 3.12735L4.23964 2.78135C4.50082 2.6847 4.50082 2.31528 4.23964 2.21863L3.30459 1.87264C3.22247 1.84225 3.15773 1.77751 3.12735 1.69539L2.78135 0.760342Z\\\" fill=\\\"#EEBC26\\\"/>\\n      <path d=\\\"M6.96892 2.26724C6.80784 1.83193 6.19214 1.83193 6.03106 2.26724L5.09428 4.79887C5.04363 4.93573 4.93573 5.04363 4.79887 5.09428L2.26724 6.03106C1.83193 6.19214 1.83193 6.80784 2.26724 6.96892L4.79887 7.9057C4.93573 7.95635 5.04363 8.06425 5.09428 8.20111L6.03106 10.7327C6.19214 11.168 6.80784 11.168 6.96892 10.7327L7.9057 8.20111C7.95635 8.06425 8.06425 7.95635 8.20111 7.9057L10.7327 6.96892C11.168 6.80784 11.168 6.19214 10.7327 6.03106L8.20111 5.09428C8.06425 5.04363 7.95635 4.93573 7.9057 4.79887L6.96892 2.26724Z\\\" fill=\\\"#EEBC26\\\"/>\\n  </svg>\";\n      var surpriseButton = createOptionButton(surpriseIcon, 'Random', /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var randomPrompts, randomPrompt;\n        return _regeneratorRuntime().wrap(function _callee3$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              // Disable button during API call\n              surpriseButton.disabled = true;\n              surpriseButton.style.opacity = '0.5';\n              surpriseButton.style.cursor = 'not-allowed';\n              try {\n                // Generate random prompts - would connect to API but we're using a simple set for now\n                randomPrompts = _randomPrompts_js__WEBPACK_IMPORTED_MODULE_0__.generativeShapePrompts; // Pick a random prompt\n                randomPrompt = randomPrompts[Math.floor(Math.random() * randomPrompts.length)]; // Set the prompt in the input field\n                descriptionInput.value = randomPrompt;\n                descriptionInput.focus();\n\n                // Save form state with the new prompt\n                _this3.saveFormState();\n\n                // Add some animation to show the change\n                descriptionInput.style.transition = 'background-color 0.3s ease';\n                descriptionInput.style.backgroundColor = '#222';\n                setTimeout(function () {\n                  descriptionInput.style.backgroundColor = '#111';\n                }, 300);\n              } catch (error) {\n                console.error('Error generating random prompt:', error);\n                alert('Failed to generate a random prompt. Please try again.');\n              } finally {\n                // Re-enable button\n                surpriseButton.disabled = false;\n                surpriseButton.style.opacity = '1';\n                surpriseButton.style.cursor = 'pointer';\n              }\n            case 4:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee3);\n      })));\n\n      // Style the buttons to match the design more closely\n      [imageSvgButton, sketchButton, surpriseButton].forEach(function (button) {\n        // Make buttons more pill-shaped with darker background like in the screenshot\n        button.style.backgroundColor = '#000';\n        button.style.borderRadius = '30px'; // More rounded\n        button.style.padding = '6px 12px'; // Slightly more padding\n        button.style.minWidth = 'fit-content'; // Ensure buttons fit their content\n      });\n\n      // Create a container for the option buttons (positioned left)\n      var leftButtonsContainer = document.createElement('div');\n      leftButtonsContainer.style.display = 'flex';\n      leftButtonsContainer.style.gap = '10px';\n      leftButtonsContainer.style.flexWrap = 'wrap';\n      leftButtonsContainer.style.margin = '10px 0';\n\n      // Add option buttons to the left container\n      leftButtonsContainer.appendChild(imageSvgButton);\n      leftButtonsContainer.appendChild(sketchButton);\n      leftButtonsContainer.appendChild(surpriseButton);\n\n      // Add the left container to the main options container\n      optionsContainer.appendChild(leftButtonsContainer);\n\n      // Progress bar (initially hidden)\n      var progressContainer = document.createElement('div');\n      progressContainer.id = 'progress-container';\n      progressContainer.style.marginTop = '14px';\n      progressContainer.style.display = 'none';\n      var progressLabel = document.createElement('div');\n      progressLabel.textContent = 'Generating shape...';\n      progressLabel.style.fontSize = '12px';\n      progressLabel.style.color = '#999';\n      progressLabel.style.marginBottom = '6px';\n      var progressBarOuter = document.createElement('div');\n      progressBarOuter.style.width = '100%';\n      progressBarOuter.style.height = '4px'; // Made thinner\n      progressBarOuter.style.backgroundColor = '#222';\n      progressBarOuter.style.borderRadius = '2px';\n      progressBarOuter.style.overflow = 'hidden';\n      var progressBarInner = document.createElement('div');\n      progressBarInner.id = 'progress-bar';\n      progressBarInner.style.width = '0%';\n      progressBarInner.style.height = '100%';\n      progressBarInner.style.backgroundColor = '#fff';\n      progressBarInner.style.borderRadius = '2px';\n      progressBarInner.style.transition = 'width 0.5s ease';\n      progressBarOuter.appendChild(progressBarInner);\n      progressContainer.appendChild(progressLabel);\n      progressContainer.appendChild(progressBarOuter);\n      var errorMessageContainer = document.createElement('div');\n      errorMessageContainer.id = 'generation-error-message'; // The ID must match\n      errorMessageContainer.style.display = 'none'; // Start hidden\n      // Add other styling as needed (colors, padding, etc.)\n      errorMessageContainer.style.color = '#FF5555';\n      errorMessageContainer.style.padding = '8px 12px';\n      errorMessageContainer.style.marginTop = '12px';\n      errorMessageContainer.style.backgroundColor = 'rgba(255, 85, 85, 0.1)';\n      errorMessageContainer.style.borderRadius = '4px';\n      errorMessageContainer.style.fontSize = '12px';\n      errorMessageContainer.style.wordBreak = 'break-word';\n\n      // Submit button with arrow icon\n      var submitButton = document.createElement('button');\n      submitButton.id = 'generate-button';\n      submitButton.type = 'submit';\n      submitButton.innerHTML = \"<svg width=\\\"35\\\" height=\\\"35\\\" viewBox=\\\"0 0 35 35\\\" fill=\\\"none\\\" stroke=\\\"currentColor\\\" stroke-width=\\\"2\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\">\\n    <path d=\\\"M9 17.5h17M17.5 9l8.5 8.5-8.5 8.5\\\"></path>\\n  </svg>\";\n      submitButton.style.backgroundColor = '#fff';\n      submitButton.style.color = '#000';\n      submitButton.style.border = 'none';\n      submitButton.style.borderRadius = '50%';\n      submitButton.style.width = '32px';\n      submitButton.style.height = '32px';\n      submitButton.style.minWidth = '32px';\n      submitButton.style.minHeight = '32px';\n      submitButton.style.padding = '0';\n      submitButton.style.overflow = 'hidden';\n      submitButton.style.cursor = 'pointer';\n      submitButton.style.position = 'relative';\n      submitButton.style.display = 'flex';\n      submitButton.style.alignItems = 'center';\n      submitButton.style.justifyContent = 'center';\n      submitButton.addEventListener('mouseover', function () {\n        submitButton.style.transform = 'scale(1.05)';\n      });\n      submitButton.addEventListener('mouseout', function () {\n        submitButton.style.transform = 'scale(1)';\n      });\n      optionsContainer.appendChild(submitButton);\n\n      // Assemble form\n      form.appendChild(descriptionGroup);\n      form.appendChild(progressContainer);\n      form.appendChild(errorMessageContainer);\n      form.appendChild(optionsContainer);\n\n      // Assemble modal\n      modalContent.appendChild(modalHeader);\n      modalContent.appendChild(form);\n      modal.appendChild(modalContent);\n\n      // Add modal to document\n      document.body.appendChild(modal);\n\n      // Focus on description input\n      descriptionInput.focus();\n\n      // Add Escape key handler\n      var _handleEscape = function handleEscape(e) {\n        if (e.key === 'Escape') {\n          // Save form state before closing\n          _this3.saveFormState();\n          modal.remove();\n          // Clean up mobile elements if they exist\n          if (isMobile && document.getElementById('mobile-submit-bar')) {\n            document.getElementById('mobile-submit-bar').remove();\n          }\n          document.removeEventListener('keydown', _handleEscape);\n          e.stopPropagation();\n        }\n      };\n      document.addEventListener('keydown', _handleEscape);\n\n      // Add keydown handler for Ctrl+S to save shape\n      document.addEventListener('keydown', function (e) {\n        if ((e.ctrlKey || e.metaKey) && e.key === 's') {\n          e.preventDefault();\n          _this3.saveFormState();\n\n          // Show save confirmation\n          var notification = document.createElement('div');\n          notification.textContent = 'Work saved';\n          notification.style.position = 'absolute';\n          notification.style.bottom = '20px';\n          notification.style.left = '50%';\n          notification.style.transform = 'translateX(-50%)';\n          notification.style.backgroundColor = 'rgba(76, 175, 80, 0.8)';\n          notification.style.color = 'white';\n          notification.style.padding = '8px 16px';\n          notification.style.borderRadius = '4px';\n          notification.style.fontSize = '14px';\n          notification.style.zIndex = '2001';\n          document.body.appendChild(notification);\n\n          // Remove notification after a few seconds\n          setTimeout(function () {\n            notification.style.opacity = '0';\n            notification.style.transition = 'opacity 0.5s ease';\n            setTimeout(function () {\n              return notification.remove();\n            }, 500);\n          }, 2000);\n        }\n      });\n\n      // Add keyboard navigation for tab key\n      form.addEventListener('keydown', function (e) {\n        if (e.key === 'Tab') {\n          // Handle tab navigation within the modal\n          var focusable = form.querySelectorAll('button, textarea, input');\n          var firstFocusable = focusable[0];\n          var lastFocusable = focusable[focusable.length - 1];\n          if (e.shiftKey && document.activeElement === firstFocusable) {\n            lastFocusable.focus();\n            e.preventDefault();\n          } else if (!e.shiftKey && document.activeElement === lastFocusable) {\n            firstFocusable.focus();\n            e.preventDefault();\n          }\n        }\n      });\n\n      // Add beforeunload event to warn about closing with unsaved changes\n      var beforeUnloadHandler = function beforeUnloadHandler(e) {\n        if (descriptionInput.value.trim() !== '' || _this3.attachedImagesData.length > 0) {\n          // Save state one final time\n          _this3.saveFormState();\n\n          // Show warning\n          e.preventDefault();\n          e.returnValue = 'You have unsaved changes. Are you sure you want to leave?';\n          return e.returnValue;\n        }\n      };\n      window.addEventListener('beforeunload', beforeUnloadHandler);\n\n      // Remove handler when modal is closed\n      closeButton.onclick = function () {\n        window.removeEventListener('beforeunload', beforeUnloadHandler);\n        // Save form state before closing\n        _this3.saveFormState();\n        // Clean up mobile elements if they exist\n        if (isMobile && document.getElementById('mobile-submit-bar')) {\n          document.getElementById('mobile-submit-bar').remove();\n        }\n        modal.remove();\n      };\n\n      // After modal creation, try to load saved state\n      setTimeout(function () {\n        var stateLoaded = _this3.loadFormState();\n        if (stateLoaded) {\n          console.log('Your previous work has been restored');\n        }\n      }, 200);\n    }\n\n    /**\n    * Check if canvas has drawing content (not empty)\n    * @param {HTMLCanvasElement} canvas - The canvas to check\n    * @returns {boolean} - True if canvas has visible content\n    */\n  }, {\n    key: \"hasCanvasContent\",\n    value: function hasCanvasContent(canvas) {\n      var ctx = canvas.getContext('2d');\n      var pixelData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;\n\n      // Check if any pixel is non-transparent (alpha > 0)\n      for (var i = 3; i < pixelData.length; i += 4) {\n        if (pixelData[i] > 0) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    /**\n     * Prepare sketch data for API request\n     * @returns {Promise<boolean>} - True if sketch was added\n     */\n  }, {\n    key: \"prepareSketchData\",\n    value: (function () {\n      var _prepareSketchData = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var canvas, sketchDataUrl, resizedSketch;\n        return _regeneratorRuntime().wrap(function _callee4$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              canvas = document.getElementById('sketch-canvas');\n              if (canvas) {\n                _context5.next = 3;\n                break;\n              }\n              return _context5.abrupt(\"return\", false);\n            case 3:\n              if (this.hasCanvasContent(canvas)) {\n                _context5.next = 5;\n                break;\n              }\n              return _context5.abrupt(\"return\", false);\n            case 5:\n              _context5.prev = 5;\n              // Convert canvas to base64 data URL\n              sketchDataUrl = canvas.toDataURL('image/png'); // Resize to 256x256 for API\n              _context5.next = 9;\n              return this.resizeImageToBase64(sketchDataUrl, 'image/png', 'user-sketch.png');\n            case 9:\n              resizedSketch = _context5.sent;\n              // Add to attached images\n              this.attachedImagesData.push(resizedSketch);\n\n              // Show toast notification\n              console.log('Sketch attached!');\n              return _context5.abrupt(\"return\", true);\n            case 15:\n              _context5.prev = 15;\n              _context5.t0 = _context5[\"catch\"](5);\n              console.error('Error preparing sketch data:', _context5.t0);\n              return _context5.abrupt(\"return\", false);\n            case 19:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee4, this, [[5, 15]]);\n      }));\n      function prepareSketchData() {\n        return _prepareSketchData.apply(this, arguments);\n      }\n      return prepareSketchData;\n    }()\n    /**\n     * Create a form group with label\n     */\n    )\n  }, {\n    key: \"createFormGroup\",\n    value: function createFormGroup(label) {\n      var group = document.createElement('div');\n      group.className = 'form-group';\n      group.style.marginBottom = '16px';\n      return group;\n    }\n\n    /**\n     * Generate shape using Claude API via proxy\n     */\n    /**\n    * Generate shape using Claude API via proxy\n    */\n    // async generateShape() {\n    //   if (this.isGenerating) return;\n\n    //   // Get form values\n    //   const descriptionInput = document.getElementById('description-input');\n    //   const generateButton = document.getElementById('generate-button');\n    //   const progressContainer = document.getElementById('progress-container');\n    //   const progressBar = document.getElementById('progress-bar');\n\n    //   const errorMessageContainer = document.getElementById('generation-error-message');\n\n    //   if (!descriptionInput || !generateButton) {\n    //     alert('Form elements not found');\n    //     return;\n    //   }\n\n    //   const description = descriptionInput.value.trim();\n\n    //   if (!description) {\n    //     alert('Please enter a shape description');\n    //     descriptionInput.focus();\n    //     return;\n    //   }\n\n    //   // Store description for possible regeneration\n    //   this.currentDescription = description;\n\n    //   let progressInterval;\n\n    //   try {\n    //     // Update UI to show progress\n    //     this.isGenerating = true;\n\n    //     // Disable the generate button and change its appearance\n    //     generateButton.disabled = true;\n    //     generateButton.style.backgroundColor = '#444';\n    //     generateButton.style.cursor = 'not-allowed';\n    //     generateButton.style.opacity = '0.5';\n\n    //     // Show progress indicator\n    //     progressContainer.style.display = 'block';\n\n    //     // Simulate progress updates\n    //     let progress = 0;\n    //     const progressInterval = setInterval(() => {\n    //       progress += 5;\n    //       if (progress > 95) {\n    //         progress = 95; // Max out at 95% until complete\n    //       }\n    //       progressBar.style.width = `${progress}%`;\n    //     }, 500);\n\n    //     // Check for sketch and add it to attached images if present\n    //     await this.prepareSketchData();\n\n    //     // Prepare the request body with the images\n    //     const requestBody = {\n    //       model: 'claude-3-7-sonnet-20250219',\n    //       max_tokens: 4000,\n    //       temperature: 1.0,\n    //       messages: [\n    //         {\n    //           role: 'user',\n    //           content: []\n    //         }\n    //       ]\n    //     };\n\n    //     // Add text content first\n    //     requestBody.messages[0].content.push({\n    //       type: 'text',\n    //       text: description\n    //     });\n\n    //     // Add any attached images to the content array\n    //     if (this.attachedImagesData && this.attachedImagesData.length > 0) {\n    //       for (const imageData of this.attachedImagesData) {\n    //         // Add each image as a media object\n    //         // Extract just the base64 data part (remove data URL prefix)\n    //         const base64Data = imageData.data.split(',')[1];\n\n    //         requestBody.messages[0].content.push({\n    //           type: 'image',\n    //           source: {\n    //             type: 'base64',\n    //             media_type: imageData.type,\n    //             data: base64Data\n    //           }\n    //         });\n    //       }\n    //     }\n\n    //     // Make the API request through the proxy\n    //     // const response = await fetch(this.proxyUrl, {\n    //     //   method: 'POST',\n    //     //   headers: {\n    //     //     'Content-Type': 'application/json'\n    //     //   },\n    //     //   body: JSON.stringify(requestBody)\n    //     // });\n\n    //     const supabaseAnonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImF2dWZzZ2p3YnpqaW55Y2NydXFjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDE3NjYwMzgsImV4cCI6MjA1NzM0MjAzOH0.0tRCOWd1HByLbpw6q2ov4ipUOjByte2vmH-Wjpke0_A';\n\n    //     console.log(\"Sending request to:\", this.proxyUrl);\n\n    //     // Make the API request through the proxy\n    //     const response = await fetch(this.proxyUrl, {\n    //       method: 'POST',\n    //       headers: {\n    //         'Content-Type': 'application/json',\n    //         'Authorization': `Bearer ${supabaseAnonKey}`\n    //       },\n    //       body: JSON.stringify(requestBody)\n    //     });\n\n    //     // Clear the progress interval\n    //     clearInterval(progressInterval);\n\n    //     if (!response.ok) {\n    //       const errorData = await response.json();\n    //       throw new Error(`API error: ${errorData.error?.message || response.statusText}`);\n    //     }\n\n    //     const data = await response.json();\n    //     console.log(\"API Response Data:\", JSON.stringify(data, null, 2));\n\n    //     // Extract code based on response format\n    //     let generatedCode;\n\n    //     // Handle different possible response formats\n    //     if (data.content && Array.isArray(data.content) && data.content[0]?.text) {\n    //       // Format from dummy response\n    //       generatedCode = data.content[0].text;\n    //       console.log(\"Extracted code from 'content[0].text' format\");\n    //     } else if (data.content && Array.isArray(data.content) && data.content[0]?.type === \"text\") {\n    //       // Another possible format\n    //       generatedCode = data.content[0].text;\n    //       console.log(\"Extracted code from 'content[0].type=text' format\");\n    //     } else if (typeof data === 'string') {\n    //       // Direct string response\n    //       generatedCode = data;\n    //       console.log(\"Extracted code from direct string response\");\n    //     } else {\n    //       console.error(\"Unexpected API response format:\", data);\n    //       throw new Error(\"Unexpected API response format. Could not extract code.\");\n    //     }\n\n    //     // Set progress to 100%\n    //     progressBar.style.width = '100%';\n\n    //     // Process the generated code and show a preview instead of immediately injecting\n    //     this.processAndPreviewShapeClass(generatedCode, description);\n\n    //     // Clear attachedImagesData after successful generation to prevent reusing in regeneration\n    //     this.attachedImagesData = [];\n\n    //   } catch (error) {\n    //     console.error('Error generating shape:', error);\n\n    //     // Show error message\n    //     const modal = document.getElementById('create-shape-modal');\n    //     if (modal) {\n    //       const errorMessage = document.createElement('div');\n    //       errorMessage.textContent = `Error: ${error.message}`;\n    //       errorMessage.style.color = '#FF5555';\n    //       errorMessage.style.padding = '12px';\n    //       errorMessage.style.marginTop = '12px';\n    //       errorMessage.style.backgroundColor = 'rgba(255, 85, 85, 0.1)';\n    //       errorMessage.style.borderRadius = '4px';\n    //       errorMessage.style.fontSize = '12px';\n\n    //       // Find and insert before the button group\n    //       const buttonGroup = modal.querySelector('form > div:last-child');\n    //       if (buttonGroup) {\n    //         buttonGroup.parentNode.insertBefore(errorMessage, buttonGroup);\n    //       }\n    //     }\n\n    //     // Reset UI\n    //     generateButton.disabled = false;\n    //     generateButton.style.backgroundColor = '#222';\n    //     this.isGenerating = false;\n\n    //     // Clear progress interval just in case\n    //     if (progressInterval) {\n    //       clearInterval(progressInterval);\n    //     }\n    //   }\n    // }\n\n    /**\n     * Generate shape using the Gemini API via Supabase proxy\n     */\n  }, {\n    key: \"generateShape\",\n    value: (function () {\n      var _generateShape = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var descriptionInput, generateButton, progressContainer, progressBar, errorMessageContainer, description, progressInterval, _data$content, _data$candidates, progress, requestBody, supabaseAnonKey, response, _errorData$error, errorData, data, generatedCode, _data$error, backendError, codeMatch;\n        return _regeneratorRuntime().wrap(function _callee5$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              if (!this.isGenerating) {\n                _context6.next = 2;\n                break;\n              }\n              return _context6.abrupt(\"return\");\n            case 2:\n              // --- Get UI Elements ---\n              descriptionInput = document.getElementById('description-input');\n              generateButton = document.getElementById('generate-button');\n              progressContainer = document.getElementById('progress-container');\n              progressBar = document.getElementById('progress-bar');\n              errorMessageContainer = document.getElementById('generation-error-message'); // Check if all elements are found\n              if (!(!descriptionInput || !generateButton || !progressContainer || !progressBar || !errorMessageContainer)) {\n                _context6.next = 11;\n                break;\n              }\n              console.error('Required UI elements not found in generateShape');\n              // Show error safely\n              if (errorMessageContainer) {\n                errorMessageContainer.textContent = 'Internal UI Error: Could not find required elements.';\n                errorMessageContainer.style.display = 'block';\n              } else {\n                alert('Internal UI Error. Please close and reopen the modal.');\n              }\n              return _context6.abrupt(\"return\");\n            case 11:\n              description = descriptionInput.value.trim();\n              if (description) {\n                _context6.next = 16;\n                break;\n              }\n              alert('Please enter a shape description');\n              descriptionInput.focus();\n              return _context6.abrupt(\"return\");\n            case 16:\n              // Clear previous errors\n              errorMessageContainer.textContent = '';\n              errorMessageContainer.style.display = 'none';\n              this.currentDescription = description;\n              progressInterval = null;\n              _context6.prev = 20;\n              // --- Start UI Update ---\n              this.isGenerating = true;\n              generateButton.disabled = true;\n              generateButton.classList.add('disabled'); // Use CSS class instead of inline styles\n              progressContainer.style.display = 'block';\n              progressBar.style.width = '0%';\n\n              // --- Progress Simulation ---\n              progress = 0;\n              progressInterval = setInterval(function () {\n                progress += 5;\n                if (progress >= 95) {\n                  clearInterval(progressInterval);\n                  progressInterval = null;\n                  progress = 95;\n                }\n                progressBar.style.width = \"\".concat(progress, \"%\");\n              }, 300);\n\n              // --- Prepare Request Body for GEMINI function ---\n              requestBody = {\n                prompt: description,\n                options: {\n                  temperature: 1.0,\n                  // Slightly lower temperature for more consistent shapes\n                  max_tokens: 16000 // Explicitly set max tokens\n                }\n              };\n              console.log(\"Request Body:\", JSON.stringify(requestBody, null, 2));\n\n              // --- Make API Request ---\n              supabaseAnonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImF2dWZzZ2p3YnpqaW55Y2NydXFjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDE3NjYwMzgsImV4cCI6MjA1NzM0MjAzOH0.0tRCOWd1HByLbpw6q2ov4ipUOjByte2vmH-Wjpke0_A';\n              if (!(!supabaseAnonKey || supabaseAnonKey.length < 50)) {\n                _context6.next = 34;\n                break;\n              }\n              console.error(\"CRITICAL: Invalid Supabase Anon Key\");\n              throw new Error(\"Configuration error: Invalid API key\");\n            case 34:\n              console.log(\"Sending request to: \".concat(this.proxyUrl));\n              _context6.next = 37;\n              return fetch(this.proxyUrl, {\n                method: 'POST',\n                headers: {\n                  'Content-Type': 'application/json',\n                  'Authorization': \"Bearer \".concat(supabaseAnonKey),\n                  'apikey': supabaseAnonKey // Required by Supabase\n                },\n                body: JSON.stringify(requestBody)\n              });\n            case 37:\n              response = _context6.sent;\n              if (progressInterval) {\n                clearInterval(progressInterval);\n                progressInterval = null;\n              }\n              if (response.ok) {\n                _context6.next = 52;\n                break;\n              }\n              errorData = {\n                error: {\n                  message: \"HTTP error \".concat(response.status)\n                }\n              };\n              _context6.prev = 41;\n              _context6.next = 44;\n              return response.json();\n            case 44:\n              errorData = _context6.sent;\n              _context6.next = 50;\n              break;\n            case 47:\n              _context6.prev = 47;\n              _context6.t0 = _context6[\"catch\"](41);\n              errorData.error.message = \"\".concat(response.status, \" \").concat(response.statusText);\n            case 50:\n              console.error(\"API Error Response:\", errorData);\n              throw new Error(((_errorData$error = errorData.error) === null || _errorData$error === void 0 ? void 0 : _errorData$error.message) || \"API request failed: \".concat(response.status));\n            case 52:\n              _context6.next = 54;\n              return response.json();\n            case 54:\n              data = _context6.sent;\n              console.log(\"API Response Data:\", JSON.stringify(data, null, 2));\n              progressBar.style.width = '100%';\n\n              // --- Extract Generated Code (Robust Handling for Gemini Function Response) ---\n              if (!(data !== null && data !== void 0 && (_data$content = data.content) !== null && _data$content !== void 0 && (_data$content = _data$content[0]) !== null && _data$content !== void 0 && _data$content.text)) {\n                _context6.next = 62;\n                break;\n              }\n              generatedCode = data.content[0].text;\n              console.log(\"Extracted code from 'content[0].text' format\");\n              _context6.next = 80;\n              break;\n            case 62:\n              if (!(data !== null && data !== void 0 && data.text)) {\n                _context6.next = 67;\n                break;\n              }\n              generatedCode = data.text;\n              console.log(\"Extracted code from 'text' property\");\n              _context6.next = 80;\n              break;\n            case 67:\n              if (!(typeof data === 'string' && (data.includes('class') || data.trim().startsWith('import')))) {\n                _context6.next = 72;\n                break;\n              }\n              generatedCode = data;\n              console.log(\"Extracted code from direct string response\");\n              _context6.next = 80;\n              break;\n            case 72:\n              if (!(data !== null && data !== void 0 && (_data$candidates = data.candidates) !== null && _data$candidates !== void 0 && (_data$candidates = _data$candidates[0]) !== null && _data$candidates !== void 0 && (_data$candidates = _data$candidates.content) !== null && _data$candidates !== void 0 && (_data$candidates = _data$candidates.parts) !== null && _data$candidates !== void 0 && (_data$candidates = _data$candidates[0]) !== null && _data$candidates !== void 0 && _data$candidates.text)) {\n                _context6.next = 77;\n                break;\n              }\n              generatedCode = data.candidates[0].content.parts[0].text;\n              console.log(\"Extracted code from Gemini 'candidates' format\");\n              _context6.next = 80;\n              break;\n            case 77:\n              console.error(\"Unexpected API response format:\", data);\n              backendError = (data === null || data === void 0 || (_data$error = data.error) === null || _data$error === void 0 ? void 0 : _data$error.message) || JSON.stringify(data).substring(0, 100) + \"...\";\n              throw new Error(\"Unexpected response format. Could not extract code: \".concat(backendError));\n            case 80:\n              // Extract code from markdown if needed\n              if (generatedCode.includes(\"```\")) {\n                codeMatch = generatedCode.match(/```(?:javascript|js)?\\s*([\\s\\S]+?)```/);\n                if (codeMatch && codeMatch[1]) {\n                  generatedCode = codeMatch[1].trim();\n                  console.log(\"Extracted code from markdown code block\");\n                }\n              }\n\n              // Basic code validation\n              if (!(!generatedCode || typeof generatedCode !== 'string' || generatedCode.length < 50)) {\n                _context6.next = 84;\n                break;\n              }\n              console.error(\"Generated code seems invalid or empty:\", generatedCode);\n              throw new Error(\"Received invalid or empty code from the API.\");\n            case 84:\n              if (!(!generatedCode.includes(\"extends Shape\") || !generatedCode.includes(\"generateShape\"))) {\n                _context6.next = 87;\n                break;\n              }\n              console.error(\"Generated code doesn't appear to be a valid Shape class:\", generatedCode.substring(0, 100));\n              throw new Error(\"The generated code doesn't appear to be a valid Shape class.\");\n            case 87:\n              setTimeout(function () {\n                progressContainer.style.display = 'none';\n                progressBar.style.width = '0%';\n              }, 500);\n\n              // Process and show preview\n              this.processAndPreviewShapeClass(generatedCode, description);\n\n              // Clear image data after successful generation\n              this.attachedImagesData = [];\n              _context6.next = 100;\n              break;\n            case 92:\n              _context6.prev = 92;\n              _context6.t1 = _context6[\"catch\"](20);\n              console.error('Error generating shape:', _context6.t1);\n              if (progressInterval) {\n                clearInterval(progressInterval);\n                progressInterval = null;\n              }\n\n              // Show error message\n              errorMessageContainer.textContent = \"Error: \".concat(_context6.t1.message);\n              errorMessageContainer.style.display = 'block';\n              progressContainer.style.display = 'none';\n              progressBar.style.width = '0%';\n            case 100:\n              _context6.prev = 100;\n              // Reset UI\n              this.isGenerating = false;\n              if (generateButton) {\n                generateButton.disabled = false;\n                generateButton.classList.remove('disabled'); // Remove CSS class\n              }\n              return _context6.finish(100);\n            case 104:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee5, this, [[20, 92, 100, 104], [41, 47]]);\n      }));\n      function generateShape() {\n        return _generateShape.apply(this, arguments);\n      }\n      return generateShape;\n    }()\n    /**\n     * Process and show a preview of the generated shape before injecting\n     */\n    )\n  }, {\n    key: \"processAndPreviewShapeClass\",\n    value: function processAndPreviewShapeClass(generatedCode, description) {\n      try {\n        console.log(\"Raw generated code:\", generatedCode);\n\n        // Ensure generatedCode is a string\n        if (typeof generatedCode !== 'string') {\n          console.error(\"Generated code is not a string:\", _typeof(generatedCode), generatedCode);\n          throw new Error('Generated code is not in the expected format');\n        }\n\n        // Extract class name with more flexible regex\n        var classNameMatch = generatedCode.match(/class\\s+(\\w+)(?:\\s+extends\\s+Shape|\\s+extends\\s+window\\.Shape)?/);\n        if (!classNameMatch) {\n          console.error(\"Could not extract class name from:\", generatedCode.substring(0, 200) + \"...\");\n          throw new Error('Could not extract class name from generated code');\n        }\n        var className = classNameMatch[1];\n        console.log(\"Extracted class name:\", className);\n\n        // Clean up the code with more robust replacements\n        var cleanedCode = generatedCode.replace(/import\\s+.*?from\\s+['\"].*?['\"]\\s*;?/g, '') // Remove all imports\n        .replace(/import\\s+{.*?}\\s+from\\s+['\"].*?['\"]\\s*;?/g, '') // Remove specific imports\n        .replace(/export\\s+(?:default)?\\s*\\w+\\s*;?/g, '') // Remove exports\n        .replace(/extends\\s+Shape/g, 'extends window.Shape'); // Fix extends\n\n        console.log(\"Cleaned code:\", cleanedCode);\n\n        // Store for later use\n        this.currentGeneratedCode = cleanedCode;\n        this.currentClassName = className;\n\n        // Generate a preview SVG\n        this.showShapePreview(cleanedCode, className, description);\n\n        // Reset state\n        this.isGenerating = false;\n\n        // Clear the saved form state since we've successfully generated a shape\n        this.clearFormState();\n      } catch (error) {\n        console.error('Error processing shape class:', error);\n        this.showErrorInModal(error.message);\n        this.isGenerating = false;\n      }\n    }\n\n    /**\n    * Clear saved form state from localStorage\n    */\n  }, {\n    key: \"clearFormState\",\n    value: function clearFormState() {\n      try {\n        localStorage.removeItem('shapeGeneratorFormState');\n        console.log('Form state cleared after successful generation');\n        return true;\n      } catch (error) {\n        console.error('Error clearing form state:', error);\n        return false;\n      }\n    }\n\n    /**\n     * Show a preview of the shape with options to edit, regenerate, or confirm\n     */\n  }, {\n    key: \"showShapePreview\",\n    value: function showShapePreview(code, className, description) {\n      var _this4 = this;\n      // Get the modal\n      var modal = document.getElementById('create-shape-modal');\n      if (!modal) return;\n\n      // Clear existing content (except header)\n      var modalHeader = modal.querySelector('.modal-header');\n      var modalContent = modal.querySelector('.modal-content');\n\n      // Create new modal content\n      var newModalContent = document.createElement('div');\n      newModalContent.className = 'modal-content';\n      newModalContent.style.backgroundColor = '#000';\n      newModalContent.style.borderRadius = '8px';\n      newModalContent.style.padding = '20px';\n      newModalContent.style.width = '620px';\n      newModalContent.style.maxWidth = '90%';\n      newModalContent.style.color = '#e0e0e0';\n      newModalContent.style.fontFamily = \"'Menlo', 'Monaco', 'Courier New', monospace\";\n      newModalContent.style.boxShadow = '0 8px 24px rgba(0, 0, 0, 0.3)';\n\n      // Add the modal header\n      newModalContent.appendChild(modalHeader.cloneNode(true));\n\n      // Update the title\n      var newTitle = newModalContent.querySelector('h3');\n      if (newTitle) {\n        newTitle.textContent = 'Shape Preview';\n      }\n\n      // Add close button handler\n      var newCloseButton = newModalContent.querySelector('.close-button');\n      if (newCloseButton) {\n        newCloseButton.onclick = function () {\n          return modal.remove();\n        };\n      }\n\n      // Create a container for the preview\n      var previewContainer = document.createElement('div');\n      previewContainer.id = 'shape-preview-container';\n      previewContainer.style.backgroundColor = '#000';\n      previewContainer.style.borderRadius = '4px';\n      previewContainer.style.padding = '20px';\n      previewContainer.style.marginBottom = '16px';\n      previewContainer.style.display = 'flex';\n      previewContainer.style.justifyContent = 'center';\n      previewContainer.style.alignItems = 'center';\n      previewContainer.style.aspectRatio = '1/1';\n      previewContainer.style.position = 'relative'; // For overlay hint on mobile\n\n      // Add to modal content\n      newModalContent.appendChild(previewContainer);\n\n      // Create a parameters container\n      var parametersContainer = document.createElement('div');\n      parametersContainer.id = 'shape-parameters-container';\n      parametersContainer.style.backgroundColor = '#111';\n      parametersContainer.style.borderRadius = '4px';\n      parametersContainer.style.padding = '16px';\n      parametersContainer.style.marginBottom = '16px';\n      parametersContainer.style.maxHeight = '200px';\n      parametersContainer.style.overflowY = 'auto';\n      parametersContainer.style.display = 'none'; // Initially hidden until we extract parameters\n\n      // Add parameters container to modal content\n      newModalContent.appendChild(parametersContainer);\n\n      // Create loading indicator\n      var loadingIndicator = document.createElement('div');\n      loadingIndicator.textContent = 'Loading parameters...';\n      loadingIndicator.style.textAlign = 'center';\n      loadingIndicator.style.padding = '16px';\n      loadingIndicator.style.color = '#888';\n      parametersContainer.appendChild(loadingIndicator);\n      try {\n        // First create script to extract parameters from the shape class\n        var extractScript = document.createElement('script');\n        extractScript.id = 'extract-params-script';\n        extractScript.textContent = \"\\n            (function() {\\n              try {\\n                // Define temporary shape class to extract parameters\\n                \".concat(code, \"\\n                \\n                // Verify the class was defined\\n                if (typeof \").concat(className, \" !== 'function') {\\n                  throw new Error(\\\"Shape class \").concat(className, \" was not properly defined in edited code\\\");\\n                }\\n                \\n                // Extract static parameters if defined\\n                let parameters = {};\\n                if (\").concat(className, \".parameters) {\\n                  parameters = \").concat(className, \".parameters;\\n                } else if (\").concat(className, \".prototype && \").concat(className, \".prototype.constructor && \").concat(className, \".prototype.constructor.parameters) {\\n                  parameters = \").concat(className, \".prototype.constructor.parameters;\\n                }\\n                \\n                // Create instance to get default values\\n                const instance = new \").concat(className, \"();\\n                \\n                // Create parameter data with current values\\n                const paramData = {};\\n                \\n                // Extract parameters from instance and class definition\\n                Object.keys(parameters).forEach(param => {\\n                  if (param === 'seed') return; // Skip seed parameter\\n                  \\n                  const config = parameters[param];\\n                  \\n                  // Get current value from instance\\n                  let currentValue = instance[param];\\n                  if (currentValue === undefined && config.default !== undefined) {\\n                    currentValue = config.default;\\n                  }\\n                  \\n                  paramData[param] = {\\n                    min: config.min !== undefined ? config.min : 0,\\n                    max: config.max !== undefined ? config.max : 100,\\n                    value: currentValue !== undefined ? currentValue : (config.default !== undefined ? config.default : 50),\\n                    step: Number.isInteger(currentValue) ? 1 : 0.1,\\n                    options: config.options // For dropdown selects\\n                  };\\n                });\\n                \\n                // Send extracted param data to window for UI creation\\n                window.extractedShapeParams = paramData;\\n                \\n                // Signal that parameters have been extracted\\n                const event = new CustomEvent('shapeParamsExtracted');\\n                document.dispatchEvent(event);\\n              } catch (error) {\\n                console.error('Error extracting parameters:', error);\\n                \\n                // Signal error in parameter extraction\\n                window.extractedShapeParams = { error: error.message };\\n                const event = new CustomEvent('shapeParamsExtracted');\\n                document.dispatchEvent(event);\\n              }\\n            })();\\n          \");\n\n        // Add action buttons container\n        var actionsContainer = document.createElement('div');\n        actionsContainer.style.display = 'flex';\n        actionsContainer.style.justifyContent = 'space-between';\n        actionsContainer.style.marginTop = '20px';\n\n        // Create action buttons\n        var regenerateButton = this.createActionButton('Regenerate', function () {\n          _this4.regenerateShape();\n        }, '#222');\n        var editButton = this.createActionButton('Edit Shape', function () {\n          _this4.editShape(code, className);\n        }, '#222');\n        var confirmButton = this.createActionButton('Confirm', function () {\n          _this4.confirmShape();\n        }, '#fff');\n\n        // Add buttons to container\n        actionsContainer.appendChild(regenerateButton);\n        actionsContainer.appendChild(editButton);\n        actionsContainer.appendChild(confirmButton);\n\n        // Add actions to modal\n        newModalContent.appendChild(actionsContainer);\n\n        // Replace the existing modal content\n        modalContent.parentNode.replaceChild(newModalContent, modalContent);\n\n        // Now add script to generate the SVG preview\n        var previewScript = document.createElement('script');\n        previewScript.id = 'temp-shape-script';\n        previewScript.textContent = \"\\n            (function() {\\n              try {\\n                // Define temporary shape class for the preview\\n                \".concat(code, \"\\n                \\n                // Verify the class was defined\\n                if (typeof \").concat(className, \" !== 'function') {\\n                  throw new Error(\\\"Shape class \").concat(className, \" was not properly defined\\\");\\n                }\\n                \\n                // Function to update the preview with current parameters\\n                window.updateShapePreview = function(params) {\\n                  try {\\n                    // Create instance with provided parameters\\n                    const tempInstance = new \").concat(className, \"(params);\\n                    \\n                    // Get SVG content\\n                    const svgContent = tempInstance.generateShape();\\n                    \\n                    // Create the preview\\n                    const previewContainer = document.getElementById('shape-preview-container');\\n                    if (previewContainer) {\\n                      // Clear any previous content\\n                      previewContainer.innerHTML = '';\\n                      \\n                      // Create SVG element\\n                      const svgElement = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\\n                      svgElement.setAttribute('width', '100%');\\n                      svgElement.setAttribute('height', '100%');\\n                      svgElement.setAttribute('viewBox', '-110 -110 220 220');\\n                      \\n                      // Create wrapper group\\n                      const wrapperGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');\\n                      wrapperGroup.setAttribute('transform', 'translate(0,0)');\\n                      svgElement.appendChild(wrapperGroup);\\n                      \\n                      // Set the inner HTML of the wrapper\\n                      wrapperGroup.innerHTML = svgContent;\\n                      \\n                      // Add to preview container\\n                      previewContainer.appendChild(svgElement);\\n                    }\\n                  } catch (error) {\\n                    console.error('Error updating shape preview:', error);\\n                    \\n                    // Show error in preview\\n                    const previewContainer = document.getElementById('shape-preview-container');\\n                    if (previewContainer) {\\n                      previewContainer.innerHTML = '<div style=\\\"color: #FF5555; padding: 20px; text-align: center;\\\">Error rendering preview: ' + error.message + '</div>';\\n                    }\\n                  }\\n                };\\n                \\n                // Generate initial preview\\n                window.updateShapePreview({});\\n              } catch (error) {\\n                console.error('Error creating shape preview:', error);\\n                \\n                // Show error in preview\\n                const previewContainer = document.getElementById('shape-preview-container');\\n                if (previewContainer) {\\n                  previewContainer.innerHTML = '<div style=\\\"color: #FF5555; padding: 20px; text-align: center;\\\">Error rendering preview: ' + error.message + '</div>';\\n                }\\n              }\\n            })();\\n          \");\n\n        // Event listener for parameter extraction\n        document.addEventListener('shapeParamsExtracted', function () {\n          // Get the extracted params\n          var params = window.extractedShapeParams;\n\n          // Clear loading indicator\n          parametersContainer.innerHTML = '';\n          if (params.error) {\n            // Show error message\n            var errorMsg = document.createElement('div');\n            errorMsg.textContent = \"Couldn't extract parameters: \".concat(params.error);\n            errorMsg.style.color = '#FF5555';\n            errorMsg.style.padding = '12px';\n            parametersContainer.appendChild(errorMsg);\n            return;\n          }\n\n          // Show parameters container if we have parameters\n          if (Object.keys(params).length > 0) {\n            parametersContainer.style.display = 'block';\n\n            // Add title\n            //   const title = document.createElement('div');\n            //   title.textContent = '';\n            //   title.style.marginBottom = '12px';\n            //   title.style.fontSize = '14px';\n            //   title.style.fontWeight = 'bold';\n            //   title.style.color = '#999';\n            //   parametersContainer.appendChild(title);\n\n            // Track current parameter values\n            var currentParams = {};\n\n            // Create controls for each parameter\n            Object.keys(params).forEach(function (param) {\n              var paramConfig = params[param];\n\n              // Set initial value in currentParams\n              currentParams[param] = paramConfig.value;\n\n              // Create parameter container\n              var paramContainer = document.createElement('div');\n              paramContainer.style.marginBottom = '12px';\n\n              // Create label\n              var label = document.createElement('div');\n              label.style.display = 'flex';\n              label.style.justifyContent = 'space-between';\n              label.style.marginBottom = '4px';\n              var nameSpan = document.createElement('span');\n              nameSpan.textContent = param;\n              nameSpan.style.fontSize = '12px';\n              nameSpan.style.color = '#999';\n              var valueSpan = document.createElement('span');\n              valueSpan.id = \"\".concat(param, \"-value\");\n              valueSpan.textContent = paramConfig.value;\n              valueSpan.style.fontSize = '12px';\n              valueSpan.style.color = '#bbb';\n              label.appendChild(nameSpan);\n              label.appendChild(valueSpan);\n\n              // Create control\n              var control;\n              if (paramConfig.options) {\n                // Dropdown for options\n                control = document.createElement('select');\n                control.style.width = '100%';\n                control.style.backgroundColor = '#333';\n                control.style.color = '#666';\n                control.style.border = 'none';\n                control.style.borderRadius = '4px';\n                control.style.padding = '4px 8px';\n                control.style.fontSize = '12px';\n                paramConfig.options.forEach(function (option) {\n                  var optElement = document.createElement('option');\n                  optElement.value = option;\n                  optElement.textContent = option;\n                  if (option === paramConfig.value) {\n                    optElement.selected = true;\n                  }\n                  control.appendChild(optElement);\n                });\n                control.addEventListener('change', function () {\n                  currentParams[param] = control.value;\n                  valueSpan.textContent = control.value;\n                  window.updateShapePreview(currentParams);\n                });\n              } else {\n                // Slider for numeric parameters\n                control = document.createElement('input');\n                control.type = 'range';\n                control.min = paramConfig.min;\n                control.max = paramConfig.max;\n                control.step = paramConfig.step;\n                control.value = paramConfig.value;\n                control.style.width = '100%';\n                control.style.accentColor = '#fff';\n\n                // Add touch-friendly styles\n                control.style.height = '20px'; // Taller for mobile touch\n\n                control.addEventListener('input', function () {\n                  // Update value in real-time\n                  var value = Number(control.value);\n                  currentParams[param] = value;\n                  valueSpan.textContent = paramConfig.step === 1 ? value.toFixed(0) : value.toFixed(1);\n                  window.updateShapePreview(currentParams);\n                });\n              }\n\n              // Add elements to container\n              paramContainer.appendChild(label);\n              paramContainer.appendChild(control);\n              parametersContainer.appendChild(paramContainer);\n            });\n\n            // Add hint for mobile users\n            if ('ontouchstart' in window) {\n              var touchHint = document.createElement('div');\n              touchHint.textContent = 'Use sliders to adjust shape parameters';\n              touchHint.style.position = 'absolute';\n              touchHint.style.bottom = '10px';\n              touchHint.style.left = '0';\n              touchHint.style.right = '0';\n              touchHint.style.textAlign = 'center';\n              touchHint.style.backgroundColor = 'rgba(0,0,0,0.7)';\n              touchHint.style.color = '#fff';\n              touchHint.style.padding = '8px';\n              touchHint.style.fontSize = '12px';\n              touchHint.style.borderRadius = '4px';\n              touchHint.style.zIndex = '5';\n              previewContainer.appendChild(touchHint);\n\n              // Auto-hide hint after 5 seconds\n              setTimeout(function () {\n                touchHint.style.opacity = '0';\n                touchHint.style.transition = 'opacity 0.5s ease';\n                setTimeout(function () {\n                  return touchHint.remove();\n                }, 500);\n              }, 5000);\n            }\n          }\n\n          // Store current parameters in window for confirmation\n          window.finalShapeParams = params;\n        });\n\n        // Add scripts to the page in correct order\n        document.body.appendChild(extractScript);\n        document.body.appendChild(previewScript);\n\n        // Clean up scripts after execution\n        setTimeout(function () {\n          if (extractScript.parentNode) extractScript.parentNode.removeChild(extractScript);\n          if (previewScript.parentNode) previewScript.parentNode.removeChild(previewScript);\n        }, 1000);\n      } catch (error) {\n        console.error('Error showing shape preview:', error);\n        this.showErrorInModal('Failed to generate shape preview: ' + error.message);\n      }\n    }\n\n    /**\n     * Create an action button for the preview screen\n     */\n  }, {\n    key: \"createActionButton\",\n    value: function createActionButton(text, onClick) {\n      var bgColor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '#222';\n      var button = document.createElement('button');\n      button.textContent = text;\n      button.style.backgroundColor = bgColor;\n      button.style.color = bgColor === '#222' ? '#fff' : '#000';\n      button.style.border = 'none';\n      button.style.borderRadius = '4px';\n      button.style.padding = '10px 20px';\n      button.style.cursor = 'pointer';\n      button.style.fontFamily = \"'Menlo', 'Monaco', 'Courier New', monospace\";\n      button.style.fontSize = '12px';\n      button.style.transition = 'background-color 0.2s';\n      button.addEventListener('mouseover', function () {\n        button.style.backgroundColor = bgColor === '#222' ? '#333' : '#d4d4d4';\n      });\n      button.addEventListener('mouseout', function () {\n        button.style.backgroundColor = bgColor;\n      });\n      button.addEventListener('click', onClick);\n      return button;\n    }\n\n    /**\n     * Regenerate the shape with the same description and images\n     */\n  }, {\n    key: \"regenerateShape\",\n    value: function regenerateShape() {\n      var _this5 = this;\n      if (!this.currentDescription) return;\n\n      // Store a copy of the current attached images\n      var currentImages = _toConsumableArray(this.attachedImagesData);\n\n      // Close the preview and show the generation form again\n      var modal = document.getElementById('create-shape-modal');\n      if (modal) {\n        modal.remove();\n      }\n\n      // Show the create modal again\n      this.showCreateModal();\n\n      // Set the description to the current description\n      var descriptionInput = document.getElementById('description-input');\n      if (descriptionInput) {\n        descriptionInput.value = this.currentDescription;\n\n        // Restore the attached images\n        this.attachedImagesData = currentImages;\n\n        // Create previews for images\n        currentImages.forEach(function (img) {\n          _this5.createImagePreview(img.data, img.name);\n        });\n\n        // Trigger the generation\n        setTimeout(function () {\n          _this5.generateShape();\n        }, 100);\n      }\n    }\n\n    /**\n     * Show shape edit UI with prompt\n     */\n  }, {\n    key: \"editShape\",\n    value: function editShape(code, className) {\n      var _this6 = this;\n      // Get the modal\n      var modal = document.getElementById('create-shape-modal');\n      if (!modal) return;\n\n      // Clear existing content (except header)\n      var modalHeader = modal.querySelector('.modal-header');\n      var modalContent = modal.querySelector('.modal-content');\n\n      // Create new modal content\n      var newModalContent = document.createElement('div');\n      newModalContent.className = 'modal-content';\n      newModalContent.style.backgroundColor = '#000';\n      newModalContent.style.borderRadius = '8px';\n      newModalContent.style.padding = '20px';\n      newModalContent.style.width = '550px'; // Slightly wider for better layout\n      newModalContent.style.maxWidth = '90%';\n      newModalContent.style.color = '#e0e0e0';\n      newModalContent.style.fontFamily = \"'Menlo', 'Monaco', 'Courier New', monospace\";\n      newModalContent.style.boxShadow = '0 8px 24px rgba(0, 0, 0, 0.3)';\n\n      // Add the modal header\n      newModalContent.appendChild(modalHeader.cloneNode(true));\n\n      // Update the title\n      var newTitle = newModalContent.querySelector('h3');\n      if (newTitle) {\n        newTitle.textContent = 'Modify Shape';\n      }\n\n      // Add close button handler\n      var newCloseButton = newModalContent.querySelector('.close-button');\n      if (newCloseButton) {\n        newCloseButton.onclick = function () {\n          return modal.remove();\n        };\n      }\n\n      // Create a container for the preview\n      var previewContainer = document.createElement('div');\n      previewContainer.id = 'shape-preview-container';\n      previewContainer.style.backgroundColor = '#000';\n      previewContainer.style.borderRadius = '4px';\n      previewContainer.style.padding = '20px';\n      previewContainer.style.marginBottom = '16px';\n      previewContainer.style.display = 'flex';\n      previewContainer.style.justifyContent = 'center';\n      previewContainer.style.alignItems = 'center';\n      previewContainer.style.aspectRatio = '1/1';\n      previewContainer.style.position = 'relative';\n\n      // Add to modal content\n      newModalContent.appendChild(previewContainer);\n\n      // Create edit input container\n      var editContainer = document.createElement('div');\n      editContainer.className = 'edit-container';\n      editContainer.style.marginBottom = '16px';\n\n      // Create prompt input\n      var promptInput = document.createElement('textarea');\n      promptInput.id = 'edit-prompt-input';\n      promptInput.placeholder = 'Describe what changes you want...';\n      promptInput.style.width = '100%';\n      promptInput.style.backgroundColor = '#111';\n      promptInput.style.color = '#e0e0e0';\n      promptInput.style.border = 'none';\n      promptInput.style.borderRadius = '4px';\n      promptInput.style.padding = '12px';\n      promptInput.style.fontFamily = \"'Menlo', 'Monaco', 'Courier New', monospace\";\n      promptInput.style.fontSize = '12px';\n      promptInput.style.minHeight = '100px';\n      promptInput.style.resize = 'vertical';\n      promptInput.style.transition = 'border-color 0.2s, box-shadow 0.2s';\n\n      // Add loading container (initially hidden)\n      var loadingContainer = document.createElement('div');\n      loadingContainer.id = 'edit-loading-container';\n      loadingContainer.style.display = 'none';\n      loadingContainer.style.marginTop = '12px';\n      var loadingText = document.createElement('div');\n      loadingText.textContent = 'Updating shape...';\n      loadingText.style.fontSize = '12px';\n      loadingText.style.color = '#999';\n      loadingText.style.marginBottom = '6px';\n      var loadingBarOuter = document.createElement('div');\n      loadingBarOuter.style.width = '100%';\n      loadingBarOuter.style.height = '4px';\n      loadingBarOuter.style.backgroundColor = '#222';\n      loadingBarOuter.style.borderRadius = '2px';\n      loadingBarOuter.style.overflow = 'hidden';\n      var loadingBarInner = document.createElement('div');\n      loadingBarInner.id = 'edit-loading-bar';\n      loadingBarInner.style.width = '0%';\n      loadingBarInner.style.height = '100%';\n      loadingBarInner.style.backgroundColor = '#fff';\n      loadingBarInner.style.borderRadius = '2px';\n      loadingBarInner.style.transition = 'width 0.5s ease';\n      loadingBarOuter.appendChild(loadingBarInner);\n      loadingContainer.appendChild(loadingText);\n      loadingContainer.appendChild(loadingBarOuter);\n      editContainer.appendChild(promptInput);\n      editContainer.appendChild(loadingContainer);\n\n      // Actions container\n      var actionsContainer = document.createElement('div');\n      actionsContainer.style.display = 'flex';\n      actionsContainer.style.justifyContent = 'space-between';\n      actionsContainer.style.marginTop = '20px';\n      actionsContainer.style.justifyContent = 'flex-end';\n\n      // Create action buttons\n      var updateButton = this.createActionButton('Update Shape', function () {\n        var editPrompt = promptInput.value.trim();\n        if (!editPrompt) {\n          alert('Please enter a description of the changes you want to make.');\n          promptInput.focus();\n          return;\n        }\n\n        // Send edit request to API\n        _this6.sendEditRequest(code, className, editPrompt);\n      }, '#fff');\n      actionsContainer.appendChild(updateButton);\n\n      // Assemble the new modal content\n      newModalContent.appendChild(editContainer);\n      newModalContent.appendChild(actionsContainer);\n\n      // Replace the existing modal content\n      modalContent.parentNode.replaceChild(newModalContent, modalContent);\n\n      // Now add script to generate the SVG preview\n      var previewScript = document.createElement('script');\n      previewScript.id = 'temp-shape-script';\n      previewScript.textContent = \"\\n          (function() {\\n            try {\\n              // Define temporary shape class for the preview\\n              \".concat(code, \"\\n              \\n              // Verify the class was defined\\n              if (typeof \").concat(className, \" !== 'function') {\\n                throw new Error(\\\"Shape class \").concat(className, \" was not properly defined\\\");\\n              }\\n              \\n              // Create instance with default parameters\\n              const tempInstance = new \").concat(className, \"();\\n              \\n              // Get SVG content\\n              const svgContent = tempInstance.generateShape();\\n              \\n              // Create the preview\\n              const previewContainer = document.getElementById('shape-preview-container');\\n              if (previewContainer) {\\n                // Clear any previous content\\n                previewContainer.innerHTML = '';\\n                \\n                // Create SVG element\\n                const svgElement = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\\n                svgElement.setAttribute('width', '100%');\\n                svgElement.setAttribute('height', '100%');\\n                svgElement.setAttribute('viewBox', '-110 -110 220 220');\\n                \\n                // Create wrapper group\\n                const wrapperGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');\\n                wrapperGroup.setAttribute('transform', 'translate(0,0)');\\n                svgElement.appendChild(wrapperGroup);\\n                \\n                // Set the inner HTML of the wrapper\\n                wrapperGroup.innerHTML = svgContent;\\n                \\n                // Add to preview container\\n                previewContainer.appendChild(svgElement);\\n              }\\n            } catch (error) {\\n              console.error('Error creating shape preview:', error);\\n              \\n              // Show error in preview\\n              const previewContainer = document.getElementById('shape-preview-container');\\n              if (previewContainer) {\\n                previewContainer.innerHTML = '<div style=\\\"color: #FF5555; padding: 20px; text-align: center;\\\">Error rendering preview: ' + error.message + '</div>';\\n              }\\n            }\\n          })();\\n        \");\n\n      // Add script to the page\n      document.body.appendChild(previewScript);\n\n      // Clean up script after execution\n      setTimeout(function () {\n        if (previewScript.parentNode) previewScript.parentNode.removeChild(previewScript);\n      }, 1000);\n\n      // Focus the prompt input\n      promptInput.focus();\n    }\n\n    //   editShape(code, className) {\n    //     const modal = document.getElementById('create-shape-modal');\n    //     if (!modal) return;\n    //     const modalContent = modal.querySelector('.modal-content');\n    //     if (!modalContent) return;\n\n    //     // --- Create Edit UI Elements ---\n    //     const editUI = document.createElement('div');\n    //     editUI.id = 'shape-edit-ui';\n\n    //     // Clone header\n    //     const modalHeader = modalContent.querySelector('.modal-header');\n    //     if (modalHeader) {\n    //          const editHeader = modalHeader.cloneNode(true);\n    //          // ... (update title, close button handler) ...\n    //          editUI.appendChild(editHeader);\n\n    //     }\n\n    //     // Container for Preview and Drawing Canvas\n    //     const previewAndDrawContainer = document.createElement('div');\n    //     previewAndDrawContainer.style.position = 'relative'; // Needed for overlay canvas\n    //     previewAndDrawContainer.style.width = '100%'; // Adjust as needed\n    //     previewAndDrawContainer.style.aspectRatio = '1 / 1';\n    //     previewAndDrawContainer.style.marginBottom = '15px';\n    //     previewAndDrawContainer.style.border = '1px solid #222';\n    //     previewAndDrawContainer.style.borderRadius = '8px';\n    //     previewAndDrawContainer.style.overflow = 'hidden'; // Clip corners\n\n    //     // SVG Preview Container (goes underneath)\n    //     const previewContainer = document.createElement('div');\n    //     previewContainer.id = 'shape-preview-container'; // For SVG rendering\n    //     previewContainer.style.position = 'absolute';\n    //     previewContainer.style.top = '0';\n    //     previewContainer.style.left = '0';\n    //     previewContainer.style.width = '100%';\n    //     previewContainer.style.height = '100%';\n    //     previewContainer.style.display = 'flex';\n    //     previewContainer.style.justifyContent = 'center';\n    //     previewContainer.style.alignItems = 'center';\n    //     previewContainer.style.zIndex = '1'; // Below drawing canvas\n    //     previewContainer.innerHTML = '<div style=\"color:#888; font-size:12px;\">Loading Preview...</div>';\n    //     previewAndDrawContainer.appendChild(previewContainer);\n\n    //     // Drawing Canvas (Overlay)\n    //     const drawCanvas = document.createElement('canvas');\n    //     drawCanvas.id = 'edit-draw-canvas';\n    //     drawCanvas.style.position = 'absolute';\n    //     drawCanvas.style.top = '0';\n    //     drawCanvas.style.left = '0';\n    //     drawCanvas.style.width = '100%'; // Match container size visually\n    //     drawCanvas.style.height = '100%';\n    //     drawCanvas.style.cursor = 'crosshair';\n    //     drawCanvas.style.zIndex = '2'; // Above SVG preview\n    //     // Make background transparent so SVG shows through\n    //     drawCanvas.style.backgroundColor = 'transparent';\n    //     previewAndDrawContainer.appendChild(drawCanvas);\n\n    //     // Drawing Controls (e.g., Clear button)\n    //     const drawControls = document.createElement('div');\n    //     drawControls.style.position = 'absolute';\n    //     drawControls.style.bottom = '5px';\n    //     drawControls.style.right = '5px';\n    //     drawControls.style.zIndex = '3'; // Above drawing canvas\n\n    //     const clearDrawButton = document.createElement('button');\n    //     clearDrawButton.type = 'button';\n    //     clearDrawButton.textContent = 'Clear Sketch';\n    //     // ... (style clear button: small, transparent bg, etc.) ...\n    //     clearDrawButton.style.fontSize = '10px';\n    //     clearDrawButton.style.padding = '2px 6px';\n    //     clearDrawButton.style.backgroundColor = 'rgba(0,0,0,0.5)';\n    //     clearDrawButton.style.color = '#ccc';\n    //     clearDrawButton.style.border = '1px solid #555';\n    //     clearDrawButton.style.borderRadius = '4px';\n    //     clearDrawButton.style.cursor = 'pointer';\n    //     clearDrawButton.onmouseover = () => clearDrawButton.style.backgroundColor = 'rgba(50,50,50,0.7)';\n    //     clearDrawButton.onmouseout = () => clearDrawButton.style.backgroundColor = 'rgba(0,0,0,0.5)';\n\n    //     drawControls.appendChild(clearDrawButton);\n    //     previewAndDrawContainer.appendChild(drawControls);\n\n    //     editUI.appendChild(previewAndDrawContainer);\n\n    //     // 3. Edit Input Group (Text prompt, Image Upload)\n    //     const editInputGroup = document.createElement('div');\n    //     editInputGroup.style.marginBottom = '15px';\n\n    //     // 3a. Text Prompt Input\n    //     const promptInput = document.createElement('textarea');\n    //     promptInput.id = 'edit-prompt-input'; // Assign ID\n    //     promptInput.placeholder = 'Describe changes... (Optional: Add sketch/image)';\n    //     promptInput.style.width = '100%';\n    //     promptInput.style.backgroundColor = '#111';\n    //     promptInput.style.color = '#e0e0e0';\n    //     promptInput.style.border = '1px solid #333'; // Subtle border\n    //     promptInput.style.borderRadius = '4px';\n    //     promptInput.style.padding = '12px';\n    //     promptInput.style.fontFamily = \"'Menlo', 'Monaco', 'Courier New', monospace\";\n    //     promptInput.style.fontSize = '12px';\n    //     promptInput.style.minHeight = '80px'; // Slightly shorter\n    //     promptInput.style.resize = 'vertical';\n    //     promptInput.style.boxSizing = 'border-box';\n    //     editInputGroup.appendChild(promptInput);\n\n    //     // 3b. Container for image upload button and preview\n    //     const imageUploadContainer = document.createElement('div');\n    //     imageUploadContainer.style.display = 'flex';\n    //     imageUploadContainer.style.alignItems = 'center';\n    //     imageUploadContainer.style.gap = '10px';\n    //     imageUploadContainer.style.marginTop = '10px';\n\n    //     // Add Image Button (similar to create modal)\n    //     const editImageButton = this.createActionButton('Attach Image', () => {\n    //          // Logic to handle file input, read image, store in this.editImageData\n    //          // and create a preview (similar to imageSvgButton logic in showCreateModal,\n    //          // but store data in a specific variable like this.editImageData and allow only one)\n    //          const fileInput = document.createElement('input');\n    //          fileInput.type = 'file';\n    //          fileInput.accept = 'image/*';\n    //          fileInput.style.display = 'none';\n    //          document.body.appendChild(fileInput);\n    //          fileInput.onchange = async (e) => {\n    //              if (e.target.files && e.target.files[0]) {\n    //                  const file = e.target.files[0];\n    //                  try {\n    //                      const reader = new FileReader();\n    //                      const dataUrl = await new Promise((res, rej) => { /* ... readAsDataURL ... */ });\n    //                      // Store resized image data (allow only one for edit)\n    //                      this.editImageData = await this.resizeImageToBase64(dataUrl, file.type, file.name);\n    //                      // Show preview for the edit image\n    //                      this.createEditImagePreview(this.editImageData);\n    //                  } catch (err) {\n    //                      console.error(\"Error attaching edit image:\", err);\n    //                      this.showErrorInModal(\"Failed to attach image.\", 'edit-status-container');\n    //                      this.editImageData = null; // Clear on error\n    //                  }\n    //              }\n    //              document.body.removeChild(fileInput);\n    //          };\n    //          fileInput.click();\n\n    //     }, '#333'); // Style as secondary button\n    //     editImageButton.style.padding = '5px 10px'; // Smaller button\n    //     editImageButton.style.fontSize = '11px';\n\n    //     // Container specifically for the edit image preview\n    //     const editImagePreviewContainer = document.createElement('div');\n    //     editImagePreviewContainer.id = 'edit-image-preview';\n    //     // Style this container as needed\n\n    //     imageUploadContainer.appendChild(editImageButton);\n    //     imageUploadContainer.appendChild(editImagePreviewContainer); // Add preview next to button\n    //     editInputGroup.appendChild(imageUploadContainer); // Add under the text prompt\n\n    //     // Status Container (for errors/progress)\n    //     const statusContainer = document.createElement('div');\n    //     statusContainer.id = 'edit-status-container'; // Assign ID\n    //     statusContainer.style.marginTop = '10px';\n    //     statusContainer.style.minHeight = '20px';\n    //     editInputGroup.appendChild(statusContainer); // Add below image upload stuff\n\n    //     // Actions (Update Button)\n    //     const actionsContainer = document.createElement('div');\n    //     actionsContainer.style.display = 'flex';\n    //     actionsContainer.style.justifyContent = 'flex-end';\n    //     actionsContainer.style.marginTop = '15px';\n\n    //     // *** Assign specific ID to the Update button ***\n    //     const updateButton = this.createActionButton('Update Shape', null, '#fff'); // onClick handled later\n    //     updateButton.id = 'edit-update-button'; // Assign the ID here\n\n    //     // Add the click handler here, gathering all data\n    //     updateButton.onclick = () => {\n    //         const editPromptText = promptInput.value.trim();\n    //         let sketchData = null;\n    //         // Check drawCanvas for content before getting dataURL\n    //         if (this.hasCanvasContent(drawCanvas)) {\n    //             try {\n    //                 sketchData = drawCanvas.toDataURL('image/png');\n    //             } catch (e) {\n    //                 console.error(\"Error getting sketch dataURL:\", e);\n    //                 this.showErrorInModal(\"Could not capture sketch.\", 'edit-status-container');\n    //             }\n    //         }\n    //         // Pass original code, text prompt, sketch data, and reference image data\n    //         this.sendEditRequest(code, className, editPromptText, sketchData, this.editImageData);\n    //     };\n\n    //     actionsContainer.appendChild(updateButton);\n\n    //     // Assemble Edit UI\n    //     editUI.appendChild(editInputGroup);\n    //     editUI.appendChild(actionsContainer);\n\n    //     // Replace modal content\n    //     while (modalContent.firstChild) { modalContent.removeChild(modalContent.firstChild); }\n    //     modalContent.appendChild(editUI);\n\n    //     // --- Setup Drawing Canvas ---\n    //     const ctx = drawCanvas.getContext('2d');\n    //     // Set canvas internal size to match container's display size AFTER it's in the DOM\n    //      setTimeout(() => {\n    //         const bounds = drawCanvas.getBoundingClientRect();\n    //         drawCanvas.width = bounds.width;\n    //         drawCanvas.height = bounds.height;\n    //          // Setup drawing context AFTER setting size\n    //          this.setupDrawing(drawCanvas, ctx); // Separate function for clarity\n    //      }, 0); // Execute after current event loop cycle\n\n    //     clearDrawButton.onclick = () => {\n    //         ctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);\n    //     };\n\n    //     // --- Load Initial SVG Preview ---\n    //     this.renderSvgPreview(code, className, previewContainer); // Use helper\n\n    //     promptInput.focus();\n    //     this.editImageData = null; // Reset edit image data when opening edit modal\n    // }\n\n    // Helper to setup drawing listeners\n  }, {\n    key: \"setupDrawing\",\n    value: function setupDrawing(canvas, ctx) {\n      var drawing = false;\n      ctx.strokeStyle = '#FFDE03'; // Yellow drawing color for visibility\n      ctx.lineWidth = 3;\n      ctx.lineCap = 'round';\n      ctx.lineJoin = 'round';\n      var getPos = function getPos(e) {\n        var rect = canvas.getBoundingClientRect();\n        var scaleX = canvas.width / rect.width;\n        var scaleY = canvas.height / rect.height;\n        var clientX = e.touches ? e.touches[0].clientX : e.clientX;\n        var clientY = e.touches ? e.touches[0].clientY : e.clientY;\n        return {\n          x: (clientX - rect.left) * scaleX,\n          y: (clientY - rect.top) * scaleY\n        };\n      };\n      var start = function start(e) {\n        drawing = true;\n        var pos = getPos(e);\n        ctx.beginPath();\n        ctx.moveTo(pos.x, pos.y);\n      };\n      var draw = function draw(e) {\n        if (!drawing) return;\n        var pos = getPos(e);\n        ctx.lineTo(pos.x, pos.y);\n        ctx.stroke();\n      };\n      var stop = function stop() {\n        drawing = false;\n      };\n      canvas.addEventListener('mousedown', start);\n      canvas.addEventListener('mousemove', draw);\n      canvas.addEventListener('mouseup', stop);\n      canvas.addEventListener('mouseout', stop);\n      canvas.addEventListener('touchstart', function (e) {\n        e.preventDefault();\n        start(e);\n      }, {\n        passive: false\n      });\n      canvas.addEventListener('touchmove', function (e) {\n        e.preventDefault();\n        draw(e);\n      }, {\n        passive: false\n      });\n      canvas.addEventListener('touchend', stop);\n    }\n\n    // Helper to render SVG preview\n  }, {\n    key: \"renderSvgPreview\",\n    value: function renderSvgPreview(code, className, container) {\n      var script = document.createElement('script');\n      script.textContent = \"\\n         (function() {\\n           const previewContainer = document.getElementById('\".concat(container.id, \"'); // Use passed container ID\\n           if (!previewContainer) return;\\n           try {\\n             if (!window.Shape) throw new Error(\\\"Base Shape class missing.\\\");\\n             \").concat(code, \" // Define class\\n             if (typeof \").concat(className, \" !== 'function') throw new Error(\\\"Class \").concat(className, \" not defined.\\\");\\n             const instance = new \").concat(className, \"(); // Default params\\n             const svgContent = instance.generateShape();\\n             if (typeof svgContent !== 'string' || !svgContent.trim()) throw new Error(\\\"generateShape empty.\\\");\\n             previewContainer.innerHTML = `<svg width=\\\"90%\\\" height=\\\"90%\\\" viewBox=\\\"-110 -110 220 220\\\" preserveAspectRatio=\\\"xMidYMid meet\\\"><g>${svgContent}</g></svg>`;\\n           } catch (error) {\\n             console.error('Error rendering SVG preview:', error);\\n             previewContainer.innerHTML = `<div style=\\\"color:#FF8A80; padding:10px; font-size:12px;\\\">Preview Error: ${error.message}</div>`;\\n           }\\n         })();\\n       \");\n      document.body.appendChild(script);\n      setTimeout(function () {\n        if (script.parentNode) script.parentNode.removeChild(script);\n      }, 50);\n    }\n\n    // Helper to create preview for the attached EDIT image\n  }, {\n    key: \"createEditImagePreview\",\n    value: function createEditImagePreview(imageData) {\n      var _this7 = this;\n      var container = document.getElementById('edit-image-preview');\n      if (!container) return;\n      container.innerHTML = ''; // Clear previous\n\n      var previewItem = document.createElement('div');\n      previewItem.style.position = 'relative';\n      previewItem.style.width = '48px'; // Smaller preview for edit\n      previewItem.style.height = '48px';\n      var img = document.createElement('img');\n      img.src = imageData.data;\n      img.style.width = '100%';\n      img.style.height = '100%';\n      img.style.objectFit = 'cover';\n      img.style.borderRadius = '4px';\n      previewItem.appendChild(img);\n      var removeBtn = document.createElement('button');\n      // ... style remove button (similar to createImagePreview) ...\n      removeBtn.innerHTML = 'X'; // Simple remove\n      removeBtn.style.position = 'absolute';\n      removeBtn.style.top = '-5px';\n      removeBtn.style.right = '-5px';\n      // ... more styling ...\n      removeBtn.onclick = function () {\n        _this7.editImageData = null; // Clear data\n        container.innerHTML = ''; // Remove preview\n      };\n      previewItem.appendChild(removeBtn);\n      container.appendChild(previewItem);\n    }\n\n    /**\n    * Send edit request to the Gemini API via Supabase proxy\n    */\n  }, {\n    key: \"sendEditRequest\",\n    value: (function () {\n      var _sendEditRequest = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(originalCode, className, editPrompt) {\n        var sketchDataUrl,\n          referenceImageData,\n          promptInput,\n          updateButton,\n          statusContainer,\n          progressInterval,\n          _data$content2,\n          loadingBar,\n          progress,\n          textPromptPart,\n          requestBody,\n          supabaseAnonKey,\n          response,\n          _errorData$error2,\n          errorData,\n          data,\n          updatedCode,\n          _data$error2,\n          backendError,\n          _args7 = arguments;\n        return _regeneratorRuntime().wrap(function _callee6$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              sketchDataUrl = _args7.length > 3 && _args7[3] !== undefined ? _args7[3] : null;\n              referenceImageData = _args7.length > 4 && _args7[4] !== undefined ? _args7[4] : null;\n              // Added params for images\n              console.log(\"Sending edit request for:\", className);\n              // Get UI elements using specific IDs for reliability\n              promptInput = document.getElementById('edit-prompt-input'); // *** Give the update button a specific ID in editShape function ***\n              updateButton = document.getElementById('edit-update-button');\n              statusContainer = document.getElementById('edit-status-container');\n              if (!(!promptInput || !updateButton || !statusContainer)) {\n                _context7.next = 10;\n                break;\n              }\n              // Use the showErrorInModal helper for consistency\n              this.showErrorInModal(\"Edit UI elements missing. Cannot send request.\", 'edit-status-container'); // Pass container ID\n              console.error(\"Edit UI elements missing:\", {\n                promptInput: !!promptInput,\n                updateButton: !!updateButton,\n                statusContainer: !!statusContainer\n              });\n              return _context7.abrupt(\"return\");\n            case 10:\n              statusContainer.innerHTML = ''; // Clear previous status/error\n              progressInterval = null;\n              _context7.prev = 12;\n              promptInput.disabled = true;\n              updateButton.disabled = true;\n              updateButton.style.opacity = '0.5';\n              updateButton.style.cursor = 'not-allowed';\n\n              // Show progress indicator within status container\n              // *** Add correct progress bar HTML ***\n              statusContainer.innerHTML = \"\\n              <div style=\\\"font-size:11px; color:#999; margin-bottom:5px;\\\">Updating shape...</div>\\n              <div style=\\\"width:100%; height:4px; background-color:#222; border-radius:2px; overflow:hidden;\\\">\\n                  <div id=\\\"edit-loading-bar\\\" style=\\\"width:0%; height:100%; background-color:#fff; border-radius:2px; transition: width 0.5s ease;\\\"></div>\\n              </div>\";\n              loadingBar = document.getElementById('edit-loading-bar'); // Get the created bar\n              progress = 0;\n              progressInterval = setInterval(function () {\n                progress += 5;\n                if (progress >= 95) {\n                  clearInterval(progressInterval);\n                  progressInterval = null;\n                  progress = 95;\n                }\n                if (loadingBar) loadingBar.style.width = \"\".concat(progress, \"%\");\n              }, 300);\n\n              // --- Construct the Prompt for Gemini (Edit Task) ---\n              // This part remains largely the same, focusing on text instructions + code\n              textPromptPart = \"I have this JavaScript shape class that extends window.Shape:\\n    ```javascript\\n    \".concat(originalCode, \"\\n    ```\\n    Based *only* on that code, please apply the following modification: \\\"\").concat(editPrompt, \"\\\".\"); // --- Prepare Request Body for GEMINI function (NOW MULTIMODAL) ---\n              requestBody = _objectSpread(_objectSpread({\n                originalCode: originalCode,\n                // Send original code separately\n                editPrompt: editPrompt,\n                // Send text prompt separately\n                options: {\n                  temperature: 0.5\n                }\n              }, sketchDataUrl && {\n                sketchImage: sketchDataUrl\n              }), referenceImageData && {\n                referenceImage: referenceImageData\n              });\n              console.log(\"Sending MULTIMODAL edit request body:\", JSON.stringify(requestBody, function (k, v) {\n                return v && typeof v === 'string' && v.length > 100 ? v.substring(0, 100) + '...' : v;\n              }, 2)); // Log truncated data\n\n              // --- Make API Request ---\n              supabaseAnonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImF2dWZzZ2p3YnpqaW55Y2NydXFjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDE3NjYwMzgsImV4cCI6MjA1NzM0MjAzOH0.0tRCOWd1HByLbpw6q2ov4ipUOjByte2vmH-Wjpke0_A';\n              if (!(!supabaseAnonKey || supabaseAnonKey === 'YOUR_REAL_SUPABASE_ANON_KEY')) {\n                _context7.next = 27;\n                break;\n              }\n              throw new Error(\"Supabase key missing.\");\n            case 27:\n              _context7.next = 29;\n              return fetch(this.proxyUrl, {\n                // Use the Gemini proxyUrl\n                method: 'POST',\n                headers: {\n                  'Content-Type': 'application/json',\n                  'Authorization': \"Bearer \".concat(supabaseAnonKey),\n                  'apikey': supabaseAnonKey\n                },\n                body: JSON.stringify(requestBody) // Send the new multimodal body\n              });\n            case 29:\n              response = _context7.sent;\n              if (progressInterval) {\n                clearInterval(progressInterval);\n                progressInterval = null;\n              }\n\n              // --- Handle Response ---\n              if (response.ok) {\n                _context7.next = 44;\n                break;\n              }\n              errorData = {\n                error: {\n                  message: \"HTTP error \".concat(response.status)\n                }\n              };\n              _context7.prev = 33;\n              _context7.next = 36;\n              return response.json();\n            case 36:\n              errorData = _context7.sent;\n              _context7.next = 42;\n              break;\n            case 39:\n              _context7.prev = 39;\n              _context7.t0 = _context7[\"catch\"](33);\n              errorData.error.message = \"\".concat(response.status, \" \").concat(response.statusText);\n            case 42:\n              console.error(\"API Edit Error Response:\", errorData);\n              throw new Error(((_errorData$error2 = errorData.error) === null || _errorData$error2 === void 0 ? void 0 : _errorData$error2.message) || \"API edit request failed: \".concat(response.status));\n            case 44:\n              _context7.next = 46;\n              return response.json();\n            case 46:\n              data = _context7.sent;\n              console.log(\"API Edit Response Data:\", JSON.stringify(data, null, 2));\n              if (loadingBar) loadingBar.style.width = \"100%\"; // Complete progress\n\n              // --- Extract Updated Code ---\n              if (!(data !== null && data !== void 0 && (_data$content2 = data.content) !== null && _data$content2 !== void 0 && (_data$content2 = _data$content2[0]) !== null && _data$content2 !== void 0 && _data$content2.text)) {\n                _context7.next = 53;\n                break;\n              }\n              updatedCode = data.content[0].text;\n              _context7.next = 59;\n              break;\n            case 53:\n              if (!(typeof data === 'string' && (data.includes('class') || data.trim().startsWith('import')))) {\n                _context7.next = 57;\n                break;\n              }\n              updatedCode = data;\n              _context7.next = 59;\n              break;\n            case 57:\n              backendError = (data === null || data === void 0 || (_data$error2 = data.error) === null || _data$error2 === void 0 ? void 0 : _data$error2.message) || JSON.stringify(data).substring(0, 100) + \"...\";\n              throw new Error(\"Unexpected API response format during edit. Could not extract code. Response: \".concat(backendError));\n            case 59:\n              // Clean potential markdown (safer regex)\n              updatedCode = updatedCode.replace(/^```(?:javascript|js)?\\s*|```\\s*$/g, '').trim();\n\n              // Basic validation\n              if (!(!updatedCode || typeof updatedCode !== 'string' || !updatedCode.includes(\"class \".concat(className)))) {\n                _context7.next = 63;\n                break;\n              }\n              console.error(\"Updated code seems invalid or didn't preserve class name:\", updatedCode);\n              throw new Error(\"Received invalid code modification from the API.\");\n            case 63:\n              // --- Update internal state and return to preview ---\n              this.currentGeneratedCode = updatedCode; // Store the modified code\n              // Pass description (maybe update it based on editPrompt later?)\n              this.showShapePreview(updatedCode, className, this.currentDescription);\n              _context7.next = 72;\n              break;\n            case 67:\n              _context7.prev = 67;\n              _context7.t1 = _context7[\"catch\"](12);\n              console.error('Error sending edit request:', _context7.t1);\n              if (progressInterval) {\n                clearInterval(progressInterval);\n                progressInterval = null;\n              }\n              // Show error message in the status container\n              statusContainer.innerHTML = \"<div style=\\\"color:#FF8A80; font-size:12px; padding: 5px 0;\\\">Error: \".concat(_context7.t1.message, \"</div>\");\n            case 72:\n              _context7.prev = 72;\n              // Re-enable UI\n              promptInput.disabled = false;\n              if (updateButton) {\n                updateButton.disabled = false;\n                updateButton.style.opacity = '1';\n                updateButton.style.cursor = 'pointer';\n              }\n              return _context7.finish(72);\n            case 76:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee6, this, [[12, 67, 72, 76], [33, 39]]);\n      }));\n      function sendEditRequest(_x2, _x3, _x4) {\n        return _sendEditRequest.apply(this, arguments);\n      }\n      return sendEditRequest;\n    }() // --- End of sendEditRequest ---\n    )\n  }, {\n    key: \"resizeImageToBase64\",\n    value: function resizeImageToBase64(originalBase64, mimeType, fileName) {\n      return new Promise(function (resolve, reject) {\n        var img = new Image();\n        img.onload = function () {\n          // Create a canvas to resize the image\n          var canvas = document.createElement('canvas');\n          canvas.width = 256;\n          canvas.height = 256;\n          var ctx = canvas.getContext('2d');\n\n          // Fill with black background to handle transparency\n          ctx.fillStyle = '#000000';\n          ctx.fillRect(0, 0, 256, 256);\n\n          // Draw the image with proper scaling to fit 256x256\n          // Using object-fit: cover behavior (preserve aspect ratio, crop if needed)\n          var aspectRatio = img.width / img.height;\n          var sourceX = 0,\n            sourceY = 0,\n            sourceWidth = img.width,\n            sourceHeight = img.height;\n          if (aspectRatio > 1) {\n            // Image is wider than tall\n            sourceWidth = img.height;\n            sourceX = (img.width - sourceWidth) / 2;\n          } else if (aspectRatio < 1) {\n            // Image is taller than wide\n            sourceHeight = img.width;\n            sourceY = (img.height - sourceHeight) / 2;\n          }\n\n          // Draw image centered and cropped to square\n          ctx.drawImage(img, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, 256, 256);\n\n          // Get base64 data URL\n          var resizedBase64 = canvas.toDataURL(mimeType || 'image/png');\n          resolve({\n            data: resizedBase64,\n            name: fileName,\n            type: mimeType\n          });\n        };\n        img.onerror = function (err) {\n          reject(new Error('Failed to load image for resizing'));\n        };\n\n        // Load the image from base64 data\n        img.src = originalBase64;\n      });\n    }\n\n    /**\n     * Confirm and register the shape\n     */\n  }, {\n    key: \"confirmShape\",\n    value: function confirmShape() {\n      var _this8 = this;\n      // Get the final parameters if available\n      var finalParams = window.finalShapeParams || {};\n\n      // Process the final shape with updated parameters\n      this.injectFinalShapeClass(this.currentGeneratedCode, this.currentClassName, this.currentDescription, finalParams);\n      if (this.controller.analytics) {\n        this.controller.analytics.createShape(this.currentClassName, this.currentDescription);\n      }\n\n      // IMPORTANT: Clear saved form state after successful shape creation\n      try {\n        localStorage.removeItem('shapeGeneratorFormState');\n        console.log('Successfully cleared shape generator form state');\n\n        // Also reset our local state\n        this.attachedImagesData = [];\n        this.currentDescription = null;\n      } catch (e) {\n        console.error('Error clearing form state:', e);\n      }\n\n      // Close the modal\n      var modal = document.getElementById('create-shape-modal');\n      if (modal) {\n        modal.remove();\n      }\n\n      // After a brief delay to allow for shape registration, show My Shapes modal\n      setTimeout(function () {\n        // Check if we have access to the user shapes manager\n        if (_this8.controller && _this8.controller.userShapesManager && typeof _this8.controller.userShapesManager.showMyShapesModal === 'function') {\n          // Check if user is authenticated\n          if (_this8.controller.auth && _this8.controller.auth.isAuthenticated()) {\n            // Call the showMyShapesModal method to display all user shapes\n            _this8.controller.userShapesManager.showMyShapesModal();\n          }\n        }\n      }, 500); // Short delay to ensure the shape has been registered and saved\n    }\n\n    /**\n    * Inject the final shape class into the app\n    */\n  }, {\n    key: \"injectFinalShapeClass\",\n    value: function injectFinalShapeClass(code, className, description) {\n      var params = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      try {\n        // Create a script to register the shape\n        var script = document.createElement('script');\n        script.type = 'text/javascript';\n\n        // Serialize parameters for injection\n        var serializedParams = JSON.stringify(params);\n\n        // Properly escape the description using JSON.stringify\n        var safeDescription = JSON.stringify(description || \"\");\n        script.textContent = \"\\n    (function() {\\n      try {\\n        // Ensure window.Shape exists before continuing\\n        if (!window.Shape) {\\n          throw new Error(\\\"window.Shape is not defined. Shape base class is missing.\\\");\\n        }\\n        \\n        // Define the shape class - no import or export statements\\n        \".concat(code, \"\\n        \\n        // Verify the class was defined\\n        if (typeof \").concat(className, \" !== 'function') {\\n          throw new Error(\\\"Shape class \").concat(className, \" was not properly defined\\\");\\n        }\\n        \\n        // If we have parameters, store the customized values\\n        const finalParams = \").concat(serializedParams, \";\\n        if (Object.keys(finalParams).length > 0) {\\n          // Store user-defined parameter values\\n          const userParams = {};\\n          \\n          // Extract current values from parameters\\n          Object.keys(finalParams).forEach(param => {\\n            if (finalParams[param] && finalParams[param].value !== undefined) {\\n              userParams[param] = finalParams[param].value;\\n            }\\n          });\\n          \\n          // Create a wrapper class that applies the custom parameters\\n          const OriginalClass = \").concat(className, \";\\n          \").concat(className, \" = class extends OriginalClass {\\n            constructor(props = {}) {\\n              // Merge user parameters with provided ones\\n              const mergedProps = { ...userParams, ...props };\\n              super(mergedProps);\\n            }\\n          };\\n          \\n          // Preserve original parameters for the UI\\n          \").concat(className, \".parameters = OriginalClass.parameters;\\n        }\\n        \\n        // Register the shape with the app\\n        if (window.shapeApp && window.shapeApp.shapes) {\\n          window.shapeApp.shapes['\").concat(className, \"'] = \").concat(className, \";\\n          console.log('Shape \").concat(className, \" registered successfully');\\n          \\n          // Refresh grid\\n          if (window.shapeApp.renderShapeGrid) {\\n            window.shapeApp.renderShapeGrid(true);\\n          }\\n          \\n          // Show success message\\n          const toast = document.createElement('div');\\n          toast.textContent = 'Shape added to your collection!';\\n          toast.style.position = 'fixed';\\n          toast.style.bottom = '20px';\\n          toast.style.left = '50%';\\n          toast.style.transform = 'translateX(-50%)';\\n          toast.style.backgroundColor = '#4CAF50';\\n          toast.style.color = 'white';\\n          toast.style.padding = '12px 20px';\\n          toast.style.borderRadius = '4px';\\n          toast.style.zIndex = '9999';\\n          toast.style.fontSize = '14px';\\n          toast.style.boxShadow = '0 2px 8px rgba(0,0,0,0.2)';\\n          document.body.appendChild(toast);\\n          \\n          setTimeout(() => {\\n            toast.style.opacity = '0';\\n            toast.style.transition = 'opacity 0.5s ease';\\n            setTimeout(() => toast.remove(), 500);\\n          }, 3000);\\n        } else {\\n          throw new Error(\\\"window.shapeApp or window.shapeApp.shapes is not defined\\\");\\n        }\\n      } catch (error) {\\n        console.error('Error creating shape:', error);\\n        \\n        // Create a fallback shape if the main one fails\\n        createFallbackShape('\").concat(className, \"', \").concat(safeDescription, \", JSON.stringify(error.message));\\n      }\\n    })();\\n    \\n    // Fallback function\\n    function createFallbackShape(className, description, errorMessage) {\\n      try {\\n        // Create a simplified version of the shape as fallback\\n        class FallbackShape extends window.Shape {\\n          static parameters = {\\n            size: { min: 10, max: 100, default: 50 },\\n            thickness: { min: 1, max: 10, default: 2 }\\n          };\\n          \\n          generateShape() {\\n            return '<circle cx=\\\"0\\\" cy=\\\"0\\\" r=\\\"' + this.size + '\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"' + this.thickness + '\\\" stroke-dasharray=\\\"5,5\\\"/>' + \\n                   '<text x=\\\"0\\\" y=\\\"0\\\" text-anchor=\\\"middle\\\" dominant-baseline=\\\"middle\\\" fill=\\\"white\\\" font-size=\\\"10\\\">Fallback Shape</text>' +\\n                   '<text x=\\\"0\\\" y=\\\"20\\\" text-anchor=\\\"middle\\\" fill=\\\"white\\\" font-size=\\\"8\\\">Error: ' + String(errorMessage).substring(0, 30) + '</text>';\\n          }\\n        }\\n        \\n        // Register the fallback shape\\n        if (window.shapeApp && window.shapeApp.shapes) {\\n          window.shapeApp.shapes[className] = FallbackShape;\\n          console.log('Fallback shape registered as ' + className);\\n          \\n          if (window.shapeApp.renderShapeGrid) {\\n            window.shapeApp.renderShapeGrid(true);\\n          }\\n          \\n          // Show fallback message\\n          const toast = document.createElement('div');\\n          toast.textContent = 'Created fallback shape due to error: ' + errorMessage;\\n          toast.style.position = 'fixed';\\n          toast.style.bottom = '20px';\\n          toast.style.left = '50%';\\n          toast.style.transform = 'translateX(-50%)';\\n          toast.style.backgroundColor = '#FF9800';\\n          toast.style.color = 'white';\\n          toast.style.padding = '12px 20px';\\n          toast.style.borderRadius = '4px';\\n          toast.style.zIndex = '9999';\\n          toast.style.fontSize = '14px';\\n          toast.style.maxWidth = '80%';\\n          toast.style.textAlign = 'center';\\n          document.body.appendChild(toast);\\n          \\n          setTimeout(() => {\\n            toast.style.opacity = '0';\\n            toast.style.transition = 'opacity 0.5s ease';\\n            setTimeout(() => toast.remove(), 500);\\n          }, 6000);\\n        }\\n      } catch (fallbackError) {\\n        console.error('Fallback creation also failed:', fallbackError);\\n      }\\n    }\\n    \");\n\n        // Add the script to the page\n        document.body.appendChild(script);\n        setTimeout(function () {\n          document.body.removeChild(script);\n        }, 200);\n      } catch (error) {\n        console.error('Error injecting final shape class:', error);\n        // Show error notification\n        var toast = document.createElement('div');\n        toast.textContent = 'Error adding shape: ' + error.message;\n        toast.style.position = 'fixed';\n        toast.style.bottom = '20px';\n        toast.style.left = '50%';\n        toast.style.transform = 'translateX(-50%)';\n        toast.style.backgroundColor = '#FF5555';\n        toast.style.color = 'white';\n        toast.style.padding = '12px 20px';\n        toast.style.borderRadius = '4px';\n        toast.style.zIndex = '9999';\n        toast.style.fontSize = '14px';\n        document.body.appendChild(toast);\n        setTimeout(function () {\n          toast.style.opacity = '0';\n          toast.style.transition = 'opacity 0.5s ease';\n          setTimeout(function () {\n            return toast.remove();\n          }, 500);\n        }, 3000);\n      }\n    }\n\n    /**\n     * Helper method to show error messages in the modal\n     */\n    // showErrorInModal(message) {\n    //   const modal = document.getElementById('create-shape-modal');\n    //   if (!modal) return;\n\n    //   // Remove any existing error messages\n    //   const existingErrors = modal.querySelectorAll('.error-message');\n    //   existingErrors.forEach(el => el.remove());\n\n    //   const errorMessage = document.createElement('div');\n    //   errorMessage.className = 'error-message';\n    //   errorMessage.textContent = `Error: ${message}`;\n    //   errorMessage.style.color = '#FF5555';\n    //   errorMessage.style.padding = '12px';\n    //   errorMessage.style.marginTop = '12px';\n    //   errorMessage.style.backgroundColor = 'rgba(255, 85, 85, 0.1)';\n    //   errorMessage.style.borderRadius = '4px';\n    //   errorMessage.style.fontSize = '12px';\n\n    //   // Find and insert before the button group\n    //   const buttonGroup = modal.querySelector('form > div:last-child');\n    //   if (buttonGroup) {\n    //     buttonGroup.parentNode.insertBefore(errorMessage, buttonGroup);\n    //   } else {\n    //     // If button group not found, append to the modal content\n    //     const modalContent = modal.querySelector('.modal-content');\n    //     if (modalContent) {\n    //       modalContent.appendChild(errorMessage);\n    //     }\n    //   }\n    // }\n  }, {\n    key: \"showErrorInModal\",\n    value: function showErrorInModal(message) {\n      var containerId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var targetContainer = null;\n      if (containerId) {\n        targetContainer = document.getElementById(containerId);\n      }\n      var modalContent = document.querySelector('#create-shape-modal .modal-content');\n      if (!modalContent) {\n        alert(\"Error: \".concat(message));\n        return;\n      } // Fallback alert if modal gone\n\n      // Remove previous errors in the target or globally in modal\n      var selector = targetContainer ? \"#\".concat(containerId, \" .error-message-display\") : '#create-shape-modal .error-message-display';\n      modalContent.querySelectorAll(selector).forEach(function (el) {\n        return el.remove();\n      });\n      var errorDiv = document.createElement('div');\n      errorDiv.className = 'error-message-display'; // Use a class\n      errorDiv.textContent = \"Error: \".concat(message);\n      // ... error styling ...\n      errorDiv.style.color = '#FF8A80'; /* Softer Red */\n      errorDiv.style.padding = '8px 10px';\n      errorDiv.style.marginTop = '10px';\n      errorDiv.style.backgroundColor = 'rgba(255, 138, 128, 0.1)'; /* Softer Red Background */\n      errorDiv.style.border = '1px solid rgba(255, 138, 128, 0.3)'; /* Softer Red Border */\n      errorDiv.style.borderRadius = '4px';\n      errorDiv.style.fontSize = '12px';\n      errorDiv.style.wordBreak = 'break-word';\n      if (targetContainer) {\n        targetContainer.appendChild(errorDiv); // Append to specific container\n        targetContainer.style.minHeight = 'auto'; // Adjust height if needed\n      } else {\n        // Fallback: Append before action buttons if possible\n        var actions = modalContent.querySelector('.actions-container'); // Assume actions have this class\n        if (actions) {\n          modalContent.insertBefore(errorDiv, actions);\n        } else {\n          modalContent.appendChild(errorDiv); // Append to end as last resort\n        }\n      }\n    }\n  }]);\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ShapeGenerator);\n\n//# sourceURL=webpack://generative-shapes/./src/ShapeGenerator.js?");

/***/ }),

/***/ "./src/ShapeHistory.js":
/*!*****************************!*\
  !*** ./src/ShapeHistory.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, \"catch\": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar ShapeHistory = /*#__PURE__*/function () {\n  function ShapeHistory(controller) {\n    _classCallCheck(this, ShapeHistory);\n    this.controller = controller;\n    // Store history separately for each shape\n    this.historyByShape = {};\n    this.currentShapeName = null;\n    this.maxHistorySize = 100;\n    this.lastDatabaseSaveTime = 0;\n    this.minTimeBetweenSaves = 3000; // 3 seconds minimum between database saves\n\n    this.isRestoring = false;\n\n    // Auto-save configuration\n    this.autoSaveEnabled = true; // Enable auto-save by default\n    this.autoSaveTimeout = null; // For debouncing\n    this.currentShapeId = null; // Track the current shape ID for saving\n  }\n  return _createClass(ShapeHistory, [{\n    key: \"initShapeHistory\",\n    value: function initShapeHistory(shapeName) {\n      if (!shapeName) return;\n\n      // Initialize history for this shape if it doesn't exist\n      if (!this.historyByShape[shapeName]) {\n        this.historyByShape[shapeName] = {\n          states: [],\n          currentIndex: -1\n        };\n      }\n      this.currentShapeName = shapeName;\n\n      // Look up the shape ID for database operations\n      this.findShapeId(shapeName);\n    }\n\n    /**\n     * Find the database ID for a shape by name\n     */\n  }, {\n    key: \"findShapeId\",\n    value: function findShapeId(shapeName) {\n      // Reset current shape ID\n      this.currentShapeId = null;\n\n      // Check if we have access to user shapes manager\n      if (!this.controller.userShapesManager) return;\n\n      // Look for the shape in loaded user shapes\n      var userShapes = this.controller.userShapesManager.userShapes || [];\n      var shape = userShapes.find(function (s) {\n        return s.shape_name === shapeName;\n      });\n      if (shape && shape.id) {\n        this.currentShapeId = shape.id;\n        console.log(\"Found shape ID for \\\"\".concat(shapeName, \"\\\": \").concat(this.currentShapeId));\n      }\n    }\n  }, {\n    key: \"saveState\",\n    value: function saveState() {\n      var isSilent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      if (this.isRestoring || !this.currentShapeName) return;\n      var shapeHistory = this.historyByShape[this.currentShapeName];\n      if (!shapeHistory) return;\n\n      // State object to store both parameters and style information\n      var state = {\n        parameters: {},\n        styleParams: {}\n      };\n\n      // If editor is open, use its parameters and style settings\n      if (this.controller.editor && this.controller.editor.editorOpen) {\n        // Save parameters\n        state.parameters = _objectSpread({}, this.controller.editor.parameters);\n\n        // Save style parameters if available\n        if (this.controller.editor.styleController) {\n          state.styleParams = _objectSpread({}, this.controller.editor.styleController.styleParams);\n        }\n      }\n      // Otherwise use controller parameters\n      else if (this.controller.parameters) {\n        state.parameters = _objectSpread({}, this.controller.parameters);\n      }\n\n      // If we're not at the end of history, remove future states\n      if (shapeHistory.currentIndex < shapeHistory.states.length - 1) {\n        shapeHistory.states = shapeHistory.states.slice(0, shapeHistory.currentIndex + 1);\n      }\n\n      // Add new state\n      shapeHistory.states.push(state);\n      shapeHistory.currentIndex++;\n\n      // Remove oldest state if exceeding max size\n      if (shapeHistory.states.length > this.maxHistorySize) {\n        shapeHistory.states.shift();\n        shapeHistory.currentIndex--;\n      }\n      this.updateButtonsState();\n\n      // Now trigger auto-save functionality\n      // this.autoSaveCurrentState();\n\n      // Only trigger auto-save notification for non-silent saves\n      if (!isSilent) {\n        this.autoSaveCurrentState();\n      }\n    }\n\n    /**\n     * Auto-save current state to database after debouncing\n     */\n  }, {\n    key: \"autoSaveCurrentState\",\n    value: function autoSaveCurrentState() {\n      var _this = this;\n      // Skip if auto-save is disabled or we don't have a shape ID\n      if (!this.autoSaveEnabled || !this.currentShapeId) return;\n\n      // Clear any existing timeout\n      if (this.autoSaveTimeout) {\n        clearTimeout(this.autoSaveTimeout);\n      }\n\n      // Set a new timeout for debouncing (3 seconds)\n      this.autoSaveTimeout = setTimeout(function () {\n        _this.saveStateToDatabase();\n      }, 3000);\n    }\n\n    /**\n     * Save current state to database\n     */\n  }, {\n    key: \"saveStateToDatabase\",\n    value: (function () {\n      var _saveStateToDatabase = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var currentState, updateData, result;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!(!this.currentShapeId || !this.controller.userShapesManager)) {\n                _context.next = 2;\n                break;\n              }\n              return _context.abrupt(\"return\");\n            case 2:\n              _context.prev = 2;\n              // Get current state\n              currentState = this.getCurrentState();\n              if (currentState) {\n                _context.next = 6;\n                break;\n              }\n              return _context.abrupt(\"return\");\n            case 6:\n              // Prepare update data\n              updateData = {\n                parameters: currentState.parameters || {},\n                styleParams: currentState.styleParams || {}\n              }; // Call the update method\n              _context.next = 9;\n              return this.controller.userShapesManager.updateShapeInDatabase(this.currentShapeId, updateData);\n            case 9:\n              result = _context.sent;\n              if (result.success) {\n                console.log(\"Auto-saved shape \\\"\".concat(this.currentShapeName, \"\\\" successfully\"));\n\n                // Show subtle success indicator (optional)\n                this.showAutoSaveIndicator();\n              } else {\n                console.error(\"Auto-save failed for shape \\\"\".concat(this.currentShapeName, \"\\\":\"), result.error);\n              }\n              _context.next = 16;\n              break;\n            case 13:\n              _context.prev = 13;\n              _context.t0 = _context[\"catch\"](2);\n              console.error('Error during auto-save:', _context.t0);\n            case 16:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[2, 13]]);\n      }));\n      function saveStateToDatabase() {\n        return _saveStateToDatabase.apply(this, arguments);\n      }\n      return saveStateToDatabase;\n    }()\n    /**\n     * Get the current state from history\n     */\n    )\n  }, {\n    key: \"getCurrentState\",\n    value: function getCurrentState() {\n      if (!this.currentShapeName) return null;\n      var shapeHistory = this.historyByShape[this.currentShapeName];\n      if (!shapeHistory || shapeHistory.currentIndex < 0 || shapeHistory.states.length === 0) return null;\n      return shapeHistory.states[shapeHistory.currentIndex];\n    }\n\n    /**\n     * Show a subtle auto-save success indicator\n     */\n  }, {\n    key: \"showAutoSaveIndicator\",\n    value: function showAutoSaveIndicator() {\n      // Find or create the indicator element\n      var indicator = document.getElementById('auto-save-indicator');\n      if (!indicator) {\n        indicator = document.createElement('div');\n        indicator.id = 'auto-save-indicator';\n\n        // Fixed position in the center of top header\n        indicator.style.position = 'fixed';\n        indicator.style.top = '14px';\n        indicator.style.left = '50%';\n        indicator.style.transform = 'translateX(-50%)';\n\n        // Subtle styling\n        indicator.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';\n        indicator.style.color = '#fff';\n        indicator.style.padding = '6px 12px';\n        indicator.style.borderRadius = '30px';\n        indicator.style.fontSize = '12px';\n        indicator.style.fontFamily = \"'Menlo', 'Monaco', 'Courier New', monospace\";\n        indicator.style.opacity = '0';\n        indicator.style.transition = 'opacity 0.8s ease';\n        indicator.style.zIndex = '9999';\n        indicator.style.pointerEvents = 'none';\n        document.body.appendChild(indicator);\n      }\n\n      // Clear any existing timeout\n      if (this._indicatorTimeout) {\n        clearTimeout(this._indicatorTimeout);\n      }\n\n      // Set text content\n      indicator.textContent = 'Changes saved';\n\n      // Force a reflow before changing opacity to ensure transition applies\n      indicator.offsetHeight; // This forces a reflow\n\n      // Now set opacity to trigger the transition\n      indicator.style.opacity = '0.85';\n\n      // Fade out after delay\n      this._indicatorTimeout = setTimeout(function () {\n        indicator.style.opacity = '0';\n      }, 2000);\n    }\n  }, {\n    key: \"restoreState\",\n    value: function restoreState(state) {\n      if (!state) return;\n      try {\n        this.isRestoring = true;\n\n        // Restore parameters\n        if (state.parameters) {\n          this.controller.parameters = _objectSpread({}, state.parameters);\n        }\n\n        // Check if we should update through editor or controller\n        if (this.controller.editor && this.controller.editor.editorOpen) {\n          // If editor is open, update through editor\n          if (state.parameters) {\n            this.controller.editor.parameters = _objectSpread({}, state.parameters);\n          }\n\n          // Restore style parameters if available\n          if (state.styleParams && this.controller.editor.styleController) {\n            this.controller.editor.styleController.styleParams = _objectSpread({}, state.styleParams);\n          }\n\n          // Update the shape with combined parameter and style changes\n          this.controller.editor.updateShape();\n        } else {\n          // Otherwise use controller's method\n          this.controller.updateShape();\n        }\n      } finally {\n        this.isRestoring = false;\n      }\n    }\n  }, {\n    key: \"undo\",\n    value: function undo() {\n      if (!this.currentShapeName) return;\n      var shapeHistory = this.historyByShape[this.currentShapeName];\n      if (!shapeHistory || shapeHistory.currentIndex <= 0) return;\n      shapeHistory.currentIndex--;\n      this.restoreState(shapeHistory.states[shapeHistory.currentIndex]);\n      this.updateButtonsState();\n\n      // Auto-save after undo\n      this.autoSaveCurrentState();\n    }\n  }, {\n    key: \"redo\",\n    value: function redo() {\n      if (!this.currentShapeName) return;\n      var shapeHistory = this.historyByShape[this.currentShapeName];\n      if (!shapeHistory || shapeHistory.currentIndex >= shapeHistory.states.length - 1) return;\n      shapeHistory.currentIndex++;\n      this.restoreState(shapeHistory.states[shapeHistory.currentIndex]);\n      this.updateButtonsState();\n\n      // Auto-save after redo\n      this.autoSaveCurrentState();\n    }\n  }, {\n    key: \"updateButtonsState\",\n    value: function updateButtonsState() {\n      var undoBtn = document.getElementById('undoBtn');\n      var redoBtn = document.getElementById('redoBtn');\n      if (!this.currentShapeName) {\n        if (undoBtn) undoBtn.disabled = true;\n        if (redoBtn) redoBtn.disabled = true;\n        return;\n      }\n      var shapeHistory = this.historyByShape[this.currentShapeName];\n      if (undoBtn) {\n        undoBtn.disabled = !shapeHistory || shapeHistory.currentIndex <= 0;\n      }\n      if (redoBtn) {\n        redoBtn.disabled = !shapeHistory || shapeHistory.currentIndex >= shapeHistory.states.length - 1;\n      }\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      if (this.currentShapeName) {\n        this.historyByShape[this.currentShapeName] = {\n          states: [],\n          currentIndex: -1\n        };\n        this.updateButtonsState();\n      }\n    }\n  }]);\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ShapeHistory);\n\n//# sourceURL=webpack://generative-shapes/./src/ShapeHistory.js?");

/***/ }),

/***/ "./src/ShapeParameterControls.js":
/*!***************************************!*\
  !*** ./src/ShapeParameterControls.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n/**\n * ShapeParameterControls.js\n * Handles creation and management of parameter controls for the ShapeEditor\n */\nvar ShapeParameterControls = /*#__PURE__*/function () {\n  function ShapeParameterControls(editor) {\n    _classCallCheck(this, ShapeParameterControls);\n    this.editor = editor;\n  }\n\n  /**\n   * Create parameter controls with dark theme\n   * @param {Object} parameters - Parameter definitions\n   * @param {HTMLElement} container - Container for the controls\n   */\n  return _createClass(ShapeParameterControls, [{\n    key: \"createControls\",\n    value: function createControls(parameters, container) {\n      var _this = this;\n      Object.entries(parameters).forEach(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n          param = _ref2[0],\n          config = _ref2[1];\n        if (param === 'seed') return; // skip seed if needed\n\n        var paramContainer = document.createElement('div');\n        paramContainer.className = 'control-row';\n\n        // For options\n        if (config.options) {\n          // Create a select dropdown\n          var select = document.createElement('select');\n          select.className = 'param-select';\n          select.style.backgroundColor = '#000';\n          select.style.color = '#e0e0e0';\n          select.style.border = '1px solid #333';\n          select.style.borderRadius = '4px';\n          select.style.padding = '10px 8px'; // Increased padding for touch\n          select.style.fontFamily = \"'Menlo', 'Monaco', 'Courier New', monospace\";\n          select.style.fontSize = '12px'; // Slightly larger for readability\n          select.style.width = '100%';\n          select.style.cursor = 'pointer';\n          select.style.appearance = 'none'; // Better for mobile styling\n          select.style.backgroundImage = \"url(\\\"data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23999' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e\\\")\";\n          select.style.backgroundRepeat = 'no-repeat';\n          select.style.backgroundPosition = 'right 8px center';\n          select.style.backgroundSize = '16px';\n          select.setAttribute('data-param', param);\n          config.options.forEach(function (option) {\n            var opt = document.createElement('option');\n            opt.value = option;\n            opt.textContent = option;\n            if (option === _this.editor.parameters[param]) opt.selected = true;\n            select.appendChild(opt);\n          });\n          select.addEventListener('change', function () {\n            _this.editor.parameters[param] = select.value;\n            _this.editor.updateShape();\n            if (_this.editor.controller.history) {\n              _this.editor.controller.history.saveState();\n            }\n          });\n          paramContainer.appendChild(select);\n        } else if (config.min !== undefined && config.max !== undefined) {\n          // Create a container with value display\n          var sliderContainer = document.createElement('div');\n          sliderContainer.style.display = 'flex';\n          sliderContainer.style.alignItems = 'center';\n          sliderContainer.style.width = '100%';\n          sliderContainer.style.gap = '8px';\n\n          // Numeric range (slider)\n          var slider = document.createElement('input');\n          slider.type = 'range';\n          slider.min = config.min;\n          slider.max = config.max;\n          slider.step = Number.isInteger(config[\"default\"]) ? '1' : '0.1';\n          slider.value = _this.editor.parameters[param];\n          slider.className = 'param-slider';\n          slider.setAttribute('data-param', param);\n          slider.style.flex = '1';\n\n          // Slider input with debounce for performance\n          var debounceTimer = null;\n          var isDragging = false;\n\n          // Track when user starts dragging\n          slider.addEventListener('mousedown', function () {\n            isDragging = true;\n          });\n\n          // Track when user stops dragging anywhere in the document\n          document.addEventListener('mouseup', function () {\n            if (isDragging) {\n              isDragging = false;\n              // Save state only when user completes the drag operation\n              if (_this.editor.controller.history) {\n                _this.editor.controller.history.saveState();\n              }\n            }\n          });\n\n          // Handle continuous value changes during sliding\n          slider.addEventListener('input', function (e) {\n            var value = e.target.value;\n            var floatVal = parseFloat(value);\n            var processed = isNaN(floatVal) ? config[\"default\"] : Number.isInteger(config[\"default\"]) ? Math.round(floatVal) : parseFloat(floatVal.toFixed(2));\n            _this.editor.parameters[param] = processed;\n            _this.editor.updateShape();\n\n            // Clear any existing timeout\n            clearTimeout(debounceTimer);\n\n            // Only save state if not actively dragging and significant time has passed\n            debounceTimer = setTimeout(function () {\n              // Only save if user has stopped interacting for a while (1 second)\n              if (!isDragging && _this.editor.controller.history) {\n                _this.editor.controller.history.saveState();\n              }\n            }, 1000); // Increased from 300ms to 1000ms\n          });\n          sliderContainer.appendChild(slider);\n          paramContainer.appendChild(sliderContainer);\n        } else if (typeof _this.editor.parameters[param] === 'boolean') {\n          // Improved boolean parameter -> checkbox/toggle\n          var toggleContainer = document.createElement('div');\n          toggleContainer.style.display = 'flex';\n          toggleContainer.style.alignItems = 'center';\n          toggleContainer.style.gap = '8px';\n\n          // Create toggle switch instead of checkbox\n          var toggle = document.createElement('div');\n          toggle.className = 'toggle-switch';\n          toggle.style.position = 'relative';\n          toggle.style.width = '36px';\n          toggle.style.height = '20px';\n          toggle.style.backgroundColor = _this.editor.parameters[param] ? '#555' : '#222';\n          toggle.style.borderRadius = '10px';\n          toggle.style.cursor = 'pointer';\n          toggle.style.transition = 'background-color 0.2s';\n          var toggleHandle = document.createElement('div');\n          toggleHandle.style.position = 'absolute';\n          toggleHandle.style.width = '16px';\n          toggleHandle.style.height = '16px';\n          toggleHandle.style.top = '2px';\n          toggleHandle.style.left = _this.editor.parameters[param] ? '18px' : '2px';\n          toggleHandle.style.backgroundColor = '#e0e0e0';\n          toggleHandle.style.borderRadius = '50%';\n          toggleHandle.style.transition = 'left 0.2s';\n          toggle.appendChild(toggleHandle);\n\n          // Label\n          var toggleLabel = document.createElement('span');\n          toggleLabel.textContent = _this.editor.parameters[param] ? 'On' : 'Off';\n          toggleLabel.style.fontSize = '12px';\n          toggleLabel.style.color = '#888';\n          toggle.addEventListener('click', function () {\n            _this.editor.parameters[param] = !_this.editor.parameters[param];\n            toggle.style.backgroundColor = _this.editor.parameters[param] ? '#555' : '#222';\n            toggleHandle.style.left = _this.editor.parameters[param] ? '18px' : '2px';\n            toggleLabel.textContent = _this.editor.parameters[param] ? 'On' : 'Off';\n            _this.editor.updateShape();\n            if (_this.editor.controller.history) {\n              _this.editor.controller.history.saveState();\n            }\n          });\n          toggleContainer.appendChild(toggle);\n          toggleContainer.appendChild(toggleLabel);\n          paramContainer.appendChild(toggleContainer);\n        } else {\n          // Generic text input - improved for mobile\n          var input = document.createElement('input');\n          input.type = 'text';\n          input.className = 'param-text';\n          input.setAttribute('data-param', param);\n          input.value = _this.editor.parameters[param];\n          input.style.backgroundColor = '#222';\n          input.style.color = '#e0e0e0';\n          input.style.border = '1px solid #333';\n          input.style.borderRadius = '4px';\n          input.style.padding = '10px 8px'; // Increased for touch\n          input.style.fontFamily = \"'Menlo', 'Monaco', 'Courier New', monospace\";\n          input.style.fontSize = '14px'; // Larger for mobile\n          input.style.width = '100%';\n          input.addEventListener('change', function () {\n            var numValue = parseFloat(input.value);\n            _this.editor.parameters[param] = isNaN(numValue) ? input.value : numValue;\n            _this.editor.updateShape();\n            if (_this.editor.controller.history) {\n              _this.editor.controller.history.saveState();\n            }\n          });\n          paramContainer.appendChild(input);\n        }\n\n        // Add parameter name label - positioned above control\n        var nameLabel = document.createElement('span');\n        nameLabel.className = 'param-name';\n        nameLabel.textContent = param.charAt(0).toUpperCase() + param.slice(1);\n        paramContainer.insertBefore(nameLabel, paramContainer.firstChild);\n        container.appendChild(paramContainer);\n      });\n    }\n\n    /**\n     * Update parameter controls to reflect current values\n     */\n  }, {\n    key: \"updateParameterControls\",\n    value: function updateParameterControls() {\n      var _this2 = this;\n      // For every input with a data-param attribute, update its value\n      document.querySelectorAll('[data-param]').forEach(function (input) {\n        var param = input.getAttribute('data-param');\n        if (_this2.editor.parameters.hasOwnProperty(param)) {\n          if (input.type === 'range' || input.type === 'text') {\n            input.value = _this2.editor.parameters[param];\n          } else if (input.tagName === 'SELECT') {\n            Array.from(input.options).forEach(function (option) {\n              option.selected = option.value === _this2.editor.parameters[param];\n            });\n          }\n        }\n      });\n    }\n  }]);\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ShapeParameterControls);\n\n//# sourceURL=webpack://generative-shapes/./src/ShapeParameterControls.js?");

/***/ }),

/***/ "./src/ShapeStyleController.js":
/*!*************************************!*\
  !*** ./src/ShapeStyleController.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _stylePresets_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stylePresets.js */ \"./src/stylePresets.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar ShapeStyleController = /*#__PURE__*/function () {\n  function ShapeStyleController(editor) {\n    _classCallCheck(this, ShapeStyleController);\n    this.editor = editor;\n    this.styleParams = {\n      // Fill properties\n      fillType: 'none',\n      // Default to no fill to match the black background\n      fillColor: '#000000',\n      // Black fill\n      fillOpacity: 1.0,\n      // Fill gradient properties\n      fillGradientColor1: '#3498DB',\n      fillGradientColor2: '#9B59B6',\n      fillGradientAngle: 90,\n      // Stroke properties\n      strokeType: 'solid',\n      // Default to solid stroke\n      strokeColor: '#FFFFFF',\n      // White stroke\n      strokeWidth: 1,\n      // Stroke gradient properties\n      strokeGradientColor1: '#3498DB',\n      strokeGradientColor2: '#9B59B6',\n      strokeGradientAngle: 90\n    };\n\n    // Import style presets from external file\n    this.stylePresets = _stylePresets_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n\n    // Store original parameters for reset\n    this.originalStyleParams = _objectSpread({}, this.styleParams);\n\n    // Bind methods\n    this.createStyleControls = this.createStyleControls.bind(this);\n    this.updateShapeStyle = this.updateShapeStyle.bind(this);\n    this.createCompactColorInput = this.createCompactColorInput.bind(this);\n    this.applyStylesToSVG = this.applyStylesToSVG.bind(this);\n    this.saveStyleSettings = this.saveStyleSettings.bind(this);\n    this.loadStyleSettings = this.loadStyleSettings.bind(this);\n    this.resetStyle = this.resetStyle.bind(this);\n    this.applyStylePreset = this.applyStylePreset.bind(this);\n    this.randomizeStyle = this.randomizeStyle.bind(this);\n    this.resetToDefaultStyle = this.resetToDefaultStyle.bind(this);\n  }\n  return _createClass(ShapeStyleController, [{\n    key: \"resetToDefaultStyle\",\n    value: function resetToDefaultStyle() {\n      // Reset style parameters to original defaults\n      this.styleParams = _objectSpread({}, this.originalStyleParams);\n    }\n\n    /**\n     * Apply a style preset to the current shape\n     */\n  }, {\n    key: \"applyStylePreset\",\n    value: function applyStylePreset(presetName) {\n      var _this$editor, _this$editor2;\n      var preset = this.stylePresets[presetName];\n      if (!preset) return;\n\n      // Preserve current params as a base\n      var newParams = _objectSpread({}, this.styleParams);\n\n      // Apply all properties from the preset\n      Object.keys(preset).forEach(function (key) {\n        if (key !== 'name') {\n          newParams[key] = preset[key];\n        }\n      });\n\n      // Update style parameters\n      this.styleParams = newParams;\n\n      // Update shape\n      this.updateShapeStyle((_this$editor = this.editor) === null || _this$editor === void 0 ? void 0 : _this$editor.currentShape);\n\n      // Add this line to update the UI controls\n      this.updateStyleControls();\n\n      // Save state\n      if ((_this$editor2 = this.editor) !== null && _this$editor2 !== void 0 && (_this$editor2 = _this$editor2.controller) !== null && _this$editor2 !== void 0 && _this$editor2.history) {\n        this.editor.controller.history.saveState();\n      }\n      return true;\n    }\n\n    /**\n     * Generate a random style with some constraints for visual appeal\n     */\n  }, {\n    key: \"randomizeStyle\",\n    value: function randomizeStyle() {\n      var _this$editor3, _this$editor4;\n      // New style params object\n      var newParams = _objectSpread({}, this.styleParams);\n\n      // Fill type decision\n      var fillTypeRoll = Math.random();\n      if (fillTypeRoll < 0.4) {\n        newParams.fillType = 'solid';\n        newParams.fillColor = this.getRandomColor();\n      } else if (fillTypeRoll < 0.8) {\n        newParams.fillType = Math.random() < 0.7 ? 'linearGradient' : 'radialGradient';\n        newParams.fillGradientColor1 = this.getRandomColor();\n        newParams.fillGradientColor2 = this.getRandomColor();\n        newParams.fillGradientAngle = Math.floor(Math.random() * 360);\n      } else {\n        newParams.fillType = 'none';\n      }\n\n      // Fill opacity\n      newParams.fillOpacity = newParams.fillType !== 'none' ? 0.6 + Math.random() * 0.4 : 1.0; // More opaque than transparent\n\n      // Stroke decisions - if no fill, always have a stroke\n      if (newParams.fillType === 'none') {\n        newParams.strokeType = 'solid';\n      } else {\n        var strokeTypeRoll = Math.random();\n        if (strokeTypeRoll < 0.4) {\n          newParams.strokeType = 'none';\n        } else if (strokeTypeRoll < 0.7) {\n          newParams.strokeType = 'solid';\n        } else if (strokeTypeRoll < 0.9) {\n          newParams.strokeType = Math.random() < 0.5 ? 'linearGradient' : 'radialGradient';\n          newParams.strokeGradientColor1 = this.getRandomColor();\n          newParams.strokeGradientColor2 = this.getRandomColor();\n          newParams.strokeGradientAngle = Math.floor(Math.random() * 360);\n        } else {\n          newParams.strokeType = 'solid';\n        }\n      }\n\n      // Stroke properties\n      if (newParams.strokeType !== 'none') {\n        newParams.strokeColor = this.getRandomColor();\n        newParams.strokeWidth = 0.5 + Math.random() * 3; // 0.5 to 3.5\n      }\n\n      // Prevent invisible shapes (no fill and no stroke)\n      if (newParams.fillType === 'none' && newParams.strokeType === 'none') {\n        newParams.strokeType = 'solid';\n        newParams.strokeColor = this.getRandomColor();\n        newParams.strokeWidth = 1 + Math.random() * 2; // 1 to 3\n      }\n\n      // Sometimes use a color theme for better visual harmony\n      if (Math.random() < 0.3) {\n        var baseColor = this.getRandomColor();\n        var harmonicColors = this.generateHarmonicColors(baseColor);\n        if (newParams.fillType === 'solid') {\n          newParams.fillColor = baseColor;\n        } else if (newParams.fillType.includes('Gradient')) {\n          newParams.fillGradientColor1 = baseColor;\n          newParams.fillGradientColor2 = harmonicColors[0];\n        }\n        if (newParams.strokeType === 'solid') {\n          newParams.strokeColor = harmonicColors[1];\n        } else if (newParams.strokeType.includes('Gradient')) {\n          newParams.strokeGradientColor1 = harmonicColors[1];\n          newParams.strokeGradientColor2 = harmonicColors[2];\n        }\n      }\n\n      // Update style parameters\n      this.styleParams = newParams;\n\n      // Update shape\n      this.updateShapeStyle((_this$editor3 = this.editor) === null || _this$editor3 === void 0 ? void 0 : _this$editor3.currentShape);\n\n      // Save state\n      if ((_this$editor4 = this.editor) !== null && _this$editor4 !== void 0 && (_this$editor4 = _this$editor4.controller) !== null && _this$editor4 !== void 0 && _this$editor4.history) {\n        this.editor.controller.history.saveState();\n      }\n      return true;\n    }\n\n    /**\n     * Generate a random color in hex format\n     */\n  }, {\n    key: \"getRandomColor\",\n    value: function getRandomColor() {\n      // Bright and visually appealing colors, avoid dull colors\n      var hue = Math.floor(Math.random() * 360);\n      var saturation = 50 + Math.floor(Math.random() * 50); // 50-100%\n      var lightness = 30 + Math.floor(Math.random() * 50); // 30-80%\n\n      // Convert HSL to Hex\n      var h = hue / 360;\n      var s = saturation / 100;\n      var l = lightness / 100;\n      var r, g, b;\n      if (s === 0) {\n        r = g = b = l; // achromatic\n      } else {\n        var hue2rgb = function hue2rgb(p, q, t) {\n          if (t < 0) t += 1;\n          if (t > 1) t -= 1;\n          if (t < 1 / 6) return p + (q - p) * 6 * t;\n          if (t < 1 / 2) return q;\n          if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n          return p;\n        };\n        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n        var p = 2 * l - q;\n        r = hue2rgb(p, q, h + 1 / 3);\n        g = hue2rgb(p, q, h);\n        b = hue2rgb(p, q, h - 1 / 3);\n      }\n      var toHex = function toHex(x) {\n        var hex = Math.round(x * 255).toString(16);\n        return hex.length === 1 ? '0' + hex : hex;\n      };\n      return \"#\".concat(toHex(r)).concat(toHex(g)).concat(toHex(b));\n    }\n\n    /**\n     * Generate harmonic colors based on a base color\n     */\n  }, {\n    key: \"generateHarmonicColors\",\n    value: function generateHarmonicColors(baseColor) {\n      // Convert hex to HSL\n      var r = parseInt(baseColor.slice(1, 3), 16) / 255;\n      var g = parseInt(baseColor.slice(3, 5), 16) / 255;\n      var b = parseInt(baseColor.slice(5, 7), 16) / 255;\n      var max = Math.max(r, g, b);\n      var min = Math.min(r, g, b);\n      var h,\n        s,\n        l = (max + min) / 2;\n      if (max === min) {\n        h = s = 0; // achromatic\n      } else {\n        var d = max - min;\n        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n        switch (max) {\n          case r:\n            h = (g - b) / d + (g < b ? 6 : 0);\n            break;\n          case g:\n            h = (b - r) / d + 2;\n            break;\n          case b:\n            h = (r - g) / d + 4;\n            break;\n        }\n        h /= 6;\n      }\n\n      // Create harmonic colors\n      var colors = [];\n\n      // Complementary color (opposite on color wheel)\n      var h1 = (h + 0.5) % 1;\n      colors.push(this.hslToHex(h1, s, l));\n\n      // Analogous color (adjacent on color wheel)\n      var h2 = (h + 0.1) % 1;\n      colors.push(this.hslToHex(h2, s, l));\n\n      // Triadic color\n      var h3 = (h + 0.33) % 1;\n      colors.push(this.hslToHex(h3, s, l));\n      return colors;\n    }\n\n    /**\n     * Convert HSL to Hex color\n     */\n  }, {\n    key: \"hslToHex\",\n    value: function hslToHex(h, s, l) {\n      var r, g, b;\n      if (s === 0) {\n        r = g = b = l; // achromatic\n      } else {\n        var hue2rgb = function hue2rgb(p, q, t) {\n          if (t < 0) t += 1;\n          if (t > 1) t -= 1;\n          if (t < 1 / 6) return p + (q - p) * 6 * t;\n          if (t < 1 / 2) return q;\n          if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n          return p;\n        };\n        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n        var p = 2 * l - q;\n        r = hue2rgb(p, q, h + 1 / 3);\n        g = hue2rgb(p, q, h);\n        b = hue2rgb(p, q, h - 1 / 3);\n      }\n      var toHex = function toHex(x) {\n        var hex = Math.round(x * 255).toString(16);\n        return hex.length === 1 ? '0' + hex : hex;\n      };\n      return \"#\".concat(toHex(r)).concat(toHex(g)).concat(toHex(b));\n    }\n\n    /**\n     * Load style settings from localStorage\n     */\n  }, {\n    key: \"loadStyleSettings\",\n    value: function loadStyleSettings(shapeName) {\n      if (!shapeName) return;\n\n      // Reset to defaults first\n      this.styleParams = _objectSpread({}, this.originalStyleParams);\n      try {\n        var savedStyles = localStorage.getItem('shapeStyleRegistry');\n        if (savedStyles) {\n          var registry = JSON.parse(savedStyles);\n          if (registry[shapeName]) {\n            this.styleParams = _objectSpread(_objectSpread({}, this.styleParams), registry[shapeName]);\n          }\n        }\n      } catch (error) {\n        console.error('Error loading style settings:', error);\n      }\n    }\n\n    /**\n     * Save style settings to localStorage\n     */\n  }, {\n    key: \"saveStyleSettings\",\n    value: function saveStyleSettings(shapeName) {\n      if (!shapeName) return;\n      try {\n        var registry = {};\n        var savedStyles = localStorage.getItem('shapeStyleRegistry');\n        if (savedStyles) {\n          registry = JSON.parse(savedStyles);\n        }\n        registry[shapeName] = _objectSpread({}, this.styleParams);\n        localStorage.setItem('shapeStyleRegistry', JSON.stringify(registry));\n      } catch (error) {\n        console.error('Error saving style settings:', error);\n      }\n    }\n  }, {\n    key: \"createStyleControls\",\n    value: function createStyleControls(container) {\n      var _this = this;\n      // First, remove ANY existing style controls from the entire document\n      var existingPresetRows = document.querySelectorAll('.preset-row');\n      existingPresetRows.forEach(function (row) {\n        return row.remove();\n      });\n      var existingStyleRows = document.querySelectorAll('.style-row');\n      existingStyleRows.forEach(function (row) {\n        return row.remove();\n      });\n\n      // Create the combined style section\n      var styleRow = document.createElement('div');\n      styleRow.className = 'style-row';\n      styleRow.id = 'style-control-row';\n      styleRow.style.display = 'flex';\n      styleRow.style.flexDirection = 'column';\n      styleRow.style.gap = '12px';\n      styleRow.style.padding = '8px 0';\n\n      // Create label for styles\n      var styleLabel = document.createElement('span');\n      styleLabel.className = 'param-name';\n      styleLabel.textContent = 'STYLES';\n      styleLabel.style.fontSize = '10px';\n      styleLabel.style.marginBottom = '8px';\n      styleRow.appendChild(styleLabel);\n\n      // Create a container for style previews and controls\n      var styleControls = document.createElement('div');\n      styleControls.style.display = 'flex';\n      styleControls.style.flexWrap = 'wrap';\n      styleControls.style.alignItems = 'center';\n      styleControls.style.gap = '10px';\n      styleControls.style.width = '100%';\n\n      // Create the scrollable presets container with a fixed width\n      var presetsOuterContainer = document.createElement('div');\n      presetsOuterContainer.style.display = 'flex';\n      presetsOuterContainer.style.alignItems = 'center';\n      presetsOuterContainer.style.gap = '5px';\n      presetsOuterContainer.style.maxWidth = '360px'; // Limit width\n\n      // Create a scrollable wrapper for presets\n      var presetsScrollContainer = document.createElement('div');\n      presetsScrollContainer.style.display = 'flex';\n      presetsScrollContainer.style.overflowX = 'auto';\n      presetsScrollContainer.style.overflowY = 'hidden';\n      presetsScrollContainer.style.scrollbarWidth = 'none'; // Hide scrollbar in Firefox\n      presetsScrollContainer.style.msOverflowStyle = 'none'; // Hide scrollbar in IE/Edge\n      presetsScrollContainer.style.maxWidth = '330px'; // Control visible area\n      presetsScrollContainer.style.paddingBottom = '5px'; // Space for invisible scrollbar\n\n      // Add style to hide scrollbar for WebKit browsers\n      var scrollStyle = document.createElement('style');\n      scrollStyle.textContent = \"\\n          .presets-scroll-container::-webkit-scrollbar {\\n            display: none;\\n          }\\n        \";\n      document.head.appendChild(scrollStyle);\n      presetsScrollContainer.className = 'presets-scroll-container';\n\n      // Create the actual container for preset circles\n      var presetsContainer = document.createElement('div');\n      presetsContainer.style.display = 'flex';\n      presetsContainer.style.gap = '8px';\n      presetsContainer.style.alignItems = 'center';\n      presetsContainer.style.paddingLeft = '2px';\n      presetsContainer.style.paddingRight = '2px';\n\n      // Create a visual preview for random style (always first)\n      var randomPreview = this.createStylePreview('Random', null, function () {\n        _this.randomizeStyle();\n        _this.updateStyleControls(styleRow);\n      });\n      randomPreview.style.background = 'linear-gradient(45deg, #FF5E62, #FF9966, #2E3192, #1BFFFF, #FF61D2)';\n      randomPreview.style.backgroundSize = '400% 400%';\n      randomPreview.style.animation = 'gradient-shift 3s ease infinite';\n\n      // Create style for gradient animation\n      var styleElement = document.createElement('style');\n      styleElement.textContent = \"\\n          @keyframes gradient-shift {\\n            0% { background-position: 0% 50%; }\\n            50% { background-position: 100% 50%; }\\n            100% { background-position: 0% 50%; }\\n          }\\n        \";\n      document.head.appendChild(styleElement);\n      presetsContainer.appendChild(randomPreview);\n\n      // Add presets (each style preset)\n      var presetKeys = Object.keys(this.stylePresets);\n      presetKeys.forEach(function (presetKey) {\n        var preset = _this.stylePresets[presetKey];\n        var previewElement = _this.createStylePreview(preset.name, preset, function () {\n          // Apply preset without rebuilding the UI first\n          _this.applyStylePreset(presetKey);\n          // Don't update UI controls if it's already the correct style\n        });\n        presetsContainer.appendChild(previewElement);\n      });\n\n      // Scroll buttons\n      var leftScrollButton = document.createElement('button');\n      leftScrollButton.innerHTML = '&lt;';\n      leftScrollButton.title = 'Scroll left';\n      leftScrollButton.style.border = 'none';\n      leftScrollButton.style.background = '#1A1A1A';\n      leftScrollButton.style.color = '#666';\n      leftScrollButton.style.borderRadius = '50%';\n      leftScrollButton.style.width = '18px';\n      leftScrollButton.style.height = '18px';\n      leftScrollButton.style.display = 'flex';\n      leftScrollButton.style.alignItems = 'center';\n      leftScrollButton.style.justifyContent = 'center';\n      leftScrollButton.style.cursor = 'pointer';\n      leftScrollButton.style.fontSize = '10px';\n      leftScrollButton.style.flexShrink = '0';\n      var rightScrollButton = document.createElement('button');\n      rightScrollButton.innerHTML = '&gt;';\n      rightScrollButton.title = 'Scroll right';\n      rightScrollButton.style.border = 'none';\n      rightScrollButton.style.background = '#1A1A1A';\n      rightScrollButton.style.color = '#666';\n      rightScrollButton.style.borderRadius = '50%';\n      rightScrollButton.style.width = '18px';\n      rightScrollButton.style.height = '18px';\n      rightScrollButton.style.display = 'flex';\n      rightScrollButton.style.alignItems = 'center';\n      rightScrollButton.style.justifyContent = 'center';\n      rightScrollButton.style.cursor = 'pointer';\n      rightScrollButton.style.fontSize = '10px';\n      rightScrollButton.style.flexShrink = '0';\n\n      // Add scroll event listeners\n      leftScrollButton.addEventListener('click', function () {\n        presetsScrollContainer.scrollBy({\n          left: -100,\n          behavior: 'smooth'\n        });\n      });\n      rightScrollButton.addEventListener('click', function () {\n        presetsScrollContainer.scrollBy({\n          left: 100,\n          behavior: 'smooth'\n        });\n      });\n\n      // Hover effects for scroll buttons\n      [leftScrollButton, rightScrollButton].forEach(function (btn) {\n        btn.addEventListener('mouseover', function () {\n          btn.style.color = '#fff';\n          btn.style.background = '#272727';\n        });\n        btn.addEventListener('mouseout', function () {\n          btn.style.color = '#666';\n          btn.style.background = '#1A1A1A';\n        });\n      });\n\n      // Add all elements to containers\n      presetsScrollContainer.appendChild(presetsContainer);\n      presetsOuterContainer.appendChild(leftScrollButton);\n      presetsOuterContainer.appendChild(presetsScrollContainer);\n      presetsOuterContainer.appendChild(rightScrollButton);\n      styleControls.appendChild(presetsOuterContainer);\n\n      // Separator line\n      var separator = document.createElement('div');\n      separator.style.height = '24px';\n      separator.style.width = '1px';\n      separator.style.backgroundColor = '#333';\n      separator.style.margin = '0 5px';\n      styleControls.appendChild(separator);\n\n      // Add compact fill controls\n      var fillControls = this.createCompactFillControls();\n      styleControls.appendChild(fillControls);\n\n      // Add compact stroke controls\n      var strokeControls = this.createCompactStrokeControls();\n      styleControls.appendChild(strokeControls);\n      styleRow.appendChild(styleControls);\n      container.appendChild(styleRow);\n\n      // Store in a class property to remember scroll position\n      if (typeof this.lastPresetScrollPosition === 'undefined') {\n        this.lastPresetScrollPosition = 0;\n      }\n\n      // Helper function to update scroll button states\n      var updateScrollButtonsState = function updateScrollButtonsState() {\n        // Check if scrolling is possible and update buttons accordingly\n        var canScrollLeft = presetsScrollContainer.scrollLeft > 0;\n        var canScrollRight = presetsScrollContainer.scrollLeft < presetsScrollContainer.scrollWidth - presetsScrollContainer.clientWidth - 5;\n        leftScrollButton.style.opacity = canScrollLeft ? '1' : '0.4';\n        leftScrollButton.style.cursor = canScrollLeft ? 'pointer' : 'default';\n        rightScrollButton.style.opacity = canScrollRight ? '1' : '0.4';\n        rightScrollButton.style.cursor = canScrollRight ? 'pointer' : 'default';\n      };\n\n      // Initialize scroll position without animation\n      presetsScrollContainer.style.scrollBehavior = 'auto'; // Disable smooth scrolling temporarily\n      presetsScrollContainer.scrollLeft = this.lastPresetScrollPosition || 0;\n      updateScrollButtonsState();\n      // Re-enable smooth scrolling for user interactions only\n      presetsScrollContainer.style.scrollBehavior = 'smooth';\n\n      // Save scroll position when scrolling - but don't trigger a UI update\n      presetsScrollContainer.addEventListener('scroll', function () {\n        _this.lastPresetScrollPosition = presetsScrollContainer.scrollLeft;\n        updateScrollButtonsState();\n      });\n\n      // Add scroll event listener to update button states\n      presetsScrollContainer.addEventListener('scroll', updateScrollButtonsState);\n    }\n\n    /**\n     * Create a visual style preview circle (updated for more compact version)\n     */\n  }, {\n    key: \"createStylePreview\",\n    value: function createStylePreview(title, preset, onClick) {\n      var preview = document.createElement('div');\n      preview.title = title;\n      preview.style.width = '20px';\n      preview.style.height = '20px';\n      preview.style.borderRadius = '50%';\n      preview.style.cursor = 'pointer';\n      preview.style.position = 'relative';\n      preview.style.transition = 'transform 0.2s ease';\n      preview.style.flexShrink = '0'; // Prevent shrinking in flex container\n\n      // Hover effects\n      preview.addEventListener('mouseover', function () {\n        preview.style.transform = 'scale(1.1)';\n      });\n      preview.addEventListener('mouseout', function () {\n        preview.style.transform = 'scale(1)';\n      });\n\n      // Apply style to preview based on preset\n      if (preset) {\n        // Style the preview according to the preset\n        if (preset.fillType === 'solid') {\n          preview.style.backgroundColor = preset.fillColor || '#FFFFFF';\n          if (preset.strokeType === 'solid') {\n            preview.style.border = \"\".concat(preset.strokeWidth || 1, \"px solid \").concat(preset.strokeColor || '#000000');\n          } else if (preset.strokeType === 'none') {\n            preview.style.border = 'none';\n          }\n        } else if (preset.fillType === 'linearGradient') {\n          preview.style.background = \"linear-gradient(\".concat(preset.fillGradientAngle || 90, \"deg, \").concat(preset.fillGradientColor1 || '#3498DB', \", \").concat(preset.fillGradientColor2 || '#9B59B6', \")\");\n          if (preset.strokeType === 'solid') {\n            preview.style.border = \"\".concat(preset.strokeWidth || 1, \"px solid \").concat(preset.strokeColor || '#000000');\n          }\n        } else if (preset.fillType === 'radialGradient') {\n          preview.style.background = \"radial-gradient(circle, \".concat(preset.fillGradientColor1 || '#3498DB', \", \").concat(preset.fillGradientColor2 || '#9B59B6', \")\");\n          if (preset.strokeType === 'solid') {\n            preview.style.border = \"\".concat(preset.strokeWidth || 1, \"px solid \").concat(preset.strokeColor || '#000000');\n          }\n        } else if (preset.fillType === 'none') {\n          preview.style.backgroundColor = 'transparent';\n          if (preset.strokeType === 'solid') {\n            preview.style.border = \"\".concat(preset.strokeWidth || 1, \"px solid \").concat(preset.strokeColor || '#FFFFFF');\n          } else {\n            // For visibility, add a dotted border if both fill and stroke are none\n            preview.style.border = '1px dashed #666';\n          }\n        }\n      }\n\n      // Click handler\n      preview.addEventListener('click', onClick);\n      return preview;\n    }\n\n    /**\n     * Create compact fill controls\n     */\n  }, {\n    key: \"createCompactFillControls\",\n    value: function createCompactFillControls() {\n      var _this2 = this;\n      var fillGroup = document.createElement('div');\n      fillGroup.style.display = 'flex';\n      fillGroup.style.alignItems = 'center';\n      fillGroup.style.gap = '5px';\n\n      // Fill type select (tiny dropdown)\n      var fillTypeSelect = document.createElement('select');\n      fillTypeSelect.title = 'Fill Type';\n      fillTypeSelect.style.backgroundColor = '#111';\n      fillTypeSelect.style.color = '#e0e0e0';\n      fillTypeSelect.style.border = '1px solid #333';\n      fillTypeSelect.style.borderRadius = '4px';\n      fillTypeSelect.style.fontSize = '10px';\n      fillTypeSelect.style.padding = '2px 4px';\n      fillTypeSelect.style.width = '60px';\n      fillTypeSelect.style.height = '22px';\n      var fillOptions = [{\n        value: 'none',\n        label: 'No Fill'\n      }, {\n        value: 'solid',\n        label: 'Solid'\n      }, {\n        value: 'linearGradient',\n        label: 'Linear'\n      }, {\n        value: 'radialGradient',\n        label: 'Radial'\n      }];\n      fillOptions.forEach(function (option) {\n        var opt = document.createElement('option');\n        opt.value = option.value;\n        opt.textContent = option.label;\n        if (option.value === _this2.styleParams.fillType) {\n          opt.selected = true;\n        }\n        fillTypeSelect.appendChild(opt);\n      });\n      fillTypeSelect.addEventListener('change', function () {\n        var _this2$editor, _this2$editor2;\n        _this2.styleParams.fillType = fillTypeSelect.value;\n        _this2.updateVisibility(fillTypeSelect.value, colorInput, gradientContainer);\n        _this2.updateShapeStyle((_this2$editor = _this2.editor) === null || _this2$editor === void 0 ? void 0 : _this2$editor.currentShape);\n        if ((_this2$editor2 = _this2.editor) !== null && _this2$editor2 !== void 0 && (_this2$editor2 = _this2$editor2.controller) !== null && _this2$editor2 !== void 0 && _this2$editor2.history) {\n          _this2.editor.controller.history.saveState();\n        }\n      });\n\n      // Color picker (small)\n      var colorInput = document.createElement('input');\n      colorInput.type = 'color';\n      colorInput.value = this.styleParams.fillColor;\n      colorInput.title = 'Fill Color';\n      colorInput.style.width = '22px';\n      colorInput.style.height = '22px';\n      colorInput.style.border = '1px solid #333';\n      colorInput.style.borderRadius = '4px';\n      colorInput.style.padding = '0';\n      colorInput.style.backgroundColor = 'transparent';\n      colorInput.style.display = this.styleParams.fillType === 'solid' ? 'block' : 'none';\n      colorInput.addEventListener('input', function () {\n        var _this2$editor3;\n        _this2.styleParams.fillColor = colorInput.value;\n        _this2.updateShapeStyle((_this2$editor3 = _this2.editor) === null || _this2$editor3 === void 0 ? void 0 : _this2$editor3.currentShape);\n      });\n      colorInput.addEventListener('change', function () {\n        var _this2$editor4;\n        if ((_this2$editor4 = _this2.editor) !== null && _this2$editor4 !== void 0 && (_this2$editor4 = _this2$editor4.controller) !== null && _this2$editor4 !== void 0 && _this2$editor4.history) {\n          _this2.editor.controller.history.saveState();\n        }\n      });\n\n      // Gradient controls (initially hidden)\n      var gradientContainer = document.createElement('div');\n      gradientContainer.style.display = this.styleParams.fillType.includes('Gradient') ? 'flex' : 'none';\n      gradientContainer.style.alignItems = 'center';\n      gradientContainer.style.gap = '5px';\n\n      // Gradient color 1\n      var gradientColor1 = document.createElement('input');\n      gradientColor1.type = 'color';\n      gradientColor1.value = this.styleParams.fillGradientColor1;\n      gradientColor1.title = 'Gradient Start';\n      gradientColor1.style.width = '22px';\n      gradientColor1.style.height = '22px';\n      gradientColor1.style.border = '1px solid #333';\n      gradientColor1.style.borderRadius = '4px';\n      gradientColor1.style.padding = '0';\n      gradientColor1.addEventListener('input', function () {\n        var _this2$editor5;\n        _this2.styleParams.fillGradientColor1 = gradientColor1.value;\n        _this2.updateShapeStyle((_this2$editor5 = _this2.editor) === null || _this2$editor5 === void 0 ? void 0 : _this2$editor5.currentShape);\n      });\n\n      // Gradient color 2\n      var gradientColor2 = document.createElement('input');\n      gradientColor2.type = 'color';\n      gradientColor2.value = this.styleParams.fillGradientColor2;\n      gradientColor2.title = 'Gradient End';\n      gradientColor2.style.width = '22px';\n      gradientColor2.style.height = '22px';\n      gradientColor2.style.border = '1px solid #333';\n      gradientColor2.style.borderRadius = '4px';\n      gradientColor2.style.padding = '0';\n      gradientColor2.addEventListener('input', function () {\n        var _this2$editor6;\n        _this2.styleParams.fillGradientColor2 = gradientColor2.value;\n        _this2.updateShapeStyle((_this2$editor6 = _this2.editor) === null || _this2$editor6 === void 0 ? void 0 : _this2$editor6.currentShape);\n      });\n\n      // Helper to update visibility\n      var updateVisibility = function updateVisibility(fillType, colorEl, gradientEl) {\n        colorEl.style.display = fillType === 'solid' ? 'block' : 'none';\n        gradientEl.style.display = fillType.includes('Gradient') ? 'flex' : 'none';\n      };\n      this.updateVisibility = updateVisibility;\n      gradientContainer.appendChild(gradientColor1);\n      gradientContainer.appendChild(gradientColor2);\n      fillGroup.appendChild(fillTypeSelect);\n      fillGroup.appendChild(colorInput);\n      fillGroup.appendChild(gradientContainer);\n      return fillGroup;\n    }\n\n    /**\n     * Create compact stroke controls\n     */\n  }, {\n    key: \"createCompactStrokeControls\",\n    value: function createCompactStrokeControls() {\n      var _this3 = this;\n      var strokeGroup = document.createElement('div');\n      strokeGroup.style.display = 'flex';\n      strokeGroup.style.alignItems = 'center';\n      strokeGroup.style.gap = '5px';\n\n      // Stroke type select\n      var strokeTypeSelect = document.createElement('select');\n      strokeTypeSelect.title = 'Stroke Type';\n      strokeTypeSelect.style.backgroundColor = '#111';\n      strokeTypeSelect.style.color = '#e0e0e0';\n      strokeTypeSelect.style.border = '1px solid #333';\n      strokeTypeSelect.style.borderRadius = '4px';\n      strokeTypeSelect.style.fontSize = '10px';\n      strokeTypeSelect.style.padding = '2px 4px';\n      strokeTypeSelect.style.width = '60px';\n      strokeTypeSelect.style.height = '22px';\n      var strokeOptions = [{\n        value: 'none',\n        label: 'No Stroke'\n      }, {\n        value: 'solid',\n        label: 'Solid'\n      }];\n      strokeOptions.forEach(function (option) {\n        var opt = document.createElement('option');\n        opt.value = option.value;\n        opt.textContent = option.label;\n        if (option.value === _this3.styleParams.strokeType) {\n          opt.selected = true;\n        }\n        strokeTypeSelect.appendChild(opt);\n      });\n\n      // Stroke color\n      var strokeColor = document.createElement('input');\n      strokeColor.type = 'color';\n      strokeColor.value = this.styleParams.strokeColor;\n      strokeColor.title = 'Stroke Color';\n      strokeColor.style.width = '22px';\n      strokeColor.style.height = '22px';\n      strokeColor.style.border = '1px solid #333';\n      strokeColor.style.borderRadius = '4px';\n      strokeColor.style.padding = '0';\n      strokeColor.style.display = this.styleParams.strokeType === 'solid' ? 'block' : 'none';\n\n      // Stroke width (mini slider)\n      var strokeWidth = document.createElement('input');\n      strokeWidth.type = 'range';\n      strokeWidth.min = '0.5';\n      strokeWidth.max = '5';\n      strokeWidth.step = '0.5';\n      strokeWidth.value = this.styleParams.strokeWidth;\n      strokeWidth.title = \"Stroke Width: \".concat(this.styleParams.strokeWidth);\n      strokeWidth.style.width = '60px';\n      strokeWidth.className = 'param-slider';\n      strokeWidth.style.display = this.styleParams.strokeType === 'solid' ? 'block' : 'none';\n      strokeTypeSelect.addEventListener('change', function () {\n        var _this3$editor, _this3$editor2;\n        _this3.styleParams.strokeType = strokeTypeSelect.value;\n        strokeColor.style.display = strokeTypeSelect.value === 'solid' ? 'block' : 'none';\n        strokeWidth.style.display = strokeTypeSelect.value === 'solid' ? 'block' : 'none';\n        _this3.updateShapeStyle((_this3$editor = _this3.editor) === null || _this3$editor === void 0 ? void 0 : _this3$editor.currentShape);\n        if ((_this3$editor2 = _this3.editor) !== null && _this3$editor2 !== void 0 && (_this3$editor2 = _this3$editor2.controller) !== null && _this3$editor2 !== void 0 && _this3$editor2.history) {\n          _this3.editor.controller.history.saveState();\n        }\n      });\n      strokeColor.addEventListener('input', function () {\n        var _this3$editor3;\n        _this3.styleParams.strokeColor = strokeColor.value;\n        _this3.updateShapeStyle((_this3$editor3 = _this3.editor) === null || _this3$editor3 === void 0 ? void 0 : _this3$editor3.currentShape);\n      });\n      strokeWidth.addEventListener('input', function () {\n        var _this3$editor4;\n        _this3.styleParams.strokeWidth = parseFloat(strokeWidth.value);\n        strokeWidth.title = \"Stroke Width: \".concat(_this3.styleParams.strokeWidth);\n        _this3.updateShapeStyle((_this3$editor4 = _this3.editor) === null || _this3$editor4 === void 0 ? void 0 : _this3$editor4.currentShape);\n      });\n      strokeWidth.addEventListener('change', function () {\n        var _this3$editor5;\n        if ((_this3$editor5 = _this3.editor) !== null && _this3$editor5 !== void 0 && (_this3$editor5 = _this3$editor5.controller) !== null && _this3$editor5 !== void 0 && _this3$editor5.history) {\n          _this3.editor.controller.history.saveState();\n        }\n      });\n      strokeGroup.appendChild(strokeTypeSelect);\n      strokeGroup.appendChild(strokeColor);\n      strokeGroup.appendChild(strokeWidth);\n      return strokeGroup;\n    }\n\n    /**\n    * Update controls to reflect current style parameters\n    */\n  }, {\n    key: \"updateStyleControls\",\n    value: function updateStyleControls(styleRow) {\n      // Find the style row if not provided\n      if (!styleRow) {\n        styleRow = document.querySelector('.style-row');\n        if (!styleRow) return;\n      }\n\n      // Get parent container\n      var container = styleRow.parentNode;\n\n      // Remove existing style row\n      styleRow.remove();\n\n      // Create new controls with updated parameters\n      this.createStyleControls(container);\n    }\n\n    /**\n     * Update shape style\n     */\n  }, {\n    key: \"updateShapeStyle\",\n    value: function updateShapeStyle(shapeName) {\n      // Only save settings if we have a shape name\n      if (shapeName) {\n        this.saveStyleSettings(shapeName);\n      }\n\n      // Find the shape in the SVG\n      var svg = document.getElementById('preview-svg');\n      if (!svg) return;\n      var wrapperGroup = svg.querySelector('#shape');\n      if (!wrapperGroup) return;\n\n      // Apply styles to all elements in the shape\n      this.applyStylesToSVG(wrapperGroup);\n    }\n\n    /**\n     * Apply style parameters to SVG elements\n     */\n  }, {\n    key: \"applyStylesToSVG\",\n    value: function applyStylesToSVG(rootElement) {\n      var _this4 = this;\n      // First ensure defs element exists\n      var defsElement = rootElement.ownerSVGElement.querySelector('defs');\n      if (!defsElement) {\n        defsElement = document.createElementNS('http://www.w3.org/2000/svg', 'defs');\n        rootElement.ownerSVGElement.insertBefore(defsElement, rootElement.ownerSVGElement.firstChild);\n      }\n\n      // Clear existing gradients\n      var existingGradients = Array.from(defsElement.querySelectorAll('linearGradient, radialGradient'));\n      existingGradients.forEach(function (gradient) {\n        return gradient.remove();\n      });\n\n      // Create and get fill value\n      var fillValue = this.createFillValue(defsElement, 'fill');\n\n      // Create and get stroke value\n      var strokeValue = this.createFillValue(defsElement, 'stroke');\n\n      // Apply styles to SVG elements\n      var _applyStyles = function applyStyles(element) {\n        // Skip non-element nodes\n        if (element.nodeType !== Node.ELEMENT_NODE) return;\n\n        // For SVG shape elements\n        if (element.tagName === 'path' || element.tagName === 'rect' || element.tagName === 'circle' || element.tagName === 'ellipse' || element.tagName === 'polygon' || element.tagName === 'polyline') {\n          // Apply fill\n          if (_this4.styleParams.fillType === 'none') {\n            element.setAttribute('fill', 'none');\n          } else {\n            element.setAttribute('fill', fillValue);\n            element.setAttribute('fill-opacity', _this4.styleParams.fillOpacity);\n          }\n\n          // Apply stroke\n          if (_this4.styleParams.strokeType === 'none') {\n            element.setAttribute('stroke', 'none');\n          } else {\n            element.setAttribute('stroke', strokeValue);\n            element.setAttribute('stroke-width', _this4.styleParams.strokeWidth);\n          }\n        }\n\n        // Process all child elements recursively\n        Array.from(element.children).forEach(function (child) {\n          _applyStyles(child);\n        });\n      };\n\n      // Start applying styles from the root\n      _applyStyles(rootElement);\n    }\n\n    /**\n     * Reset style to defaults\n     */\n  }, {\n    key: \"resetStyle\",\n    value: function resetStyle() {\n      var _this$editor5, _this$editor6;\n      this.styleParams = _objectSpread({}, this.originalStyleParams);\n      this.updateShapeStyle((_this$editor5 = this.editor) === null || _this$editor5 === void 0 ? void 0 : _this$editor5.currentShape);\n\n      // Update UI controls - more safely\n      var styleRow = document.querySelector('.style-row');\n      if (styleRow && styleRow.parentNode) {\n        var container = styleRow.parentNode;\n\n        // Remove both preset row and style row if they exist\n        var presetRow = document.querySelector('.preset-row');\n        if (presetRow) presetRow.remove();\n        styleRow.remove();\n\n        // Recreate both controls\n        this.createStyleControls(container);\n      }\n      if ((_this$editor6 = this.editor) !== null && _this$editor6 !== void 0 && (_this$editor6 = _this$editor6.controller) !== null && _this$editor6 !== void 0 && _this$editor6.history) {\n        this.editor.controller.history.saveState();\n      }\n    }\n\n    /**\n     * Create a compact, simple color input\n     */\n  }, {\n    key: \"createCompactColorInput\",\n    value: function createCompactColorInput(label, initialColor, onChange) {\n      var container = document.createElement('div');\n      container.style.display = 'flex';\n      container.style.alignItems = 'center';\n      var labelElement = document.createElement('span');\n      labelElement.className = 'param-name';\n      labelElement.textContent = label;\n      labelElement.style.fontSize = '10px';\n      labelElement.style.marginRight = '8px';\n      var colorInput = document.createElement('input');\n      colorInput.type = 'color';\n      colorInput.value = initialColor;\n      colorInput.style.width = '24px';\n      colorInput.style.height = '24px';\n      colorInput.style.border = '1px solid #333';\n      colorInput.style.borderRadius = '4px';\n      colorInput.style.padding = '0';\n      colorInput.addEventListener('input', function () {\n        onChange(colorInput.value);\n      });\n      container.appendChild(labelElement);\n      container.appendChild(colorInput);\n      return container;\n    }\n\n    /**\n     * Helper method to create a fill value based on style type\n     */\n  }, {\n    key: \"createFillValue\",\n    value: function createFillValue(defsElement, styleType) {\n      // Determine which parameters to use based on styleType (fill or stroke)\n      var typePrefix = styleType === 'stroke' ? 'stroke' : 'fill';\n      var styleParams = {\n        type: this.styleParams[\"\".concat(typePrefix, \"Type\")],\n        color: this.styleParams[\"\".concat(typePrefix, \"Color\")],\n        gradientColor1: this.styleParams[\"\".concat(typePrefix, \"GradientColor1\")],\n        gradientColor2: this.styleParams[\"\".concat(typePrefix, \"GradientColor2\")],\n        gradientAngle: this.styleParams[\"\".concat(typePrefix, \"GradientAngle\")]\n      };\n\n      // Return value based on fill type\n      if (styleParams.type === 'solid') {\n        return styleParams.color;\n      } else if (styleParams.type === 'none') {\n        return 'none';\n      } else if (styleParams.type === 'linearGradient') {\n        // Create linear gradient\n        var gradientId = \"\".concat(typePrefix, \"LinearGradient-\").concat(Date.now(), \"-\").concat(Math.floor(Math.random() * 1000));\n        var gradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');\n        gradient.setAttribute('id', gradientId);\n\n        // Set gradient angle\n        var angle = styleParams.gradientAngle;\n        var rads = angle * Math.PI / 180;\n        var x1 = 0.5 - Math.cos(rads) * 0.5;\n        var y1 = 0.5 - Math.sin(rads) * 0.5;\n        var x2 = 0.5 + Math.cos(rads) * 0.5;\n        var y2 = 0.5 + Math.sin(rads) * 0.5;\n        gradient.setAttribute('x1', x1);\n        gradient.setAttribute('y1', y1);\n        gradient.setAttribute('x2', x2);\n        gradient.setAttribute('y2', y2);\n\n        // Create stops\n        var stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');\n        stop1.setAttribute('offset', '0%');\n        stop1.setAttribute('stop-color', styleParams.gradientColor1);\n        var stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');\n        stop2.setAttribute('offset', '100%');\n        stop2.setAttribute('stop-color', styleParams.gradientColor2);\n        gradient.appendChild(stop1);\n        gradient.appendChild(stop2);\n        defsElement.appendChild(gradient);\n        return \"url(#\".concat(gradientId, \")\");\n      } else if (styleParams.type === 'radialGradient') {\n        // Create radial gradient\n        var _gradientId = \"\".concat(typePrefix, \"RadialGradient-\").concat(Date.now(), \"-\").concat(Math.floor(Math.random() * 1000));\n        var _gradient = document.createElementNS('http://www.w3.org/2000/svg', 'radialGradient');\n        _gradient.setAttribute('id', _gradientId);\n        _gradient.setAttribute('cx', '0.5');\n        _gradient.setAttribute('cy', '0.5');\n        _gradient.setAttribute('r', '0.5');\n\n        // Create stops\n        var _stop = document.createElementNS('http://www.w3.org/2000/svg', 'stop');\n        _stop.setAttribute('offset', '0%');\n        _stop.setAttribute('stop-color', styleParams.gradientColor1);\n        var _stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');\n        _stop2.setAttribute('offset', '100%');\n        _stop2.setAttribute('stop-color', styleParams.gradientColor2);\n        _gradient.appendChild(_stop);\n        _gradient.appendChild(_stop2);\n        defsElement.appendChild(_gradient);\n        return \"url(#\".concat(_gradientId, \")\");\n      }\n\n      // Default fallback\n      return styleParams.color;\n    }\n  }]);\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ShapeStyleController);\n\n//# sourceURL=webpack://generative-shapes/./src/ShapeStyleController.js?");

/***/ }),

/***/ "./src/SupabaseAuth.js":
/*!*****************************!*\
  !*** ./src/SupabaseAuth.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, \"catch\": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n// SupabaseAuth.js\n// Handles authentication with Supabase and manages the auth state\nvar SupabaseAuth = /*#__PURE__*/function () {\n  function SupabaseAuth(app) {\n    var _this = this;\n    _classCallCheck(this, SupabaseAuth);\n    this.app = app;\n    this.supabase = null;\n    this.currentUser = null;\n    this.authStateListeners = [];\n    this.initialized = false;\n\n    // Bind methods\n    this.initialize = this.initialize.bind(this);\n    this.showAuthModal = this.showAuthModal.bind(this);\n    this.signIn = this.signIn.bind(this);\n    this.signUp = this.signUp.bind(this);\n    this.signOut = this.signOut.bind(this);\n    this.getCurrentUser = this.getCurrentUser.bind(this);\n    this.addAuthStateListener = this.addAuthStateListener.bind(this);\n    this.checkSession = this.checkSession.bind(this);\n    this.isAuthenticated = this.isAuthenticated.bind(this);\n\n    // Initialize Supabase client\n    this.loadSupabaseClient().then(function () {\n      _this.initialize();\n    });\n  }\n\n  /**\n   * Initialize Supabase client\n   */\n  return _createClass(SupabaseAuth, [{\n    key: \"initialize\",\n    value: (function () {\n      var _initialize = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _this2 = this;\n        var supabaseUrl, supabaseKey;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.prev = 0;\n              // Create Supabase client\n              supabaseUrl = 'https://avufsgjwbzjinyccruqc.supabase.co'; // For security, we should use an environment variable for the key\n              // But for this demo, we'll use a public (anon) key\n              // In a real app, you'd use process.env.SUPABASE_KEY from your server\n              supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImF2dWZzZ2p3YnpqaW55Y2NydXFjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDE3NjYwMzgsImV4cCI6MjA1NzM0MjAzOH0.0tRCOWd1HByLbpw6q2ov4ipUOjByte2vmH-Wjpke0_A'; // Make sure the supabaseClient is loaded and createClient is available\n              if (!(typeof window.supabase === 'undefined' || typeof window.supabase.createClient !== 'function')) {\n                _context.next = 6;\n                break;\n              }\n              console.error('Supabase client not loaded properly');\n              return _context.abrupt(\"return\");\n            case 6:\n              this.supabase = window.supabase.createClient(supabaseUrl, supabaseKey);\n              console.log('Supabase client initialized');\n              this.initialized = true;\n\n              // Check for existing session\n              this.checkSession();\n\n              // Set up auth state change listener\n              this.supabase.auth.onAuthStateChange(function (event, session) {\n                if (event === 'SIGNED_IN') {\n                  // Check if email is confirmed\n                  var isEmailConfirmed = session.user && (session.user.email_confirmed_at !== null || session.user.confirmed_at !== null);\n                  if (isEmailConfirmed) {\n                    _this2.currentUser = session.user;\n                    _this2.notifyAuthStateChange(true, session.user);\n                    console.log('User signed in:', session.user.email);\n                  } else {\n                    // Email not confirmed - don't consider authenticated\n                    _this2.currentUser = null;\n                    _this2.notifyAuthStateChange(false, null, {\n                      requiresEmailVerification: true,\n                      email: session.user.email\n                    });\n                    console.log('User signed in but email not confirmed:', session.user.email);\n                  }\n                } else if (event === 'SIGNED_OUT') {\n                  _this2.currentUser = null;\n                  _this2.notifyAuthStateChange(false, null);\n                  console.log('User signed out');\n                }\n              });\n              _context.next = 16;\n              break;\n            case 13:\n              _context.prev = 13;\n              _context.t0 = _context[\"catch\"](0);\n              console.error('Error initializing Supabase:', _context.t0);\n            case 16:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[0, 13]]);\n      }));\n      function initialize() {\n        return _initialize.apply(this, arguments);\n      }\n      return initialize;\n    }()\n    /**\n     * Load the Supabase client from CDN\n     */\n    )\n  }, {\n    key: \"loadSupabaseClient\",\n    value: function loadSupabaseClient() {\n      return new Promise(function (resolve, reject) {\n        // Check if already loaded\n        if (window.supabase) {\n          console.log('Supabase client already loaded');\n          resolve();\n          return;\n        }\n\n        // Create a container for the supabase client\n        window.supabase = {};\n        var script = document.createElement('script');\n        script.src = 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2';\n        script.async = true;\n        script.onload = function () {\n          console.log('Supabase client loaded');\n          // Make createClient accessible through window.supabase\n          window.supabase.createClient = window.supabase.createClient || window.createClient;\n          resolve();\n        };\n        script.onerror = function (error) {\n          console.error('Error loading Supabase client:', error);\n          reject(error);\n        };\n        document.head.appendChild(script);\n      });\n    }\n\n    /**\n     * Check for an existing session\n     */\n  }, {\n    key: \"checkSession\",\n    value: (function () {\n      var _checkSession = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var _yield$this$supabase$, data, error, isEmailConfirmed;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!(!this.initialized || !this.supabase)) {\n                _context2.next = 3;\n                break;\n              }\n              console.log('Supabase not initialized yet, cannot check session');\n              return _context2.abrupt(\"return\", false);\n            case 3:\n              _context2.prev = 3;\n              _context2.next = 6;\n              return this.supabase.auth.getSession();\n            case 6:\n              _yield$this$supabase$ = _context2.sent;\n              data = _yield$this$supabase$.data;\n              error = _yield$this$supabase$.error;\n              if (!error) {\n                _context2.next = 11;\n                break;\n              }\n              throw error;\n            case 11:\n              if (!(data && data.session)) {\n                _context2.next = 26;\n                break;\n              }\n              // Check if email is verified\n              isEmailConfirmed = data.session.user && (data.session.user.email_confirmed_at !== null || data.session.user.confirmed_at !== null);\n              if (!isEmailConfirmed) {\n                _context2.next = 20;\n                break;\n              }\n              this.currentUser = data.session.user;\n              this.notifyAuthStateChange(true, data.session.user);\n              console.log('Existing session found:', data.session.user.email);\n              return _context2.abrupt(\"return\", true);\n            case 20:\n              // Email not confirmed\n              this.currentUser = null;\n              this.notifyAuthStateChange(false, null, {\n                requiresEmailVerification: true,\n                email: data.session.user.email\n              });\n              console.log('Existing session found but email not confirmed:', data.session.user.email);\n              return _context2.abrupt(\"return\", false);\n            case 24:\n              _context2.next = 30;\n              break;\n            case 26:\n              this.currentUser = null;\n              this.notifyAuthStateChange(false, null);\n              console.log('No existing session found');\n              return _context2.abrupt(\"return\", false);\n            case 30:\n              _context2.next = 36;\n              break;\n            case 32:\n              _context2.prev = 32;\n              _context2.t0 = _context2[\"catch\"](3);\n              console.error('Error checking session:', _context2.t0);\n              return _context2.abrupt(\"return\", false);\n            case 36:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this, [[3, 32]]);\n      }));\n      function checkSession() {\n        return _checkSession.apply(this, arguments);\n      }\n      return checkSession;\n    }()\n    /**\n     * Sign in with email and password\n     */\n    )\n  }, {\n    key: \"signIn\",\n    value: (function () {\n      var _signIn = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(email, password) {\n        var _yield$this$supabase$2, data, error;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              if (!(!this.initialized || !this.supabase)) {\n                _context3.next = 3;\n                break;\n              }\n              console.error('Supabase not initialized yet, cannot sign in');\n              return _context3.abrupt(\"return\", {\n                success: false,\n                error: 'Authentication system not initialized'\n              });\n            case 3:\n              _context3.prev = 3;\n              _context3.next = 6;\n              return this.supabase.auth.signInWithPassword({\n                email: email,\n                password: password\n              });\n            case 6:\n              _yield$this$supabase$2 = _context3.sent;\n              data = _yield$this$supabase$2.data;\n              error = _yield$this$supabase$2.error;\n              if (!error) {\n                _context3.next = 11;\n                break;\n              }\n              throw error;\n            case 11:\n              this.currentUser = data.user;\n              return _context3.abrupt(\"return\", {\n                success: true,\n                user: data.user\n              });\n            case 15:\n              _context3.prev = 15;\n              _context3.t0 = _context3[\"catch\"](3);\n              console.error('Error signing in:', _context3.t0);\n              return _context3.abrupt(\"return\", {\n                success: false,\n                error: _context3.t0.message\n              });\n            case 19:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this, [[3, 15]]);\n      }));\n      function signIn(_x, _x2) {\n        return _signIn.apply(this, arguments);\n      }\n      return signIn;\n    }()\n    /**\n     * Sign up with email and password\n     */\n    )\n  }, {\n    key: \"signUp\",\n    value: (function () {\n      var _signUp = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(email, password) {\n        var _yield$this$supabase$3, data, error, isEmailConfirmed;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              if (!(!this.initialized || !this.supabase)) {\n                _context4.next = 3;\n                break;\n              }\n              console.error('Supabase not initialized yet, cannot sign up');\n              return _context4.abrupt(\"return\", {\n                success: false,\n                error: 'Authentication system not initialized'\n              });\n            case 3:\n              _context4.prev = 3;\n              _context4.next = 6;\n              return this.supabase.auth.signUp({\n                email: email,\n                password: password\n              });\n            case 6:\n              _yield$this$supabase$3 = _context4.sent;\n              data = _yield$this$supabase$3.data;\n              error = _yield$this$supabase$3.error;\n              if (!error) {\n                _context4.next = 11;\n                break;\n              }\n              throw error;\n            case 11:\n              if (!(data.user && data.user.identities && data.user.identities.length === 0)) {\n                _context4.next = 13;\n                break;\n              }\n              return _context4.abrupt(\"return\", {\n                success: false,\n                error: 'Email already in use. Please sign in instead.'\n              });\n            case 13:\n              // CRITICAL: Always check email confirmation status explicitly\n              isEmailConfirmed = data.user && (data.user.email_confirmed_at !== null || data.user.confirmed_at !== null);\n              console.log('Signup complete, email verified:', isEmailConfirmed);\n              if (!isEmailConfirmed) {\n                _context4.next = 20;\n                break;\n              }\n              // Only consider the user authenticated if email is confirmed\n              this.currentUser = data.user;\n              return _context4.abrupt(\"return\", {\n                success: true,\n                user: data.user,\n                emailConfirmed: true,\n                requiresEmailVerification: false,\n                message: 'Signed in successfully'\n              });\n            case 20:\n              // Don't set current user if email is not confirmed\n              this.currentUser = null;\n              return _context4.abrupt(\"return\", {\n                success: true,\n                user: data.user,\n                emailConfirmed: false,\n                requiresEmailVerification: true,\n                message: 'Please check your email to confirm your account. You must verify your email before you can create shapes.'\n              });\n            case 22:\n              _context4.next = 28;\n              break;\n            case 24:\n              _context4.prev = 24;\n              _context4.t0 = _context4[\"catch\"](3);\n              console.error('Error signing up:', _context4.t0);\n              return _context4.abrupt(\"return\", {\n                success: false,\n                error: _context4.t0.message\n              });\n            case 28:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this, [[3, 24]]);\n      }));\n      function signUp(_x3, _x4) {\n        return _signUp.apply(this, arguments);\n      }\n      return signUp;\n    }()\n    /**\n     * Sign out\n     */\n    )\n  }, {\n    key: \"signOut\",\n    value: (function () {\n      var _signOut = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var _yield$this$supabase$4, error;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              if (!(!this.initialized || !this.supabase)) {\n                _context5.next = 3;\n                break;\n              }\n              console.error('Supabase not initialized yet, cannot sign out');\n              return _context5.abrupt(\"return\", {\n                success: false,\n                error: 'Authentication system not initialized'\n              });\n            case 3:\n              _context5.prev = 3;\n              _context5.next = 6;\n              return this.supabase.auth.signOut();\n            case 6:\n              _yield$this$supabase$4 = _context5.sent;\n              error = _yield$this$supabase$4.error;\n              if (!error) {\n                _context5.next = 10;\n                break;\n              }\n              throw error;\n            case 10:\n              this.currentUser = null;\n              return _context5.abrupt(\"return\", {\n                success: true\n              });\n            case 14:\n              _context5.prev = 14;\n              _context5.t0 = _context5[\"catch\"](3);\n              console.error('Error signing out:', _context5.t0);\n              return _context5.abrupt(\"return\", {\n                success: false,\n                error: _context5.t0.message\n              });\n            case 18:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this, [[3, 14]]);\n      }));\n      function signOut() {\n        return _signOut.apply(this, arguments);\n      }\n      return signOut;\n    }()\n    /**\n     * Get the current user\n     */\n    )\n  }, {\n    key: \"getCurrentUser\",\n    value: function getCurrentUser() {\n      return this.currentUser;\n    }\n\n    /**\n     * Check if user is authenticated\n     */\n  }, {\n    key: \"isAuthenticated\",\n    value: function isAuthenticated() {\n      // No user means not authenticated\n      if (!this.currentUser) return false;\n\n      // Strictly check for email confirmation fields\n      var isEmailConfirmed = this.currentUser.email_confirmed_at !== null && this.currentUser.email_confirmed_at !== undefined || this.currentUser.confirmed_at !== null && this.currentUser.confirmed_at !== undefined;\n\n      // Log authentication status for debugging\n      console.log('Auth check:', {\n        user: this.currentUser.email,\n        isConfirmed: isEmailConfirmed,\n        confirmedAt: this.currentUser.email_confirmed_at || this.currentUser.confirmed_at\n      });\n      return isEmailConfirmed;\n    }\n\n    /**\n     * Add an auth state listener\n     */\n  }, {\n    key: \"addAuthStateListener\",\n    value: function addAuthStateListener(listener) {\n      var _this3 = this;\n      this.authStateListeners.push(listener);\n\n      // Immediately notify with current state\n      if (listener) {\n        listener(this.isAuthenticated(), this.currentUser);\n      }\n\n      // Return function to remove listener\n      return function () {\n        _this3.authStateListeners = _this3.authStateListeners.filter(function (l) {\n          return l !== listener;\n        });\n      };\n    }\n\n    /**\n     * Notify all listeners of auth state change\n     */\n  }, {\n    key: \"notifyAuthStateChange\",\n    value: function notifyAuthStateChange(isAuthenticated, user) {\n      var additionalInfo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      this.authStateListeners.forEach(function (listener) {\n        if (listener) {\n          try {\n            listener(isAuthenticated, user, additionalInfo);\n          } catch (error) {\n            console.error('Error in auth state listener:', error);\n          }\n        }\n      });\n    }\n\n    /**\n     * Show the auth modal\n     */\n  }, {\n    key: \"showAuthModal\",\n    value: function showAuthModal() {\n      var _this4 = this;\n      var mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'signin';\n      var onSuccess = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var actionDescription = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'continue';\n      // Remove any existing modal\n      var existingModal = document.getElementById('auth-modal');\n      if (existingModal) {\n        existingModal.remove();\n      }\n\n      // Create modal container\n      var modal = document.createElement('div');\n      modal.id = 'auth-modal';\n      modal.className = 'modal';\n      modal.style.position = 'fixed';\n      modal.style.top = '0';\n      modal.style.left = '0';\n      modal.style.width = '100%';\n      modal.style.height = '100%';\n      modal.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';\n      modal.style.display = 'flex';\n      modal.style.justifyContent = 'center';\n      modal.style.alignItems = 'center';\n      modal.style.zIndex = '2000';\n      modal.style.backdropFilter = 'blur(5px)';\n\n      // Create modal content\n      var modalContent = document.createElement('div');\n      modalContent.className = 'modal-content';\n      modalContent.style.backgroundColor = '#000';\n      modalContent.style.borderRadius = '8px';\n      modalContent.style.padding = '30px';\n      modalContent.style.width = '380px';\n      modalContent.style.maxWidth = '90%';\n      modalContent.style.color = '#e0e0e0';\n      modalContent.style.fontFamily = \"'Menlo', 'Monaco', 'Courier New', monospace\";\n\n      // Create modal header\n      var modalHeader = document.createElement('div');\n      modalHeader.className = 'modal-header';\n      modalHeader.style.display = 'flex';\n      modalHeader.style.justifyContent = 'space-between';\n      modalHeader.style.alignItems = 'center';\n      modalHeader.style.marginBottom = '24px';\n      var modalTitle = document.createElement('h3');\n      modalTitle.textContent = mode === 'signup' ? 'Create Account' : 'Sign In';\n      modalTitle.style.margin = '0';\n      modalTitle.style.fontSize = '20px';\n      modalTitle.style.fontWeight = 'normal';\n      modalTitle.style.color = '#e0e0e0';\n      var closeButton = document.createElement('button');\n      closeButton.className = 'close-button';\n      closeButton.innerHTML = \"\\n        <svg width=\\\"14\\\" height=\\\"14\\\" viewBox=\\\"0 0 14 14\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n          <path d=\\\"M1 1L13 13M1 13L13 1\\\" stroke=\\\"#e0e0e0\\\" stroke-width=\\\"1.5\\\" stroke-linecap=\\\"round\\\"/>\\n        </svg>\\n      \";\n      closeButton.style.backgroundColor = 'transparent';\n      closeButton.style.border = 'none';\n      closeButton.style.cursor = 'pointer';\n      closeButton.style.padding = '4px';\n      closeButton.style.display = 'flex';\n      closeButton.style.alignItems = 'center';\n      closeButton.style.justifyContent = 'center';\n      closeButton.onclick = function () {\n        return modal.remove();\n      };\n      modalHeader.appendChild(modalTitle);\n      modalHeader.appendChild(closeButton);\n\n      // Action description\n      var actionText = document.createElement('p');\n      actionText.textContent = \"Sign in or create an account to \".concat(actionDescription, \".\");\n      actionText.style.fontSize = '14px';\n      actionText.style.color = '#999';\n      actionText.style.marginBottom = '20px';\n\n      // Create form\n      var form = document.createElement('form');\n      form.id = 'auth-form';\n      form.setAttribute('autocomplete', 'off');\n      form.setAttribute('data-lpignore', 'true'); // Helps with LastPass\n      form.setAttribute('novalidate', ''); // Prevents browser validation which can trigger save prompts\n\n      form.onsubmit = /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(e) {\n          var email, password, result, verificationContainer, verificationTitle, verificationText, emailInfoText, closeVerificationButton, toast;\n          return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n            while (1) switch (_context6.prev = _context6.next) {\n              case 0:\n                e.preventDefault();\n                if (!(!_this4.initialized || !_this4.supabase)) {\n                  _context6.next = 5;\n                  break;\n                }\n                errorMessage.textContent = 'Authentication system is still initializing. Please try again in a moment.';\n                errorMessage.style.display = 'block';\n                return _context6.abrupt(\"return\");\n              case 5:\n                // Get form data\n                email = emailInput.value.trim();\n                password = passwordInput.value.trim(); // Validate form\n                if (!(!email || !password)) {\n                  _context6.next = 11;\n                  break;\n                }\n                errorMessage.textContent = 'Please enter both email and password';\n                errorMessage.style.display = 'block';\n                return _context6.abrupt(\"return\");\n              case 11:\n                // Set loading state\n                submitButton.disabled = true;\n                submitButton.textContent = 'Processing...';\n                errorMessage.style.display = 'none';\n                _context6.prev = 14;\n                if (!(mode === 'signup')) {\n                  _context6.next = 21;\n                  break;\n                }\n                _context6.next = 18;\n                return _this4.signUp(email, password);\n              case 18:\n                result = _context6.sent;\n                _context6.next = 24;\n                break;\n              case 21:\n                _context6.next = 23;\n                return _this4.signIn(email, password);\n              case 23:\n                result = _context6.sent;\n              case 24:\n                if (result.success) {\n                  // Always show verification message for new signups\n                  if (mode === 'signup' || result.requiresEmailVerification) {\n                    // Force verification UI to show\n                    result.requiresEmailVerification = true;\n\n                    // Clear loading state\n                    submitButton.disabled = false;\n                    submitButton.textContent = mode === 'signup' ? 'Create Account' : 'Sign In';\n\n                    // Force verification notification to stay visible\n                    setTimeout(function () {\n                      _this4.showEmailVerificationNotice(email);\n                    }, 500);\n\n                    // Show verification required message\n                    errorMessage.textContent = '';\n\n                    // Create verification message\n                    verificationContainer = document.createElement('div');\n                    verificationContainer.style.backgroundColor = '#334433';\n                    verificationContainer.style.padding = '15px';\n                    verificationContainer.style.borderRadius = '4px';\n                    verificationContainer.style.marginBottom = '20px';\n                    verificationContainer.style.marginTop = '10px';\n                    verificationTitle = document.createElement('h4');\n                    verificationTitle.textContent = 'Email Verification Required';\n                    verificationTitle.style.margin = '0 0 10px 0';\n                    verificationTitle.style.color = '#FFF';\n                    verificationTitle.style.fontSize = '16px';\n                    verificationText = document.createElement('p');\n                    verificationText.innerHTML = '<strong>Important:</strong> You must verify your email address before you can create shapes or save favorites.';\n                    verificationText.style.margin = '0 0 10px 0';\n                    verificationText.style.color = '#CCC';\n                    verificationText.style.fontSize = '14px';\n                    verificationText.style.lineHeight = '1.4';\n                    emailInfoText = document.createElement('p');\n                    emailInfoText.textContent = \"Email sent to: \".concat(email);\n                    emailInfoText.style.margin = '10px 0 0 0';\n                    emailInfoText.style.color = '#AAA';\n                    emailInfoText.style.fontSize = '13px';\n                    emailInfoText.style.fontStyle = 'italic';\n                    verificationContainer.appendChild(verificationTitle);\n                    verificationContainer.appendChild(verificationText);\n                    verificationContainer.appendChild(emailInfoText);\n\n                    // Replace form with verification message\n                    form.innerHTML = '';\n                    form.appendChild(verificationContainer);\n\n                    // Add close button\n                    closeVerificationButton = document.createElement('button');\n                    closeVerificationButton.textContent = 'Close';\n                    closeVerificationButton.style.width = '100%';\n                    closeVerificationButton.style.backgroundColor = '#555';\n                    closeVerificationButton.style.color = '#FFF';\n                    closeVerificationButton.style.border = 'none';\n                    closeVerificationButton.style.borderRadius = '4px';\n                    closeVerificationButton.style.padding = '12px';\n                    closeVerificationButton.style.fontSize = '14px';\n                    closeVerificationButton.style.cursor = 'pointer';\n                    closeVerificationButton.style.fontWeight = 'bold';\n                    closeVerificationButton.style.marginTop = '15px';\n                    closeVerificationButton.addEventListener('click', function () {\n                      modal.remove();\n                    });\n                    form.appendChild(closeVerificationButton);\n                  } else {\n                    // Email is verified, continue normally\n                    modal.remove();\n\n                    // Show success message\n                    toast = document.createElement('div');\n                    toast.textContent = result.message || 'Signed in successfully!';\n                    toast.style.position = 'fixed';\n                    toast.style.bottom = '20px';\n                    toast.style.left = '50%';\n                    toast.style.transform = 'translateX(-50%)';\n                    toast.style.backgroundColor = '#4CAF50';\n                    toast.style.color = 'white';\n                    toast.style.padding = '12px 20px';\n                    toast.style.borderRadius = '4px';\n                    toast.style.zIndex = '9999';\n                    document.body.appendChild(toast);\n                    setTimeout(function () {\n                      toast.style.opacity = '0';\n                      toast.style.transition = 'opacity 0.5s ease';\n                      setTimeout(function () {\n                        return toast.remove();\n                      }, 500);\n                    }, 3000);\n\n                    // Call onSuccess callback if provided\n                    if (onSuccess && typeof onSuccess === 'function') {\n                      onSuccess();\n                    }\n                  }\n                } else {\n                  // Show error message\n                  errorMessage.textContent = result.error || 'An error occurred';\n                  errorMessage.style.display = 'block';\n                  submitButton.disabled = false;\n                  submitButton.textContent = mode === 'signup' ? 'Create Account' : 'Sign In';\n                }\n                _context6.next = 34;\n                break;\n              case 27:\n                _context6.prev = 27;\n                _context6.t0 = _context6[\"catch\"](14);\n                console.error('Auth error:', _context6.t0);\n                errorMessage.textContent = _context6.t0.message || 'An error occurred';\n                errorMessage.style.display = 'block';\n                submitButton.disabled = false;\n                submitButton.textContent = mode === 'signup' ? 'Create Account' : 'Sign In';\n              case 34:\n              case \"end\":\n                return _context6.stop();\n            }\n          }, _callee6, null, [[14, 27]]);\n        }));\n        return function (_x5) {\n          return _ref.apply(this, arguments);\n        };\n      }();\n\n      // Email input\n      var emailGroup = document.createElement('div');\n      emailGroup.className = 'form-group';\n      emailGroup.style.marginBottom = '16px';\n      var emailLabel = document.createElement('label');\n      emailLabel.textContent = 'Email';\n      emailLabel.htmlFor = 'email-input';\n      emailLabel.style.display = 'block';\n      emailLabel.style.marginBottom = '8px';\n      emailLabel.style.fontSize = '14px';\n      emailLabel.style.color = '#999';\n      var emailInput = document.createElement('input');\n      emailInput.type = 'email';\n      emailInput.id = 'email-input';\n      emailInput.required = true;\n      emailInput.style.width = '100%';\n      emailInput.style.backgroundColor = '#111';\n      emailInput.style.color = '#e0e0e0';\n      emailInput.style.border = 'none';\n      emailInput.style.borderRadius = '4px';\n      emailInput.style.padding = '10px';\n      emailInput.style.fontSize = '14px';\n      emailInput.style.boxSizing = 'border-box';\n      emailInput.setAttribute('autocomplete', 'off');\n      emailInput.setAttribute('autocapitalize', 'off');\n      emailInput.setAttribute('spellcheck', 'false');\n      emailGroup.appendChild(emailLabel);\n      emailGroup.appendChild(emailInput);\n\n      // Password input\n      var passwordGroup = document.createElement('div');\n      passwordGroup.className = 'form-group';\n      passwordGroup.style.marginBottom = '24px';\n      var passwordLabel = document.createElement('label');\n      passwordLabel.textContent = 'Password';\n      passwordLabel.htmlFor = 'password-input';\n      passwordLabel.style.display = 'block';\n      passwordLabel.style.marginBottom = '8px';\n      passwordLabel.style.fontSize = '14px';\n      passwordLabel.style.color = '#999';\n      var passwordInput = document.createElement('input');\n      passwordInput.type = 'password';\n      passwordInput.id = 'password-input';\n      passwordInput.required = true;\n      passwordInput.style.width = '100%';\n      passwordInput.style.backgroundColor = '#111';\n      passwordInput.style.color = '#e0e0e0';\n      passwordInput.style.border = 'none';\n      passwordInput.style.borderRadius = '4px';\n      passwordInput.style.padding = '10px';\n      passwordInput.style.fontSize = '14px';\n      passwordInput.style.boxSizing = 'border-box';\n      passwordInput.setAttribute('autocomplete', 'new-password'); // This helps prevent prompts\n      passwordInput.setAttribute('data-lpignore', 'true'); // Helps with LastPass\n\n      passwordGroup.appendChild(passwordLabel);\n      passwordGroup.appendChild(passwordInput);\n\n      // Error message\n      var errorMessage = document.createElement('div');\n      errorMessage.className = 'error-message';\n      errorMessage.style.color = '#FF5555';\n      errorMessage.style.fontSize = '14px';\n      errorMessage.style.marginBottom = '16px';\n      errorMessage.style.display = 'none';\n\n      // Show initialization status if not ready\n      if (!this.initialized) {\n        var _errorMessage$parentN;\n        var initMessage = document.createElement('div');\n        initMessage.textContent = 'Authentication system is initializing...';\n        initMessage.style.color = '#FFA500';\n        initMessage.style.fontSize = '14px';\n        initMessage.style.marginBottom = '16px';\n        initMessage.style.display = 'block';\n        ((_errorMessage$parentN = errorMessage.parentNode) === null || _errorMessage$parentN === void 0 ? void 0 : _errorMessage$parentN.insertBefore(initMessage, errorMessage)) || form.appendChild(initMessage);\n      }\n\n      // Submit button\n      var buttonGroup = document.createElement('div');\n      buttonGroup.style.marginTop = '24px';\n      var submitButton = document.createElement('button');\n      submitButton.type = 'submit';\n      submitButton.textContent = mode === 'signup' ? 'Create Account' : 'Sign In';\n      submitButton.style.width = '100%';\n      submitButton.style.backgroundColor = '#FFFFFF';\n      submitButton.style.color = '#000000';\n      submitButton.style.border = 'none';\n      submitButton.style.borderRadius = '4px';\n      submitButton.style.padding = '12px';\n      submitButton.style.fontSize = '14px';\n      submitButton.style.cursor = 'pointer';\n      submitButton.style.fontWeight = 'bold';\n      submitButton.style.transition = 'all 0.2s';\n      submitButton.addEventListener('mouseover', function () {\n        submitButton.style.backgroundColor = '#EEEEEE';\n      });\n      submitButton.addEventListener('mouseout', function () {\n        submitButton.style.backgroundColor = '#FFFFFF';\n      });\n      buttonGroup.appendChild(submitButton);\n\n      // Toggle mode button\n      var toggleGroup = document.createElement('div');\n      toggleGroup.style.marginTop = '20px';\n      toggleGroup.style.textAlign = 'center';\n      var toggleText = document.createElement('span');\n      toggleText.textContent = mode === 'signup' ? 'Already have an account? ' : \"Don't have an account? \";\n      toggleText.style.fontSize = '14px';\n      toggleText.style.color = '#999';\n      var toggleButton = document.createElement('button');\n      toggleButton.type = 'button';\n      toggleButton.textContent = mode === 'signup' ? 'Sign In' : 'Create Account';\n      toggleButton.style.backgroundColor = 'transparent';\n      toggleButton.style.color = '#FFFFFF';\n      toggleButton.style.border = 'none';\n      toggleButton.style.padding = '0';\n      toggleButton.style.fontSize = '14px';\n      toggleButton.style.cursor = 'pointer';\n      toggleButton.style.textDecoration = 'underline';\n      toggleButton.onclick = function () {\n        _this4.showAuthModal(mode === 'signup' ? 'signin' : 'signup', onSuccess, actionDescription);\n      };\n      toggleGroup.appendChild(toggleText);\n      toggleGroup.appendChild(toggleButton);\n\n      // Assemble form\n      form.appendChild(emailGroup);\n      form.appendChild(passwordGroup);\n      form.appendChild(errorMessage);\n      form.appendChild(buttonGroup);\n\n      // Assemble modal\n      modalContent.appendChild(modalHeader);\n      modalContent.appendChild(actionText);\n      modalContent.appendChild(form);\n      modalContent.appendChild(toggleGroup);\n      modal.appendChild(modalContent);\n\n      // Add to document\n      document.body.appendChild(modal);\n\n      // Focus email input\n      setTimeout(function () {\n        emailInput.focus();\n      }, 100);\n    }\n  }, {\n    key: \"showEmailVerificationNotice\",\n    value: function showEmailVerificationNotice(email) {\n      var _this5 = this;\n      // Remove any existing notice\n      var existingNotice = document.getElementById('email-verify-notice');\n      if (existingNotice) {\n        existingNotice.remove();\n      }\n      var verifyNotice = document.createElement('div');\n      verifyNotice.id = 'email-verify-notice';\n      verifyNotice.style.position = 'fixed';\n      verifyNotice.style.bottom = '20px';\n      verifyNotice.style.right = '20px';\n      verifyNotice.style.backgroundColor = '#334433';\n      verifyNotice.style.color = 'white';\n      verifyNotice.style.padding = '15px 20px';\n      verifyNotice.style.borderRadius = '4px';\n      verifyNotice.style.zIndex = '9999';\n      verifyNotice.style.maxWidth = '300px';\n      verifyNotice.style.boxShadow = '0 4px 8px rgba(0,0,0,0.2)';\n      var noticeTitle = document.createElement('div');\n      noticeTitle.textContent = 'Email Verification Required';\n      noticeTitle.style.fontWeight = 'bold';\n      noticeTitle.style.marginBottom = '5px';\n      noticeTitle.style.fontSize = '14px';\n      var noticeText = document.createElement('div');\n      noticeText.textContent = \"Please check your email (\".concat(email, \") and verify your account to access all features.\");\n      noticeText.style.fontSize = '13px';\n      noticeText.style.lineHeight = '1.4';\n\n      // Add refresh button to check verification status\n      var refreshButton = document.createElement('button');\n      refreshButton.textContent = 'Check Verification Status';\n      refreshButton.style.backgroundColor = '#4a664a';\n      refreshButton.style.color = 'white';\n      refreshButton.style.border = 'none';\n      refreshButton.style.borderRadius = '4px';\n      refreshButton.style.padding = '8px 12px';\n      refreshButton.style.marginTop = '10px';\n      refreshButton.style.cursor = 'pointer';\n      refreshButton.style.fontSize = '12px';\n      refreshButton.style.width = '100%';\n      refreshButton.addEventListener('click', function () {\n        // Show loading state\n        refreshButton.textContent = 'Checking...';\n        refreshButton.disabled = true;\n\n        // Check session to see if email has been verified\n        _this5.checkSession().then(function (isAuthenticated) {\n          if (isAuthenticated) {\n            // Email has been verified, remove notice\n            verifyNotice.style.backgroundColor = '#33aa33';\n            noticeTitle.textContent = 'Email Verified!';\n            noticeText.textContent = 'Your email has been verified. You now have full access to all features.';\n            refreshButton.style.display = 'none';\n\n            // Add close button\n            var _closeButton = document.createElement('button');\n            _closeButton.textContent = 'Close';\n            _closeButton.style.backgroundColor = '#2d882d';\n            _closeButton.style.color = 'white';\n            _closeButton.style.border = 'none';\n            _closeButton.style.borderRadius = '4px';\n            _closeButton.style.padding = '8px 12px';\n            _closeButton.style.marginTop = '10px';\n            _closeButton.style.cursor = 'pointer';\n            _closeButton.style.fontSize = '12px';\n            _closeButton.style.width = '100%';\n            _closeButton.addEventListener('click', function () {\n              verifyNotice.remove();\n            });\n            verifyNotice.appendChild(_closeButton);\n\n            // Auto-remove after 5 seconds\n            setTimeout(function () {\n              verifyNotice.style.opacity = '0';\n              verifyNotice.style.transition = 'opacity 0.5s ease';\n              setTimeout(function () {\n                if (verifyNotice.parentNode) {\n                  verifyNotice.remove();\n                }\n              }, 500);\n            }, 5000);\n          } else {\n            // Email still not verified\n            refreshButton.textContent = 'Check Verification Status';\n            refreshButton.disabled = false;\n          }\n        });\n      });\n      var closeButton = document.createElement('button');\n      closeButton.textContent = '';\n      closeButton.style.position = 'absolute';\n      closeButton.style.top = '5px';\n      closeButton.style.right = '8px';\n      closeButton.style.background = 'transparent';\n      closeButton.style.border = 'none';\n      closeButton.style.color = 'white';\n      closeButton.style.fontSize = '18px';\n      closeButton.style.cursor = 'pointer';\n      closeButton.onclick = function () {\n        return verifyNotice.remove();\n      };\n      verifyNotice.appendChild(closeButton);\n      verifyNotice.appendChild(noticeTitle);\n      verifyNotice.appendChild(noticeText);\n      verifyNotice.appendChild(refreshButton);\n      document.body.appendChild(verifyNotice);\n\n      // Don't auto-remove this notice - keep it visible until user verifies email\n    }\n  }]);\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SupabaseAuth);\n\n//# sourceURL=webpack://generative-shapes/./src/SupabaseAuth.js?");

/***/ }),

/***/ "./src/UserShapesIntegration.js":
/*!**************************************!*\
  !*** ./src/UserShapesIntegration.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   integrateUserShapes: () => (/* binding */ integrateUserShapes)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, \"catch\": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n// UserShapesIntegration.js - Manages user shapes functionality\nvar UserShapesManager = /*#__PURE__*/function () {\n  function UserShapesManager(app) {\n    var _this = this;\n    _classCallCheck(this, UserShapesManager);\n    this.app = app;\n    this.supabase = null;\n    this.userShapes = [];\n    this.isLoading = false;\n\n    // Bind methods\n    this.initialize = this.initialize.bind(this);\n    this.addMyShapesButton = this.addMyShapesButton.bind(this);\n    this.saveShapeToDatabase = this.saveShapeToDatabase.bind(this);\n    this.loadUserShapes = this.loadUserShapes.bind(this);\n    this.showMyShapesModal = this.showMyShapesModal.bind(this);\n    this.deleteUserShape = this.deleteUserShape.bind(this);\n    this.loadShapeFromDatabase = this.loadShapeFromDatabase.bind(this);\n\n    // Initialize when auth is ready\n    if (app.auth && app.auth.supabase) {\n      this.supabase = app.auth.supabase;\n      this.initialize();\n    } else {\n      // Wait for auth to be initialized\n      var checkAuth = setInterval(function () {\n        if (app.auth && app.auth.supabase) {\n          _this.supabase = app.auth.supabase;\n          _this.initialize();\n          clearInterval(checkAuth);\n        }\n      }, 100);\n    }\n  }\n\n  /**\n   * Initialize user shapes functionality\n   */\n  return _createClass(UserShapesManager, [{\n    key: \"initialize\",\n    value: function initialize() {\n      var _this2 = this;\n      // Add the My Shapes button to the header if authenticated\n      if (this.app.auth.isAuthenticated()) {\n        this.addMyShapesButton();\n      }\n\n      // Add auth state listener to add/remove button based on auth state\n      this.app.auth.addAuthStateListener(function (isAuthenticated) {\n        if (isAuthenticated) {\n          _this2.addMyShapesButton();\n        } else {\n          var myShapesBtn = document.getElementById('my-shapes-btn');\n          if (myShapesBtn) {\n            myShapesBtn.remove();\n          }\n        }\n      });\n\n      // Modify the shape generator to save shapes to the database\n      this.modifyShapeGenerator();\n    }\n\n    /**\n    * Update an existing shape in the database with new parameters and style\n    * @param {string} shapeId - The ID of the shape to update\n    * @param {object} updateData - Object containing parameters and styleParams\n    * @returns {Promise<object>} - Result with success status\n    */\n  }, {\n    key: \"updateShapeInDatabase\",\n    value: (function () {\n      var _updateShapeInDatabase = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(shapeId, updateData) {\n        var _yield$this$supabase$, user, _yield$this$supabase$2, data, error, index;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (this.supabase) {\n                _context.next = 3;\n                break;\n              }\n              console.error('Supabase client not available');\n              return _context.abrupt(\"return\", {\n                success: false,\n                error: 'Database not available'\n              });\n            case 3:\n              _context.prev = 3;\n              _context.next = 6;\n              return this.supabase.auth.getUser();\n            case 6:\n              _yield$this$supabase$ = _context.sent;\n              user = _yield$this$supabase$.data.user;\n              if (!(!user || !user.id)) {\n                _context.next = 10;\n                break;\n              }\n              throw new Error('User not authenticated or ID not available');\n            case 10:\n              _context.next = 12;\n              return this.supabase.from('user_shapes').update({\n                parameters: updateData.parameters || {},\n                style_params: updateData.styleParams || {}\n                // last_modified will be updated automatically by the trigger\n              }).eq('id', shapeId).eq('user_id', user.id) // Security check: only update user's own shapes\n              .select();\n            case 12:\n              _yield$this$supabase$2 = _context.sent;\n              data = _yield$this$supabase$2.data;\n              error = _yield$this$supabase$2.error;\n              if (!error) {\n                _context.next = 17;\n                break;\n              }\n              throw error;\n            case 17:\n              // Update local cache\n              index = this.userShapes.findIndex(function (shape) {\n                return shape.id === shapeId;\n              });\n              if (index !== -1) {\n                this.userShapes[index] = _objectSpread(_objectSpread({}, this.userShapes[index]), {}, {\n                  parameters: updateData.parameters || {},\n                  style_params: updateData.styleParams || {}\n                });\n              }\n              console.log(\"Shape \".concat(shapeId, \" updated successfully\"));\n              return _context.abrupt(\"return\", {\n                success: true,\n                shape: data[0]\n              });\n            case 23:\n              _context.prev = 23;\n              _context.t0 = _context[\"catch\"](3);\n              console.error('Error updating shape in database:', _context.t0);\n              return _context.abrupt(\"return\", {\n                success: false,\n                error: _context.t0.message\n              });\n            case 27:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[3, 23]]);\n      }));\n      function updateShapeInDatabase(_x, _x2) {\n        return _updateShapeInDatabase.apply(this, arguments);\n      }\n      return updateShapeInDatabase;\n    }()\n    /**\n     * Add My Shapes button to the header\n     */\n    )\n  }, {\n    key: \"addMyShapesButton\",\n    value: function addMyShapesButton() {\n      // Check if button already exists\n      if (document.getElementById('my-shapes-btn')) {\n        return;\n      }\n\n      // Find the header actions container\n      var header = document.getElementById('main-header');\n      if (!header) return;\n      var actionsContainer = header.querySelector('.header-actions');\n      if (!actionsContainer) {\n        actionsContainer = document.createElement('div');\n        actionsContainer.className = 'header-actions';\n        actionsContainer.style.display = 'flex';\n        actionsContainer.style.gap = '8px';\n        header.appendChild(actionsContainer);\n      }\n\n      // Create My Shapes button\n      var myShapesBtn = document.createElement('button');\n      myShapesBtn.id = 'my-shapes-btn';\n      myShapesBtn.className = 'my-shapes-btn';\n      myShapesBtn.title = 'My Shapes';\n      myShapesBtn.innerHTML = \"\\n<span>My Shapes</span>\\n\";\n\n      // Style the button\n      myShapesBtn.style.display = 'flex';\n      myShapesBtn.style.alignItems = 'center';\n      myShapesBtn.style.borderRadius = '35px';\n      myShapesBtn.style.whiteSpace = 'nowrap';\n      myShapesBtn.style.gap = '6px';\n      myShapesBtn.style.backgroundColor = 'rgb(26, 26, 26)';\n      myShapesBtn.style.color = '#fff';\n      myShapesBtn.style.border = 'none';\n      myShapesBtn.style.padding = '6px 16px';\n      myShapesBtn.style.fontSize = '14px';\n      myShapesBtn.style.cursor = 'pointer';\n      myShapesBtn.style.fontFamily = \"'Menlo', 'Monaco', 'Courier New', monospace\";\n\n      // Add hover effects\n      myShapesBtn.addEventListener('mouseover', function () {\n        myShapesBtn.style.color = '#fff';\n        myShapesBtn.style.backgroundColor = 'rgb(42, 42, 42)';\n      });\n      myShapesBtn.addEventListener('mouseout', function () {\n        myShapesBtn.style.color = '#fff';\n        myShapesBtn.style.backgroundColor = 'rgb(26, 26, 26)';\n      });\n\n      // Add click handler\n      myShapesBtn.addEventListener('click', this.showMyShapesModal);\n\n      // Insert before the sign-in button or auth container if it exists\n      var authContainer = document.getElementById('auth-container');\n      if (authContainer) {\n        actionsContainer.insertBefore(myShapesBtn, authContainer);\n      } else {\n        actionsContainer.appendChild(myShapesBtn);\n      }\n    }\n\n    /**\n     * Modify the shape generator to save shapes to the database\n     */\n  }, {\n    key: \"modifyShapeGenerator\",\n    value: function modifyShapeGenerator() {\n      if (!this.app.generator || !this.app.generator.confirmShape) {\n        console.error('Shape generator not found or missing confirmShape method');\n        return;\n      }\n\n      // Skip if already modified\n      if (this.app.generator.confirmShape._isModifiedForSaving) {\n        return;\n      }\n\n      // Store original method\n      var originalConfirmShape = this.app.generator.confirmShape;\n\n      // Replace with version that saves to database\n      this.app.generator.confirmShape = /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var shapeData, result;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!(this.currentGeneratedCode && this.currentClassName && this.currentDescription)) {\n                _context2.next = 14;\n                break;\n              }\n              _context2.prev = 1;\n              if (!(this.controller.auth && this.controller.auth.isAuthenticated())) {\n                _context2.next = 9;\n                break;\n              }\n              // Save to database - using the UserShapesManager instance\n              shapeData = {\n                shapeName: this.currentClassName,\n                shapeClass: this.currentGeneratedCode,\n                description: this.currentDescription,\n                parameters: window.finalShapeParams || {}\n              }; // Call the saveShapeToDatabase method through the controller\n              if (!this.controller.userShapesManager) {\n                _context2.next = 9;\n                break;\n              }\n              _context2.next = 7;\n              return this.controller.userShapesManager.saveShapeToDatabase(shapeData);\n            case 7:\n              result = _context2.sent;\n              console.log('Shape saved to database:', result);\n            case 9:\n              _context2.next = 14;\n              break;\n            case 11:\n              _context2.prev = 11;\n              _context2.t0 = _context2[\"catch\"](1);\n              console.error('Error saving shape to database:', _context2.t0);\n              // Continue with normal confirmation even if database save fails\n            case 14:\n              return _context2.abrupt(\"return\", originalConfirmShape.call(this));\n            case 15:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this, [[1, 11]]);\n      }));\n\n      // Mark as modified to prevent double-wrapping\n      this.app.generator.confirmShape._isModifiedForSaving = true;\n    }\n\n    /**\n     * Save a shape to the database\n     */\n  }, {\n    key: \"saveShapeToDatabase\",\n    value: (function () {\n      var _saveShapeToDatabase = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(shapeData) {\n        var _yield$this$supabase$3, user, data, _yield$this$supabase$4, savedShape, error;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              if (this.supabase) {\n                _context3.next = 3;\n                break;\n              }\n              console.error('Supabase client not available');\n              return _context3.abrupt(\"return\", {\n                success: false,\n                error: 'Database not available'\n              });\n            case 3:\n              _context3.prev = 3;\n              _context3.next = 6;\n              return this.supabase.auth.getUser();\n            case 6:\n              _yield$this$supabase$3 = _context3.sent;\n              user = _yield$this$supabase$3.data.user;\n              if (!(!user || !user.id)) {\n                _context3.next = 10;\n                break;\n              }\n              throw new Error('User not authenticated or ID not available');\n            case 10:\n              // Prepare data for saving\n              data = {\n                user_id: user.id,\n                shape_name: shapeData.shapeName,\n                shape_class: shapeData.shapeClass,\n                description: shapeData.description,\n                parameters: shapeData.parameters,\n                created_at: new Date().toISOString()\n              }; // Insert into user_shapes table\n              _context3.next = 13;\n              return this.supabase.from('user_shapes').insert([data]).select();\n            case 13:\n              _yield$this$supabase$4 = _context3.sent;\n              savedShape = _yield$this$supabase$4.data;\n              error = _yield$this$supabase$4.error;\n              if (!error) {\n                _context3.next = 18;\n                break;\n              }\n              throw error;\n            case 18:\n              return _context3.abrupt(\"return\", {\n                success: true,\n                shape: savedShape[0]\n              });\n            case 21:\n              _context3.prev = 21;\n              _context3.t0 = _context3[\"catch\"](3);\n              console.error('Error saving shape to database:', _context3.t0);\n              return _context3.abrupt(\"return\", {\n                success: false,\n                error: _context3.t0.message\n              });\n            case 25:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this, [[3, 21]]);\n      }));\n      function saveShapeToDatabase(_x3) {\n        return _saveShapeToDatabase.apply(this, arguments);\n      }\n      return saveShapeToDatabase;\n    }()\n    /**\n     * Load user shapes from the database\n     */\n    )\n  }, {\n    key: \"loadUserShapes\",\n    value: (function () {\n      var _loadUserShapes = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var _yield$this$supabase$5, shapes, error;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              if (this.supabase) {\n                _context4.next = 3;\n                break;\n              }\n              console.error('Supabase client not available');\n              return _context4.abrupt(\"return\", {\n                success: false,\n                error: 'Database not available'\n              });\n            case 3:\n              _context4.prev = 3;\n              this.isLoading = true;\n\n              // Fetch shapes for the current user\n              _context4.next = 7;\n              return this.supabase.from('user_shapes').select('*').order('created_at', {\n                ascending: false\n              });\n            case 7:\n              _yield$this$supabase$5 = _context4.sent;\n              shapes = _yield$this$supabase$5.data;\n              error = _yield$this$supabase$5.error;\n              if (!error) {\n                _context4.next = 12;\n                break;\n              }\n              throw error;\n            case 12:\n              this.userShapes = shapes || [];\n              this.isLoading = false;\n              return _context4.abrupt(\"return\", {\n                success: true,\n                shapes: this.userShapes\n              });\n            case 17:\n              _context4.prev = 17;\n              _context4.t0 = _context4[\"catch\"](3);\n              console.error('Error loading user shapes:', _context4.t0);\n              this.isLoading = false;\n              return _context4.abrupt(\"return\", {\n                success: false,\n                error: _context4.t0.message\n              });\n            case 22:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this, [[3, 17]]);\n      }));\n      function loadUserShapes() {\n        return _loadUserShapes.apply(this, arguments);\n      }\n      return loadUserShapes;\n    }()\n    /**\n     * Delete a user shape from the database\n     */\n    )\n  }, {\n    key: \"deleteUserShape\",\n    value: (function () {\n      var _deleteUserShape = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(shapeId) {\n        var _yield$this$supabase$6, error;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              if (this.supabase) {\n                _context5.next = 3;\n                break;\n              }\n              console.error('Supabase client not available');\n              return _context5.abrupt(\"return\", {\n                success: false,\n                error: 'Database not available'\n              });\n            case 3:\n              _context5.prev = 3;\n              _context5.next = 6;\n              return this.supabase.from('user_shapes')[\"delete\"]().eq('id', shapeId);\n            case 6:\n              _yield$this$supabase$6 = _context5.sent;\n              error = _yield$this$supabase$6.error;\n              if (!error) {\n                _context5.next = 10;\n                break;\n              }\n              throw error;\n            case 10:\n              // Remove from local cache\n              this.userShapes = this.userShapes.filter(function (shape) {\n                return shape.id !== shapeId;\n              });\n              return _context5.abrupt(\"return\", {\n                success: true\n              });\n            case 14:\n              _context5.prev = 14;\n              _context5.t0 = _context5[\"catch\"](3);\n              console.error('Error deleting user shape:', _context5.t0);\n              return _context5.abrupt(\"return\", {\n                success: false,\n                error: _context5.t0.message\n              });\n            case 18:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this, [[3, 14]]);\n      }));\n      function deleteUserShape(_x4) {\n        return _deleteUserShape.apply(this, arguments);\n      }\n      return deleteUserShape;\n    }()\n    /**\n    * Load a shape from the database with its saved parameters and style\n    */\n    )\n  }, {\n    key: \"loadShapeFromDatabase\",\n    value: function loadShapeFromDatabase(shape) {\n      try {\n        var id = shape.id,\n          shape_name = shape.shape_name,\n          shape_class = shape.shape_class,\n          parameters = shape.parameters,\n          style_params = shape.style_params;\n\n        // Create a script to register the shape\n        var script = document.createElement('script');\n        script.type = 'text/javascript';\n        script.textContent = \"\\n    (function() {\\n      try {\\n        // Ensure window.Shape exists before continuing\\n        if (!window.Shape) {\\n          throw new Error(\\\"window.Shape is not defined. Shape base class is missing.\\\");\\n        }\\n        \\n        // Define the shape class\\n        \".concat(shape_class, \"\\n        \\n        // Verify the class was defined\\n        if (typeof \").concat(shape_name, \" !== 'function') {\\n          throw new Error(\\\"Shape class \").concat(shape_name, \" was not properly defined\\\");\\n        }\\n        \\n        // Store shape state for editor to use\\n        window.loadingShapeData = {\\n          id: \\\"\").concat(id, \"\\\",\\n          parameters: \").concat(JSON.stringify(parameters || {}), \",\\n          styleParams: \").concat(JSON.stringify(style_params || {}), \"\\n        };\\n        \\n        // Extract parameter values for shape construction\\n        const userParams = {};\\n        const finalParams = \").concat(JSON.stringify(parameters || {}), \";\\n        \\n        if (finalParams && Object.keys(finalParams).length > 0) {\\n          // Extract current values from parameters\\n          Object.keys(finalParams).forEach(param => {\\n            if (finalParams[param] && typeof finalParams[param].value !== 'undefined') {\\n              userParams[param] = finalParams[param].value;\\n            } else {\\n              userParams[param] = finalParams[param];\\n            }\\n          });\\n        }\\n        \\n        // Create a wrapper class that applies the custom parameters\\n        const OriginalClass = \").concat(shape_name, \";\\n        \").concat(shape_name, \" = class extends OriginalClass {\\n          constructor(props = {}) {\\n            // Merge user parameters with provided ones\\n            const mergedProps = { ...userParams, ...props };\\n            super(mergedProps);\\n          }\\n        };\\n        \\n        // Preserve original parameters for the UI\\n        \").concat(shape_name, \".parameters = OriginalClass.parameters;\\n        \\n        // Register the shape with the app\\n        if (window.shapeApp && window.shapeApp.shapes) {\\n          window.shapeApp.shapes['\").concat(shape_name, \"'] = \").concat(shape_name, \";\\n          console.log('Shape \").concat(shape_name, \" registered successfully from database');\\n          \\n          // Set selected shape so editor can find it\\n          window.shapeApp.selectedShape = '\").concat(shape_name, \"';\\n          \\n          // Only refresh grid if we're not going to open the editor\\n          if (window.shapeApp.renderShapeGrid) {\\n            window.shapeApp.renderShapeGrid(true);\\n          }\\n          \\n        } else {\\n          throw new Error(\\\"window.shapeApp or window.shapeApp.shapes is not defined\\\");\\n        }\\n      } catch (error) {\\n        console.error('Error loading shape from database:', error);\\n        \\n        // Show error message\\n        const toast = document.createElement('div');\\n        toast.textContent = 'Error loading shape: ' + error.message;\\n        toast.style.position = 'fixed';\\n        toast.style.bottom = '20px';\\n        toast.style.left = '50%';\\n        toast.style.transform = 'translateX(-50%)';\\n        toast.style.backgroundColor = '#FF5555';\\n        toast.style.color = 'white';\\n        toast.style.padding = '12px 20px';\\n        toast.style.borderRadius = '4px';\\n        toast.style.zIndex = '9999';\\n        toast.style.fontSize = '14px';\\n        document.body.appendChild(toast);\\n        \\n        setTimeout(() => {\\n          toast.style.opacity = '0';\\n          toast.style.transition = 'opacity 0.5s ease';\\n          setTimeout(() => toast.remove(), 500);\\n        }, 3000);\\n      }\\n    })();\\n    \");\n\n        // Add the script to the page\n        document.body.appendChild(script);\n        setTimeout(function () {\n          document.body.removeChild(script);\n        }, 200);\n        return {\n          success: true\n        };\n      } catch (error) {\n        console.error('Error loading shape from database:', error);\n        return {\n          success: false,\n          error: error.message\n        };\n      }\n    }\n\n    /**\n     * Apply style parameters to an SVG preview element\n     * @param {SVGElement} svg - The SVG element to style\n     * @param {Object} styleParams - Style parameters to apply\n     */\n  }, {\n    key: \"applyStylesToPreview\",\n    value: function applyStylesToPreview(svg, styleParams) {\n      if (!svg || !styleParams) return;\n      try {\n        // Find or create defs element\n        var defsElement = svg.querySelector('defs');\n        if (!defsElement) {\n          defsElement = document.createElementNS('http://www.w3.org/2000/svg', 'defs');\n          svg.insertBefore(defsElement, svg.firstChild);\n        }\n\n        // Clear existing gradients\n        var existingGradients = Array.from(defsElement.querySelectorAll('linearGradient, radialGradient'));\n        existingGradients.forEach(function (gradient) {\n          return gradient.remove();\n        });\n\n        // Determine fill value based on style\n        var fillValue = this.createStyleValue(defsElement, styleParams, 'fill');\n\n        // Determine stroke value based on style\n        var strokeValue = this.createStyleValue(defsElement, styleParams, 'stroke');\n\n        // Apply to all shape elements\n        var elements = svg.querySelectorAll('path, rect, circle, ellipse, polygon, polyline');\n        elements.forEach(function (element) {\n          // Apply fill\n          if (styleParams.fillType === 'none') {\n            element.setAttribute('fill', 'none');\n          } else {\n            element.setAttribute('fill', fillValue);\n            element.setAttribute('fill-opacity', styleParams.fillOpacity || 1.0);\n          }\n\n          // Apply stroke\n          if (styleParams.strokeType === 'none') {\n            element.setAttribute('stroke', 'none');\n          } else {\n            element.setAttribute('stroke', strokeValue);\n            element.setAttribute('stroke-width', styleParams.strokeWidth || 1);\n\n            // Apply dash pattern if needed\n            if (styleParams.strokeType === 'dashed' && styleParams.strokeDasharray) {\n              element.setAttribute('stroke-dasharray', styleParams.strokeDasharray);\n            } else {\n              element.removeAttribute('stroke-dasharray');\n            }\n          }\n        });\n      } catch (error) {\n        console.error('Error applying style to SVG preview:', error);\n      }\n    }\n\n    /**\n     * Helper method to create a style value (color, gradient) for the given style type\n     */\n  }, {\n    key: \"createStyleValue\",\n    value: function createStyleValue(defsElement, styleParams, styleType) {\n      // Determine parameters to use based on style type (fill or stroke)\n      var typePrefix = styleType === 'stroke' ? 'stroke' : 'fill';\n      var type = styleParams[\"\".concat(typePrefix, \"Type\")];\n\n      // Return value based on style type\n      if (type === 'solid' || type === 'dashed') {\n        return styleParams[\"\".concat(typePrefix, \"Color\")] || '#FFFFFF';\n      } else if (type === 'none') {\n        return 'none';\n      } else if (type === 'linearGradient') {\n        // Create linear gradient\n        var gradientId = \"\".concat(typePrefix, \"LinearGradient-\").concat(Date.now(), \"-\").concat(Math.floor(Math.random() * 1000));\n        var gradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');\n        gradient.setAttribute('id', gradientId);\n\n        // Set gradient angle\n        var angle = styleParams[\"\".concat(typePrefix, \"GradientAngle\")] || 90;\n        var rads = angle * Math.PI / 180;\n        var x1 = 0.5 - Math.cos(rads) * 0.5;\n        var y1 = 0.5 - Math.sin(rads) * 0.5;\n        var x2 = 0.5 + Math.cos(rads) * 0.5;\n        var y2 = 0.5 + Math.sin(rads) * 0.5;\n        gradient.setAttribute('x1', x1);\n        gradient.setAttribute('y1', y1);\n        gradient.setAttribute('x2', x2);\n        gradient.setAttribute('y2', y2);\n\n        // Create stops\n        var stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');\n        stop1.setAttribute('offset', '0%');\n        stop1.setAttribute('stop-color', styleParams[\"\".concat(typePrefix, \"GradientColor1\")] || '#3498DB');\n        var stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');\n        stop2.setAttribute('offset', '100%');\n        stop2.setAttribute('stop-color', styleParams[\"\".concat(typePrefix, \"GradientColor2\")] || '#9B59B6');\n        gradient.appendChild(stop1);\n        gradient.appendChild(stop2);\n        defsElement.appendChild(gradient);\n        return \"url(#\".concat(gradientId, \")\");\n      } else if (type === 'radialGradient') {\n        // Create radial gradient\n        var _gradientId = \"\".concat(typePrefix, \"RadialGradient-\").concat(Date.now(), \"-\").concat(Math.floor(Math.random() * 1000));\n        var _gradient = document.createElementNS('http://www.w3.org/2000/svg', 'radialGradient');\n        _gradient.setAttribute('id', _gradientId);\n        _gradient.setAttribute('cx', '0.5');\n        _gradient.setAttribute('cy', '0.5');\n        _gradient.setAttribute('r', '0.5');\n\n        // Create stops\n        var _stop = document.createElementNS('http://www.w3.org/2000/svg', 'stop');\n        _stop.setAttribute('offset', '0%');\n        _stop.setAttribute('stop-color', styleParams[\"\".concat(typePrefix, \"GradientColor1\")] || '#3498DB');\n        var _stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');\n        _stop2.setAttribute('offset', '100%');\n        _stop2.setAttribute('stop-color', styleParams[\"\".concat(typePrefix, \"GradientColor2\")] || '#9B59B6');\n        _gradient.appendChild(_stop);\n        _gradient.appendChild(_stop2);\n        defsElement.appendChild(_gradient);\n        return \"url(#\".concat(_gradientId, \")\");\n      }\n\n      // Default fallback\n      return styleParams[\"\".concat(typePrefix, \"Color\")] || '#FFFFFF';\n    }\n\n    /**\n     * Create shape preview with parameters and style\n     * This is a new version of the rendering code in showMyShapesModal\n     */\n  }, {\n    key: \"createShapePreview\",\n    value: function createShapePreview(shape, previewContainer) {\n      try {\n        // Extract the shape parameters and style\n        var shape_name = shape.shape_name,\n          shape_class = shape.shape_class,\n          parameters = shape.parameters,\n          style_params = shape.style_params;\n\n        // Use Function constructor to safely evaluate the shape class code\n        var renderShape = new Function('Shape', 'parameters', \"\\n      try {\\n        // Define the shape class\\n        \".concat(shape_class, \"\\n        \\n        // Create instance with parameters\\n        let shapeInstance;\\n        if (parameters && Object.keys(parameters).length > 0) {\\n          // Extract parameter values from the complex structure\\n          const paramValues = {};\\n          Object.keys(parameters).forEach(param => {\\n            if (parameters[param] && typeof parameters[param].value !== 'undefined') {\\n              paramValues[param] = parameters[param].value;\\n            } else {\\n              paramValues[param] = parameters[param];\\n            }\\n          });\\n          \\n          shapeInstance = new \").concat(shape_name, \"(paramValues);\\n        } else {\\n          shapeInstance = new \").concat(shape_name, \"();\\n        }\\n        \\n        // Get SVG content\\n        return shapeInstance.generateShape();\\n      } catch (error) {\\n        console.error('Error rendering shape:', error);\\n        return null;\\n      }\\n    \"));\n\n        // Execute the function with window.Shape and parameters as arguments\n        var svgContent = renderShape(window.Shape, parameters);\n        if (svgContent) {\n          // Create SVG element\n          var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n          svg.setAttribute('width', '100%');\n          svg.setAttribute('height', '100%');\n          svg.setAttribute('viewBox', '-110 -110 220 220');\n          svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');\n\n          // Create wrapper group\n          var wrapperGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n          wrapperGroup.setAttribute('transform', 'translate(0,0)');\n\n          // Set SVG content\n          wrapperGroup.innerHTML = svgContent;\n\n          // Add to SVG\n          svg.appendChild(wrapperGroup);\n\n          // Apply style if available\n          if (style_params && Object.keys(style_params).length > 0) {\n            this.applyStylesToPreview(svg, style_params);\n          }\n          previewContainer.appendChild(svg);\n          return true;\n        } else {\n          throw new Error('Failed to generate SVG content');\n        }\n      } catch (error) {\n        console.error('Error creating shape preview:', error);\n\n        // Fallback to color-based placeholder\n        var fallbackSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n        fallbackSvg.setAttribute('width', '100%');\n        fallbackSvg.setAttribute('height', '100%');\n        fallbackSvg.setAttribute('viewBox', '-100 -100 200 200');\n\n        // Generate color from shape name\n        var color = this.getColorFromString(shape.shape_name);\n\n        // Create a shape based on first character\n        var shapeLetter = shape.shape_name.charAt(0).toUpperCase();\n        fallbackSvg.innerHTML = \"\\n      <rect x=\\\"-100\\\" y=\\\"-100\\\" width=\\\"200\\\" height=\\\"200\\\" fill=\\\"#000\\\" />\\n      <circle cx=\\\"0\\\" cy=\\\"0\\\" r=\\\"60\\\" fill=\\\"\".concat(color, \"\\\" opacity=\\\"0.7\\\" />\\n      <text x=\\\"0\\\" y=\\\"15\\\" text-anchor=\\\"middle\\\" dominant-baseline=\\\"middle\\\" \\n            fill=\\\"white\\\" font-size=\\\"70\\\" font-family=\\\"monospace\\\">\").concat(shapeLetter, \"</text>\\n    \");\n        previewContainer.appendChild(fallbackSvg);\n        return false;\n      }\n    }\n\n    /**\n     * Show the My Shapes modal\n     */\n  }, {\n    key: \"showMyShapesModal\",\n    value: (function () {\n      var _showMyShapesModal = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n        var _this3 = this;\n        var existingModal, modal, modalContent, modalHeader, modalTitle, closeButton, shapesContainer, loadingIndicator, closeAllMenusExcept, _handleEscape, _yield$this$loadUserS, success, shapes, error, errorMessage, emptyContainer, emptyMessage, createButton;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              // Remove any existing modal\n              existingModal = document.getElementById('my-shapes-modal');\n              if (existingModal) {\n                existingModal.remove();\n              }\n\n              // Create modal container with more minimal styling\n              modal = document.createElement('div');\n              modal.id = 'my-shapes-modal';\n              modal.className = 'modal';\n              modal.style.position = 'fixed';\n              modal.style.top = '0';\n              modal.style.left = '0';\n              modal.style.width = '100%';\n              modal.style.height = '100%';\n              modal.style.display = 'flex';\n              modal.style.justifyContent = 'center';\n              modal.style.alignItems = 'center';\n              modal.style.zIndex = '2000';\n              modal.style.backgroundColor = 'rgba(0, 0, 0, 0.9)';\n              modal.style.backdropFilter = 'blur(5px)';\n\n              // Create modal content - more minimal design\n              modalContent = document.createElement('div');\n              modalContent.className = 'modal-content';\n              modalContent.style.backgroundColor = '#000';\n              modalContent.style.borderRadius = '8px';\n              modalContent.style.padding = '20px';\n              modalContent.style.width = '800px';\n              modalContent.style.maxWidth = '90%';\n              modalContent.style.maxHeight = '80vh';\n              modalContent.style.color = '#e0e0e0';\n              modalContent.style.fontFamily = \"'Menlo', 'Monaco', 'Courier New', monospace\";\n              modalContent.style.overflowY = 'auto';\n\n              // Create minimal header\n              modalHeader = document.createElement('div');\n              modalHeader.className = 'modal-header';\n              modalHeader.style.display = 'flex';\n              modalHeader.style.justifyContent = 'space-between';\n              modalHeader.style.alignItems = 'center';\n              modalHeader.style.marginBottom = '16px';\n              modalTitle = document.createElement('h3');\n              modalTitle.textContent = 'My Shapes';\n              modalTitle.style.margin = '0';\n              modalTitle.style.fontSize = '18px';\n              modalTitle.style.fontWeight = 'normal';\n              modalTitle.style.color = '#e0e0e0';\n              closeButton = document.createElement('button');\n              closeButton.className = 'close-button';\n              closeButton.innerHTML = \"<svg width=\\\"14\\\" height=\\\"14\\\" viewBox=\\\"0 0 14 14\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n          <path d=\\\"M1 1L13 13M1 13L13 1\\\" stroke=\\\"#e0e0e0\\\" stroke-width=\\\"1.5\\\" stroke-linecap=\\\"round\\\"/>\\n        </svg>\";\n              closeButton.style.backgroundColor = 'transparent';\n              closeButton.style.border = 'none';\n              closeButton.style.cursor = 'pointer';\n              closeButton.style.padding = '4px';\n              closeButton.style.display = 'flex';\n              closeButton.style.alignItems = 'center';\n              closeButton.style.justifyContent = 'center';\n              closeButton.onclick = function () {\n                return modal.remove();\n              };\n              modalHeader.appendChild(modalTitle);\n              modalHeader.appendChild(closeButton);\n\n              // Create shapes grid container - more densely packed\n              shapesContainer = document.createElement('div');\n              shapesContainer.id = 'user-shapes-container';\n              shapesContainer.style.display = 'grid';\n              shapesContainer.style.gridTemplateColumns = 'repeat(auto-fill, minmax(160px, 1fr))';\n              shapesContainer.style.gap = '12px';\n\n              // Show loading indicator\n              loadingIndicator = document.createElement('div');\n              loadingIndicator.textContent = 'Loading your shapes...';\n              loadingIndicator.style.textAlign = 'center';\n              loadingIndicator.style.padding = '32px';\n              loadingIndicator.style.color = '#888';\n              loadingIndicator.style.gridColumn = '1 / -1';\n              shapesContainer.appendChild(loadingIndicator);\n\n              // Assemble modal\n              modalContent.appendChild(modalHeader);\n              modalContent.appendChild(shapesContainer);\n              modal.appendChild(modalContent);\n\n              // Add to document\n              document.body.appendChild(modal);\n\n              // Function to close all open menus except the one clicked\n              closeAllMenusExcept = function closeAllMenusExcept(exceptId) {\n                document.querySelectorAll('.shape-menu-dropdown').forEach(function (menu) {\n                  if (menu.id !== exceptId) {\n                    menu.style.display = 'none';\n                  }\n                });\n              }; // Close menus when clicking elsewhere\n              document.addEventListener('click', function (event) {\n                if (!event.target.closest('.shape-menu-button') && !event.target.closest('.shape-menu-dropdown')) {\n                  closeAllMenusExcept(null);\n                }\n              });\n\n              // Add Escape key handler\n              _handleEscape = function handleEscape(e) {\n                if (e.key === 'Escape') {\n                  modal.remove();\n                  document.removeEventListener('keydown', _handleEscape);\n                  e.stopPropagation();\n                }\n              };\n              document.addEventListener('keydown', _handleEscape);\n\n              // Fetch user shapes\n              _context8.next = 74;\n              return this.loadUserShapes();\n            case 74:\n              _yield$this$loadUserS = _context8.sent;\n              success = _yield$this$loadUserS.success;\n              shapes = _yield$this$loadUserS.shapes;\n              error = _yield$this$loadUserS.error;\n              // Clear loading indicator\n              shapesContainer.innerHTML = '';\n              if (success) {\n                _context8.next = 88;\n                break;\n              }\n              errorMessage = document.createElement('div');\n              errorMessage.textContent = \"Error loading shapes: \".concat(error || 'Unknown error');\n              errorMessage.style.color = '#FF5555';\n              errorMessage.style.padding = '32px';\n              errorMessage.style.textAlign = 'center';\n              errorMessage.style.gridColumn = '1 / -1';\n              shapesContainer.appendChild(errorMessage);\n              return _context8.abrupt(\"return\");\n            case 88:\n              if (!(!shapes || shapes.length === 0)) {\n                _context8.next = 124;\n                break;\n              }\n              emptyContainer = document.createElement('div');\n              emptyContainer.style.display = 'flex';\n              emptyContainer.style.flexDirection = 'column';\n              emptyContainer.style.alignItems = 'center';\n              emptyContainer.style.justifyContent = 'center';\n              emptyContainer.style.gridColumn = '1 / -1';\n              emptyContainer.style.padding = '40px 32px';\n\n              // Keep the existing empty message\n              emptyMessage = document.createElement('div');\n              emptyMessage.textContent = 'You haven\\'t created any shapes yet.';\n              emptyMessage.style.color = '#888';\n              emptyMessage.style.textAlign = 'center';\n              emptyMessage.style.marginBottom = '32px';\n\n              // Create the button using the same styling as main.js\n              createButton = document.createElement('button');\n              createButton.className = 'create-shape-btn';\n              createButton.title = 'Create New Shape with AI';\n              createButton.innerHTML = \"\\n            <svg xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 24 24\\\" fill=\\\"none\\\" stroke=\\\"black\\\" stroke-width=\\\"2\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\">\\n              <path d=\\\"M12 5C12 5 12 19 12 19\\\"></path>\\n              <path d=\\\"M5 12C5 12 19 12 19 12\\\"></path>\\n            </svg>\\n            <span>Create</span>\\n          \";\n\n              // Style the button to match main.js\n              createButton.style.display = 'flex';\n              createButton.style.alignItems = 'center';\n              createButton.style.justifyContent = 'center';\n              createButton.style.gap = '8px';\n              createButton.style.backgroundColor = 'rgb(255, 255, 255)';\n              createButton.style.color = '#000';\n              createButton.style.border = 'none';\n              createButton.style.borderRadius = '35px';\n              createButton.style.padding = '6px 16px';\n              createButton.style.fontSize = '14px';\n              createButton.style.cursor = 'pointer';\n              createButton.style.fontFamily = \"'Menlo', 'Monaco', 'Courier New', monospace\";\n              createButton.addEventListener('mouseover', function () {\n                createButton.style.transform = 'scale(1.05)';\n              });\n              createButton.addEventListener('mouseout', function () {\n                createButton.style.transform = 'scale(1)';\n              });\n\n              // Add click handler to close modal and show generator\n              createButton.addEventListener('click', function () {\n                // Close the current modal\n                modal.remove();\n\n                // Show the create modal using the appropriate reference\n                if (_this3.controller && _this3.controller.generator) {\n                  _this3.controller.generator.showCreateModal();\n                } else if (_this3.app && _this3.app.generator) {\n                  _this3.app.generator.showCreateModal();\n                }\n              });\n\n              // Add both elements to the container\n              emptyContainer.appendChild(emptyMessage);\n              emptyContainer.appendChild(createButton);\n\n              // Add the container to the shapes container\n              shapesContainer.appendChild(emptyContainer);\n              return _context8.abrupt(\"return\");\n            case 124:\n              // Render each shape\n              shapes.forEach(function (shape) {\n                // Create shape card\n                var shapeCard = document.createElement('div');\n                shapeCard.className = 'shape-card';\n                shapeCard.style.backgroundColor = '#111';\n                shapeCard.style.borderRadius = '4px';\n                shapeCard.style.overflow = 'hidden';\n                shapeCard.style.display = 'flex';\n                shapeCard.style.flexDirection = 'column';\n                shapeCard.style.position = 'relative';\n                shapeCard.style.cursor = 'pointer';\n                shapeCard.style.transition = 'transform 0.2s ease, box-shadow 0.2s ease';\n\n                // Add hover effects\n                shapeCard.addEventListener('mouseover', function () {\n                  shapeCard.style.transform = 'translateY(-2px)';\n                  shapeCard.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.5)';\n\n                  // Show the menu button on hover\n                  var menuBtn = shapeCard.querySelector('.shape-menu-button');\n                  if (menuBtn) menuBtn.style.opacity = '1';\n                });\n                shapeCard.addEventListener('mouseout', function () {\n                  shapeCard.style.transform = 'translateY(0)';\n                  shapeCard.style.boxShadow = 'none';\n\n                  // Hide the menu button when not hovering\n                  var menuBtn = shapeCard.querySelector('.shape-menu-button');\n                  if (menuBtn) menuBtn.style.opacity = '0';\n                });\n\n                // Handle click to open in editor\n                shapeCard.addEventListener('click', function (event) {\n                  // Don't trigger if clicked on the menu button or dropdown\n                  if (!event.target.closest('.shape-menu-button') && !event.target.closest('.shape-menu-dropdown')) {\n                    // Load shape from database\n                    _this3.loadShapeFromDatabase(shape);\n\n                    // Close the modal\n                    modal.remove();\n\n                    // Show the editor after a brief delay to allow shape to register\n                    setTimeout(function () {\n                      if (_this3.app.showShapeEditor && typeof _this3.app.showShapeEditor === 'function') {\n                        _this3.app.showShapeEditor(shape.shape_name);\n                      } else if (_this3.app.editor && _this3.app.editor.showEditor) {\n                        _this3.app.editor.showEditor(shape.shape_name);\n                      }\n                    }, 100);\n                  }\n                });\n\n                // Create shape preview container\n                var previewContainer = document.createElement('div');\n                previewContainer.style.aspectRatio = '1';\n                previewContainer.style.display = 'flex';\n                previewContainer.style.justifyContent = 'center';\n                previewContainer.style.alignItems = 'center';\n                previewContainer.style.backgroundColor = '#000';\n                previewContainer.style.padding = '8px';\n                previewContainer.id = \"preview-\".concat(shape.id);\n                _this3.createShapePreview(shape, previewContainer);\n\n                // Add menu button (hidden by default, shown on hover)\n                var menuButton = document.createElement('button');\n                menuButton.className = 'shape-menu-button';\n                menuButton.innerHTML = \"\\n            <svg width=\\\"16\\\" height=\\\"16\\\" viewBox=\\\"0 0 16 16\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n              <circle cx=\\\"8\\\" cy=\\\"3\\\" r=\\\"1.5\\\" fill=\\\"#e0e0e0\\\"/>\\n              <circle cx=\\\"8\\\" cy=\\\"8\\\" r=\\\"1.5\\\" fill=\\\"#e0e0e0\\\"/>\\n              <circle cx=\\\"8\\\" cy=\\\"13\\\" r=\\\"1.5\\\" fill=\\\"#e0e0e0\\\"/>\\n            </svg>\\n          \";\n                menuButton.style.position = 'absolute';\n                menuButton.style.top = '6px';\n                menuButton.style.right = '6px';\n                menuButton.style.backgroundColor = 'rgba(0, 0, 0, 0.6)';\n                menuButton.style.border = 'none';\n                menuButton.style.borderRadius = '50%';\n                menuButton.style.width = '24px';\n                menuButton.style.height = '24px';\n                menuButton.style.display = 'flex';\n                menuButton.style.alignItems = 'center';\n                menuButton.style.justifyContent = 'center';\n                menuButton.style.cursor = 'pointer';\n                menuButton.style.zIndex = '10';\n                menuButton.style.opacity = '0'; // Hidden by default\n                menuButton.style.transition = 'opacity 0.2s ease';\n\n                // Create dropdown menu\n                var dropdownMenu = document.createElement('div');\n                dropdownMenu.className = 'shape-menu-dropdown';\n                dropdownMenu.id = \"menu-\".concat(shape.id);\n                dropdownMenu.style.position = 'absolute';\n                dropdownMenu.style.top = '32px';\n                dropdownMenu.style.right = '6px';\n                dropdownMenu.style.backgroundColor = '#222';\n                dropdownMenu.style.border = '1px solid #333';\n                dropdownMenu.style.borderRadius = '4px';\n                dropdownMenu.style.boxShadow = '0 4px 8px rgba(0,0,0,0.3)';\n                dropdownMenu.style.zIndex = '15';\n                dropdownMenu.style.display = 'none';\n\n                // --- Save to File Option (NEW) ---\n                var saveOption = document.createElement('div');\n                saveOption.className = 'menu-option';\n                saveOption.textContent = 'Save .js';\n                saveOption.style.padding = '8px 16px';\n                saveOption.style.fontSize = '12px';\n                saveOption.style.color = '#FFFFFF';\n                saveOption.style.cursor = 'pointer';\n                saveOption.addEventListener('click', function (event) {\n                  event.stopPropagation(); // Prevent card click\n                  dropdownMenu.style.display = 'none'; // Close menu\n\n                  try {\n                    var originalContent = shape.shape_class; // Get the current content\n                    var shapeName = shape.shape_name || 'shape'; // Get the shape name (used for filename and export)\n                    var filename = \"\".concat(shapeName, \".js\");\n                    var mimeType = 'text/javascript';\n\n                    // --- Start: Format Transformation ---\n\n                    // 1. Extract the actual class name from the string (robustly)\n                    //    This regex looks for \"class ClassName extends...\"\n                    var classNameMatch = originalContent.match(/class\\s+([\\w$]+)\\s+extends/);\n                    if (!classNameMatch || !classNameMatch[1]) {\n                      // Fallback if regex fails, use shapeName (might need adjustment if shapeName !== ClassName)\n                      console.warn(\"Could not reliably extract class name, using shape_name as fallback.\");\n                      // You might want to throw an error here if the class name is crucial and not found\n                      // throw new Error(\"Could not extract class name from shape definition.\");\n                    }\n                    // Use the extracted class name or fallback to shapeName (ensure it's a valid JS identifier)\n                    var className = classNameMatch ? classNameMatch[1] : shapeName;\n\n                    // 2. Remove `window.` prefix from `extends window.Shape`\n                    //    Using replace ensures we only change it in the extends clause\n                    var classBody = originalContent.replace(\"extends window.Shape\", \"extends Shape\");\n\n                    // 3. Construct the final content with import and export\n                    var finalContent = \"import { Shape } from './Shape.js';\\n\\n\".concat(classBody, \"\\n\\nexport default \").concat(className, \";\\n\");\n\n                    // --- End: Format Transformation ---\n\n                    // Use the transformed content to create the Blob\n                    var blob = new Blob([finalContent], {\n                      type: mimeType\n                    });\n                    var url = URL.createObjectURL(blob);\n\n                    // Create temporary link\n                    var a = document.createElement('a');\n                    a.href = url;\n                    a.download = filename;\n                    a.style.display = 'none';\n                    document.body.appendChild(a);\n\n                    // Trigger download\n                    a.click();\n\n                    // Clean up\n                    document.body.removeChild(a);\n                    URL.revokeObjectURL(url);\n\n                    // Assuming 'this' refers to an object with 'showToast' method\n                    if (_this3 && typeof _this3.showToast === 'function') {\n                      _this3.showToast(\"Saved \".concat(filename), 'success');\n                    } else {\n                      console.log(\"Saved \".concat(filename)); // Fallback log\n                    }\n                  } catch (saveError) {\n                    console.error('Error saving shape to file:', saveError);\n                    // Assuming 'this' refers to an object with 'showToast' method\n                    if (_this3 && typeof _this3.showToast === 'function') {\n                      _this3.showToast('Error saving file: ' + saveError.message, 'error');\n                    } else {\n                      console.error('Error saving file:', saveError.message); // Fallback log\n                    }\n                  }\n                });\n                dropdownMenu.appendChild(saveOption); // Add the new option\n\n                // Edit option\n                var editOption = document.createElement('div');\n                editOption.className = 'menu-option';\n                editOption.textContent = 'Edit';\n                editOption.style.padding = '8px 16px';\n                editOption.style.fontSize = '12px';\n                editOption.style.color = '#FFFFFF';\n                editOption.style.cursor = 'pointer';\n                // Add hover effect\n                editOption.addEventListener('mouseover', function () {\n                  editOption.style.backgroundColor = '#333';\n                });\n                editOption.addEventListener('mouseout', function () {\n                  editOption.style.backgroundColor = 'transparent';\n                });\n                // Edit handler\n                editOption.addEventListener('click', /*#__PURE__*/function () {\n                  var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(event) {\n                    return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n                      while (1) switch (_context6.prev = _context6.next) {\n                        case 0:\n                          event.stopPropagation();\n\n                          // Close the My Shapes modal\n                          modal.remove();\n\n                          // Edit the shape\n                          _this3.editUserShape(shape);\n                        case 3:\n                        case \"end\":\n                          return _context6.stop();\n                      }\n                    }, _callee6);\n                  }));\n                  return function (_x5) {\n                    return _ref2.apply(this, arguments);\n                  };\n                }());\n                dropdownMenu.appendChild(editOption);\n\n                // Delete option\n                var deleteOption = document.createElement('div');\n                deleteOption.className = 'menu-option';\n                deleteOption.textContent = 'Delete';\n                deleteOption.style.padding = '8px 16px';\n                deleteOption.style.fontSize = '12px';\n                deleteOption.style.color = '#FF5555';\n                deleteOption.style.cursor = 'pointer';\n\n                // Add hover effect\n                deleteOption.addEventListener('mouseover', function () {\n                  deleteOption.style.backgroundColor = '#333';\n                });\n                deleteOption.addEventListener('mouseout', function () {\n                  deleteOption.style.backgroundColor = 'transparent';\n                });\n\n                // Delete handler\n                deleteOption.addEventListener('click', /*#__PURE__*/function () {\n                  var _ref3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7(event) {\n                    var result;\n                    return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n                      while (1) switch (_context7.prev = _context7.next) {\n                        case 0:\n                          event.stopPropagation();\n                          if (!confirm(\"Are you sure you want to delete \\\"\".concat(shape.shape_name, \"\\\"?\"))) {\n                            _context7.next = 6;\n                            break;\n                          }\n                          _context7.next = 4;\n                          return _this3.deleteUserShape(shape.id);\n                        case 4:\n                          result = _context7.sent;\n                          if (result.success) {\n                            // Remove card with animation\n                            shapeCard.style.opacity = '0';\n                            shapeCard.style.transform = 'scale(0.9)';\n                            shapeCard.style.transition = 'opacity 0.3s ease, transform 0.3s ease';\n                            setTimeout(function () {\n                              shapeCard.remove();\n\n                              // Check if there are any shapes left\n                              if (shapesContainer.querySelector('.shape-card') === null) {\n                                var _emptyMessage = document.createElement('div');\n                                _emptyMessage.textContent = 'You haven\\'t created any shapes yet. Generate some shapes to see them here!';\n                                _emptyMessage.style.color = '#888';\n                                _emptyMessage.style.padding = '40px 32px';\n                                _emptyMessage.style.textAlign = 'center';\n                                _emptyMessage.style.gridColumn = '1 / -1';\n                                shapesContainer.appendChild(_emptyMessage);\n                              }\n                            }, 300);\n\n                            // Show success toast\n                            _this3.showToast('Shape deleted successfully', 'success');\n                          } else {\n                            _this3.showToast(\"Error deleting shape: \".concat(result.error), 'error');\n                          }\n                        case 6:\n                          dropdownMenu.style.display = 'none';\n                        case 7:\n                        case \"end\":\n                          return _context7.stop();\n                      }\n                    }, _callee7);\n                  }));\n                  return function (_x6) {\n                    return _ref3.apply(this, arguments);\n                  };\n                }());\n\n                // Add menu option to dropdown\n                dropdownMenu.appendChild(deleteOption);\n\n                // Menu toggle\n                menuButton.addEventListener('click', function (event) {\n                  event.stopPropagation();\n\n                  // Close all other menus\n                  closeAllMenusExcept(\"menu-\".concat(shape.id));\n\n                  // Toggle this menu\n                  if (dropdownMenu.style.display === 'none') {\n                    dropdownMenu.style.display = 'block';\n                  } else {\n                    dropdownMenu.style.display = 'none';\n                  }\n                });\n\n                // Assemble card\n                //   infoContainer.appendChild(shapeDesc);\n                //   shapeCard.appendChild(infoContainer);\n                shapeCard.appendChild(previewContainer);\n                shapeCard.appendChild(menuButton);\n                shapeCard.appendChild(dropdownMenu);\n\n                // Add to grid\n                shapesContainer.appendChild(shapeCard);\n              });\n            case 125:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8, this);\n      }));\n      function showMyShapesModal() {\n        return _showMyShapesModal.apply(this, arguments);\n      }\n      return showMyShapesModal;\n    }()\n    /**\n    * Edit a user shape using the ShapeGenerator edit functionality\n    */\n    )\n  }, {\n    key: \"editUserShape\",\n    value: function editUserShape(shape) {\n      var _this4 = this;\n      try {\n        // Get the shape details\n        var shape_name = shape.shape_name,\n          shape_class = shape.shape_class,\n          description = shape.description;\n\n        // Register the shape in the app (necessary for preview)\n        this.loadShapeFromDatabase(shape);\n\n        // After a short delay, open the edit modal\n        setTimeout(function () {\n          if (_this4.app.generator) {\n            // Set the current shape data in the generator\n            _this4.app.generator.currentGeneratedCode = shape_class;\n            _this4.app.generator.currentClassName = shape_name;\n            _this4.app.generator.currentDescription = description || \"Custom shape\";\n\n            // Create the modal\n            _this4.app.generator.showCreateModal();\n\n            // After a short delay, switch to edit mode\n            setTimeout(function () {\n              // Get the newly created modal\n              var modal = document.getElementById('create-shape-modal');\n              if (modal) {\n                // Switch to edit mode\n                _this4.app.generator.editShape(shape_class, shape_name);\n              }\n            }, 100);\n          } else {\n            _this4.showToast('Shape editor not available', 'error');\n          }\n        }, 100);\n      } catch (error) {\n        console.error('Error editing shape:', error);\n        this.showToast('Error editing shape: ' + error.message, 'error');\n      }\n    }\n\n    /**\n     * Helper method to generate a color from a string\n     * @param {string} str - Input string\n     * @returns {string} - HEX color\n     */\n  }, {\n    key: \"getColorFromString\",\n    value: function getColorFromString(str) {\n      // Simple hash function\n      var hash = 0;\n      for (var i = 0; i < str.length; i++) {\n        hash = str.charCodeAt(i) + ((hash << 5) - hash);\n      }\n\n      // Generate vibrant colors (higher saturation)\n      var h = hash % 360;\n      return \"hsl(\".concat(h, \", 80%, 65%)\");\n    }\n\n    /**\n     * Display a toast message\n     * @param {string} message - Message to display\n     * @param {string} type - Type of toast (success, error)\n     */\n  }, {\n    key: \"showToast\",\n    value: function showToast(message) {\n      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'success';\n      var toast = document.createElement('div');\n      toast.textContent = message;\n      toast.style.position = 'fixed';\n      toast.style.bottom = '20px';\n      toast.style.left = '50%';\n      toast.style.transform = 'translateX(-50%)';\n      toast.style.backgroundColor = type === 'success' ? '#4CAF50' : '#FF5555';\n      toast.style.color = 'white';\n      toast.style.padding = '12px 20px';\n      toast.style.borderRadius = '4px';\n      toast.style.zIndex = '9999';\n      toast.style.fontSize = '14px';\n      toast.style.boxShadow = '0 2px 8px rgba(0,0,0,0.2)';\n      document.body.appendChild(toast);\n      setTimeout(function () {\n        toast.style.opacity = '0';\n        toast.style.transition = 'opacity 0.5s ease';\n        setTimeout(function () {\n          return toast.remove();\n        }, 500);\n      }, 3000);\n    }\n  }]);\n}(); // Export a function to integrate with the app\nfunction integrateUserShapes(app) {\n  app.userShapesManager = new UserShapesManager(app);\n  return app.userShapesManager;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (integrateUserShapes);\n\n//# sourceURL=webpack://generative-shapes/./src/UserShapesIntegration.js?");

/***/ }),

/***/ "./src/analytics.js":
/*!**************************!*\
  !*** ./src/analytics.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   events: () => (/* binding */ events),\n/* harmony export */   initGA: () => (/* binding */ initGA),\n/* harmony export */   trackEvent: () => (/* binding */ trackEvent)\n/* harmony export */ });\n// analytics.js - A simple GA4 implementation\n\n// Initialize Google Analytics\nfunction initGA() {\n  // Add the GA4 script to the page\n  var script = document.createElement('script');\n  script.async = true;\n  script.src = \"https://www.googletagmanager.com/gtag/js?id=G-1360DQWGS3\";\n  document.head.appendChild(script);\n\n  // Set up the gtag function\n  window.dataLayer = window.dataLayer || [];\n  function gtag() {\n    window.dataLayer.push(arguments);\n  }\n  gtag('js', new Date());\n  gtag('config', 'G-1360DQWGS3');\n\n  // Make gtag accessible globally\n  window.gtag = gtag;\n}\n\n// Track any event\nfunction trackEvent(eventName) {\n  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (window.gtag) {\n    window.gtag('event', eventName, params);\n  }\n}\n\n// Key events to track in your app\nvar events = {\n  // Track when a user views a shape\n  viewShape: function viewShape(shapeName) {\n    trackEvent('shape_view', {\n      shape_name: shapeName\n    });\n  },\n  // Track when a user creates a shape with AI\n  createShape: function createShape(shapeName, shapePrompt) {\n    trackEvent('shape_create', {\n      shape_name: shapeName,\n      shape_prompt: shapePrompt\n    });\n  },\n  // Track when a user edits parameters\n  editShape: function editShape(shapeName) {\n    trackEvent('shape_edit', {\n      shape_name: shapeName\n    });\n  },\n  // Track when a user exports a shape\n  exportShape: function exportShape(shapeName, format) {\n    trackEvent('shape_export', {\n      shape_name: shapeName,\n      format: format\n    });\n  }\n};\n\n//# sourceURL=webpack://generative-shapes/./src/analytics.js?");

/***/ }),

/***/ "./src/authIntegration.js":
/*!********************************!*\
  !*** ./src/authIntegration.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   integrateAuth: () => (/* binding */ integrateAuth)\n/* harmony export */ });\n/* harmony import */ var _SupabaseAuth_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SupabaseAuth.js */ \"./src/SupabaseAuth.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, \"catch\": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\n\n\n// Function to integrate auth with the ShapeApp\nfunction integrateAuth(app) {\n  app.auth = new _SupabaseAuth_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](app);\n  addAuthUI(app);\n  modifyShapeGenerator(app);\n  return app.auth;\n}\n\n// Add auth UI elements to the app\nfunction addAuthUI(app) {\n  // Wait for DOM to be ready\n  if (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', function () {\n      return addAuthUIElements(app);\n    });\n  } else {\n    addAuthUIElements(app);\n  }\n\n  // Set up auth state listener to update UI\n  app.auth.addAuthStateListener(function (isAuthenticated, user) {\n    var additionalInfo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    updateAuthUI(isAuthenticated, user, additionalInfo);\n  });\n}\n\n// Add auth UI elements to the header\nfunction addAuthUIElements(app) {\n  // Find the header\n  var header = document.getElementById('main-header');\n  if (!header) {\n    console.error('Header not found');\n    return;\n  }\n\n  // Get the actions container\n  var actionsContainer = header.querySelector('.header-actions');\n  if (!actionsContainer) {\n    // Create it if it doesn't exist\n    actionsContainer = document.createElement('div');\n    actionsContainer.className = 'header-actions';\n    actionsContainer.style.display = 'flex';\n    actionsContainer.style.gap = '8px';\n    header.appendChild(actionsContainer);\n  }\n\n  // Create auth button container\n  var authContainer = document.createElement('div');\n  authContainer.id = 'auth-container';\n  authContainer.style.display = 'flex';\n  authContainer.style.alignItems = 'center';\n  authContainer.style.marginLeft = 'auto';\n\n  // Create sign-in button (initially shown)\n  var signInButton = document.createElement('button');\n  signInButton.id = 'sign-in-button';\n  signInButton.textContent = 'Sign In';\n  signInButton.className = 'auth-button';\n  signInButton.style.backgroundColor = 'transparent';\n  signInButton.style.color = '#888';\n  signInButton.style.border = 'none';\n  signInButton.style.borderRadius = '4px';\n  signInButton.style.padding = '6px 12px';\n  signInButton.style.fontSize = '14px';\n  signInButton.style.cursor = 'pointer';\n  signInButton.style.fontFamily = \"'Menlo', 'Monaco', 'Courier New', monospace\";\n  signInButton.style.display = 'inline-block';\n  signInButton.style.whiteSpace = 'nowrap';\n  signInButton.onclick = function () {\n    return app.auth.showAuthModal('signin');\n  };\n\n  // Create user profile button (initially hidden)\n  var userButton = document.createElement('button');\n  userButton.id = 'user-button';\n  userButton.className = 'auth-button';\n  userButton.style.backgroundColor = 'transparent';\n  userButton.style.color = '#fff';\n  userButton.style.border = 'none';\n  userButton.style.borderRadius = '4px';\n  userButton.style.padding = '6px 12px';\n  userButton.style.fontSize = '14px';\n  userButton.style.cursor = 'pointer';\n  userButton.style.display = 'none';\n  userButton.style.fontFamily = \"'Menlo', 'Monaco', 'Courier New', monospace\";\n\n  // Add dropdown for signed-in user\n  var dropdownOpen = false;\n  userButton.onclick = function (e) {\n    e.stopPropagation();\n    if (dropdownOpen) {\n      var _dropdown = document.getElementById('user-dropdown');\n      if (_dropdown) _dropdown.remove();\n      dropdownOpen = false;\n      return;\n    }\n\n    // Create dropdown\n    var dropdown = document.createElement('div');\n    dropdown.id = 'user-dropdown';\n    dropdown.style.position = 'absolute';\n    dropdown.style.top = '50px';\n    dropdown.style.right = '10px';\n    dropdown.style.backgroundColor = '#000';\n    dropdown.style.border = '1px solid #333';\n    dropdown.style.borderRadius = '4px';\n    dropdown.style.padding = '8px 0';\n    dropdown.style.zIndex = '1000';\n    dropdown.style.minWidth = '150px';\n\n    // Add sign out option\n    var signOutOption = document.createElement('div');\n    signOutOption.textContent = 'Sign Out';\n    signOutOption.style.padding = '8px 16px';\n    signOutOption.style.color = '#e0e0e0';\n    signOutOption.style.fontSize = '14px';\n    signOutOption.style.cursor = 'pointer';\n    signOutOption.style.transition = 'background-color 0.2s';\n    signOutOption.addEventListener('mouseover', function () {\n      signOutOption.style.backgroundColor = '#333';\n    });\n    signOutOption.addEventListener('mouseout', function () {\n      signOutOption.style.backgroundColor = 'transparent';\n    });\n    signOutOption.onclick = /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return app.auth.signOut();\n          case 2:\n            dropdown.remove();\n            dropdownOpen = false;\n          case 4:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }));\n    dropdown.appendChild(signOutOption);\n    document.body.appendChild(dropdown);\n    dropdownOpen = true;\n\n    // Close dropdown when clicking elsewhere\n    var _clickOutside = function clickOutside(e) {\n      if (!dropdown.contains(e.target) && e.target !== userButton) {\n        dropdown.remove();\n        dropdownOpen = false;\n        document.removeEventListener('click', _clickOutside);\n      }\n    };\n    document.addEventListener('click', _clickOutside);\n  };\n\n  // Add buttons to container\n  authContainer.appendChild(signInButton);\n  authContainer.appendChild(userButton);\n\n  // Add auth container to header\n  actionsContainer.appendChild(authContainer);\n\n  // Update UI based on initial auth state\n  updateAuthUI(app.auth.isAuthenticated(), app.auth.getCurrentUser());\n}\n\n// Update auth UI based on auth state\nfunction updateAuthUI(isAuthenticated, user) {\n  var additionalInfo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var signInButton = document.getElementById('sign-in-button');\n  var userButton = document.getElementById('user-button');\n  if (!signInButton || !userButton) return;\n  if (isAuthenticated && user) {\n    // Show user button, hide sign-in button\n    signInButton.style.display = 'none';\n    userButton.style.display = 'block';\n\n    // Update user button text with email\n    var email = user.email || 'User';\n    userButton.textContent = email.split('@')[0];\n\n    // Remove any verification notice if it exists\n    var verifyNotice = document.getElementById('email-verify-notice');\n    if (verifyNotice) {\n      verifyNotice.remove();\n    }\n  } else {\n    // Show sign-in button, hide user button\n    signInButton.style.display = 'block';\n    userButton.style.display = 'none';\n\n    // Check if there's a verification requirement\n    if (additionalInfo && additionalInfo.requiresEmailVerification) {\n      // Show verification notice if not already present\n      if (!document.getElementById('email-verify-notice')) {\n        // Using the new showEmailVerificationNotice method if available\n        if (typeof app.auth.showEmailVerificationNotice === 'function') {\n          app.auth.showEmailVerificationNotice(additionalInfo.email || 'your inbox');\n        } else {\n          // Fallback to the old implementation\n          var _verifyNotice = document.createElement('div');\n          _verifyNotice.id = 'email-verify-notice';\n          _verifyNotice.style.position = 'fixed';\n          _verifyNotice.style.bottom = '20px';\n          _verifyNotice.style.right = '20px';\n          _verifyNotice.style.backgroundColor = '#334433';\n          _verifyNotice.style.color = 'white';\n          _verifyNotice.style.padding = '15px 20px';\n          _verifyNotice.style.borderRadius = '4px';\n          _verifyNotice.style.zIndex = '9999';\n          _verifyNotice.style.maxWidth = '300px';\n          _verifyNotice.style.boxShadow = '0 4px 8px rgba(0,0,0,0.2)';\n          var noticeTitle = document.createElement('div');\n          noticeTitle.textContent = 'Email Verification Required';\n          noticeTitle.style.fontWeight = 'bold';\n          noticeTitle.style.marginBottom = '5px';\n          noticeTitle.style.fontSize = '14px';\n          var noticeText = document.createElement('div');\n          noticeText.textContent = \"Please check your email (\".concat(additionalInfo.email || 'your inbox', \") and verify your account to access all features.\");\n          noticeText.style.fontSize = '13px';\n          noticeText.style.lineHeight = '1.4';\n          var closeButton = document.createElement('button');\n          closeButton.textContent = '';\n          closeButton.style.position = 'absolute';\n          closeButton.style.top = '5px';\n          closeButton.style.right = '8px';\n          closeButton.style.background = 'transparent';\n          closeButton.style.border = 'none';\n          closeButton.style.color = 'white';\n          closeButton.style.fontSize = '18px';\n          closeButton.style.cursor = 'pointer';\n          closeButton.onclick = function () {\n            return _verifyNotice.remove();\n          };\n          _verifyNotice.appendChild(closeButton);\n          _verifyNotice.appendChild(noticeTitle);\n          _verifyNotice.appendChild(noticeText);\n          document.body.appendChild(_verifyNotice);\n\n          // Auto-remove after 10 seconds\n          setTimeout(function () {\n            _verifyNotice.style.opacity = '0';\n            _verifyNotice.style.transition = 'opacity 0.5s ease';\n            setTimeout(function () {\n              if (_verifyNotice.parentNode) {\n                _verifyNotice.remove();\n              }\n            }, 500);\n          }, 10000);\n        }\n      }\n    }\n  }\n}\n\n// Modify ShapeGenerator to check auth before showing create modal\nfunction modifyShapeGenerator(app) {\n  // Make sure ShapeGenerator exists\n  if (!app.generator || !app.generator.showCreateModal) {\n    console.error('ShapeGenerator not found or missing showCreateModal method');\n    return;\n  }\n\n  // Skip if already modified\n  if (app.generator.showCreateModal._isModified) {\n    console.log('ShapeGenerator already modified');\n    return;\n  }\n\n  // Get the original showCreateModal method\n  var originalShowCreateModal = app.generator.showCreateModal;\n\n  // Replace with stricter auth-checking version\n  app.generator.showCreateModal = function () {\n    console.log('Strict auth check for shape generation');\n\n    // Hard block - User must be authenticated with verified email\n    if (!app.auth.isAuthenticated()) {\n      // Get current user for a better error message\n      var user = app.auth.getCurrentUser();\n\n      // If user exists but email not verified\n      if (user) {\n        console.log('Blocked shape generation - email not verified:', user.email);\n\n        // Show error message\n        var toast = document.createElement('div');\n        toast.textContent = 'Email verification required before creating shapes';\n        toast.style.position = 'fixed';\n        toast.style.bottom = '20px';\n        toast.style.left = '50%';\n        toast.style.transform = 'translateX(-50%)';\n        toast.style.backgroundColor = '#f44336';\n        toast.style.color = 'white';\n        toast.style.padding = '12px 20px';\n        toast.style.borderRadius = '4px';\n        toast.style.zIndex = '9999';\n        toast.style.fontSize = '14px';\n        document.body.appendChild(toast);\n\n        // Show verification notice\n        if (typeof app.auth.showEmailVerificationNotice === 'function') {\n          app.auth.showEmailVerificationNotice(user.email);\n        }\n        setTimeout(function () {\n          toast.style.opacity = '0';\n          toast.style.transition = 'opacity 0.5s ease';\n          setTimeout(function () {\n            return toast.remove();\n          }, 500);\n        }, 3000);\n        return;\n      }\n\n      // If no user at all, show auth modal\n      // console.log('No user - showing auth modal');\n      app.auth.showAuthModal('signin', function () {\n        // Verify auth state again after signin\n        if (app.auth.isAuthenticated()) {\n          originalShowCreateModal.call(app.generator);\n        }\n      }, 'create new shapes');\n      return;\n    }\n\n    // User is authenticated and email verified\n    // console.log('User verified, allowing shape creation');\n    originalShowCreateModal.call(app.generator);\n  };\n\n  // Mark as modified to prevent double-wrapping\n  app.generator.showCreateModal._isModified = true;\n  console.log('ShapeGenerator.showCreateModal has been strictly modified');\n}\n\n// Initialize auth when imported\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (integrateAuth);\n\n//# sourceURL=webpack://generative-shapes/./src/authIntegration.js?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _styles_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./styles.css */ \"./src/styles.css\");\n/* harmony import */ var _shapesRegistry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shapesRegistry */ \"./src/shapesRegistry.js\");\n/* harmony import */ var _shapes_Shape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shapes/Shape */ \"./src/shapes/Shape.js\");\n/* harmony import */ var _ShapeEditor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ShapeEditor */ \"./src/ShapeEditor.js\");\n/* harmony import */ var _ShapeHistory__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ShapeHistory */ \"./src/ShapeHistory.js\");\n/* harmony import */ var _ShapeAnimationManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ShapeAnimationManager */ \"./src/ShapeAnimationManager.js\");\n/* harmony import */ var _ShapeGenerator_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ShapeGenerator.js */ \"./src/ShapeGenerator.js\");\n/* harmony import */ var _authIntegration_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./authIntegration.js */ \"./src/authIntegration.js\");\n/* harmony import */ var _Integration_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Integration.js */ \"./src/Integration.js\");\n/* harmony import */ var _analytics_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./analytics.js */ \"./src/analytics.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n\n\n\n// import ShapeFavorites from './ShapeFavorites';\n\n\n\n\n\nvar ShapeApp = /*#__PURE__*/function () {\n  function ShapeApp() {\n    _classCallCheck(this, ShapeApp);\n    // State variables\n    this.preloader = document.getElementById('preloader');\n    this.selectedShape = null;\n    this.currentCategory = 'all'; // Currently selected category\n    this.currentSearchTerm = '';\n    this.gridColumns = 5; // Default grid size (columns)\n    this.lastSelectedShapeId = null; // To remember which shape was selected\n    this.gridState = {\n      scrollY: 0,\n      shapesVisible: [] // Will store IDs of visible shapes before editor opens\n    };\n    this.lastClickedShapeIndex = -1; // Track position in the grid\n    this.lastClickedRow = -1; // Approximate row in the grid\n    this.lastClickedColumn = -1; // Approximate column in the grid\n\n    this.parameters = {}; // Initialize parameters object\n\n    // Make Shape class available to the editor\n    this.Shape = _shapes_Shape__WEBPACK_IMPORTED_MODULE_2__.Shape;\n    this.shapes = _shapesRegistry__WEBPACK_IMPORTED_MODULE_1__[\"default\"];\n\n    // Initialize animation manager\n    this.animationEnabled = true;\n    this.animationManager = new _ShapeAnimationManager__WEBPACK_IMPORTED_MODULE_5__[\"default\"](this);\n\n    // Initialize modules\n    this.history = new _ShapeHistory__WEBPACK_IMPORTED_MODULE_4__[\"default\"](this);\n    // this.favorites = new ShapeFavorites(this);\n    this.editor = new _ShapeEditor__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this);\n    this.generator = new _ShapeGenerator_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](this);\n\n    // Bind methods\n    this.renderShapeGrid = this.renderShapeGrid.bind(this);\n    this.saveGridState = this.saveGridState.bind(this);\n    this.returnToGrid = this.returnToGrid.bind(this);\n    this.showShapeEditor = this.showShapeEditor.bind(this);\n    this.updateShape = this.updateShape.bind(this);\n  }\n\n  /**\n   * Initialize the application when DOM is loaded\n   */\n  return _createClass(ShapeApp, [{\n    key: \"init\",\n    value: function init() {\n      var _this = this;\n      // initializeAuth();\n      // Create UI controls\n      this.createMinimalHeader();\n      this.createCategoryFilters();\n      this.scrollSelectedCategoryIntoView();\n\n      // Render initial grid\n      this.renderShapeGrid();\n\n      // Initialize favorites\n      // this.favorites.init();\n\n      // Handle window resize in a simple way\n      window.addEventListener('resize', function () {\n        if (!_this.selectedShape) {\n          _this.renderShapeGrid(true, true); // Keep scroll, refresh grid only\n        }\n      });\n\n      // Start the animation loop\n      if (this.animationEnabled) {\n        this.animationManager.startAnimationLoop();\n      }\n\n      // Add global click handler as a fallback\n      document.addEventListener('click', this.handleGlobalClick.bind(this), true);\n    }\n\n    /**\n     * Update the shape display\n     * This method is used by ShapeHistory when restoring states\n     */\n  }, {\n    key: \"updateShape\",\n    value: function updateShape() {\n      if (this.editor && this.editor.updateShape) {\n        // Make sure we transfer the parameters to the editor\n        if (this.parameters && Object.keys(this.parameters).length > 0) {\n          this.editor.parameters = _objectSpread({}, this.parameters);\n        }\n        this.editor.updateShape();\n      }\n    }\n\n    // This is a complete solution including both the function that creates the pills\n    // and the function that selects them, since they need to work together\n\n    // 1. Replace the createCategoryFilters method in ShapeApp class with this version:\n  }, {\n    key: \"createCategoryFilters\",\n    value: function createCategoryFilters() {\n      var _this2 = this;\n      // Define categories array with all categories\n      var categories = [{\n        id: 'all',\n        name: 'All'\n      }, {\n        id: 'basic',\n        name: 'Basic'\n      }, {\n        id: 'stars',\n        name: 'Stars'\n      }, {\n        id: 'grids',\n        name: 'Grids'\n      }, {\n        id: 'curved',\n        name: 'Waves'\n      }, {\n        id: 'circles',\n        name: 'Circles'\n      }, {\n        id: 'layered',\n        name: 'Layered'\n      }, {\n        id: 'nature',\n        name: 'Nature'\n      }, {\n        id: 'rounded',\n        name: 'Rounded'\n      }];\n\n      // Load initial category selection\n      var initialSelectedCategory = 'all';\n      try {\n        var savedCategory = localStorage.getItem('selectedCategory');\n        if (savedCategory) {\n          initialSelectedCategory = savedCategory;\n        }\n\n        // Set the current category\n        this.currentCategory = initialSelectedCategory === 'all' ? null : initialSelectedCategory;\n        console.log(\"Loaded from localStorage: \".concat(initialSelectedCategory, \", set currentCategory to \").concat(this.currentCategory));\n      } catch (e) {\n        console.warn('Could not retrieve saved category from localStorage', e);\n      }\n\n      // Create a container for all category pills\n      var filterContainer = document.createElement('div');\n      filterContainer.className = 'category-pills-container';\n      filterContainer.id = 'category-filters-container';\n      filterContainer.style.scrollbarWidth = 'none'; // Firefox\n      filterContainer.style.msOverflowStyle = 'none'; // IE and Edge\n\n      // Generate SVG icons for each category\n      var categoryIcons = {\n        'all': \"<svg width=\\\"16\\\" height=\\\"16\\\" viewBox=\\\"0 0 16 16\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n      <rect x=\\\"3\\\" y=\\\"3\\\" width=\\\"4\\\" height=\\\"4\\\" rx=\\\"1\\\" stroke=\\\"currentColor\\\"/>\\n      <rect x=\\\"9\\\" y=\\\"3\\\" width=\\\"4\\\" height=\\\"4\\\" rx=\\\"1\\\" stroke=\\\"currentColor\\\"/>\\n      <rect x=\\\"3\\\" y=\\\"9\\\" width=\\\"4\\\" height=\\\"4\\\" rx=\\\"1\\\" stroke=\\\"currentColor\\\"/>\\n      <rect x=\\\"9\\\" y=\\\"9\\\" width=\\\"4\\\" height=\\\"4\\\" rx=\\\"1\\\" stroke=\\\"currentColor\\\"/>\\n    </svg>\",\n        'basic': \"<svg width=\\\"16\\\" height=\\\"16\\\" viewBox=\\\"0 0 16 16\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n      <rect x=\\\"3\\\" y=\\\"3\\\" width=\\\"10\\\" height=\\\"10\\\" rx=\\\"1\\\" stroke=\\\"currentColor\\\"/>\\n    </svg>\",\n        'stars': \"<svg width=\\\"16\\\" height=\\\"16\\\" viewBox=\\\"0 0 16 16\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n      <path d=\\\"M8 2L9.5 5.5L13.5 6L10.75 8.75L11.5 13L8 11L4.5 13L5.25 8.75L2.5 6L6.5 5.5L8 2Z\\\" stroke=\\\"currentColor\\\"/>\\n    </svg>\",\n        'grids': \"<svg width=\\\"16\\\" height=\\\"16\\\" viewBox=\\\"0 0 16 16\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n      <line x1=\\\"5.5\\\" y1=\\\"3\\\" x2=\\\"5.5\\\" y2=\\\"13\\\" stroke=\\\"currentColor\\\"/>\\n      <line x1=\\\"10.5\\\" y1=\\\"3\\\" x2=\\\"10.5\\\" y2=\\\"13\\\" stroke=\\\"currentColor\\\"/>\\n      <line x1=\\\"3\\\" y1=\\\"5.5\\\" x2=\\\"13\\\" y2=\\\"5.5\\\" stroke=\\\"currentColor\\\"/>\\n      <line x1=\\\"3\\\" y1=\\\"10.5\\\" x2=\\\"13\\\" y2=\\\"10.5\\\" stroke=\\\"currentColor\\\"/>\\n    </svg>\",\n        'curved': \"<svg width=\\\"16\\\" height=\\\"16\\\" viewBox=\\\"0 0 16 16\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n      <path d=\\\"M2 6C3.33 6 2.67 10 4 10C5.33 10 4.67 6 6 6C7.33 6 6.67 10 8 10C9.33 10 8.67 6 10 6C11.33 6 10.67 10 12 10C13.33 10 12.67 6 14 6\\\" stroke=\\\"currentColor\\\" stroke-width=\\\"1\\\" stroke-linecap=\\\"round\\\"/>\\n    </svg>\",\n        'circles': \"<svg width=\\\"16\\\" height=\\\"16\\\" viewBox=\\\"0 0 16 16\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n      <circle cx=\\\"8\\\" cy=\\\"8\\\" r=\\\"5\\\" stroke=\\\"currentColor\\\"/>\\n    </svg>\",\n        'layered': \"<svg width=\\\"16\\\" height=\\\"16\\\" viewBox=\\\"0 0 16 16\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n      <rect x=\\\"4\\\" y=\\\"4\\\" width=\\\"8\\\" height=\\\"8\\\" rx=\\\"1\\\" stroke=\\\"currentColor\\\"/>\\n      <rect x=\\\"6\\\" y=\\\"6\\\" width=\\\"8\\\" height=\\\"8\\\" rx=\\\"1\\\" stroke=\\\"currentColor\\\"/>\\n    </svg>\",\n        'nature': \"<svg width=\\\"16\\\" height=\\\"16\\\" viewBox=\\\"0 0 16 16\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n      <path d=\\\"M8 13V5M8 5C6.5 3.5 4 3 4 5C4 7 8 8 8 5Z M8 5C9.5 3.5 12 3 12 5C12 7 8 8 8 5Z\\\" stroke=\\\"currentColor\\\" stroke-linecap=\\\"round\\\"/>\\n    </svg>\",\n        'polygons': \"<svg width=\\\"16\\\" height=\\\"16\\\" viewBox=\\\"0 0 16 16\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n      <path d=\\\"M8 3L12.5 5.5L12.5 10.5L8 13L3.5 10.5L3.5 5.5L8 3Z\\\" stroke=\\\"currentColor\\\"/>\\n    </svg>\",\n        'rounded': \"<svg width=\\\"16\\\" height=\\\"16\\\" viewBox=\\\"0 0 16 16\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n      <rect x=\\\"3\\\" y=\\\"3\\\" width=\\\"10\\\" height=\\\"10\\\" rx=\\\"3\\\" stroke=\\\"currentColor\\\"/>\\n    </svg>\"\n      };\n\n      // Create all category pills\n      categories.forEach(function (category) {\n        var pillBtn = document.createElement('button');\n        pillBtn.className = 'category-pill';\n        pillBtn.dataset.categoryId = category.id;\n\n        // Determine if this pill should be selected initially\n        var isSelected = category.id === initialSelectedCategory;\n\n        // Set inline styles for the pill\n        pillBtn.style.display = 'flex';\n        pillBtn.style.alignItems = 'center';\n        pillBtn.style.gap = '4px';\n        pillBtn.style.flex = '0 0 auto'; // Don't allow growth or shrink\n        pillBtn.style.whiteSpace = 'nowrap'; // Prevent text wrapping\n\n        // Apply correct styling based on selection\n        if (isSelected) {\n          pillBtn.style.backgroundColor = 'white';\n          pillBtn.style.color = 'black';\n        } else {\n          pillBtn.style.backgroundColor = 'rgb(26, 26, 26)';\n          pillBtn.style.color = 'rgb(217, 217, 217)';\n        }\n\n        // Common styles\n        pillBtn.style.border = 'none';\n        pillBtn.style.borderRadius = '50px';\n        pillBtn.style.padding = '6px 12px';\n        pillBtn.style.fontSize = '12px';\n        pillBtn.style.fontFamily = \"'Menlo', 'Monaco', 'Courier New', monospace\";\n        pillBtn.style.cursor = 'pointer';\n        pillBtn.style.minWidth = 'fit-content';\n\n        // Add category icon\n        var iconSpan = document.createElement('span');\n        iconSpan.style.display = 'flex';\n        iconSpan.style.alignItems = 'center';\n        iconSpan.style.justifyContent = 'center';\n        iconSpan.style.width = '16px';\n        iconSpan.style.height = '16px';\n\n        // Set icon from our map or use default\n        iconSpan.innerHTML = categoryIcons[category.id] || categoryIcons['all'];\n\n        // Set color for the SVG based on selection\n        if (isSelected) {\n          iconSpan.style.color = 'black';\n        } else {\n          iconSpan.style.color = 'rgb(217, 217, 217)';\n        }\n        pillBtn.appendChild(iconSpan);\n\n        // Add category name\n        var textSpan = document.createElement('span');\n        textSpan.textContent = category.name;\n        textSpan.style.fontFamily = \"'Menlo', 'Monaco', 'Courier New', monospace\";\n        pillBtn.appendChild(textSpan);\n\n        // Set data attribute for selection state\n        pillBtn.dataset.selected = isSelected ? 'true' : 'false';\n\n        // Add click handler\n        pillBtn.addEventListener('click', function () {\n          // Get the category ID from the button's dataset\n          var clickedCategoryId = pillBtn.dataset.categoryId;\n\n          // Reset all pills, set only this one to selected\n          document.querySelectorAll('.category-pill').forEach(function (p) {\n            p.style.backgroundColor = 'rgb(26, 26, 26)';\n            p.style.color = 'rgb(217, 217, 217)';\n            p.dataset.selected = 'false';\n            var pIconSpan = p.querySelector('span:first-child');\n            if (pIconSpan) pIconSpan.style.color = 'rgb(217, 217, 217)';\n          });\n\n          // Set this pill to white/selected\n          pillBtn.style.backgroundColor = 'white';\n          pillBtn.style.color = 'black';\n          pillBtn.dataset.selected = 'true';\n          var iconSpan = pillBtn.querySelector('span:first-child');\n          if (iconSpan) iconSpan.style.color = 'black';\n\n          // Update app state and filter\n          _this2.currentCategory = clickedCategoryId === 'all' ? null : clickedCategoryId;\n\n          // Save selection\n          try {\n            localStorage.setItem('selectedCategory', clickedCategoryId);\n          } catch (e) {\n            console.warn('Could not save category selection to localStorage', e);\n          }\n\n          // Re-render the grid\n          _this2.renderShapeGrid(true);\n        });\n\n        // Hover effects (only for non-selected pills)\n        pillBtn.addEventListener('mouseover', function () {\n          // Only apply hover effects if not selected\n          if (pillBtn.dataset.selected !== 'true') {\n            pillBtn.style.backgroundColor = 'rgb(42, 42, 42)';\n          }\n        });\n        pillBtn.addEventListener('mouseout', function () {\n          // Only reset styles if not selected\n          if (pillBtn.dataset.selected !== 'true') {\n            pillBtn.style.backgroundColor = 'rgb(26, 26, 26)';\n          }\n        });\n        filterContainer.appendChild(pillBtn);\n      });\n\n      // Insert the filter container after the header\n      var header = document.getElementById('main-header');\n      if (header && header.nextSibling) {\n        document.body.insertBefore(filterContainer, header.nextSibling);\n      } else {\n        var grid = document.getElementById('grid');\n        if (grid) {\n          document.body.insertBefore(filterContainer, grid);\n        } else {\n          document.body.appendChild(filterContainer);\n        }\n      }\n    }\n\n    // 2. Replace the selectCategoryPill method with this version:\n  }, {\n    key: \"selectCategoryPill\",\n    value:\n    // 4. Handle category selection\n    function selectCategoryPill(categoryId) {\n      // Update UI to show selected category\n      var allPills = document.querySelectorAll('.category-pill');\n      allPills.forEach(function (pill) {\n        if (pill.dataset.categoryId === categoryId) {\n          // Selected state\n          pill.classList.add('selected');\n          pill.style.backgroundColor = 'white';\n          pill.style.color = '#333';\n          pill.style.transform = 'translateY(0)';\n          pill.style.boxShadow = '0 2px 4px rgba(0,0,0,0.15)';\n        } else {\n          // Unselected state\n          pill.classList.remove('selected');\n          pill.style.backgroundColor = '#eaeaea';\n          pill.style.color = '#555';\n          pill.style.transform = 'translateY(0)';\n          pill.style.boxShadow = '0 1px 2px rgba(0,0,0,0.1)';\n        }\n      });\n\n      // Update the currently selected category\n      this.currentCategory = categoryId === 'all' ? null : categoryId;\n\n      // Re-render the grid with the new filter\n      this.renderShapeGrid(true); // Keep scroll position\n    }\n\n    /**\n     * Handle global click events (fallback)\n     */\n  }, {\n    key: \"createCategoryPill\",\n    value:\n    // 2. Create a single category pill button\n    function createCategoryPill(category) {\n      var _this3 = this;\n      var pillBtn = document.createElement('button');\n      pillBtn.className = 'category-pill';\n      pillBtn.dataset.categoryId = category.id;\n\n      // Set inline styles for the pill\n      pillBtn.style.display = 'flex';\n      pillBtn.style.alignItems = 'center';\n      pillBtn.style.gap = '6px';\n      pillBtn.style.backgroundColor = category.id === 'all' ? 'white' : '#eaeaea';\n      pillBtn.style.color = category.id === 'all' ? '#333' : '#555';\n      pillBtn.style.border = 'none';\n      pillBtn.style.borderRadius = '50px';\n      pillBtn.style.padding = '8px 16px';\n      pillBtn.style.fontSize = '14px';\n      pillBtn.style.fontWeight = '500';\n      pillBtn.style.cursor = 'pointer';\n      pillBtn.style.transition = 'all 0.2s ease';\n      pillBtn.style.minWidth = 'fit-content';\n      pillBtn.style.boxShadow = '0 1px 2px rgba(0,0,0,0.1)';\n\n      // Create icon span if an icon is provided\n      if (category.icon) {\n        var iconSpan = document.createElement('span');\n        iconSpan.innerHTML = category.icon;\n        iconSpan.style.display = 'flex';\n        iconSpan.style.alignItems = 'center';\n        iconSpan.style.justifyContent = 'center';\n        pillBtn.appendChild(iconSpan);\n      } else {\n        // Generate a simple icon based on category name\n        var _iconSpan = this.generateCategoryIcon(category);\n        if (_iconSpan) {\n          pillBtn.appendChild(_iconSpan);\n        }\n      }\n\n      // Add category name\n      var textSpan = document.createElement('span');\n      textSpan.textContent = category.name;\n      pillBtn.appendChild(textSpan);\n\n      // Add click handler\n      pillBtn.addEventListener('click', function () {\n        _this3.selectCategoryPill(category.id);\n      });\n\n      // Hover effects\n      pillBtn.addEventListener('mouseover', function () {\n        if (!pillBtn.classList.contains('selected')) {\n          pillBtn.style.backgroundColor = '#f0f0f0';\n        }\n      });\n      pillBtn.addEventListener('mouseout', function () {\n        if (!pillBtn.classList.contains('selected')) {\n          pillBtn.style.backgroundColor = '#eaeaea';\n        }\n      });\n      return pillBtn;\n    }\n  }, {\n    key: \"handleGlobalClick\",\n    value: function handleGlobalClick(e) {\n      var _this4 = this;\n      // Check if the click was on or inside a shape-container\n      var target = e.target;\n      while (target != null) {\n        if (target.classList && target.classList.contains('shape-container')) {\n          var shapeName = target.dataset.shapeName;\n          var shapeId = target.id;\n          if (shapeName && shapeId) {\n            // Find the index in the filtered shapes\n            var shapeNames = Object.keys(_shapesRegistry__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n            var filteredShapes = shapeNames.filter(function (name) {\n              if (!_this4.currentSearchTerm) return true;\n              return name.toLowerCase().includes(_this4.currentSearchTerm);\n            });\n            this.lastClickedShapeIndex = filteredShapes.indexOf(shapeName);\n            this.selectedShape = shapeName;\n            this.lastSelectedShapeId = shapeId;\n            this.saveGridState(shapeId);\n            this.showShapeEditor(shapeName);\n\n            // Stop event propagation\n            e.stopPropagation();\n            return;\n          }\n          break;\n        }\n        target = target.parentElement;\n      }\n    }\n\n    /**\n     * Create ultra-minimal header with search and zoom controls\n     */\n  }, {\n    key: \"createMinimalHeader\",\n    value: function createMinimalHeader() {\n      var _this5 = this;\n      var header = document.createElement('header');\n      header.className = 'header';\n      header.id = 'main-header';\n\n      // Create search input (minimalist)\n      var searchInput = document.createElement('input');\n      searchInput.type = 'text';\n      searchInput.placeholder = 'Search';\n      searchInput.className = 'search-input';\n      searchInput.addEventListener('input', function (e) {\n        _this5.currentSearchTerm = e.target.value.toLowerCase();\n        _this5.renderShapeGrid(true); // Keep scroll position\n      });\n\n      // Create logo container\n      var logoContainer = document.createElement('div');\n      logoContainer.className = 'logo-container';\n      logoContainer.innerHTML = \"\\n      <svg width=\\\"32\\\" height=\\\"32\\\" viewBox=\\\"0 0 32 32\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n        <path d=\\\"M4 12C4 16.4183 7.58172 20 12 20V12H28C28 7.58172 24.4183 4 20 4H12C7.58172 4 4 7.58172 4 12Z\\\" fill=\\\"white\\\"/>\\n        <path d=\\\"M28 20C28 15.5817 24.4183 12 20 12V20H4C4 24.4183 7.58172 28 12 28H20C24.4183 28 28 24.4183 28 20Z\\\" fill=\\\"white\\\"/>\\n      </svg>\\n    \";\n      logoContainer.style.display = 'flex';\n      logoContainer.style.alignItems = 'center';\n      logoContainer.style.cursor = 'pointer';\n\n      // Add click handler to reset to main grid when logo is clicked\n      logoContainer.addEventListener('click', function () {\n        if (_this5.selectedShape) {\n          // If in shape editor, first return to grid\n          _this5.returnToGrid();\n        } else {\n          // Already in grid view - find and click the All pill directly\n          searchInput.value = '';\n          _this5.currentSearchTerm = '';\n          _this5.renderShapeGrid(true);\n          var allPill = document.querySelector('.category-pill[data-category-id=\"all\"]');\n          if (allPill) {\n            document.getElementById('category-filters-container').scrollTo({\n              left: 0,\n              behavior: 'smooth'\n            });\n            allPill.click();\n            console.log(\"Clicked the All pill while in grid view\");\n          } else {\n            console.error(\"Could not find the All pill\");\n          }\n        }\n      });\n\n      // Create the Create Shape button\n      var createShapeBtn = document.createElement('button');\n      createShapeBtn.className = 'create-shape-btn';\n      createShapeBtn.title = 'Create New Shape with AI';\n      createShapeBtn.innerHTML = \"\\n      <svg xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 24 24\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"2\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\">\\n        <path d=\\\"M12 5C12 5 12 19 12 19\\\"></path>\\n        <path d=\\\"M5 12C5 12 19 12 19 12\\\"></path>\\n      </svg>\\n      <span>Create</span>\\n    \";\n      createShapeBtn.addEventListener('click', function () {\n        _this5.generator.showCreateModal();\n      });\n\n      // Add elements to header\n      header.appendChild(logoContainer);\n      header.appendChild(searchInput);\n\n      // Add bookmark button between search and zoom controls\n      var actionsContainer = document.createElement('div');\n      actionsContainer.className = 'header-actions';\n      actionsContainer.style.display = 'flex';\n      actionsContainer.style.gap = '8px';\n      actionsContainer.appendChild(createShapeBtn);\n      header.appendChild(actionsContainer);\n\n      // Add to document\n      document.body.insertBefore(header, document.getElementById('grid'));\n      return header;\n    }\n  }, {\n    key: \"scrollSelectedCategoryIntoView\",\n    value: function scrollSelectedCategoryIntoView() {\n      // Find the selected pill\n      var selectedPill = document.querySelector('.category-pill[data-selected=\"true\"]');\n      if (selectedPill) {\n        // Get the container\n        var filterContainer = document.getElementById('category-filters-container');\n        if (filterContainer) {\n          // Scroll the selected pill into view with a smooth animation\n          selectedPill.scrollIntoView({\n            block: 'nearest',\n            inline: 'center'\n          });\n        }\n      }\n    }\n\n    /**\n     * Save the current grid state before editing\n     */\n  }, {\n    key: \"saveGridState\",\n    value: function saveGridState(selectedShapeId) {\n      var _this6 = this;\n      // Save scroll position\n      this.gridState = {\n        scrollY: window.scrollY,\n        shapesVisible: [],\n        selectedShapeId: selectedShapeId\n      };\n\n      // Store the selected shape's position in the viewport for better restoration\n      if (selectedShapeId) {\n        var selectedElement = document.getElementById(selectedShapeId);\n        if (selectedElement) {\n          var rect = selectedElement.getBoundingClientRect();\n          this.gridState.shapePosition = {\n            elementY: rect.top,\n            viewportHeight: window.innerHeight\n          };\n        }\n      }\n\n      // Optionally gather visible shapes for more complex restoration\n      var shapes = document.querySelectorAll('.shape-container');\n      shapes.forEach(function (shape) {\n        var rect = shape.getBoundingClientRect();\n        // Check if shape is visible in viewport\n        if (rect.top >= 0 && rect.bottom <= window.innerHeight) {\n          _this6.gridState.shapesVisible.push(shape.id);\n        }\n      });\n      console.log(\"Saved grid state with scrollY: \".concat(this.gridState.scrollY));\n    }\n\n    /**\n     * Show shape editor with better scroll position saving\n     */\n  }, {\n    key: \"showShapeEditor\",\n    value: function showShapeEditor(shapeName) {\n      var _this7 = this;\n      // Set selected shape\n      this.selectedShape = shapeName;\n\n      // Explicitly capture current scroll position\n      var currentScroll = window.scrollY;\n      this.lastScrollPosition = currentScroll;\n      console.log(\"Captured current scroll position: \".concat(currentScroll));\n\n      // Save grid state with this position\n      if (!this.gridState || typeof this.gridState.scrollY !== 'number' || this.gridState.scrollY !== currentScroll) {\n        // Force an update to gridState with the current scroll position\n        this.saveGridState();\n      }\n\n      // Hide category filters when in editor mode\n      var filterContainer = document.getElementById('category-filters-container');\n      if (filterContainer) {\n        filterContainer.style.display = 'none';\n      }\n\n      // Initialize parameters if needed\n      if (Object.keys(this.parameters).length === 0) {\n        // Create a default shape instance to get parameters\n        var ShapeClass = this.shapes[shapeName];\n        if (ShapeClass) {\n          var shapeInstance = new ShapeClass();\n\n          // Get parameter definitions\n          var classParameters = ShapeClass.parameters || {};\n          var allParameters = _objectSpread(_objectSpread({}, this.Shape.parameters), classParameters);\n\n          // Initialize parameters from instance\n          Object.keys(allParameters).forEach(function (param) {\n            _this7.parameters[param] = shapeInstance[param];\n          });\n        }\n      }\n\n      // Use ShapeEditor module to show editor\n      this.editor.showEditor(shapeName);\n      this.updateShape();\n    }\n\n    /**\n     * Return to grid handler with proper category pill selection and scroll position restoration\n     */\n  }, {\n    key: \"returnToGrid\",\n    value: function returnToGrid() {\n      // Clear selected shape first\n      this.selectedShape = null;\n\n      // Load category from localStorage\n      var categoryToSelect = 'all';\n      try {\n        var savedCategory = localStorage.getItem('selectedCategory');\n        if (savedCategory) {\n          categoryToSelect = savedCategory;\n          console.log(\"Returning to grid with saved category: \".concat(categoryToSelect));\n        }\n      } catch (e) {\n        console.warn('Could not retrieve saved category from localStorage', e);\n      }\n\n      // Ensure the currentCategory is set correctly\n      this.currentCategory = categoryToSelect === 'all' ? null : categoryToSelect;\n\n      // Render grid with the correct category filter\n      // Important: Don't restore scroll yet - we need to render first\n      this.renderShapeGrid(false);\n\n      // Show category filters when returning to grid\n      var filterContainer = document.getElementById('category-filters-container');\n      if (filterContainer) {\n        // Show the filter container\n        filterContainer.style.display = 'flex';\n\n        // Explicitly select the correct pill\n        var pills = filterContainer.querySelectorAll('.category-pill');\n        pills.forEach(function (pill) {\n          var pillCategoryId = pill.dataset.categoryId;\n          var isSelected = pillCategoryId === categoryToSelect;\n\n          // Reset all attributes\n          pill.dataset.selected = isSelected ? 'true' : 'false';\n          if (isSelected) {\n            pill.classList.add('selected');\n            pill.style.setProperty('background-color', 'white', 'important');\n            pill.style.setProperty('color', '#000', 'important');\n\n            // Set icon color\n            var iconSpan = pill.querySelector('span:first-child');\n            if (iconSpan) {\n              iconSpan.style.setProperty('color', '#000', 'important');\n            }\n          } else {\n            pill.classList.remove('selected');\n            pill.style.setProperty('background-color', 'rgb(26, 26, 26)', 'important');\n            pill.style.setProperty('color', '#D9D9D9', 'important');\n\n            // Set icon color\n            var _iconSpan2 = pill.querySelector('span:first-child');\n            if (_iconSpan2) {\n              _iconSpan2.style.setProperty('color', '#D9D9D9', 'important');\n            }\n          }\n        });\n      } else {\n        // If filter container doesn't exist, recreate it\n        console.log(\"Filter container not found, recreating...\");\n        this.createCategoryFilters();\n      }\n    }\n\n    /**\n     * Render grid of shapes - simplified approach for stability\n     */\n  }, {\n    key: \"renderShapeGrid\",\n    value: function renderShapeGrid() {\n      var _this8 = this;\n      var keepScroll = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var isResize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      console.log(\"Rendering grid with currentCategory: \".concat(this.currentCategory));\n      var gridContainer = document.getElementById('grid');\n      if (!gridContainer) return;\n\n      // Show main header (search and zoom controls)\n      var header = document.getElementById('main-header');\n      if (header) header.style.display = 'flex';\n\n      // Show category filters if they were hidden\n      var filterContainer = document.getElementById('category-filters-container');\n      if (filterContainer) {\n        filterContainer.style.display = 'flex';\n      }\n\n      // Only clear HTML if this is not just a resize\n      if (!isResize) {\n        // Clear existing content\n        gridContainer.innerHTML = '';\n      }\n\n      // Set class and columns\n      gridContainer.className = 'grid';\n      gridContainer.style.gridTemplateColumns = \"repeat(\".concat(this.gridColumns, \", 1fr)\");\n      gridContainer.style.gap = '20px'; // Increased gap for better spacing\n      gridContainer.style.padding = '20px'; // Add padding around the grid\n      gridContainer.style.backgroundColor = '#000000';\n\n      // Get shapes that match both search and category\n      var shapeNames = Object.keys(_shapesRegistry__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n      var filteredShapes = shapeNames.filter(function (name) {\n        // Search term filter\n        var matchesSearch = !_this8.currentSearchTerm || name.toLowerCase().includes(_this8.currentSearchTerm.toLowerCase());\n\n        // Category filter\n        var matchesCategory = true;\n        if (_this8.currentCategory && _this8.currentCategory !== 'all') {\n          // Check if this shape belongs to the selected category\n          // First try using the JSON data if available\n          if (window.shapeCategories && window.shapeCategories.shapesMetadata) {\n            var metadata = window.shapeCategories.shapesMetadata[name];\n            if (metadata && metadata.categories) {\n              matchesCategory = metadata.categories.includes(_this8.currentCategory);\n            }\n          } else {\n            // Fallback to checking if shape name contains category hints\n            var categoryHints = {\n              'basic': ['Basic', 'Box', 'Simple', 'Square', 'Rounded', 'Column'],\n              'stars': ['Star', 'Asterisk', 'Burst', 'Sun', 'Ray', 'Radial'],\n              'grids': ['Grid', 'Pattern', 'Stripe', 'Checker'],\n              'curved': ['Curve', 'Wave', 'Spline', 'Spiral', 'Rhythm'],\n              'circles': ['Circle', 'Ellipse', 'Orbital', 'Ring', 'Sphere', 'Torus'],\n              'layered': ['Layer', 'Nested', 'Stack', 'Concentric'],\n              'nature': ['Leaf', 'Flower', 'Plant', 'Tree', 'Nature', 'Petal', 'Atom', 'Molecule'],\n              'polygons': ['Polygon', 'Triangle', 'Diamond', 'Hexagon', 'Octagon'],\n              'symbols': ['Symbol', 'Icon', 'Sign', 'Arrow', 'Bookmark'],\n              'rounded': ['Rounded', 'Pill', 'Smooth', 'Blob']\n            };\n            var hints = categoryHints[_this8.currentCategory] || [];\n            matchesCategory = hints.some(function (hint) {\n              return name.includes(hint);\n            });\n          }\n        }\n        return matchesSearch && matchesCategory;\n      });\n\n      // Variables to track the shape we need to scroll to\n      var targetShapeElement = null;\n      var targetIndex = -1;\n      var currentRow = 0;\n      var currentColumn = 0;\n\n      // Only render shapes if this is not just a resize\n      if (!isResize) {\n        // Render filtered shapes\n        filteredShapes.forEach(function (shapeName, index) {\n          try {\n            var currentIndex = index;\n            var ShapeClass = _shapesRegistry__WEBPACK_IMPORTED_MODULE_1__[\"default\"][shapeName];\n            var shapeInstance = new ShapeClass();\n\n            // Create container for shape - ultra minimal, just the shape\n            var shapeContainer = document.createElement('div');\n            shapeContainer.className = 'shape-container';\n            shapeContainer.dataset.shapeName = shapeName;\n            shapeContainer.dataset.index = currentIndex;\n\n            // Also store grid position info\n            currentColumn = index % _this8.gridColumns;\n            if (currentColumn === 0 && index > 0) {\n              currentRow++;\n            }\n            shapeContainer.dataset.row = currentRow;\n            shapeContainer.dataset.column = currentColumn;\n\n            // Make the container have high z-index and explicit cursor\n            shapeContainer.style.cursor = 'pointer';\n            shapeContainer.style.position = 'relative';\n            shapeContainer.style.aspectRatio = '1 / 1'; // Keep shapes square\n            shapeContainer.style.marginBottom = '10px'; // Add vertical spacing\n            shapeContainer.style.backgroundColor = '#000000';\n\n            // Add an invisible overlay to capture clicks more reliably\n            var clickOverlay = document.createElement('div');\n            clickOverlay.className = 'click-overlay';\n            clickOverlay.style.position = 'absolute';\n            clickOverlay.style.top = '0';\n            clickOverlay.style.left = '0';\n            clickOverlay.style.width = '100%';\n            clickOverlay.style.height = '100%';\n            clickOverlay.style.zIndex = '10';\n            clickOverlay.style.cursor = 'pointer';\n\n            // Add ID to find later\n            var shapeId = \"shape-\".concat(shapeName.replace(/[^a-z0-9]/gi, ''));\n            shapeContainer.id = shapeId;\n\n            // If this is the shape we previously clicked, mark it for scrolling\n            if (index === _this8.lastClickedShapeIndex) {\n              targetShapeElement = shapeContainer;\n              targetIndex = index;\n              console.log(\"Found target shape at index \".concat(index, \", row \").concat(currentRow, \", column \").concat(currentColumn));\n            }\n\n            // Create SVG element\n            var shapeSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n            shapeSvg.setAttribute('width', '100%');\n            shapeSvg.setAttribute('height', '100%');\n            shapeSvg.setAttribute('viewBox', '-110 -110 220 220');\n            shapeSvg.style.pointerEvents = 'none'; // Don't let SVG intercept clicks\n\n            // Create wrapper group\n            var wrapperGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n            wrapperGroup.setAttribute('transform', 'translate(0,0)');\n            wrapperGroup.style.pointerEvents = 'none'; // Don't let SVG elements intercept clicks\n            shapeSvg.appendChild(wrapperGroup);\n\n            // Generate shape content\n            var shapeContent = shapeInstance.generateShape();\n\n            // Add shape content to wrapper group\n            wrapperGroup.innerHTML = shapeContent;\n\n            // Add SVG to container\n            shapeContainer.appendChild(shapeSvg);\n\n            // Add click overlay AFTER the SVG\n            shapeContainer.appendChild(clickOverlay);\n\n            // Add hover events for shape using the animation manager\n            if (_this8.animationEnabled) {\n              _this8.animationManager.setupShapeHoverEvents(shapeContainer, shapeName, shapeId);\n            }\n\n            // Direct click handler for better reliability - on the overlay\n            clickOverlay.onclick = function (e) {\n              e.stopPropagation();\n              e.preventDefault();\n              _this8.lastClickedShapeIndex = currentIndex;\n              _this8.lastClickedRow = parseInt(shapeContainer.dataset.row);\n              _this8.lastClickedColumn = parseInt(shapeContainer.dataset.column);\n              console.log(\"Clicked shape at index \".concat(currentIndex, \", row \").concat(_this8.lastClickedRow, \", column \").concat(_this8.lastClickedColumn));\n              _this8.selectedShape = shapeName;\n              _this8.lastSelectedShapeId = shapeId;\n              _this8.saveGridState(shapeId);\n              _this8.showShapeEditor(shapeName);\n              return false;\n            };\n\n            // Redundant click handler on the container itself\n            shapeContainer.onclick = function (e) {\n              e.stopPropagation();\n              e.preventDefault();\n              _this8.lastClickedShapeIndex = currentIndex;\n              _this8.lastClickedRow = parseInt(shapeContainer.dataset.row);\n              _this8.lastClickedColumn = parseInt(shapeContainer.dataset.column);\n              console.log(\"Clicked shape container at index \".concat(currentIndex, \", row \").concat(_this8.lastClickedRow, \", column \").concat(_this8.lastClickedColumn));\n              _this8.selectedShape = shapeName;\n              _this8.lastSelectedShapeId = shapeId;\n              _this8.saveGridState(shapeId);\n              _this8.showShapeEditor(shapeName);\n              return false;\n            };\n\n            // Add to grid\n            gridContainer.appendChild(shapeContainer);\n          } catch (error) {\n            console.error(\"Error rendering shape \".concat(shapeName, \":\"), error);\n\n            // Create error placeholder with same spacing\n            var errorContainer = document.createElement('div');\n            errorContainer.className = 'shape-container error';\n            errorContainer.style.cursor = 'pointer';\n            errorContainer.style.aspectRatio = '1 / 1';\n            errorContainer.style.marginBottom = '10px';\n            errorContainer.style.backgroundColor = '#000000';\n            gridContainer.appendChild(errorContainer);\n          }\n        });\n      }\n\n      // After rendering, handle scroll to the appropriate shape\n      if (!keepScroll && !this.selectedShape && this.lastClickedShapeIndex >= 0) {\n        if (targetShapeElement) {\n          targetShapeElement.scrollIntoView({\n            block: 'center',\n            behavior: 'auto'\n          });\n          console.log(\"Scrolled to target element at index \".concat(targetIndex));\n        }\n      }\n    }\n  }]);\n}();\ndocument.addEventListener('DOMContentLoaded', function () {\n  var app = new ShapeApp();\n  (0,_analytics_js__WEBPACK_IMPORTED_MODULE_9__.initGA)();\n  app.analytics = _analytics_js__WEBPACK_IMPORTED_MODULE_9__.events;\n  app.init();\n\n  // Make app available globally for debugging\n  window.shapeApp = app;\n\n  // Initialize all integrations using the setupIntegrations function\n  var integrations = (0,_Integration_js__WEBPACK_IMPORTED_MODULE_8__.setupIntegrations)(app);\n\n  // Keep a reference to each integration\n  app.auth = integrations.auth;\n  app.userShapesManager = integrations.userShapes;\n  app.creditService = integrations.creditService;\n  console.log(\"ShapeApp initialization steps completed.\");\n  if (app.preloader) {\n    app.preloader.style.opacity = '0';\n    app.preloader.addEventListener('transitionend', function () {\n      app.preloader.style.display = 'none';\n    }, {\n      once: true\n    });\n  }\n});\n\n//# sourceURL=webpack://generative-shapes/./src/main.js?");

/***/ }),

/***/ "./src/perlin.js":
/*!***********************!*\
  !*** ./src/perlin.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// perlin.js\nvar perlin = function () {\n  function Grad(x, y, z) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n  Grad.prototype.dot2 = function (x, y) {\n    return this.x * x + this.y * y;\n  };\n  var grad3 = [new Grad(1, 1, 0), new Grad(-1, 1, 0), new Grad(1, -1, 0), new Grad(-1, -1, 0), new Grad(1, 0, 1), new Grad(-1, 0, 1), new Grad(1, 0, -1), new Grad(-1, 0, -1), new Grad(0, 1, 1), new Grad(0, -1, 1), new Grad(0, 1, -1), new Grad(0, -1, -1)];\n  var p = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180];\n\n  // To remove the need for index wrapping, double the permutation table length\n  var perm = new Array(512);\n  var gradP = new Array(512);\n\n  // This isn't a very good seeding function, but it works ok. It supports 2^16\n  // different seed values. Write something better if you need more seeds.\n  function seed(seed) {\n    if (seed > 0 && seed < 1) {\n      // Scale the seed out\n      seed *= 65536;\n    }\n    seed = Math.floor(seed);\n    if (seed < 256) {\n      seed |= seed << 8;\n    }\n    for (var i = 0; i < 256; i++) {\n      var v = void 0;\n      if (i & 1) {\n        v = p[i] ^ seed & 255;\n      } else {\n        v = p[i] ^ seed >> 8 & 255;\n      }\n      perm[i] = perm[i + 256] = v;\n      gradP[i] = gradP[i + 256] = grad3[v % 12];\n    }\n  }\n  seed(0);\n\n  // Skewing and unskewing factors for 2 dimensions\n  var F2 = 0.5 * (Math.sqrt(3) - 1);\n  var G2 = (3 - Math.sqrt(3)) / 6;\n  function fade(t) {\n    return t * t * t * (t * (t * 6 - 15) + 10);\n  }\n  function lerp(a, b, t) {\n    return (1 - t) * a + t * b;\n  }\n\n  // 2D Perlin Noise\n  function perlin2(x, y) {\n    // Find unit grid cell containing point\n    var X = Math.floor(x),\n      Y = Math.floor(y);\n    // Get relative xy coordinates of point within that cell\n    x = x - X;\n    y = y - Y;\n    // Wrap the integer cells at 255 (smaller integer period can be introduced here)\n    var XX = X & 255,\n      YY = Y & 255;\n\n    // Calculate noise contributions from each of the four corners\n    var n00 = gradP[XX + perm[YY]].dot2(x, y);\n    var n01 = gradP[XX + perm[YY + 1]].dot2(x, y - 1);\n    var n10 = gradP[XX + 1 + perm[YY]].dot2(x - 1, y);\n    var n11 = gradP[XX + 1 + perm[YY + 1]].dot2(x - 1, y - 1);\n\n    // Compute the fade curve value for x\n    var u = fade(x);\n\n    // Interpolate the four results\n    return lerp(lerp(n00, n10, u), lerp(n01, n11, u), fade(y));\n  }\n\n  // The noise function that will be used in your OrganicNoiseShape class\n  function noise(x, y) {\n    return perlin2(x, y);\n  }\n  return {\n    seed: seed,\n    perlin2: perlin2,\n    noise: noise // This is the function your class is looking for\n  };\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (perlin);\n\n//# sourceURL=webpack://generative-shapes/./src/perlin.js?");

/***/ }),

/***/ "./src/randomPrompts.js":
/*!******************************!*\
  !*** ./src/randomPrompts.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generativeShapePrompts: () => (/* binding */ generativeShapePrompts)\n/* harmony export */ });\nvar generativeShapePrompts = [\"A dense packing of circles where the negative space forms intricate, branching channels.\", \"A geometric 'crystal' growing algorithmically, forming sharp facets and internal structures.\", \"Layered grids, each slightly rotated and scaled, creating complex moir interference.\", \"A shape defined by the 'shadow' projection of a rotating higher-dimensional object (like a tesseract).\", \"A recursive structure where geometric shapes are replaced by smaller, transformed versions of the whole pattern.\", \"Flow lines tracing paths through a mathematically defined vector field, bundling and diverging.\", \"A Voronoi diagram where the cell boundaries are thick and textured, not simple lines.\", \"An intricate web formed by connecting points on multiple concentric circles according to a rule.\", \"A pattern based on Penrose tiling, using kites and darts to create non-repeating complexity.\", \"Simulated reaction-diffusion patterns (like Turing patterns) constrained within a sharp geometric form.\", \"A perfect grid subtly warped by a lensing or gravitational effect emanating from a point.\", \"Geometric shapes appearing to 'dissolve' into smaller particles based on a noise field.\", \"Interlocking spiral arms that branch off recursively.\", \"A visualization of sound waves interfering, represented by intersecting arc patterns.\", \"A complex knotwork pattern generated by following algorithmic weaving rules.\", \"A shape formed by the union and intersection of many randomly placed simple geometric primitives.\", \"Hierarchical structure where larger elements contain arrangements of smaller, similar elements.\", \"A field of geometric 'agents' leaving trails as they follow swarm intelligence rules.\", \"A pattern resembling biological cells dividing or merging, represented geometrically.\", \"A space-filling curve (like a Hilbert or Peano curve variation) rendered with variable thickness.\", \"Geometric 'erosion' where a solid shape has sections recursively removed by other shapes.\", \"A symmetrical design where symmetry is progressively broken by noise or rules further from the center.\", \"Overlapping, semi-transparent polygons whose colors blend to create new shapes and shades.\", \"A structure based on L-systems, generating geometric forms instead of branching trees.\", \"A tessellation using non-traditional or custom-designed geometric tiles.\", \"Visualization of particle paths in a simulated magnetic field, shown as curved lines.\", \"A pattern mimicking the structure of diatoms or radiolarians, using geometric components.\", \"Concentric layers of geometric patterns that seem to pulse or ripple outwards.\", \"A shape defined by the 'creases' of a simulated complex origami fold.\", \"An Apollonian gasket structure, with circles filling the gaps between other circles.\", \"A geometric pattern that appears to continuously morph or flow across the canvas.\", \"Interconnected network graph where nodes are geometric shapes and edges are stylized connectors.\", \"A 'shattered' version of a simple geometric shape, with fragments slightly displaced and rotated.\", \"Truchet tile patterns where the connecting curves within tiles are dynamically generated.\", \"A surface covered in scales or plates that follow the contours of an underlying form.\", \"Geometric 'glyphs' arranged algorithmically, forming a cryptic visual language.\", \"A pattern generated by simulating wave propagation and interference in a contained space.\", \"Recursive partitioning of space using lines or curves based on mathematical functions.\", \"A structure resembling a deconstructed architectural blueprint, with overlapping geometric elements.\", \"Differential growth simulation, where lines expand and curve to fill space, like veins or roots.\", \"A field of shapes oriented according to a curl noise field, creating swirling patterns.\", \"Geometric 'islands' connected by thin 'bridges' over a contrasting background.\", \"A pattern formed by the trails of simplified billiard balls bouncing within a geometric boundary.\", \"Layered topographic map effect using contour lines derived from noise functions.\", \"A radiating pattern of lines or shapes where density decreases exponentially from the center.\", \"Simulated cracking patterns spreading across a surface.\", \"A mosaic created from geometric shards of varying colors and sizes.\", \"Chaotic attractors (like Lorenz or Clifford) visualized geometrically by connecting points.\", \"A pattern exploring the transition between order (grid) and chaos (random placement).\", \"Geometric extrusion effect, where 2D shapes appear to extend into 3D space.\", \"A pattern based on Islamic geometric principles, emphasizing stars and polygons.\", \"Shapes defined by the intersection boundaries of multiple overlapping gradient fields.\", \"A visualization of data using abstract geometric forms and arrangements.\", \"Tightly packed spirals that influence each other's paths.\", \"A geometric 'calligraphy' generated by algorithmic brush strokes.\", \"Recursive Mondrian-style divisions of space with varying line weights.\", \"A pattern simulating light caustics, formed by intersecting curved lines.\", \"Geometric shapes linked together to form flexible chains or nets.\", \"A structure built from volumetric pixels (voxels) projected onto a 2D plane.\", \"Cellular automaton patterns (like Game of Life) rendered with geometric symbols instead of pixels.\", \"A field of arrows indicating flow, but the arrows themselves are complex geometric constructs.\", \"A pattern based on the cuts and structure of faceted gemstones.\", \"Interwoven bands that change thickness and color along their path.\", \"A shape created by connecting points on the perimeter of a circle in a complex sequence.\", \"A dynamic system of geometric 'gears' driving other rotating elements.\", \"A pattern resembling stylized circuit board traces.\", \"Recursive subdivision of triangles or squares, with transformations applied at each step.\", \"A field of 'vector dashes' aligned to a flow field.\", \"Geometric 'glyphs' evolving based on cellular automata rules.\", \"A pattern formed by the superposition of many fine-lined geometric shapes.\", \"Simulated gravitational lensing distorting a background grid or pattern.\", \"A structure composed of interconnected struts and nodes, like a space frame.\", \"Dense hatching patterns where line direction follows underlying curves.\", \"A field of simple shapes (e.g., triangles) whose rotation is determined by a noise function.\", \"Geometric 'vines' or 'tendrils' growing and curling algorithmically.\", \"A pattern derived from slicing a 3D noise field at an angle.\", \"Layered 'cutouts', where each layer reveals parts of the one beneath through geometric apertures.\", \"A constellation map connecting random points with lines, perhaps forming geometric figures.\", \"Packed hexagonal cells where each cell contains a smaller, rotated internal pattern.\", \"A visualization of interference fringes using closely spaced lines or curves.\", \"Geometric patterns inspired by microscopic structures (e.g., pollen, viruses).\", \"A pattern of 'pixels' where each pixel is a small, oriented geometric shape.\", \"Shapes generated by iterating complex number functions (beyond basic Mandelbrot).\", \"A web spreading from multiple centers, with threads merging and interacting.\", \"Distorted checkerboard where squares morph based on proximity to attractors/repulsors.\", \"A pattern of nested, angular spirals.\", \"Geometric 'terrain' generated using fractal noise displacement.\", \"Interlocking shapes based on Escher's 'Metamorphosis' tessellations.\", \"A dynamic composition of lines 'drawing' themselves according to generative rules.\", \"A pattern resembling stylized magnetic field lines.\", \"Stacked, overlapping discs creating moir patterns and color blends.\", \"A geometric pattern that seems to fold or unfold dynamically.\", \"Wireframe representations of complex polyhedra overlaid and rotated.\", \"A pattern of lines constrained to flow within specific geometric channels.\", \"Recursive branching structures where branches are geometric shapes, not just lines.\", \"A field of small geometric elements pulsating or rotating collectively.\"];\n\n//# sourceURL=webpack://generative-shapes/./src/randomPrompts.js?");

/***/ }),

/***/ "./src/shapes sync ^\\.\\/(?%21Shape).*\\.js$":
/*!***************************************************************!*\
  !*** ./src/shapes/ sync nonrecursive ^\.\/(?%21Shape).*\.js$ ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var map = {\n\t\"./AbstractBalance.js\": \"./src/shapes/AbstractBalance.js\",\n\t\"./AbstractClock.js\": \"./src/shapes/AbstractClock.js\",\n\t\"./AbstractLogo.js\": \"./src/shapes/AbstractLogo.js\",\n\t\"./AbstractMolecule.js\": \"./src/shapes/AbstractMolecule.js\",\n\t\"./AbstractSmileyFace.js\": \"./src/shapes/AbstractSmileyFace.js\",\n\t\"./AbstractStar.js\": \"./src/shapes/AbstractStar.js\",\n\t\"./AbstractStripes.js\": \"./src/shapes/AbstractStripes.js\",\n\t\"./AbstractYConnector.js\": \"./src/shapes/AbstractYConnector.js\",\n\t\"./AlternatingSquaresPattern.js\": \"./src/shapes/AlternatingSquaresPattern.js\",\n\t\"./ArcConnectorShape.js\": \"./src/shapes/ArcConnectorShape.js\",\n\t\"./ArchShape.js\": \"./src/shapes/ArchShape.js\",\n\t\"./ArrowShape.js\": \"./src/shapes/ArrowShape.js\",\n\t\"./AtomShape.js\": \"./src/shapes/AtomShape.js\",\n\t\"./AtomicSymbol.js\": \"./src/shapes/AtomicSymbol.js\",\n\t\"./BarcodeShape.js\": \"./src/shapes/BarcodeShape.js\",\n\t\"./BasicAsteriskShape.js\": \"./src/shapes/BasicAsteriskShape.js\",\n\t\"./BasicSpiral.js\": \"./src/shapes/BasicSpiral.js\",\n\t\"./BentBeam.js\": \"./src/shapes/BentBeam.js\",\n\t\"./BioPlate.js\": \"./src/shapes/BioPlate.js\",\n\t\"./BlobShape.js\": \"./src/shapes/BlobShape.js\",\n\t\"./BlockFigure.js\": \"./src/shapes/BlockFigure.js\",\n\t\"./BlockTNotch.js\": \"./src/shapes/BlockTNotch.js\",\n\t\"./BookmarkShape.js\": \"./src/shapes/BookmarkShape.js\",\n\t\"./BowTieShape.js\": \"./src/shapes/BowTieShape.js\",\n\t\"./BowtieSharp.js\": \"./src/shapes/BowtieSharp.js\",\n\t\"./BrickWall.js\": \"./src/shapes/BrickWall.js\",\n\t\"./ChaliceShape.js\": \"./src/shapes/ChaliceShape.js\",\n\t\"./ChamferedSquare.js\": \"./src/shapes/ChamferedSquare.js\",\n\t\"./CheckerPattern.js\": \"./src/shapes/CheckerPattern.js\",\n\t\"./CircleComposition.js\": \"./src/shapes/CircleComposition.js\",\n\t\"./CirclePacking.js\": \"./src/shapes/CirclePacking.js\",\n\t\"./CircleStack.js\": \"./src/shapes/CircleStack.js\",\n\t\"./CirclesComposition.js\": \"./src/shapes/CirclesComposition.js\",\n\t\"./CloudShape.js\": \"./src/shapes/CloudShape.js\",\n\t\"./CloverCross.js\": \"./src/shapes/CloverCross.js\",\n\t\"./CompassArrows.js\": \"./src/shapes/CompassArrows.js\",\n\t\"./ConcaveStarShape.js\": \"./src/shapes/ConcaveStarShape.js\",\n\t\"./ConcentricArches.js\": \"./src/shapes/ConcentricArches.js\",\n\t\"./ConcentricEllipses.js\": \"./src/shapes/ConcentricEllipses.js\",\n\t\"./ConcentricFlow.js\": \"./src/shapes/ConcentricFlow.js\",\n\t\"./ConcentricHex.js\": \"./src/shapes/ConcentricHex.js\",\n\t\"./ConcentricRectangles.js\": \"./src/shapes/ConcentricRectangles.js\",\n\t\"./ConcentricRects.js\": \"./src/shapes/ConcentricRects.js\",\n\t\"./ConcentricSphereShape.js\": \"./src/shapes/ConcentricSphereShape.js\",\n\t\"./ConcentricTarget.js\": \"./src/shapes/ConcentricTarget.js\",\n\t\"./ConicalShape.js\": \"./src/shapes/ConicalShape.js\",\n\t\"./ConnectedNodesShape.js\": \"./src/shapes/ConnectedNodesShape.js\",\n\t\"./ConnectedPillsShape.js\": \"./src/shapes/ConnectedPillsShape.js\",\n\t\"./CoralGrowth.js\": \"./src/shapes/CoralGrowth.js\",\n\t\"./CornerRays.js\": \"./src/shapes/CornerRays.js\",\n\t\"./CpuChip.js\": \"./src/shapes/CpuChip.js\",\n\t\"./CrescentKites.js\": \"./src/shapes/CrescentKites.js\",\n\t\"./CrescentShape.js\": \"./src/shapes/CrescentShape.js\",\n\t\"./CrossShape.js\": \"./src/shapes/CrossShape.js\",\n\t\"./CrosshairShape.js\": \"./src/shapes/CrosshairShape.js\",\n\t\"./CrystalShard.js\": \"./src/shapes/CrystalShard.js\",\n\t\"./CubeShape.js\": \"./src/shapes/CubeShape.js\",\n\t\"./CurvedHourglass.js\": \"./src/shapes/CurvedHourglass.js\",\n\t\"./CurvedPetalFlower.js\": \"./src/shapes/CurvedPetalFlower.js\",\n\t\"./CurvedSplit.js\": \"./src/shapes/CurvedSplit.js\",\n\t\"./CutPolygon.js\": \"./src/shapes/CutPolygon.js\",\n\t\"./CutoutPill.js\": \"./src/shapes/CutoutPill.js\",\n\t\"./CyberCircuitGrid.js\": \"./src/shapes/CyberCircuitGrid.js\",\n\t\"./CycloneCrescents.js\": \"./src/shapes/CycloneCrescents.js\",\n\t\"./DNASpiral.js\": \"./src/shapes/DNASpiral.js\",\n\t\"./DandelionShape.js\": \"./src/shapes/DandelionShape.js\",\n\t\"./DecoStructure.js\": \"./src/shapes/DecoStructure.js\",\n\t\"./DendriteShape.js\": \"./src/shapes/DendriteShape.js\",\n\t\"./DiagonalCircleShape.js\": \"./src/shapes/DiagonalCircleShape.js\",\n\t\"./DiagonalGrid.js\": \"./src/shapes/DiagonalGrid.js\",\n\t\"./DiagonalStripes.js\": \"./src/shapes/DiagonalStripes.js\",\n\t\"./DiagonalTechShape.js\": \"./src/shapes/DiagonalTechShape.js\",\n\t\"./DiamondArrowShape.js\": \"./src/shapes/DiamondArrowShape.js\",\n\t\"./DiamondHexShape.js\": \"./src/shapes/DiamondHexShape.js\",\n\t\"./DiamondPairShape.js\": \"./src/shapes/DiamondPairShape.js\",\n\t\"./DiamondStarShape.js\": \"./src/shapes/DiamondStarShape.js\",\n\t\"./Dice.js\": \"./src/shapes/Dice.js\",\n\t\"./DotGrid.js\": \"./src/shapes/DotGrid.js\",\n\t\"./DotSpiral.js\": \"./src/shapes/DotSpiral.js\",\n\t\"./DoubleArrow.js\": \"./src/shapes/DoubleArrow.js\",\n\t\"./DoubleChevronShape.js\": \"./src/shapes/DoubleChevronShape.js\",\n\t\"./DoubleXShape.js\": \"./src/shapes/DoubleXShape.js\",\n\t\"./DroneIcon.js\": \"./src/shapes/DroneIcon.js\",\n\t\"./DroneSymbol.js\": \"./src/shapes/DroneSymbol.js\",\n\t\"./DualLensShape.js\": \"./src/shapes/DualLensShape.js\",\n\t\"./EllipseGrid.js\": \"./src/shapes/EllipseGrid.js\",\n\t\"./EllipsePacking.js\": \"./src/shapes/EllipsePacking.js\",\n\t\"./EllipsesStackShape.js\": \"./src/shapes/EllipsesStackShape.js\",\n\t\"./ExpandArrowsShape.js\": \"./src/shapes/ExpandArrowsShape.js\",\n\t\"./EyeShape.js\": \"./src/shapes/EyeShape.js\",\n\t\"./FiberConnector.js\": \"./src/shapes/FiberConnector.js\",\n\t\"./FingerprintShape.js\": \"./src/shapes/FingerprintShape.js\",\n\t\"./FlaredCross.js\": \"./src/shapes/FlaredCross.js\",\n\t\"./FlatWave.js\": \"./src/shapes/FlatWave.js\",\n\t\"./FloralSprayShape.js\": \"./src/shapes/FloralSprayShape.js\",\n\t\"./FloralSprout.js\": \"./src/shapes/FloralSprout.js\",\n\t\"./FlowFieldShape.js\": \"./src/shapes/FlowFieldShape.js\",\n\t\"./FlowerMandala.js\": \"./src/shapes/FlowerMandala.js\",\n\t\"./FlowerPetalsShape.js\": \"./src/shapes/FlowerPetalsShape.js\",\n\t\"./FourCirclesCross.js\": \"./src/shapes/FourCirclesCross.js\",\n\t\"./FractalFlowerShape.js\": \"./src/shapes/FractalFlowerShape.js\",\n\t\"./FractalTreeShape.js\": \"./src/shapes/FractalTreeShape.js\",\n\t\"./FragmentedStructure.js\": \"./src/shapes/FragmentedStructure.js\",\n\t\"./FramedComposition.js\": \"./src/shapes/FramedComposition.js\",\n\t\"./FrostRaysShape.js\": \"./src/shapes/FrostRaysShape.js\",\n\t\"./FunnelShape.js\": \"./src/shapes/FunnelShape.js\",\n\t\"./GenerativeGrid.js\": \"./src/shapes/GenerativeGrid.js\",\n\t\"./GeometricEmblem.js\": \"./src/shapes/GeometricEmblem.js\",\n\t\"./GeometricPetalFlower.js\": \"./src/shapes/GeometricPetalFlower.js\",\n\t\"./GlitchPattern.js\": \"./src/shapes/GlitchPattern.js\",\n\t\"./Globe.js\": \"./src/shapes/Globe.js\",\n\t\"./Goblet.js\": \"./src/shapes/Goblet.js\",\n\t\"./Grid2Blocks.js\": \"./src/shapes/Grid2Blocks.js\",\n\t\"./GridAbstract.js\": \"./src/shapes/GridAbstract.js\",\n\t\"./GridBlocks.js\": \"./src/shapes/GridBlocks.js\",\n\t\"./GridConnector.js\": \"./src/shapes/GridConnector.js\",\n\t\"./GridDots.js\": \"./src/shapes/GridDots.js\",\n\t\"./HexagonalCluster.js\": \"./src/shapes/HexagonalCluster.js\",\n\t\"./HollowEllipse.js\": \"./src/shapes/HollowEllipse.js\",\n\t\"./HomeIcon.js\": \"./src/shapes/HomeIcon.js\",\n\t\"./HorizontalRects.js\": \"./src/shapes/HorizontalRects.js\",\n\t\"./Hourglass.js\": \"./src/shapes/Hourglass.js\",\n\t\"./HourglassEllipse.js\": \"./src/shapes/HourglassEllipse.js\",\n\t\"./HourglassShape.js\": \"./src/shapes/HourglassShape.js\",\n\t\"./HyperbolicLines.js\": \"./src/shapes/HyperbolicLines.js\",\n\t\"./IncreasingRadialShape.js\": \"./src/shapes/IncreasingRadialShape.js\",\n\t\"./InterlockingArcs.js\": \"./src/shapes/InterlockingArcs.js\",\n\t\"./JaggedSquircle.js\": \"./src/shapes/JaggedSquircle.js\",\n\t\"./KandinskyLines.js\": \"./src/shapes/KandinskyLines.js\",\n\t\"./Keyhole.js\": \"./src/shapes/Keyhole.js\",\n\t\"./KochCurve.js\": \"./src/shapes/KochCurve.js\",\n\t\"./LadderShape.js\": \"./src/shapes/LadderShape.js\",\n\t\"./LanternShape.js\": \"./src/shapes/LanternShape.js\",\n\t\"./LayeredBlob.js\": \"./src/shapes/LayeredBlob.js\",\n\t\"./LayeredBlobsMaskShape.js\": \"./src/shapes/LayeredBlobsMaskShape.js\",\n\t\"./LayeredChevron.js\": \"./src/shapes/LayeredChevron.js\",\n\t\"./LayeredCross.js\": \"./src/shapes/LayeredCross.js\",\n\t\"./LayeredCubeShape.js\": \"./src/shapes/LayeredCubeShape.js\",\n\t\"./LayeredFlowShape.js\": \"./src/shapes/LayeredFlowShape.js\",\n\t\"./LayeredMountains.js\": \"./src/shapes/LayeredMountains.js\",\n\t\"./LayeredPolygon.js\": \"./src/shapes/LayeredPolygon.js\",\n\t\"./LayeredRoundedRect.js\": \"./src/shapes/LayeredRoundedRect.js\",\n\t\"./LeafVeinsShape.js\": \"./src/shapes/LeafVeinsShape.js\",\n\t\"./LineGrid.js\": \"./src/shapes/LineGrid.js\",\n\t\"./LinesBurst.js\": \"./src/shapes/LinesBurst.js\",\n\t\"./LissajousCurve.js\": \"./src/shapes/LissajousCurve.js\",\n\t\"./LoadingSpinner.js\": \"./src/shapes/LoadingSpinner.js\",\n\t\"./LogarithmicDots.js\": \"./src/shapes/LogarithmicDots.js\",\n\t\"./LogoDots.js\": \"./src/shapes/LogoDots.js\",\n\t\"./LotusShape.js\": \"./src/shapes/LotusShape.js\",\n\t\"./MagneticDipoleField.js\": \"./src/shapes/MagneticDipoleField.js\",\n\t\"./MazeShape.js\": \"./src/shapes/MazeShape.js\",\n\t\"./MeepleShape.js\": \"./src/shapes/MeepleShape.js\",\n\t\"./MeshGridShape.js\": \"./src/shapes/MeshGridShape.js\",\n\t\"./MessageBubble.js\": \"./src/shapes/MessageBubble.js\",\n\t\"./MetaBall.js\": \"./src/shapes/MetaBall.js\",\n\t\"./MetaBalls.js\": \"./src/shapes/MetaBalls.js\",\n\t\"./Meteor.js\": \"./src/shapes/Meteor.js\",\n\t\"./MinimalCirclesLogo.js\": \"./src/shapes/MinimalCirclesLogo.js\",\n\t\"./MinimalClock.js\": \"./src/shapes/MinimalClock.js\",\n\t\"./MirroredClouds.js\": \"./src/shapes/MirroredClouds.js\",\n\t\"./MirroredCurveShape.js\": \"./src/shapes/MirroredCurveShape.js\",\n\t\"./ModulatedGridShape.js\": \"./src/shapes/ModulatedGridShape.js\",\n\t\"./MoireLines.js\": \"./src/shapes/MoireLines.js\",\n\t\"./MoireWaves.js\": \"./src/shapes/MoireWaves.js\",\n\t\"./MoleculeShape.js\": \"./src/shapes/MoleculeShape.js\",\n\t\"./MondrianShape.js\": \"./src/shapes/MondrianShape.js\",\n\t\"./MultiRadialLinesShape.js\": \"./src/shapes/MultiRadialLinesShape.js\",\n\t\"./NestedCrossShape.js\": \"./src/shapes/NestedCrossShape.js\",\n\t\"./NestedSquares.js\": \"./src/shapes/NestedSquares.js\",\n\t\"./NestedTriangles.js\": \"./src/shapes/NestedTriangles.js\",\n\t\"./NodedRect.js\": \"./src/shapes/NodedRect.js\",\n\t\"./NodesNetworkShape.js\": \"./src/shapes/NodesNetworkShape.js\",\n\t\"./NotchForm.js\": \"./src/shapes/NotchForm.js\",\n\t\"./OctagonalFrame.js\": \"./src/shapes/OctagonalFrame.js\",\n\t\"./OmniPlanGrid.js\": \"./src/shapes/OmniPlanGrid.js\",\n\t\"./OpenCompact.js\": \"./src/shapes/OpenCompact.js\",\n\t\"./OrbitingFigure.js\": \"./src/shapes/OrbitingFigure.js\",\n\t\"./OrganicDiffusion.js\": \"./src/shapes/OrganicDiffusion.js\",\n\t\"./OrganicForm.js\": \"./src/shapes/OrganicForm.js\",\n\t\"./OrganicKnot.js\": \"./src/shapes/OrganicKnot.js\",\n\t\"./OrganicNodes.js\": \"./src/shapes/OrganicNodes.js\",\n\t\"./OrganicSculpture.js\": \"./src/shapes/OrganicSculpture.js\",\n\t\"./OrganicSymbol.js\": \"./src/shapes/OrganicSymbol.js\",\n\t\"./OverlappingSquares.js\": \"./src/shapes/OverlappingSquares.js\",\n\t\"./ParallelStripesCircle.js\": \"./src/shapes/ParallelStripesCircle.js\",\n\t\"./ParametricKnot.js\": \"./src/shapes/ParametricKnot.js\",\n\t\"./PedestalShape.js\": \"./src/shapes/PedestalShape.js\",\n\t\"./PencilBurst.js\": \"./src/shapes/PencilBurst.js\",\n\t\"./PerspectiveBars.js\": \"./src/shapes/PerspectiveBars.js\",\n\t\"./PerspectiveCubeShape.js\": \"./src/shapes/PerspectiveCubeShape.js\",\n\t\"./PerspectiveGrid.js\": \"./src/shapes/PerspectiveGrid.js\",\n\t\"./PerspectiveGridShape.js\": \"./src/shapes/PerspectiveGridShape.js\",\n\t\"./PieSegments.js\": \"./src/shapes/PieSegments.js\",\n\t\"./PinwheelShape.js\": \"./src/shapes/PinwheelShape.js\",\n\t\"./PixelPattern.js\": \"./src/shapes/PixelPattern.js\",\n\t\"./PixelatedSmileyFace.js\": \"./src/shapes/PixelatedSmileyFace.js\",\n\t\"./Plant.js\": \"./src/shapes/Plant.js\",\n\t\"./PlugShape.js\": \"./src/shapes/PlugShape.js\",\n\t\"./PolarLineBurst.js\": \"./src/shapes/PolarLineBurst.js\",\n\t\"./PolygonalBang.js\": \"./src/shapes/PolygonalBang.js\",\n\t\"./PolygonalShieldWireframe.js\": \"./src/shapes/PolygonalShieldWireframe.js\",\n\t\"./PrismaShape.js\": \"./src/shapes/PrismaShape.js\",\n\t\"./PuzzlePieceShape.js\": \"./src/shapes/PuzzlePieceShape.js\",\n\t\"./QuadSquaresShape.js\": \"./src/shapes/QuadSquaresShape.js\",\n\t\"./QuantumWavesShape.js\": \"./src/shapes/QuantumWavesShape.js\",\n\t\"./RadialBars.js\": \"./src/shapes/RadialBars.js\",\n\t\"./RadialBurst.js\": \"./src/shapes/RadialBurst.js\",\n\t\"./RadialGridShape.js\": \"./src/shapes/RadialGridShape.js\",\n\t\"./RadialLines.js\": \"./src/shapes/RadialLines.js\",\n\t\"./RadialTriangles.js\": \"./src/shapes/RadialTriangles.js\",\n\t\"./RainbowArcs.js\": \"./src/shapes/RainbowArcs.js\",\n\t\"./RectangleGrid.js\": \"./src/shapes/RectangleGrid.js\",\n\t\"./RecursiveCrescent.js\": \"./src/shapes/RecursiveCrescent.js\",\n\t\"./RecursiveSqrdCircles.js\": \"./src/shapes/RecursiveSqrdCircles.js\",\n\t\"./RhombusPattern.js\": \"./src/shapes/RhombusPattern.js\",\n\t\"./RhythmicWaves.js\": \"./src/shapes/RhythmicWaves.js\",\n\t\"./RibbonShape.js\": \"./src/shapes/RibbonShape.js\",\n\t\"./RoundedCross.js\": \"./src/shapes/RoundedCross.js\",\n\t\"./RoundedInnerStarShape.js\": \"./src/shapes/RoundedInnerStarShape.js\",\n\t\"./RoundedPolygon.js\": \"./src/shapes/RoundedPolygon.js\",\n\t\"./RoundedRect.js\": \"./src/shapes/RoundedRect.js\",\n\t\"./RoundedRectangles.js\": \"./src/shapes/RoundedRectangles.js\",\n\t\"./RoundedShell.js\": \"./src/shapes/RoundedShell.js\",\n\t\"./RoundedStar.js\": \"./src/shapes/RoundedStar.js\",\n\t\"./RoundedTriangle.js\": \"./src/shapes/RoundedTriangle.js\",\n\t\"./RoundedTrianglesGrid.js\": \"./src/shapes/RoundedTrianglesGrid.js\",\n\t\"./SegmentedRingSpiral.js\": \"./src/shapes/SegmentedRingSpiral.js\",\n\t\"./SegmentedShear.js\": \"./src/shapes/SegmentedShear.js\",\n\t\"./SemicirclePattern.js\": \"./src/shapes/SemicirclePattern.js\",\n\t\"./SerratedFrame.js\": \"./src/shapes/SerratedFrame.js\",\n\t\"./SierpinskiTriangle.js\": \"./src/shapes/SierpinskiTriangle.js\",\n\t\"./Signal.js\": \"./src/shapes/Signal.js\",\n\t\"./SignalShape.js\": \"./src/shapes/SignalShape.js\",\n\t\"./SmileyStar.js\": \"./src/shapes/SmileyStar.js\",\n\t\"./Sparkles.js\": \"./src/shapes/Sparkles.js\",\n\t\"./Spikes.js\": \"./src/shapes/Spikes.js\",\n\t\"./SpiralWave.js\": \"./src/shapes/SpiralWave.js\",\n\t\"./SpiroPetal.js\": \"./src/shapes/SpiroPetal.js\",\n\t\"./SpringSemicircles.js\": \"./src/shapes/SpringSemicircles.js\",\n\t\"./SpringShape.js\": \"./src/shapes/SpringShape.js\",\n\t\"./SprocketShape.js\": \"./src/shapes/SprocketShape.js\",\n\t\"./SquareBoxShape.js\": \"./src/shapes/SquareBoxShape.js\",\n\t\"./SquaresPyramid.js\": \"./src/shapes/SquaresPyramid.js\",\n\t\"./SquiggleShape.js\": \"./src/shapes/SquiggleShape.js\",\n\t\"./Squircle.js\": \"./src/shapes/Squircle.js\",\n\t\"./StackedArcs2.js\": \"./src/shapes/StackedArcs2.js\",\n\t\"./StackedChevrons.js\": \"./src/shapes/StackedChevrons.js\",\n\t\"./StackedChevronsTree.js\": \"./src/shapes/StackedChevronsTree.js\",\n\t\"./StackedCircles.js\": \"./src/shapes/StackedCircles.js\",\n\t\"./StackedTrapezoids.js\": \"./src/shapes/StackedTrapezoids.js\",\n\t\"./StampShape.js\": \"./src/shapes/StampShape.js\",\n\t\"./Star.js\": \"./src/shapes/Star.js\",\n\t\"./StarCircle.js\": \"./src/shapes/StarCircle.js\",\n\t\"./StarCluster.js\": \"./src/shapes/StarCluster.js\",\n\t\"./StarburstRingsShape.js\": \"./src/shapes/StarburstRingsShape.js\",\n\t\"./StarburstShape.js\": \"./src/shapes/StarburstShape.js\",\n\t\"./SteppedStructure.js\": \"./src/shapes/SteppedStructure.js\",\n\t\"./StitchPattern.js\": \"./src/shapes/StitchPattern.js\",\n\t\"./StitchedFrame.js\": \"./src/shapes/StitchedFrame.js\",\n\t\"./StylizedAperture.js\": \"./src/shapes/StylizedAperture.js\",\n\t\"./StylizedComet.js\": \"./src/shapes/StylizedComet.js\",\n\t\"./StylizedOShape.js\": \"./src/shapes/StylizedOShape.js\",\n\t\"./SubwayNetwork.js\": \"./src/shapes/SubwayNetwork.js\",\n\t\"./SunBurstShape.js\": \"./src/shapes/SunBurstShape.js\",\n\t\"./SwirlingVortex.js\": \"./src/shapes/SwirlingVortex.js\",\n\t\"./SymmetricAbstractForm.js\": \"./src/shapes/SymmetricAbstractForm.js\",\n\t\"./SymmetricGridPattern.js\": \"./src/shapes/SymmetricGridPattern.js\",\n\t\"./SymmetricLines.js\": \"./src/shapes/SymmetricLines.js\",\n\t\"./SymmetricTotem.js\": \"./src/shapes/SymmetricTotem.js\",\n\t\"./SymmetricalPattern.js\": \"./src/shapes/SymmetricalPattern.js\",\n\t\"./TechnoGrid.js\": \"./src/shapes/TechnoGrid.js\",\n\t\"./TerrainWireframe.js\": \"./src/shapes/TerrainWireframe.js\",\n\t\"./ThreadedShape.js\": \"./src/shapes/ThreadedShape.js\",\n\t\"./Tornado.js\": \"./src/shapes/Tornado.js\",\n\t\"./TorusShape.js\": \"./src/shapes/TorusShape.js\",\n\t\"./TotemSymbol.js\": \"./src/shapes/TotemSymbol.js\",\n\t\"./TriGearStructure.js\": \"./src/shapes/TriGearStructure.js\",\n\t\"./TriLobeBlob.js\": \"./src/shapes/TriLobeBlob.js\",\n\t\"./TriangleRays.js\": \"./src/shapes/TriangleRays.js\",\n\t\"./TriangularPortal.js\": \"./src/shapes/TriangularPortal.js\",\n\t\"./TribalArrow.js\": \"./src/shapes/TribalArrow.js\",\n\t\"./TripleRoundedShape.js\": \"./src/shapes/TripleRoundedShape.js\",\n\t\"./TruchetPattern.js\": \"./src/shapes/TruchetPattern.js\",\n\t\"./TruchetSmooth.js\": \"./src/shapes/TruchetSmooth.js\",\n\t\"./TwistedCubeShape.js\": \"./src/shapes/TwistedCubeShape.js\",\n\t\"./TwistedStems.js\": \"./src/shapes/TwistedStems.js\",\n\t\"./Vase.js\": \"./src/shapes/Vase.js\",\n\t\"./VoronoiShape.js\": \"./src/shapes/VoronoiShape.js\",\n\t\"./Wave.js\": \"./src/shapes/Wave.js\",\n\t\"./WaveField.js\": \"./src/shapes/WaveField.js\",\n\t\"./WaveFlower.js\": \"./src/shapes/WaveFlower.js\",\n\t\"./WaveFrame.js\": \"./src/shapes/WaveFrame.js\",\n\t\"./WavePattern.js\": \"./src/shapes/WavePattern.js\",\n\t\"./WavingRibbonsShape.js\": \"./src/shapes/WavingRibbonsShape.js\",\n\t\"./WavyBars.js\": \"./src/shapes/WavyBars.js\",\n\t\"./WavyHourglass.js\": \"./src/shapes/WavyHourglass.js\",\n\t\"./WavyLine.js\": \"./src/shapes/WavyLine.js\",\n\t\"./WavyLine3D.js\": \"./src/shapes/WavyLine3D.js\",\n\t\"./WovenBars.js\": \"./src/shapes/WovenBars.js\",\n\t\"./ZigzagLogo.js\": \"./src/shapes/ZigzagLogo.js\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./src/shapes sync ^\\\\.\\\\/(?%21Shape).*\\\\.js$\";\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/_sync_nonrecursive_^\\.\\/(?");

/***/ }),

/***/ "./src/shapes/AbstractBalance.js":
/*!***************************************!*\
  !*** ./src/shapes/AbstractBalance.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates an abstract shape resembling a balanced symbol, with a central\n * circle, two bars, and a crescent.\n */\nvar AbstractBalance = /*#__PURE__*/function (_Shape) {\n  function AbstractBalance() {\n    _classCallCheck(this, AbstractBalance);\n    return _callSuper(this, AbstractBalance, arguments);\n  }\n  _inherits(AbstractBalance, _Shape);\n  return _createClass(AbstractBalance, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // --- Parameter Access ---\n      var r = this.radius;\n      var halfBar = this.barLength / 2;\n      var bh = this.barHeight;\n      var centerGap = this.barCenterGap;\n\n      // Ensure crescent depth is feasible given the radius.\n      // Clamp depth so that the resulting inner radius is at least 1.\n      var depth = Math.min(this.crescentDepth, r > 1 ? r - 1 : 0);\n      var innerR = Math.max(1, r - depth); // Crescent inner radius (always >= 1)\n\n      // --- Calculations ---\n      // Calculate bar vertical positions based on the center gap\n      var topBarCenterY = -centerGap;\n      var bottomBarCenterY = centerGap;\n      // Calculate top/bottom Y coordinates for the rectangle elements\n      var topBarTopY = topBarCenterY - bh / 2;\n      var bottomBarTopY = bottomBarCenterY - bh / 2;\n      var bottomBarBottomY = bottomBarCenterY + bh / 2;\n\n      // --- SVG Element Definitions ---\n      // Define SVG elements as strings. Using .toFixed(3) for cleaner SVG output.\n      var fmt = function fmt(n) {\n        return n.toFixed(3);\n      };\n\n      // The central circle might be fully or partially obscured by the bars,\n      // depending on the parameters, but it conceptually defines the base radius.\n      var circle = \"<circle cx=\\\"0\\\" cy=\\\"0\\\" r=\\\"\".concat(fmt(r), \"\\\" fill=\\\"white\\\"/>\");\n      var topBar = \"<rect x=\\\"\".concat(fmt(-halfBar), \"\\\" y=\\\"\").concat(fmt(topBarTopY), \"\\\" width=\\\"\").concat(fmt(this.barLength), \"\\\" height=\\\"\").concat(fmt(bh), \"\\\" fill=\\\"white\\\"/>\");\n      var bottomBar = \"<rect x=\\\"\".concat(fmt(-halfBar), \"\\\" y=\\\"\").concat(fmt(bottomBarTopY), \"\\\" width=\\\"\").concat(fmt(this.barLength), \"\\\" height=\\\"\").concat(fmt(bh), \"\\\" fill=\\\"white\\\"/>\");\n\n      // --- Crescent Calculation ---\n      // The crescent shape appears below the bottom bar, formed by the area\n      // between two circular arcs.\n      // Assumption: Arcs are centered vertically with the bottom bar at (0, bottomBarCenterY).\n      // They connect horizontally along the bottom edge of the bottom bar (y = bottomBarBottomY).\n\n      var crescentBaseY = bottomBarBottomY; // Y-coordinate where crescent arcs meet the bottom bar\n\n      var crescentPathData = \"\";\n      var outerX = 0; // X-coordinate where outer arc meets the bar bottom\n      var innerX = 0; // X-coordinate where inner arc meets the bar bottom\n\n      // Calculate outer arc intersection X-coordinate at y = crescentBaseY.\n      // Derived from outer arc equation: x^2 + (y - bottomBarCenterY)^2 = r^2\n      // Substituting y = crescentBaseY gives: x^2 + (bh/2)^2 = r^2\n      // Requires r >= bh/2 for a real intersection (non-negative square root argument).\n      var outerCheckSq = r * r - bh / 2 * (bh / 2);\n      if (outerCheckSq >= 0) {\n        outerX = Math.sqrt(outerCheckSq);\n      }\n\n      // Calculate inner arc intersection X-coordinate at y = crescentBaseY.\n      // Derived from inner arc equation: x^2 + (y - bottomBarCenterY)^2 = innerR^2\n      // Substituting y = crescentBaseY gives: x^2 + (bh/2)^2 = innerR^2\n      // Requires innerR >= bh/2 for a real intersection.\n      var innerCheckSq = innerR * innerR - bh / 2 * (bh / 2);\n      if (innerCheckSq >= 0) {\n        innerX = Math.sqrt(innerCheckSq);\n      }\n\n      // Only construct the crescent path if:\n      // 1. The outer arc has a valid intersection with the bar bottom (outerX > 0).\n      // 2. The inner arc also has a valid intersection (innerCheckSq >= 0), and its intersection\n      //    point is distinct from and inside the outer arc's point (innerX < outerX).\n      if (outerX > 0 && innerX < outerX && innerCheckSq >= 0) {\n        var outerArcRadius = r;\n        var innerArcRadius = innerR;\n\n        // Path definition for the white filled crescent shape:\n        // M: Move to the left start point of the outer arc (-outerX, crescentBaseY)\n        // A: Draw the outer arc (radius r) sweep-flag=0 (clockwise), large-arc-flag=0 (<180 deg) to (+outerX, crescentBaseY)\n        // L: Line horizontally along the bar's bottom edge to the right start point of the inner arc (+innerX, crescentBaseY)\n        // A: Draw the inner arc (radius innerR) sweep-flag=1 (counter-clockwise), large-arc-flag=0 (<180 deg) back to (-innerX, crescentBaseY)\n        // Z: Close the path (implicitly lines back to the start M point)\n        crescentPathData = \"M \".concat(fmt(-outerX), \",\").concat(fmt(crescentBaseY), \" A \").concat(fmt(outerArcRadius), \",\").concat(fmt(outerArcRadius), \" 0 0 0 \").concat(fmt(outerX), \",\").concat(fmt(crescentBaseY), \" L \").concat(fmt(innerX), \",\").concat(fmt(crescentBaseY), \" A \").concat(fmt(innerArcRadius), \",\").concat(fmt(innerArcRadius), \" 0 0 1 \").concat(fmt(-innerX), \",\").concat(fmt(crescentBaseY), \" Z\");\n      }\n\n      // Create the crescent path element. If path data is empty string, this element won't render.\n      var crescent = \"<path d=\\\"\".concat(crescentPathData, \"\\\" fill=\\\"white\\\"/>\");\n\n      // --- Combine SVG Elements ---\n      // The order determines visual stacking (later elements are drawn on top).\n      // Circle is drawn first, then bars overlay it, then crescent overlays the bottom bar.\n      return \"\\n            \".concat(circle, \"\\n            \").concat(topBar, \"\\n            \").concat(bottomBar, \"\\n            \").concat(crescent, \"\\n        \");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(AbstractBalance, \"parameters\", {\n  radius: {\n    type: 'number',\n    min: 10,\n    max: 80,\n    \"default\": 42,\n    description: \"Radius of central circle and crescent base.\"\n  },\n  barLength: {\n    type: 'number',\n    min: 20,\n    max: 198,\n    \"default\": 160,\n    description: \"Total length of the horizontal bars.\"\n  },\n  barHeight: {\n    type: 'number',\n    min: 2,\n    max: 40,\n    \"default\": 18,\n    description: \"Thickness (height) of the horizontal bars.\"\n  },\n  barCenterGap: {\n    type: 'number',\n    min: 0,\n    max: 70,\n    \"default\": 35,\n    description: \"Vertical distance from center (0,0) to the middle line of each bar.\"\n  },\n  crescentDepth: {\n    type: 'number',\n    min: 1,\n    max: 79,\n    \"default\": 18,\n    description: \"Thickness of the crescent cutout (depth). Should be less than radius.\"\n  } // Max depth conceptually less than radius\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AbstractBalance);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/AbstractBalance.js?");

/***/ }),

/***/ "./src/shapes/AbstractClock.js":
/*!*************************************!*\
  !*** ./src/shapes/AbstractClock.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates an abstract, segmented clock face with an animated second hand.\n */\nvar AbstractClock = /*#__PURE__*/function (_Shape) {\n  function AbstractClock() {\n    _classCallCheck(this, AbstractClock);\n    return _callSuper(this, AbstractClock, arguments);\n  }\n  _inherits(AbstractClock, _Shape);\n  return _createClass(AbstractClock, [{\n    key: \"_rotatePoint\",\n    value:\n    // Helper function to rotate a point around the origin (0,0)\n    function _rotatePoint(x, y, angleRad) {\n      return {\n        x: x * Math.cos(angleRad) - y * Math.sin(angleRad),\n        y: x * Math.sin(angleRad) + y * Math.cos(angleRad)\n      };\n    }\n\n    // Helper function to create SVG path data for a rectangle centered at (cx, cy)\n  }, {\n    key: \"_createRectanglePath\",\n    value: function _createRectanglePath(cx, cy, width, height) {\n      var _this = this;\n      var angleDeg = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n      var angleRad = angleDeg * Math.PI / 180;\n      var hw = width / 2;\n      var hh = height / 2;\n      var points = [{\n        x: -hw,\n        y: -hh\n      },\n      // Top-left\n      {\n        x: hw,\n        y: -hh\n      },\n      // Top-right\n      {\n        x: hw,\n        y: hh\n      },\n      // Bottom-right\n      {\n        x: -hw,\n        y: hh\n      } // Bottom-left\n      ];\n      var rotatedPoints = points.map(function (p) {\n        return _this._rotatePoint(p.x, p.y, angleRad);\n      });\n      var finalPoints = rotatedPoints.map(function (p) {\n        return {\n          x: p.x + cx,\n          y: p.y + cy\n        };\n      });\n\n      // Format numbers\n      var fmt = function fmt(n) {\n        return parseFloat(n.toFixed(3));\n      };\n      var pathData = \"M \".concat(fmt(finalPoints[0].x), \",\").concat(fmt(finalPoints[0].y), \" \") + \"L \".concat(fmt(finalPoints[1].x), \",\").concat(fmt(finalPoints[1].y), \" \") + \"L \".concat(fmt(finalPoints[2].x), \",\").concat(fmt(finalPoints[2].y), \" \") + \"L \".concat(fmt(finalPoints[3].x), \",\").concat(fmt(finalPoints[3].y), \" Z\");\n      return pathData;\n    }\n\n    // Helper function to create SVG path data for a clock hand originating from (0,0)\n    // pointing straight up (along negative Y axis). Rotation is handled by transform.\n  }, {\n    key: \"_createHandPath\",\n    value: function _createHandPath(length, thickness) {\n      var w2 = thickness / 2;\n\n      // Define corners for a hand pointing upwards from 0,0\n      var points = [{\n        x: -w2,\n        y: 0\n      },\n      // Base-left\n      {\n        x: w2,\n        y: 0\n      },\n      // Base-right\n      {\n        x: w2,\n        y: -length\n      },\n      // Tip-right (negative Y is up in SVG)\n      {\n        x: -w2,\n        y: -length\n      } // Tip-left\n      ];\n\n      // Format numbers\n      var fmt = function fmt(n) {\n        return parseFloat(n.toFixed(3));\n      };\n\n      // Create path data\n      var pathData = \"M \".concat(fmt(points[0].x), \",\").concat(fmt(points[0].y), \" \") + \"L \".concat(fmt(points[1].x), \",\").concat(fmt(points[1].y), \" \") + \"L \".concat(fmt(points[2].x), \",\").concat(fmt(points[2].y), \" \") + \"L \".concat(fmt(points[3].x), \",\").concat(fmt(points[3].y), \" Z\");\n      return pathData;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this2 = this;\n      var outerRadius = this.outerRadius,\n        segmentThickness = this.segmentThickness,\n        markerSizeRatio = this.markerSizeRatio,\n        markerDistanceRatio = this.markerDistanceRatio,\n        hourHandLengthRatio = this.hourHandLengthRatio,\n        minuteHandLengthRatio = this.minuteHandLengthRatio,\n        secondHandLengthRatio = this.secondHandLengthRatio,\n        secondHandThicknessRatio = this.secondHandThicknessRatio,\n        hour = this.hour,\n        minute = this.minute,\n        showCenter = this.showCenter,\n        showMarkers = this.showMarkers;\n      var svgElements = '';\n      var fmt = function fmt(n) {\n        return parseFloat(n.toFixed(3));\n      }; // Formatting helper\n\n      var r = this.outerRadius;\n      svgElements += \"<circle cx=\\\"0\\\" cy=\\\"0\\\" r=\\\"\".concat(r.toFixed(3), \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(this.segmentThickness, \"\\\" />\");\n\n      // --- 2. Hour Markers (12, 3, 6, 9) ---\n      if (showMarkers) {\n        var markerRadius = outerRadius * markerDistanceRatio;\n        var markerSize = segmentThickness * markerSizeRatio;\n        var markerPositions = [{\n          x: 0,\n          y: -markerRadius\n        },\n        // 12\n        {\n          x: markerRadius,\n          y: 0\n        },\n        // 3\n        {\n          x: 0,\n          y: markerRadius\n        },\n        // 6\n        {\n          x: -markerRadius,\n          y: 0\n        } // 9\n        ];\n        markerPositions.forEach(function (pos) {\n          var markerPath = _this2._createRectanglePath(pos.x, pos.y, markerSize, markerSize, 0);\n          svgElements += \"<path d=\\\"\".concat(markerPath, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\\n\");\n        });\n      }\n\n      // --- 3. Center Cross ---\n      if (showCenter) {\n        var crossSize = segmentThickness * 0.75;\n        var crossOffset = crossSize / 2;\n        var crossPositions = [{\n          x: 0,\n          y: -crossOffset\n        }, {\n          x: crossOffset,\n          y: 0\n        }, {\n          x: 0,\n          y: crossOffset\n        }, {\n          x: -crossOffset,\n          y: 0\n        }];\n        crossPositions.forEach(function (pos) {\n          var crossPath = _this2._createRectanglePath(pos.x, pos.y, crossSize, crossSize, 0);\n          svgElements += \"<path d=\\\"\".concat(crossPath, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\\n\");\n        });\n      }\n\n      // --- 4. Clock Hands ---\n      // Calculate lengths and thicknesses\n      var hourHandLength = outerRadius * hourHandLengthRatio;\n      var minuteHandLength = outerRadius * minuteHandLengthRatio;\n      var secondHandLength = outerRadius * secondHandLengthRatio; // <-- New\n      var secondHandThickness = segmentThickness * secondHandThicknessRatio; // <-- New\n\n      // Get current time for initial hand positions\n      var now = new Date();\n      var currentHour = hour; // Use parameter for initial hour if needed, or now.getHours()\n      var currentMinute = minute; // Use parameter for initial minute if needed, or now.getMinutes()\n      var currentSecond = now.getSeconds();\n      var currentMillisecond = now.getMilliseconds();\n\n      // Calculate angles in degrees (0 = 12 o'clock, clockwise)\n      // Adjust hour angle based on minutes for smoother movement\n      var hourAngle = (currentHour % 12 + currentMinute / 60) * 30;\n      // Adjust minute angle based on seconds for smoother movement\n      var minuteAngle = (currentMinute + currentSecond / 60) * 6;\n      // Adjust second angle based on milliseconds for smoother start\n      var secondAngle = (currentSecond + currentMillisecond / 1000) * 6;\n\n      // Create second hand path data (drawn pointing up)\n      var secondHandPathData = this._createHandPath(secondHandLength, secondHandThickness);\n      // Apply initial rotation via transform and add animation\n      svgElements += \"<path id=\\\"second-hand\\\" d=\\\"\".concat(secondHandPathData, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" transform=\\\"rotate(\").concat(fmt(secondAngle), \" 0 0)\\\">\\n    <animateTransform\\n        attributeName=\\\"transform\\\"\\n        attributeType=\\\"XML\\\"\\n        type=\\\"rotate\\\"\\n        from=\\\"0 0 0\\\"\\n        to=\\\"360 0 0\\\"\\n        dur=\\\"60s\\\"\\n        repeatCount=\\\"indefinite\\\"\\n        additive=\\\"sum\\\" />\\n</path>\\n\"); // Note: additive=\"sum\" ensures the animation adds to the initial transform\n\n      // Create hour hand path data (drawn pointing up)\n      var hourHandPathData = this._createHandPath(hourHandLength, segmentThickness);\n      // Apply rotation via transform\n      svgElements += \"<path id=\\\"hour-hand\\\" d=\\\"\".concat(hourHandPathData, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" transform=\\\"rotate(\").concat(fmt(hourAngle), \" 0 0)\\\" />\\n\");\n\n      // Create minute hand path data (drawn pointing up)\n      var minuteHandPathData = this._createHandPath(minuteHandLength, segmentThickness);\n      // Apply rotation via transform\n      svgElements += \"<path id=\\\"minute-hand\\\" d=\\\"\".concat(minuteHandPathData, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" transform=\\\"rotate(\").concat(fmt(minuteAngle), \" 0 0)\\\" />\\n\");\n      return svgElements.trim();\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(AbstractClock, \"parameters\", {\n  outerRadius: {\n    type: 'number',\n    min: 30,\n    max: 100,\n    // Keep within viewBox\n    step: 1,\n    \"default\": 80,\n    label: 'Outer Radius'\n  },\n  segmentThickness: {\n    type: 'number',\n    min: 5,\n    max: 10,\n    step: 1,\n    \"default\": 4,\n    label: 'Segment Thickness'\n  },\n  markerSizeRatio: {\n    type: 'number',\n    min: 0.5,\n    max: 1.5,\n    // Relative to segment thickness\n    step: 0.1,\n    \"default\": 0.8,\n    label: 'Marker Size Ratio'\n  },\n  markerDistanceRatio: {\n    type: 'number',\n    min: 0.4,\n    max: 0.9,\n    // Relative to outer radius\n    step: 0.05,\n    \"default\": 0.75,\n    label: 'Marker Distance Ratio'\n  },\n  hourHandLengthRatio: {\n    type: 'number',\n    min: 0.2,\n    max: 0.8,\n    // Relative to outer radius\n    step: 0.05,\n    \"default\": 0.5,\n    label: 'Hour Hand Length Ratio'\n  },\n  minuteHandLengthRatio: {\n    type: 'number',\n    min: 0.3,\n    max: 0.95,\n    // Relative to outer radius\n    step: 0.05,\n    \"default\": 0.75,\n    label: 'Minute Hand Length Ratio'\n  },\n  secondHandLengthRatio: {\n    // <-- New Parameter\n    type: 'number',\n    min: 0.3,\n    max: 1.0,\n    // Relative to outer radius\n    step: 0.05,\n    \"default\": 0.85,\n    label: 'Second Hand Length Ratio'\n  },\n  secondHandThicknessRatio: {\n    // <-- New Parameter\n    type: 'number',\n    min: 0.1,\n    max: 1.0,\n    // Relative to segment thickness\n    step: 0.1,\n    \"default\": 0.4,\n    label: 'Second Hand Thickness Ratio'\n  },\n  hour: {\n    type: 'number',\n    min: 0,\n    max: 11,\n    step: 1,\n    \"default\": 10,\n    // Example time ~10:10\n    label: 'Hour (0-11)',\n    note: 'Initial hour display'\n  },\n  minute: {\n    type: 'number',\n    min: 0,\n    max: 59,\n    step: 1,\n    \"default\": 10,\n    // Example time ~10:10\n    label: 'Minute (0-59)',\n    note: 'Initial minute display'\n  },\n  showCenter: {\n    type: 'boolean',\n    \"default\": true,\n    label: 'Show Center Cross'\n  },\n  showMarkers: {\n    type: 'boolean',\n    \"default\": true,\n    label: 'Show Hour Markers'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AbstractClock);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/AbstractClock.js?");

/***/ }),

/***/ "./src/shapes/AbstractLogo.js":
/*!************************************!*\
  !*** ./src/shapes/AbstractLogo.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a structure resembling a stylized, layered diamond with optional\n * corner gaps and decorations.\n */\nvar AbstractLogo = /*#__PURE__*/function (_Shape) {\n  function AbstractLogo() {\n    _classCallCheck(this, AbstractLogo);\n    return _callSuper(this, AbstractLogo, arguments);\n  }\n  _inherits(AbstractLogo, _Shape);\n  return _createClass(AbstractLogo, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      var svg = '';\n      var sw = this.strokeWidth;\n\n      // Precompute sqrt(2) for efficiency in coordinate calculations involving 45-degree angles\n      var sqrt2 = Math.sqrt(2);\n\n      /**\n       * Helper function to calculate the start and end points for the four line segments\n       * that constitute a single gapped layer of the diamond shape.\n       * @param {number} radius - The distance from the center to the theoretical vertex of this layer.\n       * @param {number} gap - The length of the gap along the perimeter at each corner.\n       * @returns {Array|null} An array of 4 objects {start: {x, y}, end: {x, y}}, or null if the gap is too large.\n       */\n      var getSegmentPoints = function getSegmentPoints(radius, gap) {\n        if (radius <= 0) return null; // Radius must be positive\n\n        // Calculate the coordinate offset distance along the axes based on the gap length along the 45-degree segment\n        var offset = gap / sqrt2;\n\n        // Prevent issues if the gap is too large causing segments to overlap or disappear\n        // The segment length is roughly sqrt(2)*radius - gap. We need positive length.\n        // Simplified check: 2 * offset (total projected gap) should be less than sqrt(2)*radius (projected side)\n        if (2 * offset >= radius * sqrt2 * 0.95) {\n          // Use 0.95 factor for safety margin\n          return null; // Gap is too large relative to the layer size\n        }\n\n        // Calculate the 8 points defining the ends of the 4 segments.\n        // These points are offset inwards from the theoretical corners along the diamond's sides.\n        var p1s = {\n          x: offset,\n          y: radius - offset\n        }; // Start of segment 1 (top-right side)\n        var p1e = {\n          x: radius - offset,\n          y: offset\n        }; // End of segment 1\n        var p2s = {\n          x: radius - offset,\n          y: -offset\n        }; // Start of segment 2 (bottom-right side)\n        var p2e = {\n          x: offset,\n          y: -(radius - offset)\n        }; // End of segment 2\n        var p3s = {\n          x: -offset,\n          y: -(radius - offset)\n        }; // Start of segment 3 (bottom-left side)\n        var p3e = {\n          x: -(radius - offset),\n          y: -offset\n        }; // End of segment 3\n        var p4s = {\n          x: -(radius - offset),\n          y: offset\n        }; // Start of segment 4 (top-left side)\n        var p4e = {\n          x: -offset,\n          y: radius - offset\n        }; // End of segment 4\n\n        return [{\n          start: p1s,\n          end: p1e\n        }, {\n          start: p2s,\n          end: p2e\n        }, {\n          start: p3s,\n          end: p3e\n        }, {\n          start: p4s,\n          end: p4e\n        }];\n      };\n      var maxRadius = 0; // Track the maximum radius to ensure the shape fits the viewBox\n\n      // Iterate through each layer, starting from the center (i=0)\n      for (var i = 0; i < this.numLayers; i++) {\n        var r = this.centerSize + i * this.layerGap;\n        if (r > maxRadius) maxRadius = r; // Update max radius encountered\n\n        if (i === 0) {\n          // Draw the central diamond (layer 0) - it's a closed shape with no gaps.\n          if (r > 0) {\n            // Define path data for a diamond (rotated square) centered at (0,0)\n            var pathData = \"M 0 \".concat(r.toFixed(3), \" L \").concat(r.toFixed(3), \" 0 L 0 \").concat((-r).toFixed(3), \" L \").concat((-r).toFixed(3), \" 0 Z\");\n            // Add the central diamond path to the SVG string\n            svg += \"<path d=\\\"\".concat(pathData, \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(sw, \"\\\" stroke-linejoin=\\\"miter\\\" />\");\n          }\n        } else {\n          // Draw outer layers (i > 0) - these layers have gaps at the corners.\n          var segments = getSegmentPoints(r, this.cornerGap);\n          // Only draw the layer if the segments could be calculated (i.e., gap wasn't too large)\n          if (segments) {\n            segments.forEach(function (seg) {\n              // Add each segment as an open path (line) to the SVG string\n              svg += \"<path d=\\\"M \".concat(seg.start.x.toFixed(3), \" \").concat(seg.start.y.toFixed(3), \" L \").concat(seg.end.x.toFixed(3), \" \").concat(seg.end.y.toFixed(3), \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(sw, \"\\\" stroke-linecap=\\\"round\\\"/>\");\n            });\n          }\n        }\n      }\n\n      // Add decorative lines near the segments of the outermost layer, if configured\n      if (this.numLayers > 0 && this.decorationCount > 0 && this.decorationLength > 0) {\n        // Calculate the radius of the outermost layer that was actually drawn\n        var r_outer = this.centerSize + (this.numLayers - 1) * this.layerGap;\n        // Get the segment points for this outermost layer to position decorations\n        var outerSegments = getSegmentPoints(r_outer, this.cornerGap);\n\n        // Proceed only if the outermost layer exists and has valid segments\n        if (outerSegments) {\n          // Define unit vectors parallel to each of the four potential segment orientations\n          var segmentDirections = [{\n            x: 1 / sqrt2,\n            y: -1 / sqrt2\n          }, {\n            x: -1 / sqrt2,\n            y: -1 / sqrt2\n          }, {\n            x: -1 / sqrt2,\n            y: 1 / sqrt2\n          }, {\n            x: 1 / sqrt2,\n            y: 1 / sqrt2\n          }];\n          // Define unit vectors perpendicular to each segment, pointing generally outwards\n          var perpendicularDirections = [{\n            x: 1 / sqrt2,\n            y: 1 / sqrt2\n          }, {\n            x: 1 / sqrt2,\n            y: -1 / sqrt2\n          }, {\n            x: -1 / sqrt2,\n            y: -1 / sqrt2\n          }, {\n            x: -1 / sqrt2,\n            y: 1 / sqrt2\n          }];\n\n          // Iterate through each segment of the outermost layer\n          outerSegments.forEach(function (seg, index) {\n            // Find the midpoint of the current segment\n            var midX = (seg.start.x + seg.end.x) / 2;\n            var midY = (seg.start.y + seg.end.y) / 2;\n            var dir = segmentDirections[index]; // Unit vector along the segment\n            var perp_dir = perpendicularDirections[index]; // Unit vector perpendicular to the segment\n\n            // Calculate the total width covered by the decoration lines and their spacing\n            var totalDecoSpread = (_this.decorationCount - 1) * _this.decorationSpacing;\n            // Calculate the offset for the first decoration line relative to the midpoint (along perp_dir)\n            var firstLineOffset = -totalDecoSpread / 2;\n\n            // Generate each decoration line for this segment\n            for (var j = 0; j < _this.decorationCount; j++) {\n              // Calculate the center position of the current (j-th) decoration line\n              // Start at the segment midpoint and offset along the perpendicular direction\n              var offsetDist = firstLineOffset + j * _this.decorationSpacing;\n              var centerOffsetX = midX + perp_dir.x * offsetDist;\n              var centerOffsetY = midY + perp_dir.y * offsetDist;\n\n              // Calculate the start and end points of the decoration line\n              // Extend outwards from the center point along the segment's direction (dir)\n              var halfLen = _this.decorationLength / 2;\n              var lineStartX = centerOffsetX - dir.x * halfLen;\n              var lineStartY = centerOffsetY - dir.y * halfLen;\n              var lineEndX = centerOffsetX + dir.x * halfLen;\n              var lineEndY = centerOffsetY + dir.y * halfLen;\n\n              // Add the decoration line as an SVG path element\n              svg += \"<path d=\\\"M \".concat(lineStartX.toFixed(3), \" \").concat(lineStartY.toFixed(3), \" L \").concat(lineEndX.toFixed(3), \" \").concat(lineEndY.toFixed(3), \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(sw, \"\\\" stroke-linecap=\\\"round\\\"/>\");\n            }\n          });\n        }\n      }\n      var maxExtent = maxRadius; // Furthest point from center is a vertex at distance maxRadius\n      if (maxExtent > 99.5) {\n        // Use 99.5 to provide a small margin from the edge\n        var scaleFactor = 99.5 / maxExtent;\n        // Wrap the entire generated SVG in a group with a scaling transform\n        // Note: Visually affects stroke width; ideally avoided by parameter constraints.\n        svg = \"<g transform=\\\"scale(\".concat(scaleFactor.toFixed(3), \")\\\">\").concat(svg, \"</g>\");\n      }\n\n      // Return the complete SVG string for the generated shape\n      return svg;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(AbstractLogo, \"parameters\", {\n  centerSize: {\n    type: 'number',\n    min: 25,\n    max: 100,\n    step: 1,\n    \"default\": 50\n  },\n  // Size (half-diagonal distance from center to vertex) of the central diamond.\n  numLayers: {\n    type: 'number',\n    min: 1,\n    max: 8,\n    step: 1,\n    \"default\": 4\n  },\n  // Total number of concentric layers, including the central one.\n  layerGap: {\n    type: 'number',\n    min: 2,\n    max: 15,\n    step: 1,\n    \"default\": 8\n  },\n  // Radial distance between consecutive layers.\n  cornerGap: {\n    type: 'number',\n    min: 0,\n    max: 40,\n    step: 1,\n    \"default\": 15\n  },\n  // The length of the gap created along the perimeter near each corner of the outer layers.\n  decorationLength: {\n    type: 'number',\n    min: 0,\n    max: 25,\n    step: 1,\n    \"default\": 10\n  },\n  // Length of the small decorative lines near the segments of the outermost layer. Set to 0 to hide.\n  decorationCount: {\n    type: 'number',\n    min: 0,\n    max: 7,\n    step: 1,\n    \"default\": 3\n  },\n  // Number of decorative lines per segment on the outermost layer. Set to 0 to hide.\n  decorationSpacing: {\n    type: 'number',\n    min: 0,\n    max: 10,\n    step: 1,\n    \"default\": 4\n  },\n  // Spacing between the parallel decorative lines.\n  strokeWidth: {\n    type: 'number',\n    min: 1,\n    max: 5,\n    step: 1,\n    \"default\": 4\n  } // Stroke width applied to all lines and paths.\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AbstractLogo);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/AbstractLogo.js?");

/***/ }),

/***/ "./src/shapes/AbstractMolecule.js":
/*!****************************************!*\
  !*** ./src/shapes/AbstractMolecule.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a shape resembling a stylized molecule or connected abstract\n * circles.\n */\nvar AbstractMolecule = /*#__PURE__*/function (_Shape) {\n  function AbstractMolecule() {\n    _classCallCheck(this, AbstractMolecule);\n    return _callSuper(this, AbstractMolecule, arguments);\n  }\n  _inherits(AbstractMolecule, _Shape);\n  return _createClass(AbstractMolecule, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var cR = this.centralRadius;\n      var cG = this.centralGap / 2; // Half gap for vertical offset from center (0,0)\n      var sR = this.smallRingRadius;\n      var sD = this.smallRingDistance;\n      var sSW = this.smallRingStrokeWidth;\n      var lR = this.largeRingRadius;\n      var lD = this.largeRingDistance;\n      var lSW = this.largeRingStrokeWidth;\n      var rot = this.rotation;\n\n      // Ensure stroke width isn't larger than radius for rings\n      var actualSSW = Math.min(sSW, sR * 2 * 0.9); // Leave a small hole\n      var actualLSW = Math.min(lSW, lR * 2 * 0.9); // Leave a small hole\n\n      // Calculate center points for the main circles\n      var centerTopY = -cG;\n      var centerBottomY = cG;\n\n      // Central circles (solid)\n      var centralCircle1 = \"<circle cx=\\\"0\\\" cy=\\\"\".concat(centerTopY, \"\\\" r=\\\"\").concat(cR, \"\\\" fill=\\\"white\\\" />\");\n      var centralCircle2 = \"<circle cx=\\\"0\\\" cy=\\\"\".concat(centerBottomY, \"\\\" r=\\\"\").concat(cR, \"\\\" fill=\\\"white\\\" />\");\n\n      // Small rings (stroked) around the central structure\n      // Ring above the top central circle\n      var smallRingTop = \"<circle cx=\\\"0\\\" cy=\\\"\".concat(centerTopY - sD, \"\\\" r=\\\"\").concat(sR, \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(actualSSW, \"\\\" />\");\n      // Ring below the bottom central circle\n      var smallRingBottom = \"<circle cx=\\\"0\\\" cy=\\\"\".concat(centerBottomY + sD, \"\\\" r=\\\"\").concat(sR, \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(actualSSW, \"\\\" />\");\n      // Ring to the right, vertically centered between the two central circles\n      var smallRingRight = \"<circle cx=\\\"\".concat(sD, \"\\\" cy=\\\"0\\\" r=\\\"\").concat(sR, \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(actualSSW, \"\\\" />\");\n      // Ring to the left, vertically centered between the two central circles\n      var smallRingLeft = \"<circle cx=\\\"\".concat(-sD, \"\\\" cy=\\\"0\\\" r=\\\"\").concat(sR, \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(actualSSW, \"\\\" />\");\n\n      // Large ring (stroked) attached to the left of the top central circle\n      var largeRing = \"<circle cx=\\\"\".concat(0 - lD, \"\\\" cy=\\\"\").concat(centerTopY, \"\\\" r=\\\"\").concat(lR, \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(actualLSW, \"\\\" />\");\n\n      // Combine all SVG elements\n      var elements = [centralCircle1, centralCircle2, smallRingTop, smallRingBottom, smallRingRight, smallRingLeft, largeRing];\n\n      // Group elements and apply overall rotation\n      return \"<g transform=\\\"rotate(\".concat(rot, \" 0 0)\\\">\").concat(elements.join('\\n'), \"</g>\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(AbstractMolecule, \"parameters\", {\n  centralRadius: {\n    type: 'number',\n    min: 5,\n    max: 50,\n    step: 1,\n    \"default\": 25,\n    label: 'Central Radius'\n  },\n  centralGap: {\n    type: 'number',\n    min: 0,\n    // Allow overlap\n    max: 80,\n    step: 1,\n    \"default\": 55,\n    label: 'Central Gap'\n  },\n  smallRingRadius: {\n    type: 'number',\n    min: 2,\n    max: 30,\n    step: 1,\n    \"default\": 10,\n    label: 'Small Ring Radius'\n  },\n  smallRingDistance: {\n    type: 'number',\n    min: 5,\n    max: 60,\n    step: 1,\n    \"default\": 35,\n    label: 'Small Ring Distance'\n  },\n  smallRingStrokeWidth: {\n    type: 'number',\n    min: 1,\n    max: 10,\n    step: 0.5,\n    \"default\": 4,\n    label: 'Small Ring Stroke'\n  },\n  largeRingRadius: {\n    type: 'number',\n    min: 5,\n    max: 45,\n    step: 1,\n    \"default\": 20,\n    label: 'Large Ring Radius'\n  },\n  largeRingDistance: {\n    type: 'number',\n    min: 10,\n    max: 70,\n    step: 1,\n    \"default\": 50,\n    label: 'Large Ring Distance'\n  },\n  largeRingStrokeWidth: {\n    type: 'number',\n    min: 1,\n    max: 15,\n    step: 0.5,\n    \"default\": 5,\n    label: 'Large Ring Stroke'\n  },\n  rotation: {\n    type: 'number',\n    min: 0,\n    max: 360,\n    step: 1,\n    \"default\": 0,\n    label: 'Rotation'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AbstractMolecule);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/AbstractMolecule.js?");

/***/ }),

/***/ "./src/shapes/AbstractSmileyFace.js":
/*!******************************************!*\
  !*** ./src/shapes/AbstractSmileyFace.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a classic smiley face with customizable size, emotion (affecting\n * the smile), eyes, and style (filled/outline). Includes blinking animation.\n */\nvar AbstractSmileyFace = /*#__PURE__*/function (_Shape) {\n  function AbstractSmileyFace() {\n    _classCallCheck(this, AbstractSmileyFace);\n    return _callSuper(this, AbstractSmileyFace, arguments);\n  }\n  _inherits(AbstractSmileyFace, _Shape);\n  return _createClass(AbstractSmileyFace, [{\n    key: \"getFillAttributes\",\n    value: function getFillAttributes() {\n      switch (this.fillStyle) {\n        case 'filled':\n          return {\n            faceFill: 'white',\n            featureFill: 'black',\n            stroke: 'none'\n          };\n        default:\n          // outline\n          return {\n            faceFill: 'none',\n            featureFill: 'white',\n            stroke: 'white'\n          };\n      }\n    }\n  }, {\n    key: \"interpolateSmile\",\n    value: function interpolateSmile(emotion) {\n      // Convert emotion (-100 to 100) to a normalized range (0 to 1)\n      var t = (emotion + 100) / 200;\n\n      // Define smile characteristics at different emotional states\n      var sad = {\n        width: 0.4,\n        height: -0.15,\n        yPos: 0.3\n      };\n      var neutral = {\n        width: 0.45,\n        height: 0,\n        yPos: 0.2\n      };\n      var happy = {\n        width: 0.5,\n        height: 0.25,\n        yPos: 0.15\n      };\n\n      // Interpolate between sad and neutral for negative emotions\n      // or between neutral and happy for positive emotions\n      if (emotion < 0) {\n        var subT = (emotion + 100) / 100; // 0 to 1 for sad to neutral\n        return {\n          width: sad.width + (neutral.width - sad.width) * subT,\n          height: sad.height + (neutral.height - sad.height) * subT,\n          yPos: sad.yPos + (neutral.yPos - sad.yPos) * subT\n        };\n      } else {\n        var _subT = emotion / 100; // 0 to 1 for neutral to happy\n        return {\n          width: neutral.width + (happy.width - neutral.width) * _subT,\n          height: neutral.height + (happy.height - neutral.height) * _subT,\n          yPos: neutral.yPos + (happy.yPos - neutral.yPos) * _subT\n        };\n      }\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      var radius = this.size / 2;\n      var fill = this.getFillAttributes();\n      var elements = [];\n\n      // Face circle\n      if (fill.doubleStroke) {\n        elements.push(\"<circle \\n                cx=\\\"0\\\" \\n                cy=\\\"0\\\" \\n                r=\\\"\".concat(radius + this.borderThickness, \"\\\"\\n                fill=\\\"none\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.borderThickness, \"\\\"\\n            />\"));\n      }\n      elements.push(\"<circle \\n            cx=\\\"0\\\" \\n            cy=\\\"0\\\" \\n            r=\\\"\".concat(radius, \"\\\"\\n            fill=\\\"\").concat(fill.faceFill, \"\\\"\\n            stroke=\\\"\").concat(fill.stroke, \"\\\"\\n            stroke-width=\\\"\").concat(this.borderThickness, \"\\\"\\n        />\"));\n\n      // Calculate eye positions with rotation\n      var eyeRadians = this.eyeAngle * Math.PI / 180;\n      var baseEyeX = radius * this.eyeSpacing / 100;\n      var baseEyeY = radius * this.eyeY / 100;\n      var eyeWidthPx = radius * this.eyeWidth / 100;\n      var eyeHeightPx = radius * this.eyeHeight / 100;\n\n      // Eyes with rotation\n      ['left', 'right'].forEach(function (side) {\n        var xMult = side === 'left' ? -1 : 1;\n        var rotatedX = baseEyeX * Math.cos(eyeRadians) - baseEyeY * Math.sin(eyeRadians);\n        var rotatedY = baseEyeX * Math.sin(eyeRadians) + baseEyeY * Math.cos(eyeRadians);\n        var eyeElement = \"<ellipse\\n                transform=\\\"rotate(\".concat(_this.eyeAngle, \")\\\"\\n                cx=\\\"\").concat(xMult * rotatedX, \"\\\"\\n                cy=\\\"\").concat(rotatedY, \"\\\"\\n                rx=\\\"\").concat(eyeWidthPx / 2, \"\\\"\\n                ry=\\\"\").concat(eyeHeightPx / 2, \"\\\"\\n                fill=\\\"\").concat(fill.featureFill, \"\\\"\");\n\n        // Add blinking animation \n        eyeElement += \">\\n                    <animate \\n                        attributeName=\\\"ry\\\" \\n                        values=\\\"\".concat(eyeHeightPx / 2, \";\").concat(eyeHeightPx / 2, \";1;\").concat(eyeHeightPx / 2, \"\\\" \\n                        keyTimes=\\\"0;0.85;0.9;1\\\"\\n                        dur=\\\"\").concat(_this.blinkInterval, \"s\\\" \\n                        repeatCount=\\\"indefinite\\\" \\n                    />\\n                </ellipse>\");\n        elements.push(eyeElement);\n      });\n\n      // Generate interpolated smile (static, no animation)\n      var smile = this.interpolateSmile(this.emotion);\n      var smileWidth = radius * smile.width * 2;\n      var startX = -smileWidth / 2;\n      var endX = smileWidth / 2;\n      var centerY = radius * smile.yPos;\n\n      // Calculate control points for the smile curve\n      var curveHeight = radius * smile.height;\n      var cp1x = startX + smileWidth * 0.25;\n      var cp2x = endX - smileWidth * 0.25;\n      var cp1y = centerY + curveHeight;\n      var cp2y = centerY + curveHeight;\n      elements.push(\"<path \\n            d=\\\"M \".concat(startX, \" \").concat(centerY, \"\\n               C \").concat(cp1x, \" \").concat(cp1y, \", \").concat(cp2x, \" \").concat(cp2y, \", \").concat(endX, \" \").concat(centerY, \"\\\"\\n            fill=\\\"none\\\"\\n            stroke=\\\"\").concat(fill.featureFill, \"\\\"\\n            stroke-width=\\\"\").concat(this.borderThickness, \"\\\"\\n            stroke-linecap=\\\"round\\\"\\n        />\"));\n      return elements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(AbstractSmileyFace, \"parameters\", {\n  size: {\n    min: 50,\n    max: 200,\n    \"default\": 180\n  },\n  borderThickness: {\n    min: 1,\n    max: 10,\n    \"default\": 5\n  },\n  emotion: {\n    min: -100,\n    max: 100,\n    \"default\": 100\n  },\n  // -100 = sad, 0 = neutral, 100 = happy\n  // Eye controls\n  eyeWidth: {\n    min: 5,\n    max: 50,\n    \"default\": 15\n  },\n  eyeHeight: {\n    min: 5,\n    max: 50,\n    \"default\": 35\n  },\n  eyeSpacing: {\n    min: 10,\n    max: 100,\n    \"default\": 25\n  },\n  eyeAngle: {\n    min: -45,\n    max: 45,\n    \"default\": 0\n  },\n  eyeY: {\n    min: -50,\n    max: 50,\n    \"default\": -20\n  },\n  blinkInterval: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  },\n  // Style options\n  fillStyle: {\n    options: ['outline', 'filled'],\n    \"default\": 'filled'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AbstractSmileyFace);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/AbstractSmileyFace.js?");

/***/ }),

/***/ "./src/shapes/AbstractStar.js":
/*!************************************!*\
  !*** ./src/shapes/AbstractStar.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates an abstract star shape resembling a stylized 'A' or an arrow\n * pointing up.\n */\nvar AbstractStar = /*#__PURE__*/function (_Shape) {\n  function AbstractStar() {\n    _classCallCheck(this, AbstractStar);\n    return _callSuper(this, AbstractStar, arguments);\n  }\n  _inherits(AbstractStar, _Shape);\n  return _createClass(AbstractStar, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Ensure indentHeight is below baseHeight for a valid shape\n      var actualIndentHeight = Math.min(this.indentHeight, this.baseHeight - 1);\n\n      // Define the 6 points of the polygon\n      // Point 1: Top center\n      var p1x = 0;\n      var p1y = this.topPointY;\n\n      // Point 2: Mid right\n      var p2x = this.midWidth;\n      var p2y = this.midHeight;\n\n      // Point 3: Bottom right\n      var p3x = this.baseWidth;\n      var p3y = this.baseHeight;\n\n      // Point 4: Bottom center indent\n      var p4x = 0;\n      var p4y = actualIndentHeight;\n\n      // Point 5: Bottom left\n      var p5x = -this.baseWidth;\n      var p5y = this.baseHeight;\n\n      // Point 6: Mid left\n      var p6x = -this.midWidth;\n      var p6y = this.midHeight;\n\n      // Construct the points string for the polygon\n      var points = [\"\".concat(p1x, \",\").concat(p1y), \"\".concat(p2x, \",\").concat(p2y), \"\".concat(p3x, \",\").concat(p3y), \"\".concat(p4x, \",\").concat(p4y), \"\".concat(p5x, \",\").concat(p5y), \"\".concat(p6x, \",\").concat(p6y)].join(' ');\n\n      // Return the SVG polygon element\n      return \"<polygon points=\\\"\".concat(points, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(AbstractStar, \"parameters\", {\n  topPointY: {\n    type: 'number',\n    min: -98,\n    max: -20,\n    step: 1,\n    \"default\": -60,\n    label: 'Top Point Y' // Added label for clarity\n  },\n  midWidth: {\n    type: 'number',\n    min: 10,\n    max: 100,\n    step: 1,\n    \"default\": 60,\n    label: 'Mid Point Width'\n  },\n  midHeight: {\n    type: 'number',\n    min: -40,\n    max: 50,\n    step: 1,\n    \"default\": 5,\n    label: 'Mid Point Height'\n  },\n  baseWidth: {\n    type: 'number',\n    min: 10,\n    max: 98,\n    step: 1,\n    \"default\": 60,\n    label: 'Base Width'\n  },\n  baseHeight: {\n    type: 'number',\n    min: 0,\n    max: 98,\n    step: 1,\n    \"default\": 65,\n    label: 'Base Height'\n  },\n  indentHeight: {\n    type: 'number',\n    min: -10,\n    // Allow slight upward indent\n    max: 80,\n    // Prevent indent going below base\n    step: 1,\n    \"default\": 0,\n    label: 'Indent Height'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AbstractStar);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/AbstractStar.js?");

/***/ }),

/***/ "./src/shapes/AbstractStripes.js":
/*!***************************************!*\
  !*** ./src/shapes/AbstractStripes.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates an abstract pattern of horizontal stripes\n*/\nvar AbstractStripes = /*#__PURE__*/function (_Shape) {\n  function AbstractStripes() {\n    _classCallCheck(this, AbstractStripes);\n    return _callSuper(this, AbstractStripes, arguments);\n  }\n  _inherits(AbstractStripes, _Shape);\n  return _createClass(AbstractStripes, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var viewBoxHeight = 150; // Use slightly less than 200 for padding\n      var viewBoxWidth = 150;\n      var minX = -viewBoxWidth / 2;\n      var maxX = viewBoxWidth / 2;\n      var minY = -viewBoxHeight / 2;\n      // const maxY = viewBoxHeight / 2; // Not needed directly\n\n      var svgRects = '';\n      var numStripes = Math.max(1, this.numStripes); // Ensure at least 1 stripe\n      var slotHeight = viewBoxHeight / numStripes;\n      var stripeHeight = Math.max(1, slotHeight * this.stripeHeightRatio); // Ensure minimum height 1px\n      var gapHeight = Math.max(0, slotHeight - stripeHeight);\n      for (var i = 0; i < numStripes; i++) {\n        // Calculate vertical position\n        var y = minY + i * slotHeight + gapHeight / 2;\n\n        // Calculate width modulation based on densityBias\n        // biasFactor ranges from -1 (top) to +1 (bottom)\n        var biasFactor = numStripes === 1 ? 0 : i / (numStripes - 1) * 2 - 1;\n        // Apply density bias: multiplier affects target width. Clamped to avoid zero/negative width.\n        var widthMultiplier = Math.max(0.05, 1.0 + this.densityBias * biasFactor);\n        var targetWidth = this.maxWidth * widthMultiplier;\n\n        // Apply width variance\n        var randomWidthFactor = 1.0 - this.widthVariance * this.random(); // Varies from (1-variance) to 1\n        var w = targetWidth * randomWidthFactor;\n\n        // Apply offset variance\n        // Random offset centered around 0, scaled by offsetVariance\n        // centerBias pushes the random range left/right\n        var randomOffset = (this.random() * 2 - 1) * this.offsetVariance; // -variance to +variance\n        var biasedOffset = randomOffset + this.centerBias * (viewBoxWidth / 3); // Add center bias pull\n        // Calculate base x position (centered) and add the biased random offset\n        var x = biasedOffset - w / 2;\n\n        // Clamp width and x to stay within viewBox bounds\n        w = Math.min(w, viewBoxWidth); // Ensure width isn't wider than the box\n        w = Math.max(1, w); // Ensure minimum width 1px\n\n        x = Math.max(minX, x); // Ensure left edge doesn't go past minX\n        if (x + w > maxX) {\n          // If right edge goes past maxX\n          x = maxX - w; // Adjust x so right edge is at maxX\n        }\n        x = Math.max(minX, x); // Re-clamp left edge after width adjustment\n\n        // Add small vertical variation based on random value\n        var yOffset = (this.random() - 0.5) * gapHeight * 0.2; // Small random vertical nudge\n\n        svgRects += \"<rect x=\\\"\".concat(x.toFixed(2), \"\\\" y=\\\"\").concat((y + yOffset).toFixed(2), \"\\\" width=\\\"\").concat(w.toFixed(2), \"\\\" height=\\\"\").concat(stripeHeight.toFixed(2), \"\\\" fill=\\\"white\\\" />\\n\");\n      }\n      return svgRects;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(AbstractStripes, \"parameters\", {\n  numStripes: {\n    type: 'number',\n    min: 2,\n    max: 40,\n    step: 1,\n    \"default\": 8,\n    label: 'Number of Stripes'\n  },\n  stripeHeightRatio: {\n    type: 'number',\n    min: 0.1,\n    max: 1.0,\n    step: 0.05,\n    \"default\": 0.6,\n    label: 'Stripe Height Ratio' // Ratio of stripe height to the available vertical slot per stripe\n  },\n  maxWidth: {\n    type: 'number',\n    min: 20,\n    max: 190,\n    step: 5,\n    \"default\": 160,\n    label: 'Max Stripe Width'\n  },\n  widthVariance: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    step: 0.05,\n    \"default\": 0.4,\n    label: 'Width Variance' // 0 = all max width (modified by bias), 1 = width varies randomly from 0 to max\n  },\n  offsetVariance: {\n    type: 'number',\n    min: 0,\n    max: 90,\n    step: 5,\n    \"default\": 30,\n    label: 'Offset Variance' // Max random horizontal offset from center\n  },\n  densityBias: {\n    type: 'number',\n    min: -1.5,\n    max: 1.5,\n    step: 0.1,\n    \"default\": 0.5,\n    label: 'Density Bias' // -ve: wider/denser top, +ve: wider/denser bottom, 0: uniform\n  },\n  centerBias: {\n    type: 'number',\n    min: -1,\n    max: 1,\n    step: 0.1,\n    \"default\": 0,\n    label: 'Center Bias' // -1: push left, 1: push right, 0: centered offset variance\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AbstractStripes);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/AbstractStripes.js?");

/***/ }),

/***/ "./src/shapes/AbstractYConnector.js":
/*!******************************************!*\
  !*** ./src/shapes/AbstractYConnector.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates an abstract Y-shaped structure composed of three connected arms.\n */\nvar AbstractYConnector = /*#__PURE__*/function (_Shape) {\n  function AbstractYConnector() {\n    _classCallCheck(this, AbstractYConnector);\n    return _callSuper(this, AbstractYConnector, arguments);\n  }\n  _inherits(AbstractYConnector, _Shape);\n  return _createClass(AbstractYConnector, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Access parameters using `this`\n      var armLength = this.armLength;\n      var centralHeight = this.centralHeight;\n      var armAngleDeg = this.armAngle;\n      var strokeWidth = this.strokeWidth;\n      var junctionInset = this.junctionInset;\n\n      // Ensure inset doesn't exceed half the central height, preventing collapse\n      // Subtract a small epsilon (like 0.1 or strokeWidth/2) if needed, but simple clamp is okay\n      var maxInset = centralHeight / 2.0 - 1; // Subtract 1 to ensure minimal central line\n      var actualInset = Math.min(junctionInset, maxInset > 0 ? maxInset : 0);\n\n      // Calculate Y coordinates of the top and bottom junction points\n      var yJunctionTop = centralHeight / 2 - actualInset;\n      var yJunctionBottom = -centralHeight / 2 + actualInset;\n\n      // Convert arm angle from degrees to radians for trigonometric functions\n      var angleRad = armAngleDeg * (Math.PI / 180);\n\n      // Calculate the X and Y offsets for the arm endpoints relative to the junction points\n      // Using sin for X offset and cos for Y offset as angle is from vertical\n      var dx = armLength * Math.sin(angleRad);\n      var dy = armLength * Math.cos(angleRad);\n\n      // Calculate absolute coordinates for the four arm endpoints\n      // Ensure coordinates stay within reasonable bounds for visibility, though clipping is SVG's job\n      var limit = 98; // Stay slightly within the -100 to +100 viewbox\n      var clamp = function clamp(val) {\n        return Math.max(-limit, Math.min(limit, val));\n      };\n      var topLeftX = clamp(-dx);\n      var topLeftY = clamp(yJunctionTop + dy);\n      var topRightX = clamp(dx);\n      var topRightY = clamp(yJunctionTop + dy);\n      var bottomLeftX = clamp(-dx);\n      var bottomLeftY = clamp(yJunctionBottom - dy);\n      var bottomRightX = clamp(dx);\n      var bottomRightY = clamp(yJunctionBottom - dy);\n      var clampedYJunctionTop = clamp(yJunctionTop);\n      var clampedYJunctionBottom = clamp(yJunctionBottom);\n\n      // Construct the SVG path data string using M (moveto) and L (lineto)\n      // The path consists of three segments to form the connected Y structure:\n      // 1. Top-left arm -> top junction -> bottom junction -> bottom-left arm\n      // 2. Top-right arm -> top junction (connects to the central point)\n      // 3. Bottom-right arm -> bottom junction (connects to the central point)\n      var pathData = \"\\n            M \".concat(topLeftX, \",\").concat(topLeftY, \" L 0,\").concat(clampedYJunctionTop, \" L 0,\").concat(clampedYJunctionBottom, \" L \").concat(bottomLeftX, \",\").concat(bottomLeftY, \"\\n            M \").concat(topRightX, \",\").concat(topRightY, \" L 0,\").concat(clampedYJunctionTop, \"\\n            M \").concat(bottomRightX, \",\").concat(bottomRightY, \" L 0,\").concat(clampedYJunctionBottom, \"\\n        \");\n\n      // Return the SVG path element string.\n      // Using stroke-linecap=\"round\" and stroke-linejoin=\"round\" creates the smooth connections\n      // seen in the reference image without complex arc calculations.\n      return \"<path d=\\\"\".concat(pathData, \"\\\"\\n                      fill=\\\"none\\\"\\n                      stroke=\\\"white\\\"\\n                      stroke-width=\\\"\").concat(strokeWidth, \"\\\"\\n                      stroke-linecap=\\\"round\\\"\\n                      stroke-linejoin=\\\"round\\\" />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(AbstractYConnector, \"parameters\", {\n  armLength: {\n    type: 'number',\n    label: 'Arm Length',\n    min: 5,\n    max: 90,\n    step: 1,\n    \"default\": 45\n  },\n  centralHeight: {\n    type: 'number',\n    label: 'Central Height',\n    min: 5,\n    max: 150,\n    step: 1,\n    \"default\": 50\n  },\n  armAngle: {\n    type: 'number',\n    label: 'Arm Angle (from vertical)',\n    min: 10,\n    max: 80,\n    // Avoid angles too close to 0 or 90\n    step: 1,\n    \"default\": 40 // Angle in degrees\n  },\n  strokeWidth: {\n    type: 'number',\n    label: 'Stroke Width',\n    min: 1,\n    max: 30,\n    step: 1,\n    \"default\": 10\n  },\n  junctionInset: {\n    type: 'number',\n    label: 'Junction Inset',\n    min: 0,\n    max: 50,\n    // Practical limit, constrained further in code\n    step: 1,\n    \"default\": 5 // Small inset by default\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AbstractYConnector);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/AbstractYConnector.js?");

/***/ }),

/***/ "./src/shapes/AlternatingSquaresPattern.js":
/*!*************************************************!*\
  !*** ./src/shapes/AlternatingSquaresPattern.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\nCreates a checkerboard pattern of squares with adjustable grid size, spacing, and corner radius.\n*/\nvar AlternatingSquaresPattern = /*#__PURE__*/function (_Shape) {\n  function AlternatingSquaresPattern() {\n    _classCallCheck(this, AlternatingSquaresPattern);\n    return _callSuper(this, AlternatingSquaresPattern, arguments);\n  }\n  _inherits(AlternatingSquaresPattern, _Shape);\n  return _createClass(AlternatingSquaresPattern, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Convert parameters to numbers to ensure proper calculations\n      var gridSize = Math.round(this.gridSize);\n      var spacing = Number(this.spacing);\n      var cornerRadius = Number(this.cornerRadius);\n      var viewBoxSize = 300;\n      var squareSize = Math.min(viewBoxSize / (gridSize * 2 + (gridSize - 1) * (spacing / 100)));\n\n      // Calculate total width and height\n      var totalWidth = gridSize * squareSize + (gridSize - 1) * spacing;\n      var totalHeight = totalWidth; // Square grid\n\n      // Calculate starting point to center the pattern\n      var startX = -totalWidth / 2;\n      var startY = -totalHeight / 2;\n      var squares = [];\n\n      // Create the checkerboard pattern\n      for (var row = 0; row < gridSize; row++) {\n        for (var col = 0; col < gridSize; col++) {\n          // Only draw squares in alternating positions\n          if ((row + col) % 2 === 0) {\n            var x = startX + col * (squareSize + spacing);\n            var y = startY + row * (squareSize + spacing);\n            if (cornerRadius > 0) {\n              // Create rounded rectangle using SVG path\n              var path = this.createRoundedRectPath(x, y, squareSize, squareSize, cornerRadius);\n              squares.push(\"<path d=\\\"\".concat(path, \"\\\" fill=\\\"white\\\"/>\"));\n            } else {\n              // Create regular rectangle\n              squares.push(\"<rect \\n                            x=\\\"\".concat(x, \"\\\" \\n                            y=\\\"\").concat(y, \"\\\" \\n                            width=\\\"\").concat(squareSize, \"\\\" \\n                            height=\\\"\").concat(squareSize, \"\\\"\\n                            fill=\\\"white\\\"\\n                        />\"));\n            }\n          }\n        }\n      }\n      return squares.join('');\n    }\n  }, {\n    key: \"createRoundedRectPath\",\n    value: function createRoundedRectPath(x, y, width, height, radius) {\n      // Ensure radius isn't too large for the rectangle\n      var r = Math.min(radius, Math.min(width, height) / 2);\n\n      // Create rounded rectangle path\n      return \"\\n            M \".concat(x + r, \" \").concat(y, \"\\n            L \").concat(x + width - r, \" \").concat(y, \"\\n            Q \").concat(x + width, \" \").concat(y, \" \").concat(x + width, \" \").concat(y + r, \"\\n            L \").concat(x + width, \" \").concat(y + height - r, \"\\n            Q \").concat(x + width, \" \").concat(y + height, \" \").concat(x + width - r, \" \").concat(y + height, \"\\n            L \").concat(x + r, \" \").concat(y + height, \"\\n            Q \").concat(x, \" \").concat(y + height, \" \").concat(x, \" \").concat(y + height - r, \"\\n            L \").concat(x, \" \").concat(y + r, \"\\n            Q \").concat(x, \" \").concat(y, \" \").concat(x + r, \" \").concat(y, \"\\n            Z\\n        \").trim().replace(/\\s+/g, ' ');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(AlternatingSquaresPattern, \"parameters\", {\n  gridSize: {\n    min: 2,\n    max: 6,\n    \"default\": 3\n  },\n  spacing: {\n    min: 0,\n    max: 20,\n    \"default\": 0\n  },\n  cornerRadius: {\n    min: 0,\n    max: 30,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AlternatingSquaresPattern);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/AlternatingSquaresPattern.js?");

/***/ }),

/***/ "./src/shapes/ArcConnectorShape.js":
/*!*****************************************!*\
  !*** ./src/shapes/ArcConnectorShape.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a circular arrangement of arcs connected by optional segments.\n */\nvar ArcConnectorShape = /*#__PURE__*/function (_Shape) {\n  function ArcConnectorShape() {\n    _classCallCheck(this, ArcConnectorShape);\n    return _callSuper(this, ArcConnectorShape, arguments);\n  }\n  _inherits(ArcConnectorShape, _Shape);\n  return _createClass(ArcConnectorShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      this.arcCount = Math.round(this.arcCount);\n      var elements = [];\n      var angleStep = 2 * Math.PI / this.arcCount;\n      var arcSpanRad = this.arcSpan * Math.PI / 180;\n      var rotationRad = this.rotation * Math.PI / 180;\n      for (var i = 0; i < this.arcCount; i++) {\n        var centerAngle = i * angleStep + rotationRad;\n\n        // Calculate arc endpoints\n        var arcStartAngle = centerAngle - arcSpanRad / 2;\n        var arcEndAngle = centerAngle + arcSpanRad / 2;\n\n        // Calculate arc path\n        var startX = this.radius * Math.cos(arcStartAngle);\n        var startY = this.radius * Math.sin(arcStartAngle);\n        var endX = this.radius * Math.cos(arcEndAngle);\n        var endY = this.radius * Math.sin(arcEndAngle);\n\n        // Create arc path\n        var largeArcFlag = this.arcSpan > 180 ? 1 : 0;\n        var arcPath = \"M \".concat(startX, \" \").concat(startY, \" A \").concat(this.radius, \" \").concat(this.radius, \" 0 \").concat(largeArcFlag, \" 1 \").concat(endX, \" \").concat(endY);\n\n        // Add arc\n        elements.push(\"<path \\n                d=\\\"\".concat(arcPath, \"\\\"\\n                fill=\\\"white\\\"\\n            />\"));\n\n        // Add connector to next arc if connectorLength > 0\n        if (this.connectorLength > 0) {\n          var nextCenterAngle = (i + 1) % this.arcCount * angleStep + rotationRad;\n          var nextArcStartAngle = nextCenterAngle - arcSpanRad / 2;\n          var nextStartX = this.radius * Math.cos(nextArcStartAngle);\n          var nextStartY = this.radius * Math.sin(nextArcStartAngle);\n          var connectorPath = \"M \".concat(endX, \" \").concat(endY, \" Q \").concat(this.connectorLength * Math.cos(centerAngle), \" \").concat(this.connectorLength * Math.sin(centerAngle), \" \").concat(nextStartX, \" \").concat(nextStartY);\n          elements.push(\"<path \\n                    d=\\\"\".concat(connectorPath, \"\\\"\\n                    fill=\\\"white\\\"\\n                />\"));\n        }\n      }\n      return elements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(ArcConnectorShape, \"parameters\", {\n  radius: {\n    min: 20,\n    max: 150,\n    \"default\": 90\n  },\n  arcCount: {\n    min: 3,\n    max: 24,\n    \"default\": 8\n  },\n  arcSpan: {\n    min: 0,\n    max: 120,\n    \"default\": 5\n  },\n  connectorLength: {\n    min: 1,\n    max: 100,\n    \"default\": 1\n  },\n  rotation: {\n    min: -180,\n    max: 180,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ArcConnectorShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/ArcConnectorShape.js?");

/***/ }),

/***/ "./src/shapes/ArchShape.js":
/*!*********************************!*\
  !*** ./src/shapes/ArchShape.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Creates a rectangular shape with an arch cutout at the bottom, with\n * customizable dimensions and rounding.\n */\nvar ArchShape = /*#__PURE__*/function (_Shape) {\n  function ArchShape() {\n    _classCallCheck(this, ArchShape);\n    return _callSuper(this, ArchShape, arguments);\n  }\n  _inherits(ArchShape, _Shape);\n  return _createClass(ArchShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Scale and normalize parameters\n      var width = Math.max(50, this.width); // Ensure minimum width\n      var height = Math.max(50, this.height); // Ensure minimum height\n\n      // Adaptive arch width based on total width\n      var archWidth = Math.min(Math.max(20, this.archWidth),\n      // Minimum arch width\n      width * 0.8 // Maximum as percentage of total width\n      );\n\n      // Adaptive arch height\n      var archHeight = Math.min(Math.max(20, this.archHeight),\n      // Minimum arch height\n      height * 0.8 // Maximum as percentage of total height\n      );\n\n      // Calculate positions\n      var halfWidth = width / 2;\n      var halfArchWidth = archWidth / 2;\n      var leftEdge = -halfWidth;\n      var rightEdge = halfWidth;\n      var topEdge = -height / 2;\n      var bottomEdge = height / 2;\n      var archLeft = -halfArchWidth;\n      var archRight = halfArchWidth;\n\n      // Available space calculations\n      var outerSideWidth = Math.min(halfWidth - halfArchWidth, width * 0.3);\n      var maxOuterCornerRadius = Math.min(outerSideWidth * 0.8, height * 0.2);\n\n      // Dynamically adjust corner radius to available space\n      var cornerRadius = Math.max(0, Math.min(this.cornerRadius, maxOuterCornerRadius, width * 0.1, height * 0.1));\n\n      // Calculate safe arch top radius - must be positive and proportional\n      var maxArchRadius = Math.min(archWidth * 0.4, archHeight * 0.4);\n      var archTopRadius = Math.max(0, Math.min(this.archTopRadius, maxArchRadius));\n\n      // Define the path\n      var pathData = '';\n\n      // Create outer shape path\n      pathData = cornerRadius > 0 ? this.createRoundedRectPath(leftEdge, rightEdge, topEdge, bottomEdge, cornerRadius) : this.createRectPath(leftEdge, rightEdge, topEdge, bottomEdge);\n\n      // Create arch cutout - using fill-rule=\"evenodd\" to create the cutout effect\n      pathData += ' ' + this.createArchPath(archLeft, archRight, bottomEdge, archHeight, archTopRadius);\n      return \"<path d=\\\"\".concat(pathData, \"\\\" fill=\\\"white\\\" fill-rule=\\\"evenodd\\\" />\");\n    }\n\n    // Helper method to create rounded rectangle path\n  }, {\n    key: \"createRoundedRectPath\",\n    value: function createRoundedRectPath(left, right, top, bottom, radius) {\n      return \"\\n            M \".concat(left + radius, \",\").concat(top, \"\\n            H \").concat(right - radius, \"\\n            Q \").concat(right, \",\").concat(top, \" \").concat(right, \",\").concat(top + radius, \"\\n            V \").concat(bottom - radius, \"\\n            Q \").concat(right, \",\").concat(bottom, \" \").concat(right - radius, \",\").concat(bottom, \"\\n            H \").concat(left + radius, \"\\n            Q \").concat(left, \",\").concat(bottom, \" \").concat(left, \",\").concat(bottom - radius, \"\\n            V \").concat(top + radius, \"\\n            Q \").concat(left, \",\").concat(top, \" \").concat(left + radius, \",\").concat(top, \"\\n        \");\n    }\n\n    // Helper method to create rectangle path\n  }, {\n    key: \"createRectPath\",\n    value: function createRectPath(left, right, top, bottom) {\n      return \"\\n            M \".concat(left, \",\").concat(top, \"\\n            H \").concat(right, \"\\n            V \").concat(bottom, \"\\n            H \").concat(left, \"\\n            Z\\n        \");\n    }\n\n    // Helper method to create arch cutout path\n  }, {\n    key: \"createArchPath\",\n    value: function createArchPath(left, right, bottom, height, radius) {\n      var archTop = bottom - height;\n      if (radius <= 0) {\n        // Rectangular arch cutout\n        return \"\\n                M \".concat(left, \",\").concat(bottom, \"\\n                V \").concat(archTop, \"\\n                H \").concat(right, \"\\n                V \").concat(bottom, \"\\n                Z\\n            \");\n      } else {\n        // Arch with rounded top\n        return \"\\n                M \".concat(left, \",\").concat(bottom, \"\\n                V \").concat(archTop + radius, \"\\n                Q \").concat(left, \",\").concat(archTop, \" \").concat(left + radius, \",\").concat(archTop, \"\\n                H \").concat(right - radius, \"\\n                Q \").concat(right, \",\").concat(archTop, \" \").concat(right, \",\").concat(archTop + radius, \"\\n                V \").concat(bottom, \"\\n                Z\\n            \");\n      }\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(ArchShape, \"parameters\", {\n  width: {\n    min: 50,\n    max: 200,\n    \"default\": 150\n  },\n  height: {\n    min: 50,\n    max: 200,\n    \"default\": 150\n  },\n  archWidth: {\n    min: 30,\n    max: 120,\n    \"default\": 60\n  },\n  archHeight: {\n    min: 30,\n    max: 150,\n    \"default\": 90\n  },\n  cornerRadius: {\n    min: 0,\n    max: 20,\n    \"default\": 0\n  },\n  archTopRadius: {\n    min: 0,\n    max: 60,\n    \"default\": 30\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ArchShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/ArchShape.js?");

/***/ }),

/***/ "./src/shapes/ArrowShape.js":
/*!**********************************!*\
  !*** ./src/shapes/ArrowShape.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates various styles of filled arrow shapes with adjustable dimensions\n * and rotation.\n */\nvar ArrowShape = /*#__PURE__*/function (_Shape) {\n  function ArrowShape() {\n    var _this;\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, ArrowShape);\n    _this = _callSuper(this, ArrowShape, [options]);\n    _this.validateAndAdjustParameters();\n    return _this;\n  }\n  _inherits(ArrowShape, _Shape);\n  return _createClass(ArrowShape, [{\n    key: \"validateAndAdjustParameters\",\n    value: function validateAndAdjustParameters() {\n      // Ensure head width is proportional to length\n      var maxHeadWidth = this.length * 0.8;\n      this.headWidth = Math.min(this.headWidth, maxHeadWidth);\n\n      // Always ensure head width is greater than shaft width\n      var minHeadWidthDiff = Math.max(10, this.length * 0.1);\n      if (this.headWidth < this.shaftWidth + minHeadWidthDiff) {\n        this.headWidth = this.shaftWidth + minHeadWidthDiff;\n      }\n\n      // Ensure head length is proportional to total length\n      var maxHeadLength = this.length * 0.5;\n      this.headLength = Math.min(this.headLength, maxHeadLength);\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Apply validations to ensure proper dimensions\n      this.validateAndAdjustParameters();\n\n      // Calculate dimensions\n      var headHeight = this.headLength;\n      var shaftHeight = this.length - headHeight;\n      var halfHeadWidth = this.headWidth / 2;\n      var halfShaftWidth = this.shaftWidth / 2;\n\n      // Base Y positions\n      var baseY = -this.length / 2;\n      var shaftTopY = baseY + shaftHeight;\n      var tipY = this.length / 2;\n      var points;\n\n      // Apply different filled styles\n      switch (Math.floor(this.style)) {\n        case 1:\n          // Bold - wider shaft\n          var boldHalfShaftWidth = halfShaftWidth * 1.2;\n          points = [[-boldHalfShaftWidth, baseY], [boldHalfShaftWidth, baseY], [boldHalfShaftWidth, shaftTopY], [halfHeadWidth, shaftTopY], [0, tipY], [-halfHeadWidth, shaftTopY], [-boldHalfShaftWidth, shaftTopY]];\n          break;\n        case 2:\n          // Thin - slimmer shaft\n          var thinHalfShaftWidth = halfShaftWidth * 0.7;\n          points = [[-thinHalfShaftWidth, baseY], [thinHalfShaftWidth, baseY], [thinHalfShaftWidth, shaftTopY], [halfHeadWidth, shaftTopY], [0, tipY], [-halfHeadWidth, shaftTopY], [-thinHalfShaftWidth, shaftTopY]];\n          break;\n        case 3:\n          // Flat - shorter head\n          var flatHeadHeight = headHeight * 0.7;\n          var flatShaftTopY = baseY + (this.length - flatHeadHeight);\n          points = [[-halfShaftWidth, baseY], [halfShaftWidth, baseY], [halfShaftWidth, flatShaftTopY], [halfHeadWidth, flatShaftTopY], [0, tipY], [-halfHeadWidth, flatShaftTopY], [-halfShaftWidth, flatShaftTopY]];\n          break;\n        case 4:\n          // Sharp - longer, more pointed head\n          var sharpHeadHeight = headHeight * 1.2;\n          var sharpShaftTopY = baseY + (this.length - sharpHeadHeight);\n          var sharpHeadWidth = halfHeadWidth * 0.9; // Slightly narrower for sharper look\n          points = [[-halfShaftWidth, baseY], [halfShaftWidth, baseY], [halfShaftWidth, sharpShaftTopY], [sharpHeadWidth, sharpShaftTopY], [0, tipY], [-sharpHeadWidth, sharpShaftTopY], [-halfShaftWidth, sharpShaftTopY]];\n          break;\n        case 0: // Standard (default)\n        default:\n          points = [[-halfShaftWidth, baseY], [halfShaftWidth, baseY], [halfShaftWidth, shaftTopY], [halfHeadWidth, shaftTopY], [0, tipY], [-halfHeadWidth, shaftTopY], [-halfShaftWidth, shaftTopY]];\n          break;\n      }\n\n      // Create polygon points string\n      var pointsString = points.map(function (p) {\n        return \"\".concat(p[0], \",\").concat(p[1]);\n      }).join(' ');\n\n      // Return a filled polygon - no strokes\n      return \"\\n            <g transform=\\\"rotate(\".concat(this.rotation, \")\\\">\\n                <polygon \\n                    points=\\\"\").concat(pointsString, \"\\\"\\n                    fill=\\\"white\\\"\\n                />\\n            </g>\\n        \");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(ArrowShape, \"parameters\", {\n  // Basic dimensions\n  length: {\n    min: 50,\n    max: 150,\n    \"default\": 150\n  },\n  shaftWidth: {\n    min: 10,\n    max: 100,\n    \"default\": 30\n  },\n  headWidth: {\n    min: 20,\n    max: 200,\n    \"default\": 80\n  },\n  headLength: {\n    min: 20,\n    max: 100,\n    \"default\": 50\n  },\n  rotation: {\n    min: -180,\n    max: 180,\n    \"default\": 180,\n    step: 45\n  },\n  // Visual style parameter (all filled styles)\n  // 0=standard, 1=bold, 2=thin, 3=flat, 4=sharp\n  style: {\n    min: 0,\n    max: 4,\n    \"default\": 0,\n    step: 1\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ArrowShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/ArrowShape.js?");

/***/ }),

/***/ "./src/shapes/AtomShape.js":
/*!*********************************!*\
  !*** ./src/shapes/AtomShape.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a stylized atom symbol with a central nucleus and symmetrical\n * elliptical orbits.\n */\nvar AtomShape = /*#__PURE__*/function (_Shape) {\n  function AtomShape() {\n    _classCallCheck(this, AtomShape);\n    return _callSuper(this, AtomShape, arguments);\n  }\n  _inherits(AtomShape, _Shape);\n  return _createClass(AtomShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      this.orbitCount = Math.round(this.orbitCount);\n      var elements = [];\n\n      // Generate nucleus\n      elements.push(\"<circle\\n      cx=\\\"0\\\"\\n      cy=\\\"0\\\"\\n      r=\\\"\".concat(this.nucleusRadius, \"\\\"\\n      fill=\\\"white\\\"\\n    />\"));\n\n      // Calculate rotation angles for perfect symmetry\n      var angleStep = 180 / this.orbitCount;\n\n      // Generate orbits - perfectly symmetrical\n      for (var i = 0; i < this.orbitCount; i++) {\n        var rotation = i * angleStep;\n        elements.push(\"<ellipse\\n        cx=\\\"0\\\"\\n        cy=\\\"0\\\"\\n        rx=\\\"\".concat(this.orbitRadius, \"\\\"\\n        ry=\\\"\").concat(this.orbitRadius * this.orbitEccentricity, \"\\\"\\n        transform=\\\"rotate(\").concat(rotation, \")\\\"\\n        fill=\\\"none\\\"\\n        stroke=\\\"white\\\"\\n        stroke-width=\\\"\").concat(this.strokeWidth, \"\\\"\\n      />\"));\n      }\n      return elements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(AtomShape, \"parameters\", {\n  nucleusRadius: {\n    min: 5,\n    max: 30,\n    \"default\": 18\n  },\n  orbitCount: {\n    min: 2,\n    max: 4,\n    \"default\": 3\n  },\n  orbitRadius: {\n    min: 40,\n    max: 120,\n    \"default\": 80\n  },\n  orbitEccentricity: {\n    min: 0.2,\n    max: 0.6,\n    \"default\": 0.4\n  },\n  strokeWidth: {\n    min: 1,\n    max: 10,\n    \"default\": 4\n  },\n  symmetryAngle: {\n    min: 15,\n    max: 60,\n    \"default\": 40\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AtomShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/AtomShape.js?");

/***/ }),

/***/ "./src/shapes/AtomicSymbol.js":
/*!************************************!*\
  !*** ./src/shapes/AtomicSymbol.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a complex symbol featuring a central star, elliptical orbits, and\n * an outer segmented circle.\n */\nvar AtomicSymbol = /*#__PURE__*/function (_Shape) {\n  function AtomicSymbol() {\n    _classCallCheck(this, AtomicSymbol);\n    return _callSuper(this, AtomicSymbol, arguments);\n  }\n  _inherits(AtomicSymbol, _Shape);\n  return _createClass(AtomicSymbol, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Ensure inner radius is smaller than outer radius\n      var starInnerRadius = Math.min(this.starInnerRadius, this.starOuterRadius - 1);\n      var orbitMinorRadius = Math.min(this.orbitMinorRadius, this.orbitMajorRadius - 1);\n      var svg = '';\n\n      // 1. Generate Central Star\n      svg += this.generateStar(starInnerRadius, this.starOuterRadius, this.starPoints);\n\n      // 2. Generate Orbits\n      svg += this.generateOrbits(this.orbitMajorRadius, orbitMinorRadius, this.orbitTilt, this.orbitStrokeWidth);\n\n      // 3. Generate Outer Segmented Circle\n      svg += this.generateOuterCircle(this.outerCircleRadius, this.outerCircleSegments, this.outerCircleGap, this.outerCircleStrokeWidth);\n      return \"<g transform=\\\"rotate(0 0 0)\\\">\".concat(svg, \"</g>\"); // Optional overall rotation can be added here\n    }\n  }, {\n    key: \"generateStar\",\n    value: function generateStar(innerR, outerR, numPoints) {\n      var points = '';\n      var angleStep = Math.PI / numPoints;\n      for (var i = 0; i < 2 * numPoints; i++) {\n        var radius = i % 2 === 0 ? outerR : innerR;\n        var angle = i * angleStep - Math.PI / 2; // Start from top\n        var x = radius * Math.cos(angle);\n        var y = radius * Math.sin(angle);\n        points += \"\".concat(x.toFixed(3), \",\").concat(y.toFixed(3), \" \");\n      }\n      return \"<polygon points=\\\"\".concat(points.trim(), \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\");\n    }\n  }, {\n    key: \"generateOrbits\",\n    value: function generateOrbits(rx, ry, tilt, strokeWidth) {\n      // Draw two ellipses with different rotations\n      // Note: True weaving is complex in SVG. This creates an overlapping effect.\n      var ellipse1 = \"<ellipse cx=\\\"0\\\" cy=\\\"0\\\" rx=\\\"\".concat(rx, \"\\\" ry=\\\"\").concat(ry, \"\\\" transform=\\\"rotate(\").concat(tilt, \")\\\" />\");\n      var ellipse2 = \"<ellipse cx=\\\"0\\\" cy=\\\"0\\\" rx=\\\"\".concat(rx, \"\\\" ry=\\\"\").concat(ry, \"\\\" transform=\\\"rotate(\").concat(-tilt, \")\\\" />\");\n      return \"<g fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"\".concat(strokeWidth, \"\\\">\").concat(ellipse1).concat(ellipse2, \"</g>\");\n    }\n  }, {\n    key: \"generateOuterCircle\",\n    value: function generateOuterCircle(radius, numSegments, gapAngleDeg, strokeWidth) {\n      var paths = '';\n      var totalAngle = 360;\n      var totalGapAngle = numSegments * gapAngleDeg;\n      var segmentAngleDeg = (totalAngle - totalGapAngle) / numSegments;\n      if (segmentAngleDeg <= 0) return ''; // Avoid invalid arcs if gaps are too large\n\n      var segmentAngleRad = segmentAngleDeg * (Math.PI / 180);\n      var gapAngleRad = gapAngleDeg * (Math.PI / 180);\n      var currentAngle = -Math.PI / 2 - segmentAngleRad / 2; // Start angle to center segments visually\n\n      for (var i = 0; i < numSegments; i++) {\n        var startAngle = currentAngle;\n        var endAngle = startAngle + segmentAngleRad;\n        var startX = radius * Math.cos(startAngle);\n        var startY = radius * Math.sin(startAngle);\n        var endX = radius * Math.cos(endAngle);\n        var endY = radius * Math.sin(endAngle);\n        var largeArcFlag = segmentAngleDeg > 180 ? 1 : 0;\n        var pathData = \"M \".concat(startX.toFixed(3), \",\").concat(startY.toFixed(3), \" A \").concat(radius, \",\").concat(radius, \" 0 \").concat(largeArcFlag, \" 1 \").concat(endX.toFixed(3), \",\").concat(endY.toFixed(3));\n        paths += \"<path d=\\\"\".concat(pathData, \"\\\" />\");\n        currentAngle += segmentAngleRad + gapAngleRad;\n      }\n      return \"<g fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"\".concat(strokeWidth, \"\\\" stroke-linecap=\\\"round\\\">\").concat(paths, \"</g>\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(AtomicSymbol, \"parameters\", {\n  starPoints: {\n    type: 'number',\n    min: 3,\n    max: 16,\n    step: 1,\n    \"default\": 8,\n    label: 'Star Points'\n  },\n  starOuterRadius: {\n    type: 'number',\n    min: 5,\n    max: 50,\n    step: 1,\n    \"default\": 20,\n    label: 'Star Outer Radius'\n  },\n  starInnerRadius: {\n    type: 'number',\n    min: 2,\n    max: 45,\n    step: 1,\n    \"default\": 8,\n    label: 'Star Inner Radius'\n  },\n  orbitMajorRadius: {\n    type: 'number',\n    min: 20,\n    max: 90,\n    step: 1,\n    \"default\": 70,\n    label: 'Orbit Major Radius'\n  },\n  orbitMinorRadius: {\n    type: 'number',\n    min: 10,\n    max: 85,\n    step: 1,\n    \"default\": 45,\n    label: 'Orbit Minor Radius'\n  },\n  orbitTilt: {\n    type: 'number',\n    min: 0,\n    max: 90,\n    step: 1,\n    \"default\": 45,\n    label: 'Orbit Tilt ()'\n  },\n  orbitStrokeWidth: {\n    type: 'number',\n    min: 1,\n    max: 15,\n    step: 1,\n    \"default\": 8,\n    label: 'Orbit Stroke Width'\n  },\n  outerCircleRadius: {\n    type: 'number',\n    min: 50,\n    max: 98,\n    step: 1,\n    \"default\": 90,\n    label: 'Outer Circle Radius'\n  },\n  outerCircleSegments: {\n    type: 'number',\n    min: 2,\n    max: 12,\n    step: 1,\n    \"default\": 4,\n    label: 'Outer Circle Segments'\n  },\n  outerCircleGap: {\n    // Gap angle in degrees\n    type: 'number',\n    min: 0,\n    max: 90,\n    step: 1,\n    \"default\": 20,\n    label: 'Outer Circle Gap ()'\n  },\n  outerCircleStrokeWidth: {\n    type: 'number',\n    min: 1,\n    max: 15,\n    step: 1,\n    \"default\": 6,\n    label: 'Outer Circle Stroke Width'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AtomicSymbol);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/AtomicSymbol.js?");

/***/ }),

/***/ "./src/shapes/BarcodeShape.js":
/*!************************************!*\
  !*** ./src/shapes/BarcodeShape.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a grid of vertical lines with varying thickness based on different patterns.\n */\nvar BarcodeShape = /*#__PURE__*/function (_Shape) {\n  function BarcodeShape() {\n    _classCallCheck(this, BarcodeShape);\n    return _callSuper(this, BarcodeShape, arguments);\n  }\n  _inherits(BarcodeShape, _Shape);\n  return _createClass(BarcodeShape, [{\n    key: \"getThickness\",\n    value: function getThickness(index) {\n      switch (this.pattern) {\n        case 'random':\n          return this.minThickness + (this.maxThickness - this.minThickness) * this.random();\n        case 'alternating':\n          return index % 2 === 0 ? this.minThickness : this.maxThickness;\n        case 'increasing':\n          var step = (this.maxThickness - this.minThickness) / (this.linesCount - 1 || 1);\n          return this.minThickness + index * step;\n        case 'fibonacci':\n          {\n            // Simplified Fibonacci-based thickness\n            var fibValue = 0;\n            var a = 0,\n              b = 1;\n            for (var i = 0; i <= index % 10; i++) {\n              fibValue = a;\n              var temp = a + b;\n              a = b;\n              b = temp;\n            }\n            // Scale fibonacci number to our thickness range\n            var normalizedValue = fibValue % 21 / 20;\n            return this.minThickness + normalizedValue * (this.maxThickness - this.minThickness);\n          }\n        default:\n          return this.minThickness;\n      }\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Reset RNG for consistent generation with same parameters\n      this.resetRNG();\n      var lines = [];\n      var totalWidth = this.linesCount * this.spacing;\n      var startX = -totalWidth / 2;\n      for (var i = 0; i < this.linesCount; i++) {\n        var x = startX + i * this.spacing;\n        var thickness = this.getThickness(i);\n        lines.push(\"<line \\n                x1=\\\"\".concat(x, \"\\\" \\n                y1=\\\"\").concat(-this.height / 2, \"\\\" \\n                x2=\\\"\").concat(x, \"\\\" \\n                y2=\\\"\").concat(this.height / 2, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(thickness, \"\\\"\\n                stroke-linecap=\\\"\").concat(this.lineCap, \"\\\"\\n            />\"));\n      }\n      return lines.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(BarcodeShape, \"parameters\", {\n  linesCount: {\n    min: 4,\n    max: 16,\n    \"default\": 12\n  },\n  minThickness: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  },\n  maxThickness: {\n    min: 1,\n    max: 30,\n    \"default\": 12\n  },\n  spacing: {\n    min: 1,\n    max: 25,\n    \"default\": 12\n  },\n  height: {\n    min: 50,\n    max: 150,\n    \"default\": 200\n  },\n  // Remove randomSeed and use inherited seed\n  pattern: {\n    options: ['random', 'alternating', 'increasing', 'fibonacci'],\n    \"default\": 'random'\n  },\n  lineCap: {\n    options: ['butt', 'round'],\n    \"default\": 'butt'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BarcodeShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/BarcodeShape.js?");

/***/ }),

/***/ "./src/shapes/BasicAsteriskShape.js":
/*!******************************************!*\
  !*** ./src/shapes/BasicAsteriskShape.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a simple asterisk shape with a configurable number of rectangular\n * arms.\n */\nvar BasicAsteriskShape = /*#__PURE__*/function (_Shape) {\n  function BasicAsteriskShape() {\n    _classCallCheck(this, BasicAsteriskShape);\n    return _callSuper(this, BasicAsteriskShape, arguments);\n  }\n  _inherits(BasicAsteriskShape, _Shape);\n  return _createClass(BasicAsteriskShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      this.arms = Math.round(this.arms);\n      var paths = [];\n      var angleIncrement = 2 * Math.PI / this.arms;\n\n      // Generate each arm\n      for (var arm = 0; arm < this.arms; arm++) {\n        var angle = arm * angleIncrement;\n\n        // Calculate perpendicular angle for arm width\n        var perpAngle = angle + Math.PI / 2;\n        var halfWidth = this.armWidth / 2;\n\n        // Calculate start point (inner radius)\n        var startX = this.innerRadius * Math.cos(angle);\n        var startY = this.innerRadius * Math.sin(angle);\n\n        // Calculate end point (full length)\n        var endX = this.armLength * Math.cos(angle);\n        var endY = this.armLength * Math.sin(angle);\n\n        // Calculate the four corners of the rectangular arm\n        var p1 = {\n          x: startX + halfWidth * Math.cos(perpAngle),\n          y: startY + halfWidth * Math.sin(perpAngle)\n        };\n        var p2 = {\n          x: startX - halfWidth * Math.cos(perpAngle),\n          y: startY - halfWidth * Math.sin(perpAngle)\n        };\n        var p3 = {\n          x: endX - halfWidth * Math.cos(perpAngle),\n          y: endY - halfWidth * Math.sin(perpAngle)\n        };\n        var p4 = {\n          x: endX + halfWidth * Math.cos(perpAngle),\n          y: endY + halfWidth * Math.sin(perpAngle)\n        };\n\n        // Create path for this arm\n        var path = \"<path d=\\\"M \".concat(p1.x, \" \").concat(p1.y, \" \\n                L \").concat(p2.x, \" \").concat(p2.y, \" \\n                L \").concat(p3.x, \" \").concat(p3.y, \" \\n                L \").concat(p4.x, \" \").concat(p4.y, \" Z\\\"\\n                fill=\\\"white\\\"\\n            />\");\n        paths.push(path);\n      }\n      return paths.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(BasicAsteriskShape, \"parameters\", {\n  arms: {\n    min: 4,\n    max: 12,\n    \"default\": 8\n  },\n  armLength: {\n    min: 40,\n    max: 100,\n    \"default\": 100\n  },\n  armWidth: {\n    min: 5,\n    max: 25,\n    \"default\": 25\n  },\n  innerRadius: {\n    min: 10,\n    max: 50,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BasicAsteriskShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/BasicAsteriskShape.js?");

/***/ }),

/***/ "./src/shapes/BasicSpiral.js":
/*!***********************************!*\
  !*** ./src/shapes/BasicSpiral.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a simple spiral path with adjustable revolutions, spacing, and\n * thickness.\n */\nvar BasicSpiral = /*#__PURE__*/function (_Shape) {\n  function BasicSpiral() {\n    _classCallCheck(this, BasicSpiral);\n    return _callSuper(this, BasicSpiral, arguments);\n  }\n  _inherits(BasicSpiral, _Shape);\n  return _createClass(BasicSpiral, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Calculate points along the spiral\n      var points = [];\n      var steps = Math.floor(this.revolutions * 50); // 50 points per revolution for smoothness\n\n      for (var i = 0; i <= steps; i++) {\n        var t = i / steps * (this.revolutions * 2 * Math.PI);\n        var radius = t / (2 * Math.PI) * this.spacing;\n        var x = radius * Math.cos(t);\n        var y = radius * Math.sin(t);\n        points.push([x, y]);\n      }\n\n      // Generate SVG path\n      var pathData = points.reduce(function (path, _ref, i) {\n        var _ref2 = _slicedToArray(_ref, 2),\n          x = _ref2[0],\n          y = _ref2[1];\n        return path + (i === 0 ? \"M \".concat(x, \" \").concat(y) : \" L \".concat(x, \" \").concat(y));\n      }, '');\n      return \"<path \\n            d=\\\"\".concat(pathData, \"\\\"\\n            fill=\\\"none\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            stroke-linecap=\\\"\").concat(this.lineCap, \"\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(BasicSpiral, \"parameters\", {\n  revolutions: {\n    min: 1,\n    max: 5,\n    \"default\": 4\n  },\n  spacing: {\n    min: 10,\n    max: 50,\n    \"default\": 20\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 5\n  },\n  lineCap: {\n    options: ['butt', 'round'],\n    \"default\": 'round'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BasicSpiral);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/BasicSpiral.js?");

/***/ }),

/***/ "./src/shapes/BentBeam.js":
/*!********************************!*\
  !*** ./src/shapes/BentBeam.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates an SVG shape resembling a bent beam or block, creating a 3D effect\n * with three visible faces.\n */\nvar BentBeam = /*#__PURE__*/function (_Shape) {\n  function BentBeam() {\n    _classCallCheck(this, BentBeam);\n    return _callSuper(this, BentBeam, arguments);\n  }\n  _inherits(BentBeam, _Shape);\n  return _createClass(BentBeam, [{\n    key: \"formatPoints\",\n    value: function formatPoints(points) {\n      return points.map(function (p) {\n        return \"\".concat(p.x.toFixed(2), \",\").concat(p.y.toFixed(2));\n      }).join(' ');\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Access parameters from the instance\n      var w = this.beamWidth;\n      var l = this.beamLength; // Represents the length of the connecting edge\n      var angle_rad = this.slantAngle * Math.PI / 180;\n      var depthAngle_rad = this.depthAngle * Math.PI / 180;\n      var depth = this.depthFactor * w;\n\n      // Calculate the separation vector components between the centers of the top/bottom faces\n      var separationX = l * Math.cos(angle_rad);\n      var separationY = l * Math.sin(angle_rad);\n\n      // Calculate perspective offset vector (how \"deep\" the shape appears)\n      var dx = depth * Math.cos(depthAngle_rad);\n      var dy = depth * Math.sin(depthAngle_rad);\n\n      // Calculate the centers of the top and bottom faces relative to origin (0,0)\n      // Position the midpoint between the faces at (0,0) for overall centering\n      var topCenterX = -separationX / 2;\n      var topCenterY = -separationY / 2;\n      var bottomCenterX = separationX / 2;\n      var bottomCenterY = separationY / 2;\n\n      // --- Calculate Key Visible Vertices ---\n\n      // Top face vertices (relative to topCenter) - only need front edge T1-T2 for side face\n      var T1 = {\n        x: topCenterX - w / 2,\n        y: topCenterY + w / 2\n      }; // Top-left of top face\n      var T2 = {\n        x: topCenterX + w / 2,\n        y: topCenterY + w / 2\n      }; // Top-right of top face\n\n      // Bottom face vertices (relative to bottomCenter) - need all four for front face + T1-T2 for side face\n      var B1 = {\n        x: bottomCenterX - w / 2,\n        y: bottomCenterY + w / 2\n      }; // Top-left of front face\n      var B2 = {\n        x: bottomCenterX + w / 2,\n        y: bottomCenterY + w / 2\n      }; // Top-right of front face\n      var B3 = {\n        x: bottomCenterX + w / 2,\n        y: bottomCenterY - w / 2\n      }; // Bottom-right of front face\n      var B4 = {\n        x: bottomCenterX - w / 2,\n        y: bottomCenterY - w / 2\n      }; // Bottom-left of front face\n\n      // Perspective (\"depth\") offset vertices needed for the top face's back edge\n      var T1_p = {\n        x: T1.x + dx,\n        y: T1.y + dy\n      }; // Back-left of top face\n      var T2_p = {\n        x: T2.x + dx,\n        y: T2.y + dy\n      }; // Back-right of top face\n\n      // --- Define the Three Visible Polygons based on the calculated vertices ---\n\n      // Polygon 1: Top face (appears further back)\n      var topFacePoints = [T1, T2, T2_p, T1_p];\n\n      // Polygon 2: Front face (appears closer)\n      var frontFacePoints = [B1, B2, B3, B4];\n\n      // Polygon 3: Connecting side face (slanted)\n      // Connects the front edge of the top face (T1, T2) to the top edge of the front face (B1, B2)\n      var sideFacePoints = [T1, T2, B2, B1];\n\n      // --- Generate SVG String ---\n      // Using fill=\"white\" and no stroke for a solid appearance as in the reference image.\n      var svgElements = \"\\n            <polygon points=\\\"\".concat(this.formatPoints(topFacePoints), \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\\n            <polygon points=\\\"\").concat(this.formatPoints(frontFacePoints), \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\\n            <polygon points=\\\"\").concat(this.formatPoints(sideFacePoints), \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\\n        \");\n      return svgElements.trim(); // Return the combined SVG string\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(BentBeam, \"parameters\", {\n  beamWidth: {\n    type: 'number',\n    min: 10,\n    max: 100,\n    // Max width within the 200x200 viewbox\n    step: 1,\n    \"default\": 60,\n    label: 'Beam Width'\n  },\n  beamLength: {\n    type: 'number',\n    min: 10,\n    // Minimum length for the connecting part\n    max: 150,\n    // Maximum length to avoid going too far out\n    step: 1,\n    \"default\": 80,\n    label: 'Beam Length'\n  },\n  slantAngle: {\n    type: 'number',\n    min: 1,\n    // Avoid pure horizontal/vertical connections which might flatten the 3D effect\n    max: 89,\n    step: 1,\n    \"default\": 45,\n    // Angle similar to the example image\n    label: 'Slant Angle ()'\n  },\n  depthFactor: {\n    type: 'number',\n    min: 0,\n    // 0 depth makes it a 2D Z-shape\n    max: 1.5,\n    // Allows for exaggerated depth\n    step: 0.05,\n    \"default\": 1.0,\n    label: 'Depth Factor'\n  },\n  depthAngle: {\n    type: 'number',\n    min: 0,\n    max: 360,\n    step: 1,\n    \"default\": 135,\n    // Standard isometric-like projection angle\n    label: 'Depth Angle ()'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BentBeam);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/BentBeam.js?");

/***/ }),

/***/ "./src/shapes/BioPlate.js":
/*!********************************!*\
  !*** ./src/shapes/BioPlate.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a symmetric, organic plate shape with lobes and various cutouts.\n */\nvar BioPlate = /*#__PURE__*/function (_Shape) {\n  function BioPlate() {\n    _classCallCheck(this, BioPlate);\n    return _callSuper(this, BioPlate, arguments);\n  }\n  _inherits(BioPlate, _Shape);\n  return _createClass(BioPlate, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var size = this.size;\n      var numLobes = 8; // Fixed number of lobes for this specific design\n      var centerRadius = size * this.centerSolidRatio;\n      var centerHoleRadius = centerRadius * this.centerHoleRatio;\n      var angleStep = 2 * Math.PI / numLobes;\n\n      // --- Calculate Outer Path ---\n      var points = [];\n      var maxR = size;\n      var minR = size * (1 - this.lobeDepth);\n      for (var i = 0; i < numLobes; i++) {\n        var angle = i * angleStep;\n        // Modulate radius to create lobes (4 peaks, 4 valleys)\n        var r = (maxR + minR) / 2 + Math.cos(angle * (numLobes / 2)) * (maxR - minR) / 2;\n        var x = r * Math.cos(angle);\n        var y = r * Math.sin(angle);\n        points.push({\n          x: x,\n          y: y\n        }); // Store calculated points\n      }\n\n      // Generate smooth outer path using Catmull-Rom based Bezier curves\n      var outerPathData = this._pointsToCurvedPath(points, this.tension);\n\n      // --- Calculate Inner Cutout Paths (Counter-Clockwise for holes) ---\n      var cutoutPathData = '';\n\n      // 1. Center Hole\n      if (centerRadius > 0.1 && centerHoleRadius > 0.1) {\n        cutoutPathData += this._createCirclePath(0, 0, centerHoleRadius, true); // true for counter-clockwise\n      }\n\n      // 2. Large Elliptical Cutouts (Diagonal)\n      // Place roughly midway between center and the 'valleys' of the outer shape\n      var largeCutoutDist = (centerRadius + minR) / 2;\n      var largeCutoutMajorR = size * this.largeCutoutScale * 0.5; // Use overall size as base reference\n      var largeCutoutMinorR = largeCutoutMajorR * this.largeCutoutAspect;\n      if (largeCutoutMajorR > 0.1 && largeCutoutMinorR > 0.1) {\n        for (var _i = 0; _i < 4; _i++) {\n          var _angle = Math.PI / 4 + _i * Math.PI / 2; // 45, 135, 225, 315 degrees\n          var cx = largeCutoutDist * Math.cos(_angle);\n          var cy = largeCutoutDist * Math.sin(_angle);\n          // Rotation aligns the major axis radially\n          cutoutPathData += this._createEllipsePath(cx, cy, largeCutoutMajorR, largeCutoutMinorR, _angle * 180 / Math.PI, true);\n        }\n      }\n\n      // 3. Small Elliptical/Capsule Cutouts (Axial)\n      // Place roughly midway between center and the 'peaks' of the outer shape\n      var smallCutoutDist = (centerRadius + maxR) / 2;\n      var smallCutoutMajorR = size * this.smallCutoutScale * 0.5; // Use overall size as base reference\n      var smallCutoutMinorR = smallCutoutMajorR * this.smallCutoutAspect;\n      if (smallCutoutMajorR > 0.1 && smallCutoutMinorR > 0.1) {\n        for (var _i2 = 0; _i2 < 4; _i2++) {\n          var _angle2 = _i2 * Math.PI / 2; // 0, 90, 180, 270 degrees\n          var _cx = smallCutoutDist * Math.cos(_angle2);\n          var _cy = smallCutoutDist * Math.sin(_angle2);\n          // Rotation aligns the major axis radially\n          cutoutPathData += this._createEllipsePath(_cx, _cy, smallCutoutMajorR, smallCutoutMinorR, _angle2 * 180 / Math.PI, true);\n        }\n      }\n\n      // --- Combine Paths ---\n      // The outer path is drawn clockwise by _pointsToCurvedPath implicitly.\n      // The cutout paths are drawn counter-clockwise explicitly.\n      // fill-rule=\"evenodd\" will make the counter-clockwise paths appear as holes.\n      var finalPathData = outerPathData + cutoutPathData;\n\n      // Use fill-rule=\"evenodd\" to handle the holes\n      return \"<path d=\\\"\".concat(finalPathData, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" fill-rule=\\\"evenodd\\\" />\");\n    }\n\n    // Helper function to create a circle path segment (counter-clockwise for holes)\n  }, {\n    key: \"_createCirclePath\",\n    value: function _createCirclePath(cx, cy, r) {\n      var counterClockwise = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      if (r <= 0) return '';\n      var sweepFlag = counterClockwise ? '0' : '1';\n      // Use two 180-degree arcs for robustness\n      var x1 = (cx + r).toFixed(2);\n      var y1 = cy.toFixed(2);\n      var x2 = (cx - r).toFixed(2);\n      var y2 = cy.toFixed(2);\n      var rStr = r.toFixed(2);\n      return \" M \".concat(x1, \",\").concat(y1) // Move to start (right side)\n      + \" A \".concat(rStr, \",\").concat(rStr, \" 0 0 \").concat(sweepFlag, \" \").concat(x2, \",\").concat(y2) // Arc to left side\n      + \" A \".concat(rStr, \",\").concat(rStr, \" 0 0 \").concat(sweepFlag, \" \").concat(x1, \",\").concat(y1) // Arc back to right side\n      + \" Z\";\n    }\n\n    // Helper function to create an ellipse path segment using two arcs (counter-clockwise for holes)\n  }, {\n    key: \"_createEllipsePath\",\n    value: function _createEllipsePath(cx, cy, rx, ry, rotationDegrees) {\n      var counterClockwise = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n      if (rx <= 0 || ry <= 0) return '';\n      var sweepFlag = counterClockwise ? '0' : '1';\n      var angleRad = rotationDegrees * Math.PI / 180;\n      var cosA = Math.cos(angleRad);\n      var sinA = Math.sin(angleRad);\n\n      // Calculate ellipse points 180 degrees apart, considering rotation\n      // Point 1 (local angle 0)\n      var x1 = cx + rx * cosA;\n      var y1 = cy + rx * sinA;\n      // Point 2 (local angle PI)\n      var x2 = cx - rx * cosA;\n      var y2 = cy - rx * sinA;\n      var rxStr = rx.toFixed(2);\n      var ryStr = ry.toFixed(2);\n      var rotStr = rotationDegrees.toFixed(2);\n      var x1Str = x1.toFixed(2);\n      var y1Str = y1.toFixed(2);\n      var x2Str = x2.toFixed(2);\n      var y2Str = y2.toFixed(2);\n\n      // Use two 180-degree elliptical arcs\n      return \" M \".concat(x1Str, \",\").concat(y1Str) // Move to start point\n      + \" A \".concat(rxStr, \",\").concat(ryStr, \" \").concat(rotStr, \" 0 \").concat(sweepFlag, \" \").concat(x2Str, \",\").concat(y2Str) // First arc to opposite point\n      + \" A \".concat(rxStr, \",\").concat(ryStr, \" \").concat(rotStr, \" 0 \").concat(sweepFlag, \" \").concat(x1Str, \",\").concat(y1Str) // Second arc back to start\n      + \" Z\";\n    }\n\n    /**\n     * Creates a smooth, closed path from points using Bezier curves based on Catmull-Rom tangents.\n     * @param {Array<object>} points - Array of points {x, y}.\n     * @param {number} tension - Controls the tightness of the curve (0=straight lines, 1=high tension). Default 0.5.\n     * @returns {string} SVG path data string.\n     */\n  }, {\n    key: \"_pointsToCurvedPath\",\n    value: function _pointsToCurvedPath(points) {\n      var tension = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;\n      if (!points || points.length < 3) return '';\n      var n = points.length;\n      var path = \"M \".concat(points[0].x.toFixed(2), \",\").concat(points[0].y.toFixed(2));\n      for (var i = 0; i < n; i++) {\n        var p0 = points[(i - 1 + n) % n]; // Previous\n        var p1 = points[i]; // Current\n        var p2 = points[(i + 1) % n]; // Next\n        var p3 = points[(i + 2) % n]; // Next next\n\n        // Calculate tangent vectors using central differences (p2 - p0 and p3 - p1)\n        // The tension factor scales the length of the control point vector\n        var t1x = (p2.x - p0.x) * tension;\n        var t1y = (p2.y - p0.y) * tension;\n        var t2x = (p3.x - p1.x) * tension;\n        var t2y = (p3.y - p1.y) * tension;\n\n        // Calculate control points for the cubic Bezier segment from p1 to p2\n        // Control point 1 is p1 + tangent1 / 3\n        // Control point 2 is p2 - tangent2 / 3\n        var cp1x = p1.x + t1x / 3;\n        var cp1y = p1.y + t1y / 3;\n        var cp2x = p2.x - t2x / 3;\n        var cp2y = p2.y - t2y / 3;\n\n        // Add the cubic Bezier segment to the path\n        path += \" C \".concat(cp1x.toFixed(2), \",\").concat(cp1y.toFixed(2), \" \").concat(cp2x.toFixed(2), \",\").concat(cp2y.toFixed(2), \" \").concat(p2.x.toFixed(2), \",\").concat(p2.y.toFixed(2));\n      }\n      path += ' Z'; // Close the path\n      return path;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(BioPlate, \"parameters\", {\n  size: {\n    type: 'number',\n    min: 50,\n    max: 100,\n    \"default\": 90,\n    step: 1,\n    label: 'Overall Size'\n  },\n  lobeDepth: {\n    type: 'number',\n    min: 0.1,\n    max: 0.8,\n    \"default\": 0.4,\n    step: 0.05,\n    label: 'Lobe Depth'\n  },\n  // How much the shape dips between lobes (0=circle, 1=deep)\n  centerSolidRatio: {\n    type: 'number',\n    min: 0.05,\n    max: 0.5,\n    \"default\": 0.2,\n    step: 0.01,\n    label: 'Center Solid Size'\n  },\n  // Radius ratio of the central solid part\n  centerHoleRatio: {\n    type: 'number',\n    min: 0.1,\n    max: 0.9,\n    \"default\": 0.4,\n    step: 0.05,\n    label: 'Center Hole Size'\n  },\n  // Radius ratio of hole within center solid\n  largeCutoutScale: {\n    type: 'number',\n    min: 0.1,\n    max: 0.7,\n    \"default\": 0.5,\n    step: 0.05,\n    label: 'Large Cutout Size'\n  },\n  // Scale of the large diagonal cutouts\n  largeCutoutAspect: {\n    type: 'number',\n    min: 0.2,\n    max: 2.0,\n    \"default\": 0.5,\n    step: 0.05,\n    label: 'Large Cutout Aspect'\n  },\n  // Width/Height ratio\n  smallCutoutScale: {\n    type: 'number',\n    min: 0.05,\n    max: 0.5,\n    \"default\": 0.3,\n    step: 0.05,\n    label: 'Small Cutout Size'\n  },\n  // Scale of the small axial cutouts\n  smallCutoutAspect: {\n    type: 'number',\n    min: 0.2,\n    max: 2.0,\n    \"default\": 0.4,\n    step: 0.05,\n    label: 'Small Cutout Aspect'\n  },\n  // Width/Height ratio\n  tension: {\n    type: 'number',\n    min: 0,\n    max: 1.5,\n    \"default\": 0.5,\n    step: 0.05,\n    label: 'Outer Smoothness'\n  } // Controls rounding of the outer shape (Catmull-Rom tension)\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BioPlate);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/BioPlate.js?");

/***/ }),

/***/ "./src/shapes/BlobShape.js":
/*!*********************************!*\
  !*** ./src/shapes/BlobShape.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a dynamic, irregular blob shape using procedural point generation\n * and quadratic curves.\n */\nvar BlobShape = /*#__PURE__*/function (_Shape) {\n  function BlobShape() {\n    _classCallCheck(this, BlobShape);\n    return _callSuper(this, BlobShape, arguments);\n  }\n  _inherits(BlobShape, _Shape);\n  return _createClass(BlobShape, [{\n    key: \"toRad\",\n    value: function toRad(deg) {\n      return deg * (Math.PI / 180.0);\n    }\n  }, {\n    key: \"divide\",\n    value: function divide(count) {\n      var deg = 360.0 / count;\n      return Array.from({\n        length: count\n      }, function (_, i) {\n        return i * deg;\n      });\n    }\n  }, {\n    key: \"randomDouble\",\n    value: function randomDouble(seed) {\n      var mask = 0xffffffff;\n      var m_w = 123456789 + seed & mask;\n      var m_z = 987654321 - seed & mask;\n      return function () {\n        m_z = 36969 * (m_z & 65535) + (m_z >> 16) & mask;\n        m_w = 18000 * (m_w & 65535) + (m_w >> 16) & mask;\n        var result = (m_z << 16) + (m_w & 65535) >> 0;\n        return result / 0xffffffff;\n      };\n    }\n  }, {\n    key: \"magicPoint\",\n    value: function magicPoint(value, min, max) {\n      // Base radius calculation\n      var radius = min + value * (max - min);\n      if (this.amplitude > 0) {\n        // Calculate wave effects\n        var range = max - min;\n        var safeAmplitude = Math.min(this.amplitude, 4.5); // Cap amplitude to prevent extreme values\n\n        var primaryWave = Math.sin(this.currentAngle * this.frequency) * safeAmplitude * range * 0.4;\n        var secondaryWave = Math.sin(this.currentAngle * this.frequency * 2.7) * safeAmplitude * range * 0.15;\n        var tertiaryWave = Math.sin(this.currentAngle * this.frequency * 0.5) * safeAmplitude * range * 0.1;\n\n        // Add waves to radius with safety factor\n        radius += primaryWave + secondaryWave + tertiaryWave;\n      }\n\n      // Proper bounds handling - ensure radius stays within valid range\n      if (radius > max) {\n        radius = max; // Simply cap at maximum\n      } else if (radius < min) {\n        radius = min; // Simply cap at minimum\n      }\n      return radius;\n    }\n  }, {\n    key: \"point\",\n    value: function point(centerX, centerY, radius, degree) {\n      var skewRad = this.toRad(this.skew);\n      var angle = this.toRad(degree) + skewRad;\n      var x = centerX + radius * Math.cos(angle);\n      var y = centerY + radius * Math.sin(angle);\n      return {\n        x: x,\n        y: y\n      };\n    }\n  }, {\n    key: \"createPoints\",\n    value: function createPoints(size, minGrowth, edgesCount, seed) {\n      var _this = this;\n      var outerRad = size / 2;\n      var innerRad = minGrowth * (outerRad / 10);\n      var centerX = 0;\n      var centerY = 0;\n      var slices = this.divide(edgesCount);\n      var randVal = this.randomDouble(seed);\n      return slices.map(function (degree) {\n        _this.currentAngle = _this.toRad(degree);\n        var radius = _this.magicPoint(randVal(), innerRad, outerRad);\n        return _this.point(centerX, centerY, radius, degree);\n      });\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var baseSize = 250;\n      var points = this.createPoints(baseSize, this.growth, this.edges, this.seed);\n      if (points.length < 3) {\n        // Ensure we have enough points for a valid shape\n        return '<circle cx=\"0\" cy=\"0\" r=\"100\" fill=\"white\" />';\n      }\n      try {\n        // Generate path with proper error handling\n        var pathCommands = [];\n\n        // Calculate first midpoint safely\n        var start = {\n          x: (points[0].x + points[1].x) / 2,\n          y: (points[0].y + points[1].y) / 2\n        };\n        pathCommands.push(\"M\".concat(start.x.toFixed(2), \",\").concat(start.y.toFixed(2)));\n        for (var i = 0; i < points.length; i++) {\n          var p1 = points[(i + 1) % points.length];\n          var p2 = points[(i + 2) % points.length];\n\n          // Ensure all points are valid\n          if (isNaN(p1.x) || isNaN(p1.y) || isNaN(p2.x) || isNaN(p2.y)) {\n            continue;\n          }\n          var mid = {\n            x: (p1.x + p2.x) / 2,\n            y: (p1.y + p2.y) / 2\n          };\n\n          // Use toFixed to prevent very long decimal numbers\n          pathCommands.push(\"Q\".concat(p1.x.toFixed(2), \",\").concat(p1.y.toFixed(2), \",\").concat(mid.x.toFixed(2), \",\").concat(mid.y.toFixed(2)));\n        }\n        pathCommands.push('Z');\n        return \"<path \\n                d=\\\"\".concat(pathCommands.join(''), \"\\\"\\n                fill=\\\"white\\\"\\n            />\");\n      } catch (error) {\n        // Fallback to a circle if path generation fails\n        return '<circle cx=\"0\" cy=\"0\" r=\"100\" fill=\"white\" />';\n      }\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(BlobShape, \"parameters\", {\n  edges: {\n    min: 4,\n    max: 16,\n    \"default\": 10\n  },\n  growth: {\n    min: 3,\n    max: 6,\n    \"default\": 4\n  },\n  skew: {\n    min: -90,\n    max: 90,\n    \"default\": 0\n  },\n  amplitude: {\n    min: 0,\n    max: 5,\n    \"default\": 3\n  },\n  frequency: {\n    min: 0.5,\n    max: 4,\n    \"default\": 5.1\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BlobShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/BlobShape.js?");

/***/ }),

/***/ "./src/shapes/BlockFigure.js":
/*!***********************************!*\
  !*** ./src/shapes/BlockFigure.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a symmetric structure with a central square block and four\n * radiating rectangular arms.\n */\nvar BlockFigure = /*#__PURE__*/function (_Shape) {\n  function BlockFigure() {\n    _classCallCheck(this, BlockFigure);\n    return _callSuper(this, BlockFigure, arguments);\n  }\n  _inherits(BlockFigure, _Shape);\n  return _createClass(BlockFigure, [{\n    key: \"generateShape\",\n    value:\n    /**\n     * Generates the SVG elements for the BlockFigure shape.\n     * Accesses parameters via `this.parameterName`.\n     * @returns {string} SVG string containing multiple <rect> elements within a <g>.\n     */\n    function generateShape() {\n      // --- Parameter Access ---\n      var coreSize = this.coreSize;\n      var armWidth = this.armWidth;\n      var armLength = this.armLength;\n      var gap = this.gap;\n      var rotation = this.rotation;\n      var halfCore = coreSize / 2;\n      var halfArmWidth = armWidth / 2;\n\n      // --- Calculate Rectangle Coordinates ---\n      // Coordinates are relative to the center (0,0) before rotation.\n\n      // Central Core\n      var coreRect = \"<rect x=\\\"\".concat(-halfCore, \"\\\" y=\\\"\").concat(-halfCore, \"\\\" width=\\\"\").concat(coreSize, \"\\\" height=\\\"\").concat(coreSize, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\");\n\n      // Top Arm\n      var topArmY = -halfCore - gap - armLength;\n      var topArmRect = \"<rect x=\\\"\".concat(-halfArmWidth, \"\\\" y=\\\"\").concat(topArmY, \"\\\" width=\\\"\").concat(armWidth, \"\\\" height=\\\"\").concat(armLength, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\");\n\n      // Bottom Arm\n      var bottomArmY = halfCore + gap;\n      var bottomArmRect = \"<rect x=\\\"\".concat(-halfArmWidth, \"\\\" y=\\\"\").concat(bottomArmY, \"\\\" width=\\\"\").concat(armWidth, \"\\\" height=\\\"\").concat(armLength, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\");\n\n      // Left Arm\n      var leftArmX = -halfCore - gap - armLength;\n      var leftArmRect = \"<rect x=\\\"\".concat(leftArmX, \"\\\" y=\\\"\").concat(-halfArmWidth, \"\\\" width=\\\"\").concat(armLength, \"\\\" height=\\\"\").concat(armWidth, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\");\n\n      // Right Arm\n      var rightArmX = halfCore + gap;\n      var rightArmRect = \"<rect x=\\\"\".concat(rightArmX, \"\\\" y=\\\"\").concat(-halfArmWidth, \"\\\" width=\\\"\").concat(armLength, \"\\\" height=\\\"\").concat(armWidth, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\");\n\n      // --- Final SVG Output ---\n      // Group the elements and apply the rotation transformation.\n      return \"\\n            <g transform=\\\"rotate(\".concat(rotation, \")\\\">\\n                \").concat(coreRect, \"\\n                \").concat(topArmRect, \"\\n                \").concat(bottomArmRect, \"\\n                \").concat(leftArmRect, \"\\n                \").concat(rightArmRect, \"\\n            </g>\\n        \");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(BlockFigure, \"parameters\", {\n  coreSize: {\n    type: 'number',\n    min: 10,\n    max: 100,\n    step: 2,\n    \"default\": 40,\n    description: \"Size of the central square block\"\n  },\n  armWidth: {\n    type: 'number',\n    min: 5,\n    max: 80,\n    step: 1,\n    \"default\": 20,\n    description: \"Width of the radiating rectangular arms\"\n  },\n  armLength: {\n    type: 'number',\n    min: 10,\n    max: 100,\n    step: 2,\n    \"default\": 50,\n    description: \"Length of the radiating rectangular arms\"\n  },\n  gap: {\n    type: 'number',\n    min: 0,\n    max: 50,\n    step: 1,\n    \"default\": 8,\n    description: \"Gap between the central core and the arms\"\n  },\n  rotation: {\n    type: 'number',\n    min: 0,\n    max: 90,\n    step: 1,\n    \"default\": 0,\n    description: \"Overall rotation of the structure (degrees)\"\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BlockFigure);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/BlockFigure.js?");

/***/ }),

/***/ "./src/shapes/BlockTNotch.js":
/*!***********************************!*\
  !*** ./src/shapes/BlockTNotch.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Creates a T-shaped block with a customizable notch cut out of the stem.\n */\nvar BlockTNotch = /*#__PURE__*/function (_Shape) {\n  function BlockTNotch() {\n    _classCallCheck(this, BlockTNotch);\n    return _callSuper(this, BlockTNotch, arguments);\n  }\n  _inherits(BlockTNotch, _Shape);\n  return _createClass(BlockTNotch, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Access parameters using `this`\n      var barW = this.barWidth;\n      var barH = this.barHeight;\n      var stemW = this.stemWidth;\n      var stemH = this.stemHeight;\n      var notchW = this.notchWidth;\n      var notchH = this.notchHeight;\n      var notchY = this.notchOffsetY;\n\n      // --- Parameter Validation/Clamping ---\n      // Ensure stem is not wider than the bar\n      stemW = Math.min(stemW, barW);\n      // Ensure notch fits within the stem width (at least 1 unit gap)\n      notchW = Math.max(1, Math.min(notchW, stemW - 1));\n      // Ensure notch offset is within stem height (leaves at least 1 unit for notch height)\n      notchY = Math.max(0, Math.min(notchY, stemH - 1));\n      // Ensure notch height fits within the available space after offset (at least 1 unit high)\n      var maxNotchHeight = stemH - notchY - 1; // Calculate available height based on validated offset\n      notchH = Math.max(1, Math.min(notchH, maxNotchHeight));\n\n      // --- Coordinate Calculations (Centered at 0,0) ---\n      var totalHeight = barH + stemH;\n      // Calculate vertical positions relative to the center (0,0)\n      var yTop = totalHeight / 2; // Top edge of the bar\n      var yJunction = yTop - barH; // Junction between bar and stem ( = (stemH - barH) / 2 )\n      var yBottom = yTop - totalHeight; // Bottom edge of the stem ( = -(barH + stemH) / 2 )\n\n      var barW_half = barW / 2;\n      var stemW_half = stemW / 2;\n\n      // Notch vertical coordinates relative to the main coordinate system\n      // Notch starts `notchY` units below the `yJunction`\n      var yNotchTop = yJunction - notchY;\n      var yNotchBottom = yNotchTop - notchH;\n\n      // --- Path Construction ---\n      // Start from top-left corner and proceed clockwise\n      var pathData = [\"M \".concat(-barW_half, \", \").concat(yTop), // 1. Top-left bar corner\n      \"L \".concat(barW_half, \", \").concat(yTop), // 2. Top-right bar corner\n      \"L \".concat(barW_half, \", \").concat(yJunction), // 3. Bottom-right bar corner (outer)\n      \"L \".concat(stemW_half, \", \").concat(yJunction), // 4. Top-right stem corner\n      \"L \".concat(stemW_half, \", \").concat(yBottom), // 5. Bottom-right stem corner\n      \"L \".concat(-stemW_half, \", \").concat(yBottom), // 6. Bottom-left stem corner\n      \"L \".concat(-stemW_half, \", \").concat(yNotchBottom), // 7. Bottom-left notch corner (outer edge of stem)\n      \"L \".concat(-stemW_half + notchW, \", \").concat(yNotchBottom), // 8. Bottom-right notch corner (inner)\n      \"L \".concat(-stemW_half + notchW, \", \").concat(yNotchTop), // 9. Top-right notch corner (inner)\n      \"L \".concat(-stemW_half, \", \").concat(yNotchTop), // 10. Top-left notch corner (outer edge of stem)\n      \"L \".concat(-stemW_half, \", \").concat(yJunction), // 11. Top-left stem corner\n      \"L \".concat(-barW_half, \", \").concat(yJunction),\n      // 12. Bottom-left bar corner (outer)\n      'Z' // 13. Close path\n      ].join(' ');\n\n      // Return the SVG path element\n      return \"<path d=\\\"\".concat(pathData, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(BlockTNotch, \"parameters\", {\n  barWidth: {\n    type: 'number',\n    min: 20,\n    max: 195,\n    step: 5,\n    \"default\": 140,\n    label: 'Bar Width'\n  },\n  barHeight: {\n    type: 'number',\n    min: 10,\n    max: 90,\n    step: 1,\n    \"default\": 40,\n    label: 'Bar Height'\n  },\n  stemWidth: {\n    type: 'number',\n    min: 10,\n    max: 180,\n    step: 5,\n    \"default\": 70,\n    label: 'Stem Width'\n  },\n  stemHeight: {\n    type: 'number',\n    min: 10,\n    max: 150,\n    step: 1,\n    \"default\": 70,\n    label: 'Stem Height'\n  },\n  notchWidth: {\n    type: 'number',\n    min: 1,\n    max: 175,\n    step: 1,\n    \"default\": 35,\n    label: 'Notch Width'\n  },\n  notchHeight: {\n    type: 'number',\n    min: 1,\n    max: 140,\n    step: 1,\n    \"default\": 30,\n    label: 'Notch Height'\n  },\n  notchOffsetY: {\n    type: 'number',\n    min: 0,\n    max: 140,\n    step: 1,\n    \"default\": 10,\n    label: 'Notch Offset Y'\n  } // Offset from bar/stem junction\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BlockTNotch);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/BlockTNotch.js?");

/***/ }),

/***/ "./src/shapes/BookmarkShape.js":
/*!*************************************!*\
  !*** ./src/shapes/BookmarkShape.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a bookmark shape with a triangular cut at the bottom and optional\n * corner rounding.\n */\nvar BookmarkShape = /*#__PURE__*/function (_Shape) {\n  function BookmarkShape() {\n    _classCallCheck(this, BookmarkShape);\n    return _callSuper(this, BookmarkShape, arguments);\n  }\n  _inherits(BookmarkShape, _Shape);\n  return _createClass(BookmarkShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      this.width = this.width / 100;\n      this.height = this.height / 100;\n      this.cutDepth = this.cutDepth / 100;\n      this.cutStart = this.cutStart / 100;\n      this.rounding = this.rounding / 100;\n      var size = 100;\n      var halfSize = size / 2;\n      var halfHeight = halfSize * this.height;\n      var cutStartY = -halfHeight + this.height * size * this.cutStart;\n      var halfWidth = halfSize * this.width;\n\n      // Base points for the bookmark shape\n      var points = [{\n        x: -halfWidth,\n        y: -halfHeight\n      },\n      // Top left\n      {\n        x: halfWidth,\n        y: -halfHeight\n      },\n      // Top right\n      {\n        x: halfWidth,\n        y: halfHeight\n      },\n      // Bottom right\n      {\n        x: halfWidth,\n        y: cutStartY\n      },\n      // Right triangle start\n      {\n        x: 0,\n        y: halfHeight - this.height * size * this.cutDepth\n      },\n      // Triangle point\n      {\n        x: -halfWidth,\n        y: cutStartY\n      },\n      // Left triangle start\n      {\n        x: -halfWidth,\n        y: halfHeight\n      } // Bottom left\n      ];\n\n      // If no rounding, return straight path\n      if (this.rounding === 0) {\n        return \"<path d=\\\"\".concat(points.map(function (p, i) {\n          return (i === 0 ? 'M' : 'L') + \" \".concat(p.x, \" \").concat(p.y);\n        }).join(''), \" Z\\\" fill=\\\"white\\\" />\");\n      }\n\n      // Calculate maximum allowed corner radius\n      var minSegmentLength = Math.min(halfWidth * 2, Math.abs(points[0].y - points[6].y));\n      var maxRadius = minSegmentLength * 0.2; // Limit to 20% of smallest segment\n      var cornerRadius = maxRadius * this.rounding;\n\n      // Generate rounded corners path\n      var path = \"M \".concat(points[0].x, \" \").concat(points[0].y);\n      for (var i = 0; i < points.length; i++) {\n        var current = points[i];\n        var next = points[(i + 1) % points.length];\n        var prev = points[i === 0 ? points.length - 1 : i - 1];\n\n        // Skip rounding for triangle points\n        if (current.x === 0 || current.y === cutStartY && next.x === 0 || current.y === cutStartY && prev.x === 0) {\n          path += \" L \".concat(current.x, \" \").concat(current.y);\n          continue;\n        }\n\n        // Calculate vectors\n        var toPrev = {\n          x: prev.x - current.x,\n          y: prev.y - current.y\n        };\n        var toNext = {\n          x: next.x - current.x,\n          y: next.y - current.y\n        };\n\n        // Normalize vectors\n        var toPrevLength = Math.sqrt(toPrev.x * toPrev.x + toPrev.y * toPrev.y);\n        var toNextLength = Math.sqrt(toNext.x * toNext.x + toNext.y * toNext.y);\n        var normPrev = {\n          x: toPrev.x / toPrevLength,\n          y: toPrev.y / toPrevLength\n        };\n        var normNext = {\n          x: toNext.x / toNextLength,\n          y: toNext.y / toNextLength\n        };\n\n        // Calculate control points\n        var cp1 = {\n          x: current.x + normPrev.x * cornerRadius,\n          y: current.y + normPrev.y * cornerRadius\n        };\n        var cp2 = {\n          x: current.x + normNext.x * cornerRadius,\n          y: current.y + normNext.y * cornerRadius\n        };\n\n        // Add to path\n        path += \" L \".concat(cp1.x, \" \").concat(cp1.y);\n        path += \" Q \".concat(current.x, \" \").concat(current.y, \" \").concat(cp2.x, \" \").concat(cp2.y);\n      }\n      return \"<path d=\\\"\".concat(path, \" Z\\\" fill=\\\"white\\\" />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(BookmarkShape, \"parameters\", {\n  width: {\n    min: 25,\n    max: 100,\n    \"default\": 80\n  },\n  // Width of bookmark\n  height: {\n    min: 50,\n    max: 200,\n    \"default\": 150\n  },\n  // Height of bookmark\n  cutDepth: {\n    min: 20,\n    max: 70,\n    \"default\": 40\n  },\n  // How deep the triangle cuts in\n  cutStart: {\n    min: 50,\n    max: 100,\n    \"default\": 80\n  },\n  // Where triangle starts from top\n  rounding: {\n    min: 0,\n    max: 100,\n    \"default\": 50\n  } // Corner rounding amount\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BookmarkShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/BookmarkShape.js?");

/***/ }),

/***/ "./src/shapes/BowTieShape.js":
/*!***********************************!*\
  !*** ./src/shapes/BowTieShape.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Creates a shape resembling a stylized bow tie with a central circle and\n * curved outer elements.\n */\nvar BowTieShape = /*#__PURE__*/function (_Shape) {\n  function BowTieShape() {\n    _classCallCheck(this, BowTieShape);\n    return _callSuper(this, BowTieShape, arguments);\n  }\n  _inherits(BowTieShape, _Shape);\n  return _createClass(BowTieShape, [{\n    key: \"createCurvedElement\",\n    value: function createCurvedElement(rotation) {\n      // Create the curved shape with the given rotation\n      var startX = -this.centerSize / 2 - this.spacing;\n      var endX = -this.arcRadius;\n\n      // Calculate control points\n      var cp1x = -this.centerSize / 2 - this.arcRadius * this.curvature;\n      var cp1y = -this.arcRadius * this.curvature;\n      var cp2x = -this.arcRadius;\n      var cp2y = -this.arcRadius;\n\n      // Create paths for both upper and lower curves\n      var upperCurve = \"M \".concat(startX, \" 0 \\n                           C \").concat(cp1x, \" \").concat(cp1y, \", \").concat(cp2x, \" \").concat(cp2y, \", \").concat(endX, \" 0\");\n      var lowerCurve = \"M \".concat(startX, \" 0 \\n                           C \").concat(cp1x, \" \").concat(-cp1y, \", \").concat(cp2x, \" \").concat(-cp2y, \", \").concat(endX, \" 0\");\n\n      // Apply rotation transform\n      var rad = rotation * Math.PI / 180;\n      var cos = Math.cos(rad);\n      var sin = Math.sin(rad);\n      return \"<g transform=\\\"matrix(\".concat(cos, \" \").concat(sin, \" \").concat(-sin, \" \").concat(cos, \" 0 0)\\\">\\n                    <path d=\\\"\").concat(upperCurve, \" \").concat(lowerCurve, \"\\\"\\n                          fill=\\\"white\\\"/>\\n                </g>\");\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Create center circle\n      var centerCircle = \"<circle \\n            cx=\\\"0\\\" \\n            cy=\\\"0\\\" \\n            r=\\\"\".concat(this.centerSize / 2, \"\\\"\\n            fill=\\\"white\\\"\\n        />\");\n\n      // Create curved elements at 0 and 180 degrees\n      var leftElement = this.createCurvedElement(0);\n      var rightElement = this.createCurvedElement(180);\n\n      // Combine all elements\n      return \"<g>\\n            \".concat(centerCircle, \"\\n            \").concat(leftElement, \"\\n            \").concat(rightElement, \"\\n        </g>\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(BowTieShape, \"parameters\", {\n  arcRadius: {\n    min: 50,\n    max: 150,\n    \"default\": 80\n  },\n  centerSize: {\n    min: 10,\n    max: 100,\n    \"default\": 60\n  },\n  curvature: {\n    min: 0.1,\n    max: 1.0,\n    \"default\": 0.5\n  },\n  spacing: {\n    min: 0,\n    max: 50,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BowTieShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/BowTieShape.js?");

/***/ }),

/***/ "./src/shapes/BowtieSharp.js":
/*!***********************************!*\
  !*** ./src/shapes/BowtieSharp.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a sharp-cornered bowtie shape composed of two symmetrical, pointed\n * polygons meeting at the center.\n */\nvar BowtieSharp = /*#__PURE__*/function (_Shape) {\n  function BowtieSharp() {\n    _classCallCheck(this, BowtieSharp);\n    return _callSuper(this, BowtieSharp, arguments);\n  }\n  _inherits(BowtieSharp, _Shape);\n  return _createClass(BowtieSharp, [{\n    key: \"generateShape\",\n    value: function generateShape(params) {\n      var w = this.width / 2;\n      var h = this.height / 2;\n      var bh = Math.min(this.barHeight, h - 0.1);\n      var cw = Math.min(this.cutWidth, w - 0.1);\n      var topPoints = [[-w, h], [w, h], [w, h - bh], [cw, h - bh], [0, 0], [-cw, h - bh], [-w, h - bh]];\n      var bottomPoints = [[-w, -h], [w, -h], [w, -(h - bh)], [cw, -(h - bh)], [0, 0], [-cw, -(h - bh)], [-w, -(h - bh)]];\n      var formatPoints = function formatPoints(points) {\n        return points.map(function (p) {\n          return \"\".concat(p[0].toFixed(2), \",\").concat(p[1].toFixed(2));\n        }).join(' ');\n      };\n      var topPathData = \"M \".concat(formatPoints(topPoints), \" Z\");\n      var bottomPathData = \"M \".concat(formatPoints(bottomPoints), \" Z\");\n      return \"\\n            <path d=\\\"\".concat(topPathData, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\\n            <path d=\\\"\").concat(bottomPathData, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\\n        \");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(BowtieSharp, \"parameters\", {\n  width: {\n    type: 'number',\n    min: 20,\n    max: 190,\n    \"default\": 140,\n    step: 1\n  },\n  height: {\n    type: 'number',\n    min: 20,\n    max: 190,\n    \"default\": 100,\n    step: 1\n  },\n  barHeight: {\n    type: 'number',\n    min: 5,\n    max: 90,\n    \"default\": 25,\n    step: 1\n  },\n  cutWidth: {\n    type: 'number',\n    min: 1,\n    max: 90,\n    \"default\": 30,\n    step: 1\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BowtieSharp);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/BowtieSharp.js?");

/***/ }),

/***/ "./src/shapes/BrickWall.js":
/*!*********************************!*\
  !*** ./src/shapes/BrickWall.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a brick wall pattern with adjustable rows, columns, gaps, and\n * corner radius, using various layouts.\n */\nvar BrickWall = /*#__PURE__*/function (_Shape) {\n  function BrickWall() {\n    _classCallCheck(this, BrickWall);\n    return _callSuper(this, BrickWall, arguments);\n  }\n  _inherits(BrickWall, _Shape);\n  return _createClass(BrickWall, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Reset RNG before generating the shape\n      this.resetRNG();\n\n      // Create rectangular wall with specified rows/columns\n      var squareSize = 180;\n      var halfSize = squareSize / 2;\n\n      // Calculate row height\n      var rowHeight = squareSize / this.rows;\n\n      // Default pattern layouts - we'll select one based on parameters\n      var patterns = [\n      // Each row array contains [width1, width2, ...] values that sum to 1.0\n      [[0.33, 0.33, 0.34], [0.5, 0.5], [0.33, 0.33, 0.34], [0.5, 0.5], [0.33, 0.33, 0.34]], [[0.25, 0.25, 0.25, 0.25], [0.33, 0.34, 0.33], [0.25, 0.25, 0.25, 0.25], [0.33, 0.34, 0.33], [0.25, 0.25, 0.25, 0.25]], [[0.25, 0.5, 0.25], [0.4, 0.2, 0.4], [0.25, 0.5, 0.25], [0.33, 0.34, 0.33], [0.25, 0.5, 0.25]]];\n\n      // Select or create pattern based on parameters\n      var selectedPattern;\n      if (this.randomLayout) {\n        // Create a varied pattern that still maintains perfect grid\n        selectedPattern = [];\n        for (var r = 0; r < this.rows; r++) {\n          var rowPattern = void 0;\n          // Alternate between different division patterns\n          if (r % 2 === 0) {\n            // Create pattern with equal divisions\n            rowPattern = Array(this.columns).fill(1 / this.columns);\n          } else {\n            // Create pattern with varying brick sizes\n            // For odd rows, we'll use either 2 or 3 bricks of different sizes\n            if (this.columns <= 3 || this.random() > 0.5) {\n              // Use 2 differently sized bricks\n              var ratio = 0.6 + this.random() * 0.2; // Between 0.6-0.8\n              rowPattern = [ratio, 1 - ratio];\n            } else {\n              // Use 3 bricks with middle one possibly larger\n              var middleRatio = 0.4 + this.random() * 0.2; // 0.4-0.6\n              var sideRatio = (1 - middleRatio) / 2;\n              rowPattern = [sideRatio, middleRatio, sideRatio];\n            }\n          }\n          selectedPattern.push(rowPattern);\n        }\n      } else {\n        // Use one of the predefined patterns\n        var patternIndex = Math.min(Math.floor(this.random() * patterns.length), patterns.length - 1);\n        selectedPattern = patterns[patternIndex];\n\n        // If rows don't match pattern, repeat pattern rows\n        if (selectedPattern.length < this.rows) {\n          var basePattern = _toConsumableArray(selectedPattern);\n          for (var _r = selectedPattern.length; _r < this.rows; _r++) {\n            selectedPattern.push(basePattern[_r % basePattern.length]);\n          }\n        }\n      }\n\n      // Generate bricks using the pattern\n      var bricks = [];\n      for (var row = 0; row < this.rows; row++) {\n        // Get row pattern (or create fallback if missing)\n        var _rowPattern = selectedPattern[row] || Array(this.columns).fill(1 / this.columns);\n\n        // Calculate y position\n        var yPos = -halfSize + row * rowHeight;\n\n        // Starting x position\n        var xPos = -halfSize;\n\n        // Place bricks according to pattern\n        for (var i = 0; i < _rowPattern.length; i++) {\n          // Calculate width based on pattern proportion\n          var widthProportion = _rowPattern[i];\n          var brickWidth = squareSize * widthProportion;\n\n          // Create brick with calculated dimensions\n          var brick = \"<rect \\n                    x=\\\"\".concat(xPos + this.gapSize / 2, \"\\\" \\n                    y=\\\"\").concat(yPos + this.gapSize / 2, \"\\\" \\n                    width=\\\"\").concat(brickWidth - this.gapSize, \"\\\" \\n                    height=\\\"\").concat(rowHeight - this.gapSize, \"\\\"\\n                    rx=\\\"\").concat(this.cornerRadius, \"\\\"\\n                    ry=\\\"\").concat(this.cornerRadius, \"\\\"\\n                    fill=\\\"white\\\"\\n                    stroke=\\\"none\\\"\\n                />\");\n          bricks.push(brick);\n\n          // Move x position\n          xPos += brickWidth;\n        }\n      }\n      return bricks.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(BrickWall, \"parameters\", {\n  rows: {\n    min: 1,\n    max: 12,\n    \"default\": 4\n  },\n  columns: {\n    min: 1,\n    max: 12,\n    \"default\": 3\n  },\n  gapSize: {\n    min: 1,\n    max: 10,\n    \"default\": 6\n  },\n  cornerRadius: {\n    min: 0,\n    max: 10,\n    \"default\": 5\n  },\n  randomLayout: {\n    options: ['true', 'false'],\n    \"default\": 'true'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BrickWall);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/BrickWall.js?");

/***/ }),

/***/ "./src/shapes/ChaliceShape.js":
/*!************************************!*\
  !*** ./src/shapes/ChaliceShape.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a chalice or goblet shape with adjustable bowl, stem, and base\n * dimensions, plus curvature control.\n */\nvar ChaliceShape = /*#__PURE__*/function (_Shape) {\n  function ChaliceShape() {\n    _classCallCheck(this, ChaliceShape);\n    return _callSuper(this, ChaliceShape, arguments);\n  }\n  _inherits(ChaliceShape, _Shape);\n  return _createClass(ChaliceShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Scale to fit the -200 to 200 viewBox\n      var scale = 1;\n      var center = {\n        x: 0,\n        y: 0\n      };\n\n      // Apply scaling to parameters\n      var bowlWidth = this.bowlWidth * scale;\n      var bowlHeight = this.bowlHeight * scale;\n      var stemWidth = this.stemWidth * scale;\n      var baseWidth = this.baseWidth * scale;\n      var curvature = this.curvature;\n\n      // Calculate key points\n      var topY = center.y - bowlHeight / 2;\n      var bottomY = center.y + bowlHeight / 2;\n      var stemHeight = bowlHeight * 0.4;\n\n      // Bowl top points\n      var bowlLeftTop = {\n        x: center.x - bowlWidth / 2,\n        y: topY\n      };\n      var bowlRightTop = {\n        x: center.x + bowlWidth / 2,\n        y: topY\n      };\n\n      // Stem connection points\n      var stemLeftTop = {\n        x: center.x - stemWidth / 2,\n        y: bottomY - stemHeight\n      };\n      var stemRightTop = {\n        x: center.x + stemWidth / 2,\n        y: bottomY - stemHeight\n      };\n\n      // Base points\n      var baseLeftTop = {\n        x: center.x - baseWidth / 2,\n        y: bottomY\n      };\n      var baseRightTop = {\n        x: center.x + baseWidth / 2,\n        y: bottomY\n      };\n\n      // Control points for bowl curves\n      var controlPoint1 = {\n        x: bowlLeftTop.x,\n        y: topY + bowlHeight * curvature\n      };\n      var controlPoint2 = {\n        x: stemLeftTop.x,\n        y: stemLeftTop.y - bowlHeight * curvature\n      };\n      var controlPoint3 = {\n        x: stemRightTop.x,\n        y: stemRightTop.y - bowlHeight * curvature\n      };\n      var controlPoint4 = {\n        x: bowlRightTop.x,\n        y: topY + bowlHeight * curvature\n      };\n\n      // Generate SVG path\n      var pathCommands = [// Start at left top of bowl\n      \"M \".concat(bowlLeftTop.x, \" \").concat(bowlLeftTop.y), // Left bowl curve\n      \"C \".concat(controlPoint1.x, \" \").concat(controlPoint1.y, \" \").concat(controlPoint2.x, \" \").concat(controlPoint2.y, \" \").concat(stemLeftTop.x, \" \").concat(stemLeftTop.y), // Stem to base\n      \"L \".concat(baseLeftTop.x, \" \").concat(baseLeftTop.y), \"L \".concat(baseRightTop.x, \" \").concat(baseRightTop.y), \"L \".concat(stemRightTop.x, \" \").concat(stemRightTop.y), // Right bowl curve\n      \"C \".concat(controlPoint3.x, \" \").concat(controlPoint3.y, \" \").concat(controlPoint4.x, \" \").concat(controlPoint4.y, \" \").concat(bowlRightTop.x, \" \").concat(bowlRightTop.y),\n      // Close path\n      'Z'];\n      return \"<path \\n            d=\\\"\".concat(pathCommands.join(' '), \"\\\"\\n            fill=\\\"white\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(ChaliceShape, \"parameters\", {\n  bowlWidth: {\n    min: 50,\n    max: 200,\n    \"default\": 120\n  },\n  bowlHeight: {\n    min: 50,\n    max: 200,\n    \"default\": 100\n  },\n  stemWidth: {\n    min: 20,\n    max: 100,\n    \"default\": 40\n  },\n  baseWidth: {\n    min: 40,\n    max: 200,\n    \"default\": 80\n  },\n  curvature: {\n    min: 0,\n    max: 1,\n    \"default\": 0.5\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ChaliceShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/ChaliceShape.js?");

/***/ }),

/***/ "./src/shapes/ChamferedSquare.js":
/*!***************************************!*\
  !*** ./src/shapes/ChamferedSquare.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Creates a shape with a chamfered square outline and a square cutout in the\n * center, with rotation options.\n */\nvar ChamferedSquare = /*#__PURE__*/function (_Shape) {\n  function ChamferedSquare() {\n    _classCallCheck(this, ChamferedSquare);\n    return _callSuper(this, ChamferedSquare, arguments);\n  }\n  _inherits(ChamferedSquare, _Shape);\n  return _createClass(ChamferedSquare, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      var outerSize = this.outerSize;\n      var innerSize = this.innerSize;\n      // Ensure inner size is smaller than outer size\n      if (innerSize >= outerSize - 1) {\n        innerSize = outerSize - 1;\n      }\n\n      // Cap chamfer amount relative to the outer size to prevent inversion\n      var maxChamfer = outerSize;\n      var chamfer = Math.min(this.chamfer, maxChamfer);\n      if (chamfer < 0) chamfer = 0; // Ensure chamfer is not negative\n\n      // Outer Octagon vertices calculation\n      var o = outerSize;\n      var c = chamfer;\n      var outerPoints = [{\n        x: o,\n        y: o - c\n      }, {\n        x: o - c,\n        y: o\n      }, {\n        x: -o + c,\n        y: o\n      }, {\n        x: -o,\n        y: o - c\n      }, {\n        x: -o,\n        y: -o + c\n      }, {\n        x: -o + c,\n        y: -o\n      }, {\n        x: o - c,\n        y: -o\n      }, {\n        x: o,\n        y: -o + c\n      }];\n\n      // Inner Square vertices calculation\n      var i = innerSize;\n      var innerPoints = [{\n        x: i,\n        y: i\n      }, {\n        x: -i,\n        y: i\n      }, {\n        x: -i,\n        y: -i\n      }, {\n        x: i,\n        y: -i\n      }];\n\n      // Apply rotation\n      var totalRotationRad = this.rotation * Math.PI / 180;\n      var innerRotationRad = (this.rotation + this.innerRotationOffset) * Math.PI / 180;\n      outerPoints = outerPoints.map(function (p) {\n        return _this._rotatePoint(p.x, p.y, totalRotationRad);\n      });\n      innerPoints = innerPoints.map(function (p) {\n        return _this._rotatePoint(p.x, p.y, innerRotationRad);\n      });\n\n      // Construct path data using evenodd fill rule\n      var outerPathData = \"M\" + outerPoints.map(function (p) {\n        return \"\".concat(p.x.toFixed(3), \",\").concat(p.y.toFixed(3));\n      }).join(\" L\") + \" Z\";\n      // Inner path needs to be wound in the opposite direction (clockwise) for evenodd fill rule\n      var innerPathData = \"M\" + innerPoints.reverse().map(function (p) {\n        return \"\".concat(p.x.toFixed(3), \",\").concat(p.y.toFixed(3));\n      }).join(\" L\") + \" Z\";\n      var combinedPathData = \"\".concat(outerPathData, \" \").concat(innerPathData);\n      return \"<path d=\\\"\".concat(combinedPathData, \"\\\" fill=\\\"white\\\" fill-rule=\\\"evenodd\\\" stroke=\\\"none\\\" />\");\n    }\n  }, {\n    key: \"_rotatePoint\",\n    value: function _rotatePoint(x, y, rad) {\n      var cos = Math.cos(rad);\n      var sin = Math.sin(rad);\n      var newX = x * cos - y * sin;\n      var newY = x * sin + y * cos;\n      return {\n        x: newX,\n        y: newY\n      };\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(ChamferedSquare, \"parameters\", {\n  outerSize: {\n    type: 'number',\n    min: 10,\n    max: 100,\n    step: 1,\n    \"default\": 80,\n    label: 'Outer Size'\n  },\n  innerSize: {\n    type: 'number',\n    min: 5,\n    max: 95,\n    step: 1,\n    \"default\": 40,\n    label: 'Inner Size'\n  },\n  chamfer: {\n    type: 'number',\n    min: 0,\n    max: 50,\n    // Dynamically capped relative to outerSize later\n    step: 1,\n    \"default\": 20,\n    label: 'Chamfer Amount'\n  },\n  rotation: {\n    type: 'number',\n    min: 0,\n    max: 360,\n    step: 1,\n    \"default\": 0,\n    label: 'Rotation'\n  },\n  innerRotationOffset: {\n    type: 'number',\n    min: -180,\n    max: 180,\n    step: 1,\n    \"default\": 0,\n    label: 'Inner Rotation Offset'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ChamferedSquare);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/ChamferedSquare.js?");

/***/ }),

/***/ "./src/shapes/CheckerPattern.js":
/*!**************************************!*\
  !*** ./src/shapes/CheckerPattern.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a checkerboard pattern where squares can optionally scale\n * vertically down the grid.\n */\nvar CheckerPattern = /*#__PURE__*/function (_Shape) {\n  function CheckerPattern() {\n    _classCallCheck(this, CheckerPattern);\n    return _callSuper(this, CheckerPattern, arguments);\n  }\n  _inherits(CheckerPattern, _Shape);\n  return _createClass(CheckerPattern, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var squares = [];\n      var totalSize = this.count * this.size;\n      var offset = -totalSize / 2;\n\n      // Keep track of the previous row's position and height\n      var previousY = offset;\n      for (var row = 0; row < this.count; row++) {\n        // Calculate vertical scaling based on row position\n        var rowProgress = row / (this.count - 1);\n        var scale = 1 - rowProgress * this.scaleY / 100;\n        for (var col = 0; col < this.count; col++) {\n          if ((row + col) % 2 === 0) {\n            var x = offset + col * this.size;\n            // Instead of calculating y with spacing, use the tracked position\n            var height = this.size * scale;\n            squares.push(\"<rect \\n                        x=\\\"\".concat(x, \"\\\" \\n                        y=\\\"\").concat(previousY, \"\\\" \\n                        width=\\\"\").concat(this.size, \"\\\"\\n                        height=\\\"\").concat(height, \"\\\"\\n                        fill=\\\"white\\\"\\n                    />\"));\n          }\n        }\n        previousY += this.size * scale;\n      }\n      return squares.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(CheckerPattern, \"parameters\", {\n  size: {\n    min: 25,\n    max: 50,\n    \"default\": 40\n  },\n  count: {\n    min: 2,\n    max: 12,\n    \"default\": 4\n  },\n  scaleY: {\n    min: 0,\n    max: 100,\n    \"default\": 1\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CheckerPattern);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/CheckerPattern.js?");

/***/ }),

/***/ "./src/shapes/CircleComposition.js":
/*!*****************************************!*\
  !*** ./src/shapes/CircleComposition.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Creates a composition of overlapping rings and semi-rings based on a central\n * ring.\n */\nvar CircleComposition = /*#__PURE__*/function (_Shape) {\n  function CircleComposition() {\n    _classCallCheck(this, CircleComposition);\n    return _callSuper(this, CircleComposition, arguments);\n  }\n  _inherits(CircleComposition, _Shape);\n  return _createClass(CircleComposition, [{\n    key: \"calculateDynamicSizes\",\n    value: function calculateDynamicSizes(baseSize, balance, thickness) {\n      // Balance affects the relationship between center and side circles\n      var balanceFactor = balance / 100;\n      var thicknessFactor = thickness / 100;\n      var centerScale = 0.8 + balanceFactor * 0.4;\n      var sideScale = 1.0 - balanceFactor * 0.3;\n      var innerScale = 1.0 - thicknessFactor;\n      return {\n        center: baseSize * centerScale,\n        side: baseSize * sideScale,\n        inner: baseSize * centerScale * innerScale\n      };\n    }\n  }, {\n    key: \"createRing\",\n    value: function createRing(cx, cy, outerRadius, innerRadius) {\n      if (innerRadius <= 0) {\n        return \"<circle \\n                cx=\\\"\".concat(cx, \"\\\" \\n                cy=\\\"\").concat(cy, \"\\\" \\n                r=\\\"\").concat(outerRadius, \"\\\"\\n                fill=\\\"white\\\"\\n            />\");\n      }\n      return \"<path\\n            d=\\\"\\n                M \".concat(cx - outerRadius, \" \").concat(cy, \"\\n                A \").concat(outerRadius, \" \").concat(outerRadius, \" 0 1 1 \").concat(cx + outerRadius, \" \").concat(cy, \"\\n                A \").concat(outerRadius, \" \").concat(outerRadius, \" 0 1 1 \").concat(cx - outerRadius, \" \").concat(cy, \"\\n                M \").concat(cx - innerRadius, \" \").concat(cy, \"\\n                A \").concat(innerRadius, \" \").concat(innerRadius, \" 0 1 0 \").concat(cx + innerRadius, \" \").concat(cy, \"\\n                A \").concat(innerRadius, \" \").concat(innerRadius, \" 0 1 0 \").concat(cx - innerRadius, \" \").concat(cy, \"\\n            \\\"\\n            fill=\\\"white\\\"\\n        />\");\n    }\n  }, {\n    key: \"createSemiRing\",\n    value: function createSemiRing(cx, cy, outerRadius, innerRadius, startAngle, endAngle) {\n      var startX = cx + outerRadius * Math.cos(startAngle);\n      var startY = cy + outerRadius * Math.sin(startAngle);\n      var endX = cx + outerRadius * Math.cos(endAngle);\n      var endY = cy + outerRadius * Math.sin(endAngle);\n      var d = \"M \".concat(startX, \" \").concat(startY);\n\n      // Outer arc\n      var largeArcFlag = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;\n      d += \" A \".concat(outerRadius, \" \").concat(outerRadius, \" 0 \").concat(largeArcFlag, \" 1 \").concat(endX, \" \").concat(endY);\n      if (innerRadius > 0) {\n        // Inner arc\n        var innerStartX = cx + innerRadius * Math.cos(endAngle);\n        var innerStartY = cy + innerRadius * Math.sin(endAngle);\n        var innerEndX = cx + innerRadius * Math.cos(startAngle);\n        var innerEndY = cy + innerRadius * Math.sin(startAngle);\n        d += \" L \".concat(innerStartX, \" \").concat(innerStartY);\n        d += \" A \".concat(innerRadius, \" \").concat(innerRadius, \" 0 \").concat(largeArcFlag, \" 0 \").concat(innerEndX, \" \").concat(innerEndY);\n      } else {\n        // If no inner radius, connect to center\n        d += \" L \".concat(cx, \" \").concat(cy);\n      }\n      d += ' Z';\n      return \"<path d=\\\"\".concat(d, \"\\\" fill=\\\"white\\\"/>\");\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var scale = 1.5; // Scale factor if needed\n      var baseCenterSize = this.centerSize * scale;\n      var overlap = this.overlap * scale;\n\n      // Calculate dynamic sizes\n      var sizes = this.calculateDynamicSizes(baseCenterSize, this.balance, this.thickness);\n      var centerSize = sizes.center;\n      var innerSize = sizes.inner;\n      var effectiveSideRadius = sizes.side * this.sideRadius;\n      var effectiveSideInnerRadius = effectiveSideRadius * (1 - this.thickness / 100);\n\n      // Calculate spacing\n      var spacing = Math.max(-centerSize / 4, Math.min(centerSize / 2, overlap));\n\n      // Create center ring\n      var elements = [];\n      elements.push(this.createRing(0, 0, centerSize / 2, innerSize / 2));\n\n      // Add left semi-ring\n      var leftCenterX = -centerSize / 2 - spacing;\n      elements.push(this.createSemiRing(leftCenterX, 0, effectiveSideRadius, effectiveSideInnerRadius, Math.PI / 2, -Math.PI / 2));\n\n      // Add right semi-ring\n      var rightCenterX = centerSize / 2 + spacing;\n      elements.push(this.createSemiRing(rightCenterX, 0, effectiveSideRadius, effectiveSideInnerRadius, -Math.PI / 2, Math.PI / 2));\n      return elements.join('\\n');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(CircleComposition, \"parameters\", {\n  centerSize: {\n    min: 25,\n    max: 50,\n    \"default\": 40\n  },\n  sideRadius: {\n    min: 0.5,\n    max: 1.5,\n    \"default\": 1.0\n  },\n  overlap: {\n    min: -50,\n    max: 50,\n    \"default\": 0\n  },\n  thickness: {\n    min: 10,\n    max: 100,\n    \"default\": 50\n  },\n  balance: {\n    min: 0,\n    max: 100,\n    \"default\": 100\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CircleComposition);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/CircleComposition.js?");

/***/ }),

/***/ "./src/shapes/CirclePacking.js":
/*!*************************************!*\
  !*** ./src/shapes/CirclePacking.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a packing of circles of varying sizes within a larger circular\n * boundary using random placement attempts.\n */\nvar CirclePacking = /*#__PURE__*/function (_Shape) {\n  function CirclePacking() {\n    _classCallCheck(this, CirclePacking);\n    return _callSuper(this, CirclePacking, arguments);\n  }\n  _inherits(CirclePacking, _Shape);\n  return _createClass(CirclePacking, [{\n    key: \"canPlaceCircle\",\n    value:\n    // Try to place a new circle with the given radius\n    function canPlaceCircle(circles, x, y, radius) {\n      // Check if within container\n      var distanceFromCenter = Math.sqrt(x * x + y * y);\n      if (distanceFromCenter + radius > this.containerRadius) {\n        return false;\n      }\n\n      // Check if overlapping with any existing circle\n      var _iterator = _createForOfIteratorHelper(circles),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var circle = _step.value;\n          var dx = circle.x - x;\n          var dy = circle.y - y;\n          var distance = Math.sqrt(dx * dx + dy * dy);\n          if (distance < circle.radius + radius + this.spacing) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return true;\n    }\n\n    // Attempt to place a circle with given radius\n  }, {\n    key: \"tryPlaceCircle\",\n    value: function tryPlaceCircle(circles, radius) {\n      for (var i = 0; i < this.placementAttempts; i++) {\n        // Random angle and distance from center - using seeded randomness\n        var angle = this.random() * 2 * Math.PI;\n        var distance = this.random() * (this.containerRadius - radius);\n        var x = distance * Math.cos(angle);\n        var y = distance * Math.sin(angle);\n        if (this.canPlaceCircle(circles, x, y, radius)) {\n          return {\n            x: x,\n            y: y,\n            radius: radius\n          };\n        }\n      }\n      return null;\n    }\n\n    // Generate circle placements once, then reuse them with spacing adjustments\n  }, {\n    key: \"getCirclePlacements\",\n    value: function getCirclePlacements() {\n      // Reset RNG to initial seed to ensure consistency\n      this.resetRNG();\n      var circles = [];\n      var remainingAttempts = this.circleCount * 3; // Allow extra attempts\n\n      // Start with larger circles\n      while (circles.length < this.circleCount && remainingAttempts > 0) {\n        remainingAttempts--;\n\n        // Vary radius between min and max, favoring smaller circles as we add more\n        var progressFactor = circles.length / this.circleCount;\n        var bias = 0.3 + progressFactor * 0.7; // Starts at 0.3, approaches 1.0\n\n        // Generate radius with bias toward smaller sizes as we progress\n        var radius = this.maxRadius - (this.maxRadius - this.minRadius) * Math.pow(this.random(), 1 - bias);\n        var circle = this.tryPlaceCircle(circles, radius);\n        if (circle) {\n          circles.push(circle);\n        }\n      }\n      return circles;\n    }\n\n    // Check if circles are still valid with current spacing\n  }, {\n    key: \"validateCirclesWithSpacing\",\n    value: function validateCirclesWithSpacing(circles) {\n      // First check each circle against container\n      var _iterator2 = _createForOfIteratorHelper(circles),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var circle = _step2.value;\n          var distanceFromCenter = Math.sqrt(circle.x * circle.x + circle.y * circle.y);\n          if (distanceFromCenter + circle.radius > this.containerRadius) {\n            return false;\n          }\n        }\n\n        // Then check circles against each other\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      for (var i = 0; i < circles.length; i++) {\n        for (var j = i + 1; j < circles.length; j++) {\n          var c1 = circles[i];\n          var c2 = circles[j];\n          var dx = c1.x - c2.x;\n          var dy = c1.y - c2.y;\n          var distance = Math.sqrt(dx * dx + dy * dy);\n          if (distance < c1.radius + c2.radius + this.spacing) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Get or calculate circle placements\n      if (!this.circlePlacements) {\n        this.circlePlacements = this.getCirclePlacements();\n      }\n\n      // Make a deep copy of the placements\n      var circles = JSON.parse(JSON.stringify(this.circlePlacements));\n\n      // If circles are invalid with current spacing, regenerate them\n      if (!this.validateCirclesWithSpacing(circles)) {\n        this.circlePlacements = this.getCirclePlacements();\n        var newCircles = JSON.parse(JSON.stringify(this.circlePlacements));\n\n        // If still invalid, use a subset that works\n        if (!this.validateCirclesWithSpacing(newCircles)) {\n          // Sort by size and take only the circles that fit\n          newCircles.sort(function (a, b) {\n            return b.radius - a.radius;\n          });\n          var validCircles = [];\n          var _iterator3 = _createForOfIteratorHelper(newCircles),\n            _step3;\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var circle = _step3.value;\n              if (this.canPlaceCircle(validCircles, circle.x, circle.y, circle.radius)) {\n                validCircles.push(circle);\n              }\n              if (validCircles.length >= this.circleCount) break;\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n          return this.renderCircles(validCircles);\n        }\n        return this.renderCircles(newCircles);\n      }\n      return this.renderCircles(circles);\n    }\n  }, {\n    key: \"renderCircles\",\n    value: function renderCircles(circles) {\n      // Generate SVG elements\n      var svgElements = circles.map(function (circle) {\n        return \"<circle \\n                cx=\\\"\".concat(circle.x, \"\\\" \\n                cy=\\\"\").concat(circle.y, \"\\\" \\n                r=\\\"\").concat(circle.radius, \"\\\"\\n                fill=\\\"white\\\"\\n            />\");\n      });\n      return svgElements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(CirclePacking, \"parameters\", {\n  containerRadius: {\n    min: 50,\n    max: 100,\n    \"default\": 80\n  },\n  circleCount: {\n    min: 3,\n    max: 50,\n    \"default\": 10\n  },\n  minRadius: {\n    min: 5,\n    max: 15,\n    \"default\": 10\n  },\n  maxRadius: {\n    min: 15,\n    max: 80,\n    \"default\": 50\n  },\n  spacing: {\n    min: 0,\n    max: 10,\n    \"default\": 2\n  },\n  placementAttempts: {\n    min: 50,\n    max: 1000,\n    \"default\": 200\n  }\n  // seed parameter is now inherited from Shape class\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CirclePacking);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/CirclePacking.js?");

/***/ }),

/***/ "./src/shapes/CircleStack.js":
/*!***********************************!*\
  !*** ./src/shapes/CircleStack.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Creates a composition of two overlapping stacks, each containing a large\n * central circle and two smaller end circles.\n */\nvar CircleStack = /*#__PURE__*/function (_Shape) {\n  function CircleStack() {\n    _classCallCheck(this, CircleStack);\n    return _callSuper(this, CircleStack, arguments);\n  }\n  _inherits(CircleStack, _Shape);\n  return _createClass(CircleStack, [{\n    key: \"createCircle\",\n    value: function createCircle(cx, cy, size) {\n      return \"<circle \\n            cx=\\\"\".concat(cx, \"\\\" \\n            cy=\\\"\").concat(cy, \"\\\" \\n            r=\\\"\").concat(size / 2, \"\\\"\\n            fill=\\\"white\\\"\\n        />\");\n    }\n  }, {\n    key: \"createStack\",\n    value: function createStack(centerX, mainSize, endSize, spacing) {\n      var elements = [];\n\n      // Main circle\n      elements.push(this.createCircle(centerX, 0, mainSize));\n\n      // Top small circle\n      elements.push(this.createCircle(centerX, -(mainSize / 2 + endSize / 2 + spacing), endSize));\n\n      // Bottom small circle\n      elements.push(this.createCircle(centerX, mainSize / 2 + endSize / 2 + spacing, endSize));\n      return elements;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var scale = 0.8;\n      var mainSize = this.mainSize * scale;\n      var endSize = this.endSize * scale;\n      var spacing = this.spacing * scale;\n      var overlap = this.overlap * scale;\n      var elements = [];\n\n      // Left stack\n      var leftCenterX = -mainSize / 2 + overlap / 2;\n      elements.push.apply(elements, _toConsumableArray(this.createStack(leftCenterX, mainSize, endSize, spacing)));\n\n      // Right stack\n      var rightCenterX = mainSize / 2 - overlap / 2;\n      elements.push.apply(elements, _toConsumableArray(this.createStack(rightCenterX, mainSize, endSize, spacing)));\n      return elements.join('\\n');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(CircleStack, \"parameters\", {\n  mainSize: {\n    min: 40,\n    max: 120,\n    \"default\": 120\n  },\n  endSize: {\n    min: 20,\n    max: 100,\n    \"default\": 55\n  },\n  spacing: {\n    min: -20,\n    max: 20,\n    \"default\": -12\n  },\n  overlap: {\n    min: 0,\n    max: 40,\n    \"default\": 25\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CircleStack);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/CircleStack.js?");

/***/ }),

/***/ "./src/shapes/CirclesComposition.js":
/*!******************************************!*\
  !*** ./src/shapes/CirclesComposition.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a radial pattern of outlined circles connected to each other and to\n * a central circle by lines.\n */\nvar CirclesComposition = /*#__PURE__*/function (_Shape) {\n  function CirclesComposition() {\n    _classCallCheck(this, CirclesComposition);\n    return _callSuper(this, CirclesComposition, arguments);\n  }\n  _inherits(CirclesComposition, _Shape);\n  return _createClass(CirclesComposition, [{\n    key: \"createCircle\",\n    value: function createCircle(cx, cy, size) {\n      return \"<circle \\n            cx=\\\"\".concat(cx, \"\\\" \\n            cy=\\\"\").concat(cy, \"\\\" \\n            r=\\\"\").concat(size / 2, \"\\\"\\n            fill=\\\"none\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.lineThickness, \"\\\"\\n            stroke-linecap=\\\"round\\\"\\n        />\");\n    }\n  }, {\n    key: \"createLine\",\n    value: function createLine(x1, y1, x2, y2) {\n      return \"<line \\n            x1=\\\"\".concat(x1, \"\\\" \\n            y1=\\\"\").concat(y1, \"\\\" \\n            x2=\\\"\").concat(x2, \"\\\" \\n            y2=\\\"\").concat(y2, \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.lineThickness, \"\\\"\\n            stroke-linecap=\\\"round\\\"\\n        />\");\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var elements = [];\n      var circleCount = Math.round(this.circleCount);\n      var scale = 0.8;\n      var circleSize = this.circleSize * scale;\n      var spacing = this.spacing * scale;\n      var innerRadius = this.innerRadius * spacing;\n\n      // Draw outer circles and connections\n      for (var i = 0; i < circleCount; i++) {\n        var angle = i / circleCount * 2 * Math.PI;\n        var nextAngle = (i + 1) / circleCount * 2 * Math.PI;\n\n        // Calculate current point\n        var x = Math.cos(angle) * spacing;\n        var y = Math.sin(angle) * spacing;\n\n        // Calculate next point for connecting line\n        var nextX = Math.cos(nextAngle) * spacing;\n        var nextY = Math.sin(nextAngle) * spacing;\n\n        // Calculate inner point for center connection\n        var innerX = Math.cos(angle) * innerRadius;\n        var innerY = Math.sin(angle) * innerRadius;\n\n        // Add outer circle\n        elements.push(this.createCircle(x, y, circleSize));\n\n        // Add line to center\n        elements.push(this.createLine(x, y, innerX, innerY));\n\n        // Add connecting line to next circle\n        elements.push(this.createLine(x, y, nextX, nextY));\n      }\n\n      // Add center circle\n      elements.push(this.createCircle(0, 0, circleSize));\n      return elements.join('\\n');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(CirclesComposition, \"parameters\", {\n  circleCount: {\n    min: 3,\n    max: 12,\n    \"default\": 6\n  },\n  circleSize: {\n    min: 40,\n    max: 80,\n    \"default\": 60\n  },\n  lineThickness: {\n    min: 2,\n    max: 10,\n    \"default\": 4\n  },\n  spacing: {\n    min: 40,\n    max: 120,\n    \"default\": 80\n  },\n  innerRadius: {\n    min: 0.3,\n    max: 0.8,\n    \"default\": 0.5\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CirclesComposition);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/CirclesComposition.js?");

/***/ }),

/***/ "./src/shapes/CloudShape.js":
/*!**********************************!*\
  !*** ./src/shapes/CloudShape.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a shape resembling a cloud or rounded blob with adjustable width,\n * height, corner radius, and base curvature.\n */\nvar CloudShape = /*#__PURE__*/function (_Shape) {\n  function CloudShape() {\n    _classCallCheck(this, CloudShape);\n    return _callSuper(this, CloudShape, arguments);\n  }\n  _inherits(CloudShape, _Shape);\n  return _createClass(CloudShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var w = this.width;\n      var h = this.height;\n      var vShift = this.verticalShift;\n      var baseCurve = this.baseCurvature;\n\n      // Clamp cornerRadius based on width and height to prevent invalid geometry\n      var hw = w / 2;\n      // Ensure corner radius is at least 1 and not larger than half width or full height\n      var cr = Math.min(this.cornerRadius, hw, h);\n      cr = Math.max(1, cr);\n\n      // If corner radius forces the top arc height (h-cr) to be too small, adjust h effectively\n      // This prevents negative radius issues for the top arc. Minimum arc height is 1.\n      var effectiveHeight = Math.max(h, cr + 1);\n\n      // Calculate key Y coordinates, adjusted by vertical shift\n      var baseY = effectiveHeight / 2 + vShift; // Y coordinate of the flat part of the base\n      var topY = -effectiveHeight / 2 + vShift; // Y coordinate of the highest point\n      var cornerOffsetY = baseY - cr; // Y coordinate where corners meet top arc\n\n      // Calculate X coordinates for path points\n      var startX = -hw + cr; // Left end of base segment\n      var endX = hw - cr; // Right end of base segment\n\n      // Calculate control point for the curved base\n      // The curvature effect is scaled by the width segment between corners\n      var curveOffset = (hw - cr) * baseCurve;\n      var baseControlY = baseY + curveOffset;\n\n      // Calculate radii for the top elliptical arc\n      var topArcRx = hw; // Horizontal radius matches half width\n      var topArcRy = Math.max(1, effectiveHeight - cr); // Vertical radius based on remaining height, min 1\n\n      // Construct the SVG path data string (d attribute)\n      var d = \"M \".concat(startX, \",\").concat(baseY, \" \"); // Move to start of base segment (bottom-left)\n\n      // Add base curve (Quadratic Bezier) or straight line\n      if (Math.abs(baseCurve) > 0.01) {\n        // Use Quadratic Bezier for curved base\n        d += \"Q 0,\".concat(baseControlY, \" \").concat(endX, \",\").concat(baseY, \" \");\n      } else {\n        // Use Line for flat base\n        d += \"L \".concat(endX, \",\").concat(baseY, \" \");\n      }\n\n      // Right bottom corner arc (clockwise sweep 0)\n      // A rx ry x-axis-rotation large-arc-flag sweep-flag x y\n      d += \"A \".concat(cr, \",\").concat(cr, \" 0 0 0 \").concat(hw, \",\").concat(cornerOffsetY, \" \");\n\n      // Top elliptical arc (counter-clockwise sweep 0)\n      d += \"A \".concat(topArcRx, \",\").concat(topArcRy, \" 0 0 0 \").concat(-hw, \",\").concat(cornerOffsetY, \" \");\n\n      // Left bottom corner arc (clockwise sweep 0)\n      d += \"A \".concat(cr, \",\").concat(cr, \" 0 0 0 \").concat(startX, \",\").concat(baseY, \" \");\n\n      // Close the path\n      d += \"Z\";\n\n      // Return the path element\n      return \"<path d=\\\"\".concat(d, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(CloudShape, \"parameters\", {\n  width: {\n    type: 'number',\n    min: 40,\n    max: 190,\n    step: 1,\n    \"default\": 140,\n    // Slightly smaller default\n    label: 'Width'\n  },\n  height: {\n    type: 'number',\n    min: 20,\n    max: 95,\n    step: 1,\n    \"default\": 70,\n    // Slightly smaller default\n    label: 'Height'\n  },\n  cornerRadius: {\n    type: 'number',\n    min: 1,\n    max: 80,\n    // Max will be dynamically clamped based on width/height\n    step: 1,\n    \"default\": 25,\n    label: 'Corner Radius'\n  },\n  baseCurvature: {\n    type: 'number',\n    min: -0.4,\n    // Inward curve\n    max: 0.4,\n    // Outward curve\n    step: 0.05,\n    \"default\": 0,\n    // Flat base\n    label: 'Base Curvature'\n  },\n  verticalShift: {\n    type: 'number',\n    min: -25,\n    // Reduced range to prevent easily going out of bounds\n    max: 25,\n    step: 1,\n    \"default\": 0,\n    label: 'Vertical Shift'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CloudShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/CloudShape.js?");

/***/ }),

/***/ "./src/shapes/CloverCross.js":
/*!***********************************!*\
  !*** ./src/shapes/CloverCross.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Creates a shape combining four circular lobes (like a clover) with a central\n * cross structure.\n */\nvar CloverCross = /*#__PURE__*/function (_Shape) {\n  function CloverCross() {\n    _classCallCheck(this, CloverCross);\n    return _callSuper(this, CloverCross, arguments);\n  }\n  _inherits(CloverCross, _Shape);\n  return _createClass(CloverCross, [{\n    key: \"createLobe\",\n    value: function createLobe(cx, cy, radius) {\n      return \"<circle \\n            cx=\\\"\".concat(cx, \"\\\" \\n            cy=\\\"\").concat(cy, \"\\\" \\n            r=\\\"\").concat(radius / 2, \"\\\"\\n            fill=\\\"white\\\"\\n        />\");\n    }\n  }, {\n    key: \"createRoundedRect\",\n    value: function createRoundedRect(x, y, width, height, radius) {\n      return \"<rect \\n            x=\\\"\".concat(x, \"\\\" \\n            y=\\\"\").concat(y, \"\\\" \\n            width=\\\"\").concat(width, \"\\\" \\n            height=\\\"\").concat(height, \"\\\" \\n            rx=\\\"\").concat(radius, \"\\\"\\n            ry=\\\"\").concat(radius, \"\\\"\\n            fill=\\\"white\\\"\\n        />\");\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var elements = [];\n      var scale = 1;\n\n      // Scale parameters\n      var lobeSize = this.lobeSize * scale;\n      var crossThickness = Math.min(this.crossThickness * scale, lobeSize * 0.5);\n      var lobeRoundness = Math.min(this.lobeRoundness, 1.0);\n      var crossExtension = this.crossExtension;\n\n      // Calculate dimensions\n      var lobeRadius = lobeSize * lobeRoundness;\n      var lobeOffset = lobeSize * 0.6; // Reduced offset for more compact shape\n\n      // Create the four circular lobes\n      for (var angle = 0; angle < 360; angle += 90) {\n        var radian = angle * Math.PI / 180;\n        var lobeCenterX = Math.cos(radian) * lobeOffset;\n        var lobeCenterY = Math.sin(radian) * lobeOffset;\n        elements.push(this.createLobe(lobeCenterX, lobeCenterY, lobeRadius));\n      }\n\n      // Calculate cross dimensions\n      var crossLength = lobeSize * crossExtension * 1.2;\n\n      // Add vertical bar with rounded ends\n      elements.push(this.createRoundedRect(-crossThickness / 2, -crossLength / 2, crossThickness, crossLength, crossThickness / 2));\n\n      // Add horizontal bar with rounded ends\n      elements.push(this.createRoundedRect(-crossLength / 2, -crossThickness / 2, crossLength, crossThickness, crossThickness / 2));\n      return elements.join('\\n');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(CloverCross, \"parameters\", {\n  lobeSize: {\n    min: 30,\n    max: 150,\n    \"default\": 80\n  },\n  crossThickness: {\n    min: 10,\n    max: 50,\n    \"default\": 25\n  },\n  lobeRoundness: {\n    min: 0.1,\n    max: 1.0,\n    \"default\": 0.6\n  },\n  crossExtension: {\n    min: 0.5,\n    max: 1.5,\n    \"default\": 1.0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CloverCross);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/CloverCross.js?");

/***/ }),

/***/ "./src/shapes/CompassArrows.js":
/*!*************************************!*\
  !*** ./src/shapes/CompassArrows.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a compass-like design with four arrows pointing inwards from\n * segmented arcs, plus an optional center circle.\n */\nvar CompassArrows = /*#__PURE__*/function (_Shape) {\n  function CompassArrows() {\n    _classCallCheck(this, CompassArrows);\n    return _callSuper(this, CompassArrows, arguments);\n  }\n  _inherits(CompassArrows, _Shape);\n  return _createClass(CompassArrows, [{\n    key: \"_degreeToRadians\",\n    value:\n    // Helper to convert degrees to radians\n    function _degreeToRadians(degrees) {\n      return degrees * (Math.PI / 180);\n    }\n\n    /**\n     * Generates the SVG elements for the CompassArrows shape.\n     * Accesses parameters via `this.parameterName`.\n     * @returns {string} SVG string containing elements like <path>, <circle>, etc.\n     */\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var svgElements = [];\n      var r = this.outerRadius;\n      // Ensure arrow length doesn't exceed radius\n      var len = Math.min(this.arrowLength, r - (this.showCenter ? this.centerRadius + 5 : 5));\n      var headSize = this.arrowHeadSize;\n      // Ensure gap angle doesn't exceed 90 degrees total\n      var gapAngleDeg = Math.min(this.arcGapAngleDeg, 85);\n      var gapAngleRad = this._degreeToRadians(gapAngleDeg / 2); // Half gap angle in radians\n      var sw = this.strokeWidth;\n      var numArrows = 4;\n      var angleStep = 2 * Math.PI / numArrows; // PI/2 or 90 degrees\n\n      // Common attributes for paths\n      var pathAttrs = \"fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"\".concat(sw, \"\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\"\");\n\n      // Generate Arrows and Arcs\n      for (var i = 0; i < numArrows; i++) {\n        var angle = i * angleStep; // Angle for the current arrow (0, PI/2, PI, 3PI/2)\n        var cosA = Math.cos(angle);\n        var sinA = Math.sin(angle);\n\n        // --- Arrow ---\n        var basePt = {\n          x: r * cosA,\n          y: r * sinA\n        };\n        var tipPt = {\n          x: (r - len) * cosA,\n          y: (r - len) * sinA\n        };\n\n        // Arrowhead points (perpendicular to shaft direction)\n        var perpVec = {\n          x: -sinA,\n          y: cosA\n        }; // Vector perpendicular to the arrow direction\n        var headPt1 = {\n          x: tipPt.x + perpVec.x * headSize / 2,\n          y: tipPt.y + perpVec.y * headSize / 2\n        };\n        var headPt2 = {\n          x: tipPt.x - perpVec.x * headSize / 2,\n          y: tipPt.y - perpVec.y * headSize / 2\n        };\n\n        // Draw arrow using a single path: Head (Point1 -> Tip -> Point2) then Shaft (Tip -> Base)\n        var arrowPathData = \"M \".concat(headPt1.x.toFixed(2), \",\").concat(headPt1.y.toFixed(2), \" L \").concat(tipPt.x.toFixed(2), \",\").concat(tipPt.y.toFixed(2), \" L \").concat(headPt2.x.toFixed(2), \",\").concat(headPt2.y.toFixed(2), \" M \").concat(tipPt.x.toFixed(2), \",\").concat(tipPt.y.toFixed(2), \" L \").concat(basePt.x.toFixed(2), \",\").concat(basePt.y.toFixed(2));\n        svgElements.push(\"<path d=\\\"\".concat(arrowPathData, \"\\\" \").concat(pathAttrs, \" />\"));\n\n        // --- Arc Segment ---\n        // Calculate angles for the arc segment between this arrow and the next one\n        var startAngle = angle + gapAngleRad;\n        var endAngle = angle + angleStep - gapAngleRad;\n\n        // Calculate arc start and end points on the outer radius\n        var arcStartX = r * Math.cos(startAngle);\n        var arcStartY = r * Math.sin(startAngle);\n        var arcEndX = r * Math.cos(endAngle);\n        var arcEndY = r * Math.sin(endAngle);\n\n        // Arc flags (large-arc-flag is 0 since arc < 180 deg, sweep-flag is 1 for positive angle direction CCW)\n        var largeArcFlag = 0;\n        var sweepFlag = 1;\n\n        // Create the SVG arc path data string\n        var arcPathData = \"M \".concat(arcStartX.toFixed(2), \",\").concat(arcStartY.toFixed(2), \" A \").concat(r.toFixed(2), \",\").concat(r.toFixed(2), \" 0 \").concat(largeArcFlag, \" \").concat(sweepFlag, \" \").concat(arcEndX.toFixed(2), \",\").concat(arcEndY.toFixed(2));\n        svgElements.push(\"<path d=\\\"\".concat(arcPathData, \"\\\" \").concat(pathAttrs, \" />\"));\n      }\n\n      // --- Center Circle ---\n      if (this.showCenter && this.centerRadius > 0) {\n        svgElements.push(\"<circle cx=\\\"0\\\" cy=\\\"0\\\" r=\\\"\".concat(this.centerRadius.toFixed(2), \"\\\" \").concat(pathAttrs, \" />\"));\n        // Note: The reference image has a slightly skewed ellipse and a '3'.\n        // A simple circle is used here for geometric clarity.\n        // An ellipse could be used instead:\n        // <ellipse cx=\"0\" cy=\"0\" rx=\"${(this.centerRadius * 1.1).toFixed(2)}\" ry=\"${(this.centerRadius * 0.9).toFixed(2)}\" transform=\"rotate(-10)\" ${pathAttrs} />\n      }\n      return svgElements.join('\\n');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(CompassArrows, \"parameters\", {\n  outerRadius: {\n    type: 'number',\n    min: 20,\n    max: 95,\n    step: 1,\n    \"default\": 80,\n    label: 'Outer Radius'\n  },\n  arrowLength: {\n    type: 'number',\n    min: 5,\n    max: 70,\n    // Ensure arrow doesn't go past center\n    step: 1,\n    \"default\": 25,\n    label: 'Arrow Length'\n  },\n  arrowHeadSize: {\n    type: 'number',\n    min: 2,\n    max: 40,\n    step: 1,\n    \"default\": 20,\n    label: 'Arrow Head Size'\n  },\n  arcGapAngleDeg: {\n    type: 'number',\n    min: 5,\n    max: 85,\n    // Must be less than 90\n    step: 1,\n    \"default\": 30,\n    label: 'Arc Gap Angle ()'\n  },\n  centerRadius: {\n    type: 'number',\n    min: 0,\n    max: 40,\n    step: 1,\n    \"default\": 15,\n    label: 'Center Circle Radius'\n  },\n  showCenter: {\n    type: 'boolean',\n    \"default\": true,\n    label: 'Show Center Circle'\n  },\n  strokeWidth: {\n    type: 'number',\n    min: 0.5,\n    max: 10,\n    step: 0.5,\n    \"default\": 3,\n    label: 'Stroke Width'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CompassArrows);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/CompassArrows.js?");

/***/ }),

/***/ "./src/shapes/ConcaveStarShape.js":
/*!****************************************!*\
  !*** ./src/shapes/ConcaveStarShape.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a star shape where the sides curve inwards between the points,\n * creating concave edges.\n */\nvar ConcaveStarShape = /*#__PURE__*/function (_Shape) {\n  function ConcaveStarShape() {\n    _classCallCheck(this, ConcaveStarShape);\n    return _callSuper(this, ConcaveStarShape, arguments);\n  }\n  _inherits(ConcaveStarShape, _Shape);\n  return _createClass(ConcaveStarShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var centerX = 0;\n      var centerY = 0;\n      var radius = 100;\n\n      // Convert rotation to radians\n      var rotationRad = this.rotation * Math.PI / 180;\n      var numberOfPoints = Math.floor(this.points);\n      var pathCommands = [];\n\n      // Generate points and curves\n      for (var i = 0; i <= numberOfPoints * 2; i++) {\n        var angle = i * Math.PI / numberOfPoints + rotationRad;\n        var currentRadius = i % 2 === 0 ? radius : radius * (1 - this.innerDepth);\n        var point = {\n          x: centerX + Math.cos(angle) * currentRadius,\n          y: centerY + Math.sin(angle) * currentRadius\n        };\n        if (i === 0) {\n          // Move to first point\n          pathCommands.push(\"M \".concat(point.x, \" \").concat(point.y));\n        } else {\n          // Calculate previous point data\n          var prevAngle = (i - 1) * Math.PI / numberOfPoints + rotationRad;\n          var prevRadius = (i - 1) % 2 === 0 ? radius : radius * (1 - this.innerDepth);\n          var prevPoint = {\n            x: centerX + Math.cos(prevAngle) * prevRadius,\n            y: centerY + Math.sin(prevAngle) * prevRadius\n          };\n\n          // Calculate control points using angle bisector\n          var _midAngle = (prevAngle + angle) / 2;\n          var _controlDistance = this.sharpness * currentRadius * 0.5;\n          var control1 = {\n            x: prevPoint.x + Math.cos(_midAngle) * _controlDistance,\n            y: prevPoint.y + Math.sin(_midAngle) * _controlDistance\n          };\n          var control2 = {\n            x: point.x - Math.cos(_midAngle) * _controlDistance,\n            y: point.y - Math.sin(_midAngle) * _controlDistance\n          };\n\n          // Add cubic Bzier curve\n          pathCommands.push(\"C \".concat(control1.x, \" \").concat(control1.y, \", \").concat(control2.x, \" \").concat(control2.y, \", \").concat(point.x, \" \").concat(point.y));\n        }\n      }\n\n      // Close the path with a final curve back to the start\n      var firstPoint = {\n        x: centerX + Math.cos(rotationRad) * radius,\n        y: centerY + Math.sin(rotationRad) * radius\n      };\n      var lastAngle = numberOfPoints * 2 * Math.PI / numberOfPoints + rotationRad;\n      var midAngle = (lastAngle + (rotationRad + 2 * Math.PI)) / 2;\n      var controlDistance = this.sharpness * radius * 0.5;\n      var lastPoint = {\n        x: centerX + Math.cos(lastAngle) * (radius * (1 - this.innerDepth)),\n        y: centerY + Math.sin(lastAngle) * (radius * (1 - this.innerDepth))\n      };\n      var finalControl1 = {\n        x: lastPoint.x + Math.cos(midAngle) * controlDistance,\n        y: lastPoint.y + Math.sin(midAngle) * controlDistance\n      };\n      var finalControl2 = {\n        x: firstPoint.x - Math.cos(midAngle) * controlDistance,\n        y: firstPoint.y - Math.sin(midAngle) * controlDistance\n      };\n\n      // Add final curve to close the path\n      pathCommands.push(\"C \".concat(finalControl1.x, \" \").concat(finalControl1.y, \", \").concat(finalControl2.x, \" \").concat(finalControl2.y, \", \").concat(firstPoint.x, \" \").concat(firstPoint.y));\n      return \"<path\\n            d=\\\"\".concat(pathCommands.join(' '), \"\\\"\\n            fill=\\\"white\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(ConcaveStarShape, \"parameters\", {\n  points: {\n    min: 4,\n    max: 16,\n    \"default\": 8\n  },\n  innerDepth: {\n    min: 0.1,\n    max: 0.9,\n    \"default\": 0.3\n  },\n  sharpness: {\n    min: 0.1,\n    max: 2.0,\n    \"default\": 0.7\n  },\n  rotation: {\n    min: -180,\n    max: 180,\n    \"default\": 22.5\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ConcaveStarShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/ConcaveStarShape.js?");

/***/ }),

/***/ "./src/shapes/ConcentricArches.js":
/*!****************************************!*\
  !*** ./src/shapes/ConcentricArches.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a series of concentric semi-circular arches, optionally supported\n * by vertical legs with rounded corners.\n */\nvar ConcentricArches = /*#__PURE__*/function (_Shape) {\n  function ConcentricArches() {\n    _classCallCheck(this, ConcentricArches);\n    return _callSuper(this, ConcentricArches, arguments);\n  }\n  _inherits(ConcentricArches, _Shape);\n  return _createClass(ConcentricArches, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var svgPaths = '';\n      var bottomY = this.legHeight > 0 ? this.legHeight : 0; // Y-coordinate for the bottom of the legs\n\n      // Ensure the largest arch stays within bounds\n      var maxRadius = this.innerRadius + (this.numArches - 1) * this.archSpacing;\n      var scaleFactor = Math.min(1, 98 / (maxRadius + this.strokeWidth / 2)); // Leave a small margin\n      var scaledInnerRadius = this.innerRadius * scaleFactor;\n      var scaledArchSpacing = this.archSpacing * scaleFactor;\n      var scaledLegHeight = Math.min(98 - this.strokeWidth / 2, this.legHeight) * scaleFactor; // Ensure legs also stay within bounds vertically\n      var scaledCornerRadius = Math.min(this.cornerRadius, scaledArchSpacing / 2, scaledLegHeight); // Cap corner radius\n\n      for (var i = 0; i < this.numArches; i++) {\n        var r = scaledInnerRadius + i * scaledArchSpacing;\n        var yBottom = scaledLegHeight;\n\n        // Adjusted start/end points for corner radius\n        var startX = -r + (scaledCornerRadius > 0 ? scaledCornerRadius : 0);\n        var endX = r - (scaledCornerRadius > 0 ? scaledCornerRadius : 0);\n        var startY = yBottom - (scaledCornerRadius > 0 ? scaledCornerRadius : 0);\n        var pathData = void 0;\n        if (scaledLegHeight <= 0) {\n          // Draw only the semicircle if legHeight is 0\n          pathData = \"M \".concat(-r, \",0 A \").concat(r, \",\").concat(r, \" 0 0 1 \").concat(r, \",0\");\n        } else if (scaledCornerRadius > 0) {\n          // Rounded corners on legs\n          pathData = \"\\n                    M \".concat(startX, \",\").concat(yBottom, \"\\n                    A \").concat(scaledCornerRadius, \",\").concat(scaledCornerRadius, \" 0 0 1 \").concat(-r, \",\").concat(startY, \"\\n                    L \").concat(-r, \",0\\n                    A \").concat(r, \",\").concat(r, \" 0 0 1 \").concat(r, \",0\\n                    L \").concat(r, \",\").concat(startY, \"\\n                    A \").concat(scaledCornerRadius, \",\").concat(scaledCornerRadius, \" 0 0 1 \").concat(endX, \",\").concat(yBottom, \"\\n                 \");\n          // Removed closing Z as it's an open path/stroke\n        } else {\n          // Sharp corners on legs\n          pathData = \"\\n                    M \".concat(-r, \",\").concat(yBottom, \"\\n                    L \").concat(-r, \",0\\n                    A \").concat(r, \",\").concat(r, \" 0 0 1 \").concat(r, \",0\\n                    L \").concat(r, \",\").concat(yBottom, \"\\n                \");\n        }\n        svgPaths += \"<path d=\\\"\".concat(pathData, \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(this.strokeWidth, \"\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\" />\\n\");\n      }\n\n      // Center the drawing vertically if legs are present\n      var verticalShift = scaledLegHeight > 0 ? -scaledLegHeight / 2 : 0;\n      return \"<g transform=\\\"translate(0, \".concat(verticalShift, \")\\\">\").concat(svgPaths, \"</g>\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(ConcentricArches, \"parameters\", {\n  numArches: {\n    type: 'number',\n    min: 1,\n    max: 6,\n    step: 1,\n    \"default\": 2,\n    label: 'Number of Arches'\n  },\n  innerRadius: {\n    type: 'number',\n    min: 10,\n    max: 70,\n    step: 1,\n    \"default\": 35,\n    label: 'Inner Radius'\n  },\n  archSpacing: {\n    type: 'number',\n    min: 5,\n    max: 30,\n    step: 1,\n    \"default\": 15,\n    label: 'Arch Spacing'\n  },\n  strokeWidth: {\n    type: 'number',\n    min: 1,\n    max: 25,\n    step: 1,\n    \"default\": 8,\n    label: 'Stroke Width'\n  },\n  legHeight: {\n    type: 'number',\n    min: 0,\n    max: 80,\n    step: 1,\n    \"default\": 45,\n    label: 'Leg Height'\n  },\n  cornerRadius: {\n    // Added parameter for rounded corners on the bottom legs\n    type: 'number',\n    min: 0,\n    max: 20,\n    step: 1,\n    \"default\": 0,\n    label: 'Corner Radius'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ConcentricArches);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/ConcentricArches.js?");

/***/ }),

/***/ "./src/shapes/ConcentricEllipses.js":
/*!******************************************!*\
  !*** ./src/shapes/ConcentricEllipses.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a pattern of concentric ellipses, allowing for offset centers to\n * create a tunneling effect.\n */\nvar ConcentricEllipsesShape = /*#__PURE__*/function (_Shape) {\n  function ConcentricEllipsesShape() {\n    _classCallCheck(this, ConcentricEllipsesShape);\n    return _callSuper(this, ConcentricEllipsesShape, arguments);\n  }\n  _inherits(ConcentricEllipsesShape, _Shape);\n  return _createClass(ConcentricEllipsesShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var ellipses = [];\n\n      // Calculate radii for largest and smallest ellipses\n      var outerRx = this.width / 2;\n      var outerRy = this.height / 2;\n      var innerRx = (this.width - (this.count - 1) * this.spacing * 2) / 2;\n      var innerRy = (this.height - (this.count - 1) * this.spacing * 2) / 2;\n\n      // Calculate the maximum safe offset scale\n      // This is the ratio that allows the innermost circle to just touch the edge\n      var maxScaleX = (outerRx - innerRx) / Math.abs(this.xOffset || 1);\n      var maxScaleY = (outerRy - innerRy) / Math.abs(this.yOffset || 1);\n      var safeScale = Math.min(maxScaleX, maxScaleY, this.offsetScale);\n\n      // Calculate base offsets\n      var baseOffsetX = this.xOffset * safeScale;\n      var baseOffsetY = this.yOffset * safeScale;\n      for (var i = 0; i < this.count; i++) {\n        // Calculate current ellipse dimensions\n        var rx = (this.width - i * this.spacing * 2) / 2;\n        var ry = (this.height - i * this.spacing * 2) / 2;\n\n        // Break if ellipse would be too small\n        if (rx <= 0 || ry <= 0) break;\n\n        // Calculate progress for this ring (0 for outer, 1 for inner)\n        var progress = i / (this.count - 1);\n\n        // Apply offset based on progress\n        var cx = baseOffsetX * progress;\n        var cy = baseOffsetY * progress;\n        ellipses.push(\"<ellipse \\n                cx=\\\"\".concat(cx, \"\\\"\\n                cy=\\\"\").concat(cy, \"\\\"\\n                rx=\\\"\").concat(rx, \"\\\"\\n                ry=\\\"\").concat(ry, \"\\\"\\n                fill=\\\"none\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            />\"));\n      }\n      return ellipses.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(ConcentricEllipsesShape, \"parameters\", {\n  width: {\n    min: 50,\n    max: 200,\n    \"default\": 200\n  },\n  height: {\n    min: 50,\n    max: 200,\n    \"default\": 200\n  },\n  count: {\n    min: 2,\n    max: 12,\n    \"default\": 6\n  },\n  spacing: {\n    min: 5,\n    max: 40,\n    \"default\": 20\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  },\n  xOffset: {\n    min: -100,\n    max: 100,\n    \"default\": 0\n  },\n  yOffset: {\n    min: -100,\n    max: 100,\n    \"default\": 0\n  },\n  offsetScale: {\n    min: 0,\n    max: 1,\n    \"default\": 1.0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ConcentricEllipsesShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/ConcentricEllipses.js?");

/***/ }),

/***/ "./src/shapes/ConcentricFlow.js":
/*!**************************************!*\
  !*** ./src/shapes/ConcentricFlow.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a pattern of concentric, distorted rings and arcs using Perlin\n * noise to simulate organic flow.\n */\nvar ConcentricFlow = /*#__PURE__*/function (_Shape) {\n  function ConcentricFlow() {\n    _classCallCheck(this, ConcentricFlow);\n    return _callSuper(this, ConcentricFlow, arguments);\n  }\n  _inherits(ConcentricFlow, _Shape);\n  return _createClass(ConcentricFlow, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      this.resetRNG();\n      var elements = [];\n\n      // Generate concentric rings with ultra smooth curve rendering\n      for (var r = 0; r < this.ringCount; r++) {\n        var radius = this.innerRadius + (this.outerRadius - this.innerRadius) * (r / (this.ringCount - 1));\n\n        // Generate more points for higher resolution\n        var totalPoints = Math.max(this.pointsPerRing, 200); // Ensure enough points for smoothness\n        var points = [];\n\n        // Generate initial points with noise distortion\n        for (var i = 0; i <= totalPoints; i++) {\n          var angle = i / totalPoints * Math.PI * 2;\n          var baseX = Math.cos(angle) * radius;\n          var baseY = Math.sin(angle) * radius;\n\n          // Apply multi-octave noise for more organic distortion\n          var distortionFactor = this.noiseStrength * (radius / this.outerRadius);\n\n          // Use multiple noise frequencies for more natural look\n          var primaryNoise = this.getNoise(baseX / 50, baseY / 50);\n          var secondaryNoise = this.getNoise(baseX / 25, baseY / 25) * 0.5;\n          var tertiaryNoise = this.getNoise(baseX / 100, baseY / 100) * 0.25;\n          var combinedNoise = (primaryNoise + secondaryNoise + tertiaryNoise) / 1.75;\n          var distortedRadius = radius + combinedNoise * distortionFactor;\n          var x = Math.cos(angle) * distortedRadius;\n          var y = Math.sin(angle) * distortedRadius;\n          points.push({\n            x: x,\n            y: y\n          });\n        }\n\n        // Ensure smooth closure by adding additional points at the beginning/end\n        var firstPoint = points[0];\n        var lastPoint = points[points.length - 1];\n\n        // Close the curve perfectly\n        points.push(_objectSpread({}, firstPoint));\n\n        // Use SVG path commands with tension parameter for optimal smoothness\n        var pathData = \"\";\n\n        // For very small rings, use simplified paths\n        if (radius < this.innerRadius * 1.2) {\n          // Use simple control point calculation for small rings\n          pathData = this.generateSimpleSmoothedPath(points);\n        } else {\n          // Use catmull-rom spline approach for larger rings\n          pathData = this.generateCatmullRomPath(points, this.curveTension);\n        }\n\n        // Add the complete path for this ring\n        if (pathData !== \"\") {\n          elements.push(\"<path \\n                    d=\\\"\".concat(pathData, \"\\\" \\n                    stroke=\\\"white\\\" \\n                    fill=\\\"none\\\"\\n                    stroke-width=\\\"\").concat(this.strokeWidth, \"\\\"\\n                    stroke-linecap=\\\"round\\\"\\n                    stroke-linejoin=\\\"round\\\"\\n                />\"));\n        }\n      }\n\n      // Add curved arch pattern lines with enhanced smoothness\n      var archCount = Math.floor(this.ringCount / 2);\n      for (var a = 0; a < archCount; a++) {\n        var startAngle = this.random() * Math.PI * 2;\n        var arcLength = Math.PI * (0.3 + this.random() * 0.5);\n        var _radius = this.innerRadius + this.random() * (this.outerRadius - this.innerRadius);\n\n        // Generate more points for the arch\n        var archPoints = [];\n\n        // Use higher resolution for smoother arcs\n        var arcResolution = 40;\n        for (var _i = 0; _i <= arcResolution; _i++) {\n          var _angle = startAngle + arcLength * _i / arcResolution;\n          var _x = Math.cos(_angle) * _radius;\n          var _y = Math.sin(_angle) * _radius;\n\n          // Add subtle variation to make arcs more organic\n          var variation = this.getNoise(_i / 10, a / 5) * 2 * (this.noiseStrength / 15);\n          archPoints.push({\n            x: _x + variation * Math.cos(_angle + Math.PI / 2),\n            y: _y + variation * Math.sin(_angle + Math.PI / 2)\n          });\n        }\n\n        // Create ultra smooth curve for arch\n        var archPath = this.generateCatmullRomPath(archPoints, this.curveTension);\n        elements.push(\"<path \\n                d=\\\"\".concat(archPath, \"\\\" \\n                stroke=\\\"white\\\" \\n                fill=\\\"none\\\"\\n                stroke-width=\\\"\").concat(this.strokeWidth, \"\\\"\\n                stroke-linecap=\\\"round\\\"\\n                stroke-linejoin=\\\"round\\\"\\n            />\"));\n      }\n      return elements.join('');\n    }\n\n    // Generate simple smoothed path with optimized control points\n  }, {\n    key: \"generateSimpleSmoothedPath\",\n    value: function generateSimpleSmoothedPath(points) {\n      if (points.length < 3) return \"\";\n      var pathCommands = [\"M\".concat(points[0].x, \",\").concat(points[0].y)];\n\n      // Use quadratic curves for simplicity and smoothness\n      for (var i = 1; i < points.length; i++) {\n        var prev = points[i - 1];\n        var current = points[i];\n\n        // For simplified paths, use quadratic bezier curves\n        if (i < points.length - 1) {\n          var next = points[i + 1];\n          var controlX = (prev.x + current.x * 2 + next.x) / 4;\n          var controlY = (prev.y + current.y * 2 + next.y) / 4;\n          pathCommands.push(\"Q\".concat(current.x, \",\").concat(current.y, \" \").concat(controlX, \",\").concat(controlY));\n        } else {\n          pathCommands.push(\"L\".concat(current.x, \",\").concat(current.y));\n        }\n      }\n      return pathCommands.join(\" \");\n    }\n\n    // Generate optimized Catmull-Rom spline path\n  }, {\n    key: \"generateCatmullRomPath\",\n    value: function generateCatmullRomPath(points) {\n      var tension = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;\n      if (points.length < 2) return \"\";\n\n      // Start the path\n      var pathData = \"M\".concat(points[0].x, \",\").concat(points[0].y);\n\n      // For higher quality, use a Catmull-Rom spline approximation with cubic beziers\n      // Add extra control points at the beginning and end for better curve calculation\n      var controlPoints = [points[0]].concat(_toConsumableArray(points), [points[points.length - 1] // Duplicate last point\n      ]);\n\n      // Process the points in groups of 4 to create smooth cubic bezier curves\n      for (var i = 0; i < controlPoints.length - 3; i++) {\n        var p0 = controlPoints[i];\n        var p1 = controlPoints[i + 1];\n        var p2 = controlPoints[i + 2];\n        var p3 = controlPoints[i + 3];\n\n        // Skip duplicated points at the beginning\n        if (i === 0 && p0.x === p1.x && p0.y === p1.y) continue;\n\n        // Calculate optimal control points for the cubic bezier curve\n        // The tension parameter controls how \"tight\" the curve is\n        var cp1x = p1.x + (p2.x - p0.x) * tension / 3;\n        var cp1y = p1.y + (p2.y - p0.y) * tension / 3;\n        var cp2x = p2.x - (p3.x - p1.x) * tension / 3;\n        var cp2y = p2.y - (p3.y - p1.y) * tension / 3;\n\n        // Skip the very first point since we already have a \"M\" command for it\n        if (i > 0 || p0.x !== p1.x || p0.y !== p1.y) {\n          pathData += \" C\".concat(cp1x.toFixed(2), \",\").concat(cp1y.toFixed(2), \" \").concat(cp2x.toFixed(2), \",\").concat(cp2y.toFixed(2), \" \").concat(p2.x.toFixed(2), \",\").concat(p2.y.toFixed(2));\n        }\n      }\n      return pathData;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(ConcentricFlow, \"parameters\", {\n  ringCount: {\n    min: 5,\n    max: 25,\n    \"default\": 15\n  },\n  pointsPerRing: {\n    min: 50,\n    max: 500,\n    \"default\": 200\n  },\n  innerRadius: {\n    min: 20,\n    max: 60,\n    \"default\": 50\n  },\n  outerRadius: {\n    min: 60,\n    max: 180,\n    \"default\": 95\n  },\n  noiseStrength: {\n    min: 0.1,\n    max: 15,\n    \"default\": 10\n  },\n  noiseScale: {\n    min: 0.5,\n    max: 5,\n    \"default\": 2.5\n  },\n  strokeWidth: {\n    min: 0.5,\n    max: 3,\n    \"default\": 2\n  },\n  curveTension: {\n    min: 0.1,\n    max: 0.9,\n    \"default\": 0.3\n  },\n  curveSegmentLength: {\n    min: 2,\n    max: 10,\n    \"default\": 3\n  },\n  seed: {\n    min: 0,\n    max: 1000,\n    \"default\": 1\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ConcentricFlow);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/ConcentricFlow.js?");

/***/ }),

/***/ "./src/shapes/ConcentricHex.js":
/*!*************************************!*\
  !*** ./src/shapes/ConcentricHex.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a receding hexagonal shape using concentric polylines,\n * creating an optical illusion of depth. Similar to op-art patterns.\n */\nvar ConcentricHex = /*#__PURE__*/function (_Shape) {\n  function ConcentricHex() {\n    _classCallCheck(this, ConcentricHex);\n    return _callSuper(this, ConcentricHex, arguments);\n  }\n  _inherits(ConcentricHex, _Shape);\n  return _createClass(ConcentricHex, [{\n    key: \"lerp\",\n    value:\n    /**\n     * Linearly interpolates between two points.\n     * @param {{x: number, y: number}} p1 - Start point.\n     * @param {{x: number, y: number}} p2 - End point.\n     * @param {number} t - Interpolation factor (0 to 1).\n     * @returns {{x: number, y: number}} Interpolated point.\n     */\n    function lerp(p1, p2, t) {\n      return {\n        x: p1.x + (p2.x - p1.x) * t,\n        y: p1.y + (p2.y - p1.y) * t\n      };\n    }\n\n    /**\n     * Finds the X-coordinate intersection of a horizontal line (y=Y)\n     * with the line segment defined by points p1 and p2.\n     * Returns the X-coordinate or null if no intersection within the segment's Y range.\n     */\n  }, {\n    key: \"intersectHorizontal\",\n    value: function intersectHorizontal(Y, p1, p2) {\n      var minY = Math.min(p1.y, p2.y);\n      var maxY = Math.max(p1.y, p2.y);\n      // Check if Y is within the segment's vertical range (allow for floating point error)\n      if (Y < minY - 1e-9 || Y > maxY + 1e-9) {\n        return null;\n      }\n      // Handle vertical line segment\n      if (Math.abs(p1.x - p2.x) < 1e-9) {\n        return p1.x;\n      }\n      // Handle horizontal line segment - should not happen for the edges we test against typically\n      if (Math.abs(p1.y - p2.y) < 1e-9) {\n        // If Y matches the horizontal line's Y, it intersects along the whole segment.\n        // Return null as it doesn't define a unique intersection X for width calculation here.\n        return null;\n      }\n\n      // Calculate interpolation factor 't' based on Y\n      var t = (Y - p1.y) / (p2.y - p1.y);\n      // Calculate the x-coordinate at the intersection point\n      return p1.x + t * (p2.x - p1.x);\n    }\n\n    /**\n     * Generates the SVG polyline elements for the concentric hexagonal shells.\n     * @returns {string} SVG string containing multiple <polyline> elements.\n     */\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      var s = this.size / 2;\n\n      // 1. Calculate Outer Hexagon Vertices (Isometric Projection Style)\n      var dx = s * Math.sqrt(3) / 2; // Horizontal distance for side vertices\n      var dy = s / 2; // Vertical distance for side vertices from equator\n      // Ensure vertices are within the -100 to 100 range for the default size\n      var scaleFactor = Math.min(1, 95 / Math.max(dx, s)); // Scale down slightly if needed\n      var scaled_s = s * scaleFactor;\n      var scaled_dx = dx * scaleFactor;\n      var scaled_dy = dy * scaleFactor;\n      var v = [/* v0 */{\n        x: 0,\n        y: scaled_s\n      },\n      // Bottom Point\n      /* v1 */\n      {\n        x: scaled_dx,\n        y: scaled_dy\n      },\n      // Bottom Right Mid-Point\n      /* v2 */\n      {\n        x: -scaled_dx,\n        y: scaled_dy\n      },\n      // Bottom Left Mid-Point\n      /* v3 */\n      {\n        x: -scaled_dx,\n        y: -scaled_dy\n      },\n      // Top Left Mid-Point\n      /* v4 */\n      {\n        x: 0,\n        y: -scaled_s\n      },\n      // Top Point\n      /* v5 */\n      {\n        x: scaled_dx,\n        y: -scaled_dy\n      } // Top Right Mid-Point\n      ];\n\n      // 2. Calculate Inner Target Points based on depthRatio and innerTipWidthRatio\n      var innerY = -scaled_s + 2 * scaled_s * this.depthRatio;\n      var dy_limit = scaled_dy; // |Y| value for midpoint vertices\n\n      var xLeftOuter, xRightOuter;\n\n      // Find intersection X on the left side edge based on innerY position\n      if (innerY >= dy_limit - 1e-9) {\n        // At or below bottom midpoints\n        xLeftOuter = this.intersectHorizontal(innerY, v[2], v[0]);\n      } else if (innerY <= -dy_limit + 1e-9) {\n        // At or above top midpoints\n        xLeftOuter = this.intersectHorizontal(innerY, v[3], v[4]);\n      } else {\n        // Between midpoints (on the vertical section)\n        xLeftOuter = v[2].x; // = -scaled_dx\n      }\n\n      // Find intersection X on the right side edge based on innerY position\n      if (innerY >= dy_limit - 1e-9) {\n        // At or below bottom midpoints\n        xRightOuter = this.intersectHorizontal(innerY, v[1], v[0]);\n      } else if (innerY <= -dy_limit + 1e-9) {\n        // At or above top midpoints\n        xRightOuter = this.intersectHorizontal(innerY, v[5], v[4]);\n      } else {\n        // Between midpoints (on the vertical section)\n        xRightOuter = v[1].x; // = scaled_dx\n      }\n\n      // Handle cases where intersection might fail (e.g., if innerY perfectly matches a vertex Y)\n      // Use vertex X if intersection is null but Y matches.\n      if (xLeftOuter === null) {\n        if (Math.abs(innerY - v[0].y) < 1e-9) xLeftOuter = v[0].x;else if (Math.abs(innerY - v[2].y) < 1e-9) xLeftOuter = v[2].x;else if (Math.abs(innerY - v[3].y) < 1e-9) xLeftOuter = v[3].x;else if (Math.abs(innerY - v[4].y) < 1e-9) xLeftOuter = v[4].x;else {\n          // Fallback if still null\n          console.warn(\"Fallback for xLeftOuter at innerY\", innerY);\n          xLeftOuter = -scaled_dx;\n        }\n      }\n      if (xRightOuter === null) {\n        if (Math.abs(innerY - v[0].y) < 1e-9) xRightOuter = v[0].x;else if (Math.abs(innerY - v[1].y) < 1e-9) xRightOuter = v[1].x;else if (Math.abs(innerY - v[5].y) < 1e-9) xRightOuter = v[5].x;else if (Math.abs(innerY - v[4].y) < 1e-9) xRightOuter = v[4].x;else {\n          // Fallback if still null\n          console.warn(\"Fallback for xRightOuter at innerY\", innerY);\n          xRightOuter = scaled_dx;\n        }\n      }\n      var outerWidthAtInnerY = xRightOuter - xLeftOuter;\n      var innerWidth = outerWidthAtInnerY * this.innerTipWidthRatio;\n\n      // Define inner target points (TL, TR form the inner base line, Mid is the convergence point)\n      // Calculate TL/TR based on the calculated outer width and inner ratio\n      var TL = {\n        x: xLeftOuter + (outerWidthAtInnerY - innerWidth) / 2,\n        y: innerY\n      };\n      var TR = {\n        x: xRightOuter - (outerWidthAtInnerY - innerWidth) / 2,\n        y: innerY\n      };\n      var MidInnerBase = {\n        x: (TL.x + TR.x) / 2,\n        y: innerY\n      }; // Point for top/bottom convergence\n\n      // 3. Generate Concentric Polylines\n      var polylines = [];\n      var numSteps = this.numLines;\n\n      // Define the mapping from outer vertices (v index) to inner target points\n      var innerTargets = [MidInnerBase,\n      // v[0] (Bottom) -> MidInnerBase\n      TR,\n      // v[1] (Bottom Right) -> TR\n      TL,\n      // v[2] (Bottom Left) -> TL\n      TL,\n      // v[3] (Top Left) -> TL\n      MidInnerBase,\n      // v[4] (Top) -> MidInnerBase\n      TR // v[5] (Top Right) -> TR\n      ];\n      var _loop = function _loop() {\n        // Interpolation factor t goes from 0 (outer) to 1 (inner)\n        var t = numSteps === 1 ? 0 : i / (numSteps - 1);\n\n        // Calculate vertices for the current shell using linear interpolation\n        var p = v.map(function (outerPoint, index) {\n          return _this.lerp(outerPoint, innerTargets[index], t);\n        });\n\n        // Create the points string for the polyline outlining this shell\n        // Order: Bottom -> BR -> TR -> Top -> TL -> BL -> (close loop visually by path closing)\n        var pointsString = [p[0], p[1], p[5], p[4], p[3], p[2]].map(function (pt) {\n          return \"\".concat(pt.x.toFixed(2), \",\").concat(pt.y.toFixed(2));\n        }).join(' ');\n        polylines.push(// Draw as closed polygon outline instead of polyline to ensure sharp corners visually join\n        \"<polygon points=\\\"\".concat(pointsString, \"\\\"\\n                           fill=\\\"none\\\"\\n                           stroke=\\\"white\\\"\\n                           stroke-width=\\\"\").concat(_this.strokeWidth, \"\\\"\\n                           stroke-linejoin=\\\"miter\\\"/>\") // Use miter for sharp corners requested by image\n        );\n      };\n      for (var i = 0; i < numSteps; i++) {\n        _loop();\n      }\n\n      // Return all generated polyline strings joined together\n      return polylines.join('\\n');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(ConcentricHex, \"parameters\", {\n  size: {\n    type: 'number',\n    min: 20,\n    max: 190,\n    // Slightly reduced max to prevent clipping with stroke\n    step: 1,\n    \"default\": 190,\n    label: 'Overall Size'\n  },\n  numLines: {\n    type: 'number',\n    min: 4,\n    max: 32,\n    // More lines create denser effect\n    step: 1,\n    \"default\": 8,\n    label: 'Number of Shells'\n  },\n  depthRatio: {\n    type: 'number',\n    min: 0.05,\n    // Avoid 0 (flat)\n    max: 0.95,\n    // Avoid 1 (fully collapsed)\n    step: 0.05,\n    \"default\": 0.5,\n    // Deeper recession by default\n    label: 'Receding Depth (0=Shallow, 1=Deep)'\n  },\n  innerTipWidthRatio: {\n    type: 'number',\n    min: 0.0,\n    // Allow convergence to a point/line\n    max: 1.0,\n    // Avoid becoming the full width\n    step: 0.05,\n    \"default\": 1.0,\n    // Narrower inner base by default\n    label: 'Inner Base Width Ratio'\n  },\n  strokeWidth: {\n    type: 'number',\n    min: 0.1,\n    max: 5,\n    // Allow thicker lines, but might overlap visually at corners\n    step: 0.1,\n    \"default\": 4,\n    label: 'Line Stroke Width'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ConcentricHex);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/ConcentricHex.js?");

/***/ }),

/***/ "./src/shapes/ConcentricRectangles.js":
/*!********************************************!*\
  !*** ./src/shapes/ConcentricRectangles.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a series of concentric rectangular outlines with adjustable count,\n * spacing, and thickness.\n */\nvar ConcentricRectangles = /*#__PURE__*/function (_Shape) {\n  function ConcentricRectangles() {\n    _classCallCheck(this, ConcentricRectangles);\n    return _callSuper(this, ConcentricRectangles, arguments);\n  }\n  _inherits(ConcentricRectangles, _Shape);\n  return _createClass(ConcentricRectangles, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var squares = [];\n      for (var i = 0; i < this.count; i++) {\n        var currentSize = this.size - i * this.spacing * 2;\n        if (currentSize <= 0) break;\n        var halfSize = currentSize / 2;\n\n        // Create path string for the square\n        var pathData = \"M \".concat(-halfSize, \" \").concat(-halfSize, \" \") + \"L \".concat(halfSize, \" \").concat(-halfSize, \" \") + \"L \".concat(halfSize, \" \").concat(halfSize, \" \") + \"L \".concat(-halfSize, \" \").concat(halfSize, \" Z\");\n        squares.push(\"<path \\n                d=\\\"\".concat(pathData, \"\\\"\\n                fill=\\\"none\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            />\"));\n      }\n      return squares.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(ConcentricRectangles, \"parameters\", {\n  count: {\n    min: 2,\n    max: 10,\n    \"default\": 6\n  },\n  spacing: {\n    min: 5,\n    max: 40,\n    \"default\": 20\n  },\n  size: {\n    min: 100,\n    max: 200,\n    \"default\": 190\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ConcentricRectangles);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/ConcentricRectangles.js?");

/***/ }),

/***/ "./src/shapes/ConcentricRects.js":
/*!***************************************!*\
  !*** ./src/shapes/ConcentricRects.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a series of concentric rounded rectangles, mimicking a layered or\n * extruded effect.\n */\nvar ConcentricRects = /*#__PURE__*/function (_Shape) {\n  function ConcentricRects() {\n    _classCallCheck(this, ConcentricRects);\n    return _callSuper(this, ConcentricRects, arguments);\n  }\n  _inherits(ConcentricRects, _Shape);\n  return _createClass(ConcentricRects, [{\n    key: \"generateShape\",\n    value:\n    /**\n     * Generates the SVG elements for the ConcentricRects shape.\n     * Accesses parameters via `this.parameterName`.\n     * @param {object} params - An object containing the parameter values for this shape instance (available as this.parameterName).\n     * @returns {string} SVG string containing <rect> elements.\n     */\n    function generateShape(params) {\n      var svgElements = '';\n\n      // Loop through each layer, starting from the outside\n      for (var i = 0; i < this.numLayers; i++) {\n        // Calculate dimensions and position for the current layer\n        var currentWidth = this.outerWidth - 2 * i * this.spacing;\n        var currentHeight = this.outerHeight - 2 * i * this.spacing;\n\n        // Stop if the rectangle dimensions become too small or negative\n        if (currentWidth <= 0 || currentHeight <= 0) {\n          break;\n        }\n\n        // Calculate the top-left corner position to keep it centered\n        var x = -currentWidth / 2;\n        var y = -currentHeight / 2;\n\n        // Calculate the corner radius for the current layer\n        // Ensure radius doesn't exceed half of the smallest dimension\n        // and decreases naturally with layers, but not below 0.\n        var currentRadius = this.cornerRadius - i * this.spacing;\n        currentRadius = Math.max(0, currentRadius); // Cannot be negative\n        currentRadius = Math.min(currentRadius, currentWidth / 2, currentHeight / 2); // Cannot exceed half dimensions\n\n        // Generate the SVG <rect> element for the current layer\n        svgElements += \"<rect x=\\\"\".concat(x, \"\\\" y=\\\"\").concat(y, \"\\\" width=\\\"\").concat(currentWidth, \"\\\" height=\\\"\").concat(currentHeight, \"\\\" rx=\\\"\").concat(currentRadius, \"\\\" ry=\\\"\").concat(currentRadius, \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(this.strokeWidth, \"\\\" />\\n\");\n      }\n\n      // If no layers were generated (e.g., invalid parameters), return an empty string or a default shape\n      if (!svgElements) {\n        // Optional: return a small default rectangle or circle\n        // return `<rect x=\"-10\" y=\"-10\" width=\"20\" height=\"20\" rx=\"2\" ry=\"2\" fill=\"none\" stroke=\"white\" stroke-width=\"${this.strokeWidth}\" />`;\n        return ''; // Return empty string if nothing generated\n      }\n      return svgElements;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(ConcentricRects, \"parameters\", {\n  numLayers: {\n    type: 'number',\n    min: 1,\n    max: 30,\n    step: 1,\n    \"default\": 10,\n    label: 'Number of Layers' // Added label for clarity\n  },\n  outerWidth: {\n    type: 'number',\n    min: 20,\n    max: 190,\n    // Keep within bounds\n    step: 1,\n    \"default\": 150,\n    label: 'Outer Width'\n  },\n  outerHeight: {\n    type: 'number',\n    min: 20,\n    max: 190,\n    // Keep within bounds\n    step: 1,\n    \"default\": 100,\n    label: 'Outer Height'\n  },\n  cornerRadius: {\n    type: 'number',\n    min: 0,\n    max: 95,\n    // Max half of the smallest default dimension / 2\n    step: 1,\n    \"default\": 20,\n    label: 'Outer Corner Radius'\n  },\n  spacing: {\n    type: 'number',\n    min: 1,\n    max: 15,\n    step: 0.5,\n    \"default\": 5,\n    label: 'Layer Spacing'\n  },\n  strokeWidth: {\n    type: 'number',\n    min: 0.1,\n    max: 5,\n    step: 0.1,\n    \"default\": 1.5,\n    label: 'Stroke Width'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ConcentricRects);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/ConcentricRects.js?");

/***/ }),

/***/ "./src/shapes/ConcentricSphereShape.js":
/*!*********************************************!*\
  !*** ./src/shapes/ConcentricSphereShape.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Creates a 3D-like sphere representation using stacked, outlined ellipses to\n * simulate horizontal slices.\n */\nvar ConcentricSphereShape = /*#__PURE__*/function (_Shape) {\n  function ConcentricSphereShape() {\n    _classCallCheck(this, ConcentricSphereShape);\n    return _callSuper(this, ConcentricSphereShape, arguments);\n  }\n  _inherits(ConcentricSphereShape, _Shape);\n  return _createClass(ConcentricSphereShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var elements = [];\n      var radius = this.radius,\n        layers = this.layers,\n        spacing = this.spacing,\n        rotationX = this.rotationX,\n        strokeWidth = this.strokeWidth;\n\n      // Convert rotation to radians\n      var rotationRadX = rotationX * Math.PI / 180;\n\n      // Calculate the distance between each layer\n      var layerDistance = 2 * radius / (layers + 1);\n\n      // Generate horizontal slices of the sphere\n      for (var i = 0; i < layers; i++) {\n        // Position along the y-axis, from -radius+layerDistance to radius-layerDistance\n        var y = -radius + layerDistance * (i + 1);\n\n        // Calculate the radius of this horizontal slice using the circle equation\n        // r = R - y where R is the sphere radius and y is the height\n        var sliceRadius = Math.sqrt(radius * radius - y * y);\n\n        // Apply the perspective by compressing the height\n        var projectedY = y * Math.cos(rotationRadX);\n\n        // Draw the circle for this layer\n        elements.push(\"<ellipse \\n          cx=\\\"0\\\" \\n          cy=\\\"\".concat(projectedY, \"\\\" \\n          rx=\\\"\").concat(sliceRadius, \"\\\" \\n          ry=\\\"\").concat(sliceRadius * Math.sin(rotationRadX), \"\\\" \\n          stroke=\\\"white\\\" \\n          stroke-width=\\\"\").concat(strokeWidth, \"\\\" \\n          fill=\\\"none\\\" \\n        />\"));\n      }\n      return elements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(ConcentricSphereShape, \"parameters\", {\n  radius: {\n    min: 50,\n    max: 100,\n    \"default\": 100\n  },\n  layers: {\n    min: 3,\n    max: 30,\n    \"default\": 12\n  },\n  spacing: {\n    min: 0.1,\n    max: 2,\n    \"default\": 1\n  },\n  rotationX: {\n    min: 1,\n    max: 90,\n    \"default\": 30\n  },\n  strokeWidth: {\n    min: 0.5,\n    max: 5,\n    \"default\": 1.5\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ConcentricSphereShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/ConcentricSphereShape.js?");

/***/ }),

/***/ "./src/shapes/ConcentricTarget.js":
/*!****************************************!*\
  !*** ./src/shapes/ConcentricTarget.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a target-like pattern of concentric rings with adjustable count,\n * spacing, and thickness distribution.\n */\nvar ConcentricTarget = /*#__PURE__*/function (_Shape) {\n  function ConcentricTarget() {\n    _classCallCheck(this, ConcentricTarget);\n    return _callSuper(this, ConcentricTarget, arguments);\n  }\n  _inherits(ConcentricTarget, _Shape);\n  return _createClass(ConcentricTarget, [{\n    key: \"validateParameters\",\n    value: function validateParameters() {\n      // Ensure we have valid parameters\n      this.ringCount = Math.min(8, Math.max(2, this.ringCount));\n      this.outerThickness = Math.min(40, Math.max(5, this.outerThickness));\n      this.innerThickness = Math.min(30, Math.max(3, this.innerThickness));\n\n      // Check if we have enough space for all rings\n      var totalSpace = this.maxRadius;\n      var thicknessSum = this.calculateTotalThickness();\n      var spacingNeeded = (this.ringCount - 1) * this.spacing;\n      if (thicknessSum + spacingNeeded > totalSpace) {\n        // Reduce ring count if needed\n        this.ringCount = Math.max(2, Math.floor((totalSpace - this.outerThickness) / ((this.outerThickness + this.innerThickness) / 2 + this.spacing)));\n      }\n    }\n  }, {\n    key: \"calculateTotalThickness\",\n    value: function calculateTotalThickness() {\n      var total = 0;\n      var thicknesses = this.calculateRingThicknesses();\n      thicknesses.forEach(function (t) {\n        return total += t;\n      });\n      return total;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var elements = [];\n      var rings = this.calculateRings();\n\n      // Generate each ring\n      for (var i = 0; i < rings.length; i++) {\n        elements.push(\"<circle \\n                cx=\\\"0\\\" \\n                cy=\\\"0\\\" \\n                r=\\\"\".concat(rings[i].radius, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(rings[i].thickness, \"\\\"\\n                fill=\\\"none\\\"\\n            />\"));\n      }\n\n      // Add center dot if requested\n      if (this.centerDotSize > 0) {\n        elements.push(\"<circle \\n                cx=\\\"0\\\" \\n                cy=\\\"0\\\" \\n                r=\\\"\".concat(this.centerDotSize, \"\\\"\\n                fill=\\\"white\\\"\\n                stroke=\\\"none\\\"\\n            />\"));\n      }\n      return elements.join('');\n    }\n  }, {\n    key: \"calculateRings\",\n    value: function calculateRings() {\n      var rings = [];\n      var thicknesses = this.calculateRingThicknesses();\n      var currentRadius = this.maxRadius;\n      for (var i = 0; i < this.ringCount; i++) {\n        var thickness = thicknesses[i];\n        rings.push({\n          radius: currentRadius,\n          thickness: thickness\n        });\n\n        // Calculate the inner edge of current ring\n        var innerEdge = currentRadius - thickness;\n\n        // Next ring's radius is after the spacing\n        currentRadius = innerEdge - this.spacing;\n\n        // Stop if we're getting too small\n        if (currentRadius < this.centerDotSize * 2) {\n          break;\n        }\n      }\n      return rings;\n    }\n  }, {\n    key: \"calculateRingThicknesses\",\n    value: function calculateRingThicknesses() {\n      var thicknesses = [];\n      switch (this.thicknessPattern) {\n        case 'ascending':\n          // Thinner outer rings, thicker inner rings\n          for (var i = 0; i < this.ringCount; i++) {\n            var ratio = i / (this.ringCount - 1);\n            var thickness = this.innerThickness + ratio * (this.outerThickness - this.innerThickness);\n            thicknesses.push(thickness);\n          }\n          break;\n        case 'alternating':\n          // Alternate between thick and thin\n          for (var _i = 0; _i < this.ringCount; _i++) {\n            thicknesses.push(_i % 2 === 0 ? this.outerThickness : this.innerThickness);\n          }\n          break;\n        case 'random':\n          // Random thickness between inner and outer values\n          for (var _i2 = 0; _i2 < this.ringCount; _i2++) {\n            var randomFactor = Math.random();\n            var _thickness = this.innerThickness + randomFactor * (this.outerThickness - this.innerThickness);\n            thicknesses.push(_thickness);\n          }\n          break;\n        case 'descending':\n        default:\n          // Thicker outer rings, thinner inner rings (default)\n          for (var _i3 = 0; _i3 < this.ringCount; _i3++) {\n            var _ratio = _i3 / (this.ringCount - 1);\n            var _thickness2 = this.outerThickness - _ratio * (this.outerThickness - this.innerThickness);\n            thicknesses.push(_thickness2);\n          }\n          break;\n      }\n      return thicknesses;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(ConcentricTarget, \"parameters\", {\n  maxRadius: {\n    min: 30,\n    max: 90,\n    \"default\": 80\n  },\n  ringCount: {\n    min: 2,\n    max: 8,\n    \"default\": 4\n  },\n  outerThickness: {\n    min: 5,\n    max: 40,\n    \"default\": 20\n  },\n  innerThickness: {\n    min: 3,\n    max: 30,\n    \"default\": 10\n  },\n  spacing: {\n    min: 3,\n    max: 40,\n    \"default\": 15\n  },\n  centerDotSize: {\n    min: 0,\n    max: 25,\n    \"default\": 8\n  },\n  thicknessPattern: {\n    options: ['descending', 'ascending', 'alternating', 'random'],\n    \"default\": 'descending'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ConcentricTarget);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/ConcentricTarget.js?");

/***/ }),

/***/ "./src/shapes/ConicalShape.js":
/*!************************************!*\
  !*** ./src/shapes/ConicalShape.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a wireframe representation of a cone or frustum with optional\n * filled/outlined ends and dashed sides.\n */\nvar ConicalShape = /*#__PURE__*/function (_Shape) {\n  function ConicalShape() {\n    _classCallCheck(this, ConicalShape);\n    return _callSuper(this, ConicalShape, arguments);\n  }\n  _inherits(ConicalShape, _Shape);\n  return _createClass(ConicalShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Convert string parameters to boolean\n      var topFilledBool = this.topFilled === 'true';\n      var bottomFilledBool = this.bottomFilled === 'true';\n\n      // Calculate positions\n      var halfHeight = this.height / 2;\n      var topY = -halfHeight;\n      var bottomY = halfHeight;\n\n      // Apply rotation if needed\n      var rotationTransform = this.rotation !== 0 ? \"transform=\\\"rotate(\".concat(this.rotation, \")\\\"\") : '';\n\n      // Create the elements array\n      var elements = [];\n\n      // Create the conical sides (two lines)\n      var dashArray = this.dashEffect > 0 ? \"stroke-dasharray=\\\"\".concat(this.dashEffect / 10, \", \").concat(this.dashEffect / 20, \"\\\"\") : '';\n\n      // Left side line\n      elements.push(\"<line \\n            x1=\\\"-\".concat(this.topRadius, \"\\\" \\n            y1=\\\"\").concat(topY, \"\\\" \\n            x2=\\\"-\").concat(this.bottomRadius, \"\\\" \\n            y2=\\\"\").concat(bottomY, \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"2\\\"\\n            \").concat(dashArray, \"\\n            \").concat(rotationTransform, \"\\n        />\"));\n\n      // Right side line\n      elements.push(\"<line \\n            x1=\\\"\".concat(this.topRadius, \"\\\" \\n            y1=\\\"\").concat(topY, \"\\\" \\n            x2=\\\"\").concat(this.bottomRadius, \"\\\" \\n            y2=\\\"\").concat(bottomY, \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"2\\\"\\n            \").concat(dashArray, \"\\n            \").concat(rotationTransform, \"\\n        />\"));\n\n      // Top circle\n      if (topFilledBool) {\n        elements.push(\"<circle \\n                cx=\\\"0\\\" \\n                cy=\\\"\".concat(topY, \"\\\" \\n                r=\\\"\").concat(this.topRadius, \"\\\"\\n                fill=\\\"white\\\"\\n                \").concat(rotationTransform, \"\\n            />\"));\n      } else {\n        elements.push(\"<circle \\n                cx=\\\"0\\\" \\n                cy=\\\"\".concat(topY, \"\\\" \\n                r=\\\"\").concat(this.topRadius, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"2\\\"\\n                fill=\\\"none\\\"\\n                \").concat(rotationTransform, \"\\n            />\"));\n      }\n\n      // Bottom circle\n      if (bottomFilledBool) {\n        elements.push(\"<ellipse \\n                cx=\\\"0\\\" \\n                cy=\\\"\".concat(bottomY, \"\\\" \\n                rx=\\\"\").concat(this.bottomRadius, \"\\\"\\n                ry=\\\"\").concat(this.bottomRadius * 0.3, \"\\\" \\n                fill=\\\"white\\\"\\n                \").concat(rotationTransform, \"\\n            />\"));\n      } else {\n        elements.push(\"<ellipse \\n                cx=\\\"0\\\" \\n                cy=\\\"\".concat(bottomY, \"\\\" \\n                rx=\\\"\").concat(this.bottomRadius, \"\\\"\\n                ry=\\\"\").concat(this.bottomRadius * 0.3, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"2\\\"\\n                fill=\\\"none\\\"\\n                \").concat(rotationTransform, \"\\n            />\"));\n      }\n      return elements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(ConicalShape, \"parameters\", {\n  topRadius: {\n    min: 10,\n    max: 80,\n    \"default\": 15\n  },\n  bottomRadius: {\n    min: 20,\n    max: 150,\n    \"default\": 80\n  },\n  height: {\n    min: 50,\n    max: 150,\n    \"default\": 150\n  },\n  dashEffect: {\n    min: 0,\n    max: 100,\n    \"default\": 70\n  },\n  topFilled: {\n    options: ['true', 'false'],\n    \"default\": 'true'\n  },\n  bottomFilled: {\n    options: ['true', 'false'],\n    \"default\": 'true'\n  },\n  rotation: {\n    min: -180,\n    max: 180,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ConicalShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/ConicalShape.js?");

/***/ }),

/***/ "./src/shapes/ConnectedNodesShape.js":
/*!*******************************************!*\
  !*** ./src/shapes/ConnectedNodesShape.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a network-like structure with a central node and several outer\n * nodes connected by lines, using Perlin noise for placement.\n */\nvar ConnectedNodesShape = /*#__PURE__*/function (_Shape) {\n  function ConnectedNodesShape() {\n    _classCallCheck(this, ConnectedNodesShape);\n    return _callSuper(this, ConnectedNodesShape, arguments);\n  }\n  _inherits(ConnectedNodesShape, _Shape);\n  return _createClass(ConnectedNodesShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      this.resetRNG();\n      var elements = [];\n      var nodes = [];\n      var nodeCount = this.nodeCount,\n        maxRadius = this.maxRadius,\n        minRadius = this.minRadius,\n        connectionOpacity = this.connectionOpacity,\n        spread = this.spread;\n\n      // Generate central node\n      nodes.push({\n        x: 0,\n        y: 0,\n        radius: minRadius\n      });\n\n      // Generate outer nodes with perlin noise influence\n      var attempts = 0;\n      var maxAttempts = nodeCount * 100;\n      while (nodes.length < nodeCount + 1 && attempts < maxAttempts) {\n        attempts++;\n\n        // Base position with some randomness\n        var angle = attempts % nodeCount / nodeCount * Math.PI * 2 + this.random() * 0.5;\n        var baseDistance = this.random() * spread * 0.7 + spread * 0.3;\n\n        // Apply noise influence\n        var noiseValue = this.getNoise(Math.cos(angle), Math.sin(angle));\n        var noiseFactor = 0.2 + noiseValue * 0.3;\n        var distance = baseDistance * (1 + noiseFactor);\n        var x = Math.cos(angle) * distance;\n        var y = Math.sin(angle) * distance;\n\n        // Determine radius with some noise influence\n        var radiusNoise = this.getNoise(x / 100, y / 100) * 0.5 + 0.5;\n        var radius = minRadius + radiusNoise * (maxRadius - minRadius);\n\n        // Check for overlap with existing nodes\n        var overlaps = false;\n        var _iterator = _createForOfIteratorHelper(nodes),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var node = _step.value;\n            var dx = node.x - x;\n            var dy = node.y - y;\n            var _distance = Math.sqrt(dx * dx + dy * dy);\n            if (_distance < node.radius + radius + 5) {\n              overlaps = true;\n              break;\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        if (!overlaps) {\n          nodes.push({\n            x: x,\n            y: y,\n            radius: radius\n          });\n        }\n      }\n\n      // Draw connections first (so they appear behind nodes)\n      for (var i = 1; i < nodes.length; i++) {\n        var _node = nodes[i];\n        elements.push(\"<line x1=\\\"0\\\" y1=\\\"0\\\" x2=\\\"\".concat(_node.x, \"\\\" y2=\\\"\").concat(_node.y, \"\\\" stroke=\\\"white\\\" stroke-width=\\\"1.5\\\" opacity=\\\"\").concat(connectionOpacity, \"\\\" />\"));\n      }\n\n      // Draw nodes\n      nodes.forEach(function (node) {\n        elements.push(\"<circle cx=\\\"\".concat(node.x, \"\\\" cy=\\\"\").concat(node.y, \"\\\" r=\\\"\").concat(node.radius, \"\\\" fill=\\\"white\\\" />\"));\n      });\n      return elements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(ConnectedNodesShape, \"parameters\", {\n  nodeCount: {\n    min: 4,\n    max: 12,\n    \"default\": 8\n  },\n  maxRadius: {\n    min: 5,\n    max: 30,\n    \"default\": 25\n  },\n  minRadius: {\n    min: 3,\n    max: 15,\n    \"default\": 8\n  },\n  connectionOpacity: {\n    min: 0.2,\n    max: 1,\n    \"default\": 0.6\n  },\n  spread: {\n    min: 30,\n    max: 60,\n    \"default\": 80\n  },\n  noiseScale: {\n    min: 0.1,\n    max: 1.5,\n    \"default\": 0.5\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ConnectedNodesShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/ConnectedNodesShape.js?");

/***/ }),

/***/ "./src/shapes/ConnectedPillsShape.js":
/*!*******************************************!*\
  !*** ./src/shapes/ConnectedPillsShape.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Creates a shape featuring two vertical, rounded 'pill' rectangles connected\n * or overlapped by a central circle.\n */\nvar ConnectedPillsShape = /*#__PURE__*/function (_Shape) {\n  function ConnectedPillsShape() {\n    _classCallCheck(this, ConnectedPillsShape);\n    return _callSuper(this, ConnectedPillsShape, arguments);\n  }\n  _inherits(ConnectedPillsShape, _Shape);\n  return _createClass(ConnectedPillsShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Apply scale factor to match viewBox\n      var scale = 0.8; // Adjust scale to fit -200,200 coordinate space\n      var pillHeight = this.pillHeight * scale;\n      var pillWidth = this.pillWidth * scale;\n      var spacing = this.spacing * scale;\n      var cornerRadius = this.cornerRadius * scale;\n      var circleSize = this.centerCircleSize * scale;\n\n      // Calculate positions\n      var centerX = 0;\n      var centerY = 0;\n\n      // Create the paths\n      var paths = [];\n\n      // Left pill rounded rectangle\n      var leftX = centerX - spacing / 2 - pillWidth;\n      var leftY = centerY - pillHeight / 2;\n      paths.push(this.createRoundedRect(leftX, leftY, pillWidth, pillHeight, cornerRadius));\n\n      // Right pill rounded rectangle\n      var rightX = centerX + spacing / 2;\n      var rightY = centerY - pillHeight / 2;\n      paths.push(this.createRoundedRect(rightX, rightY, pillWidth, pillHeight, cornerRadius));\n\n      // Center circle\n      var circleX = centerX;\n      var circleY = centerY;\n      var circle = \"\\n            <circle \\n                cx=\\\"\".concat(circleX, \"\\\"\\n                cy=\\\"\").concat(circleY, \"\\\"\\n                r=\\\"\").concat(circleSize / 2, \"\\\"\\n                fill=\\\"white\\\"\\n            />\\n        \");\n      paths.push(circle);\n      return paths.join('\\n');\n    }\n  }, {\n    key: \"createRoundedRect\",\n    value: function createRoundedRect(x, y, width, height, radius) {\n      // Create SVG path for rounded rectangle\n      var commands = [// Start at top left after the corner radius\n      \"M \".concat(x + radius, \" \").concat(y), // Top line to right corner\n      \"H \".concat(x + width - radius), // Top right corner\n      \"A \".concat(radius, \" \").concat(radius, \" 0 0 1 \").concat(x + width, \" \").concat(y + radius), // Right line\n      \"V \".concat(y + height - radius), // Bottom right corner\n      \"A \".concat(radius, \" \").concat(radius, \" 0 0 1 \").concat(x + width - radius, \" \").concat(y + height), // Bottom line\n      \"H \".concat(x + radius), // Bottom left corner\n      \"A \".concat(radius, \" \").concat(radius, \" 0 0 1 \").concat(x, \" \").concat(y + height - radius), // Left line\n      \"V \".concat(y + radius), // Top left corner\n      \"A \".concat(radius, \" \").concat(radius, \" 0 0 1 \").concat(x + radius, \" \").concat(y),\n      // Close path\n      'Z'];\n      return \"\\n            <path \\n                d=\\\"\".concat(commands.join(' '), \"\\\"\\n                fill=\\\"white\\\"\\n            />\\n        \");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(ConnectedPillsShape, \"parameters\", {\n  pillHeight: {\n    min: 100,\n    max: 300,\n    \"default\": 240\n  },\n  pillWidth: {\n    min: 40,\n    max: 120,\n    \"default\": 85\n  },\n  spacing: {\n    min: 0,\n    max: 100,\n    \"default\": 15\n  },\n  cornerRadius: {\n    min: 20,\n    max: 60,\n    \"default\": 42\n  },\n  centerCircleSize: {\n    min: 20,\n    max: 100,\n    \"default\": 85\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ConnectedPillsShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/ConnectedPillsShape.js?");

/***/ }),

/***/ "./src/shapes/CoralGrowth.js":
/*!***********************************!*\
  !*** ./src/shapes/CoralGrowth.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Creates a generative coral-like branching structure with adjustable levels,\n * length/width decay, and randomness.\n */\nvar CoralGrowth = /*#__PURE__*/function (_Shape) {\n  function CoralGrowth() {\n    _classCallCheck(this, CoralGrowth);\n    return _callSuper(this, CoralGrowth, arguments);\n  }\n  _inherits(CoralGrowth, _Shape);\n  return _createClass(CoralGrowth, [{\n    key: \"generateShape\",\n    value:\n    /**\n     * Generates the SVG elements for the CoralGrowth shape.\n     * Accesses parameters via `this.parameterName`.\n     * @returns {string} SVG string containing <path> elements for the coral structure.\n     */\n    function generateShape() {\n      var paths = [];\n      var baseY = this.baseYOffset; // Start branches from the bottom part of the viewbox\n\n      // Generate initial branches\n      for (var i = 0; i < this.initialBranches; i++) {\n        // Distribute initial angles somewhat evenly but with randomness, pointing upwards\n        var baseAngle = -Math.PI / 2; // Straight up\n        var angleOffset = (i / (this.initialBranches - 1 || 1) - 0.5) * (Math.PI * 0.6); // Spread initial branches slightly\n        var initialAngle = baseAngle + angleOffset + (this.random() - 0.5) * Math.PI * 0.2 * this.randomness;\n        this.growBranch(0,\n        // Start X at center\n        baseY,\n        // Start Y at base offset\n        initialAngle, this.initialLength, this.initialWidth, 0,\n        // Initial level\n        paths);\n      }\n\n      // Group paths by stroke-width for potential optimization (optional, but good practice)\n      var pathsByWidth = paths.reduce(function (acc, path) {\n        var width = path.width;\n        if (!acc[width]) {\n          acc[width] = [];\n        }\n        acc[width].push(path.d);\n        return acc;\n      }, {});\n      var svgString = '';\n      // Render paths from thickest to thinnest for better visual layering\n      var sortedWidths = Object.keys(pathsByWidth).map(parseFloat).sort(function (a, b) {\n        return b - a;\n      });\n      var _iterator = _createForOfIteratorHelper(sortedWidths),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var width = _step.value;\n          var dCombined = pathsByWidth[width].join(' ');\n          svgString += \"<path d=\\\"\".concat(dCombined, \"\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(width.toFixed(2), \"\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\" fill=\\\"none\\\" />\\n\");\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return svgString;\n    }\n\n    /**\n     * Recursively generates branches for the coral structure.\n     * @param {number} startX - Starting X coordinate of the branch.\n     * @param {number} startY - Starting Y coordinate of the branch.\n     * @param {number} angle - Angle of the branch in radians.\n     * @param {number} length - Length of the branch segment.\n     * @param {number} width - Stroke width of the branch segment.\n     * @param {number} level - Current branching level.\n     * @param {Array<object>} paths - Array to store the generated path data strings and widths.\n     */\n  }, {\n    key: \"growBranch\",\n    value: function growBranch(startX, startY, angle, length, width, level, paths) {\n      // Termination condition\n      if (level >= this.levels || length < 1 || width < 0.5) {\n        return;\n      }\n\n      // Introduce randomness to angle and length\n      var currentAngle = angle + (this.random() - 0.5) * (this.angleSpread * Math.PI / 180) * this.randomness * (level > 0 ? 1 : 0.5); // Less randomness for initial angle\n      var currentLength = length * (1 + (this.random() - 0.5) * 0.5 * this.randomness);\n\n      // Calculate end point\n      var endX = startX + currentLength * Math.cos(currentAngle);\n      var endY = startY + currentLength * Math.sin(currentAngle);\n\n      // Prevent branches from going too far down (past the base) or excessively wide/high\n      if (endY > this.baseYOffset + 10 || Math.abs(endX) > 100 || endY < -100) {\n        // Stop this branch if it goes out of reasonable bounds\n        return;\n      }\n\n      // Calculate control point for quadratic Bezier curve\n      var midX = (startX + endX) / 2;\n      var midY = (startY + endY) / 2;\n      var perpAngle = currentAngle + Math.PI / 2; // Perpendicular angle\n      var curveOffset = currentLength * this.curveFactor * (this.random() - 0.5) * 2; // Random offset distance for curve\n      var ctrlX = midX + curveOffset * Math.cos(perpAngle);\n      var ctrlY = midY + curveOffset * Math.sin(perpAngle);\n\n      // Create path data string using quadratic curve\n      var pathData = \"M \".concat(startX.toFixed(2), \",\").concat(startY.toFixed(2), \" Q \").concat(ctrlX.toFixed(2), \",\").concat(ctrlY.toFixed(2), \" \").concat(endX.toFixed(2), \",\").concat(endY.toFixed(2));\n      paths.push({\n        d: pathData,\n        width: width\n      });\n\n      // Determine number of child branches (usually 1 or 2)\n      var numChildren = this.random() < 0.65 && level < this.levels - 1 ? 2 : 1; // More likely to branch earlier\n\n      // Recursively grow child branches\n      for (var i = 0; i < numChildren; i++) {\n        var spreadSign = numChildren == 1 ? (this.random() - 0.5) * 2 : i === 0 ? -1 : 1; // Spread children left/right if two\n        var branchAngleOffset = spreadSign * (this.angleSpread / 2 * Math.PI / 180) * (0.5 + this.random() * 0.5); // Angle relative to parent\n\n        var nextAngle = currentAngle + branchAngleOffset;\n        var nextLength = currentLength * this.lengthDecay;\n        var nextWidth = Math.max(0.5, width * this.widthDecay); // Ensure minimum width\n\n        this.growBranch(endX, endY, nextAngle, nextLength, nextWidth, level + 1, paths);\n      }\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(CoralGrowth, \"parameters\", {\n  levels: {\n    type: 'number',\n    min: 1,\n    max: 6,\n    step: 1,\n    \"default\": 4,\n    label: 'Branching Levels'\n  },\n  initialBranches: {\n    type: 'number',\n    min: 2,\n    max: 15,\n    step: 1,\n    \"default\": 7,\n    label: 'Initial Branches'\n  },\n  initialLength: {\n    type: 'number',\n    min: 20,\n    max: 80,\n    step: 1,\n    \"default\": 55,\n    label: 'Initial Length'\n  },\n  initialWidth: {\n    type: 'number',\n    min: 3,\n    max: 25,\n    step: 1,\n    \"default\": 14,\n    label: 'Initial Width'\n  },\n  lengthDecay: {\n    type: 'number',\n    min: 0.5,\n    max: 0.95,\n    step: 0.01,\n    \"default\": 0.75,\n    label: 'Length Decay'\n  },\n  widthDecay: {\n    type: 'number',\n    min: 0.5,\n    max: 0.95,\n    step: 0.01,\n    \"default\": 0.7,\n    label: 'Width Decay'\n  },\n  angleSpread: {\n    type: 'number',\n    min: 15,\n    max: 120,\n    step: 1,\n    \"default\": 60,\n    label: 'Angle Spread ()'\n  },\n  randomness: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    step: 0.05,\n    \"default\": 0.4,\n    label: 'Randomness'\n  },\n  baseYOffset: {\n    type: 'number',\n    min: 40,\n    max: 95,\n    step: 1,\n    \"default\": 85,\n    label: 'Base Y Offset'\n  },\n  curveFactor: {\n    type: 'number',\n    min: 0,\n    max: 0.5,\n    step: 0.01,\n    \"default\": 0.2,\n    label: 'Curve Factor'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CoralGrowth);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/CoralGrowth.js?");

/***/ }),

/***/ "./src/shapes/CornerRays.js":
/*!**********************************!*\
  !*** ./src/shapes/CornerRays.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a shape consisting of a solid triangle filling one corner of a square,\n * and rays emanating from the same corner, filling the other triangle part.\n */\nvar CornerRays = /*#__PURE__*/function (_Shape) {\n  function CornerRays() {\n    _classCallCheck(this, CornerRays);\n    return _callSuper(this, CornerRays, arguments);\n  }\n  _inherits(CornerRays, _Shape);\n  return _createClass(CornerRays, [{\n    key: \"generateShape\",\n    value:\n    /**\n     * Generates the SVG elements for the corner rays shape.\n     * @returns {string} SVG string containing a <polygon> and multiple <line> elements.\n     */\n    function generateShape() {\n      var s = this.size / 2; // Half size\n\n      // Define square corners based on size, centered at (0,0)\n      var O = {\n        x: -s,\n        y: -s\n      }; // Top-left corner (Origin for rays)\n      var TR = {\n        x: s,\n        y: -s\n      }; // Top-right corner\n      var BR = {\n        x: s,\n        y: s\n      }; // Bottom-right corner\n      var BL = {\n        x: -s,\n        y: s\n      }; // Bottom-left corner\n\n      // 1. Solid triangle (filling the bottom-left section relative to the main diagonal)\n      // Points are Origin (TL), Bottom-Left (BL), Bottom-Right (BR)\n      var trianglePoints = \"\".concat(O.x.toFixed(2), \",\").concat(O.y.toFixed(2), \" \") + \"\".concat(BL.x.toFixed(2), \",\").concat(BL.y.toFixed(2), \" \") + \"\".concat(BR.x.toFixed(2), \",\").concat(BR.y.toFixed(2));\n      var triangle = \"<polygon points=\\\"\".concat(trianglePoints, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\");\n\n      // 2. Rays (filling the top-right section relative to the main diagonal)\n      // Rays emanate from Origin (O) and end on the line segment from Top-Right (TR) to Bottom-Right (BR)\n      var rays = [];\n      if (this.numRays >= 2) {\n        // Calculate the vertical distance between ray endpoints on the right edge\n        var yStep = (BR.y - TR.y) / (this.numRays - 1);\n        for (var i = 0; i < this.numRays; i++) {\n          var endY = TR.y + i * yStep;\n          var endX = TR.x; // All rays end on the right edge (x = s)\n\n          // Add line element for the ray\n          rays.push(\"<line x1=\\\"\".concat(O.x.toFixed(2), \"\\\" y1=\\\"\").concat(O.y.toFixed(2), \"\\\"\\n                           x2=\\\"\").concat(endX.toFixed(2), \"\\\" y2=\\\"\").concat(endY.toFixed(2), \"\\\"\\n                           stroke=\\\"white\\\" stroke-width=\\\"\").concat(this.strokeWidth, \"\\\" />\"));\n        }\n      } else if (this.numRays === 1) {\n        // Handle the case of a single ray: point it to the middle of the target edge segment (TR to BR)\n        var _endX = TR.x;\n        var _endY = (TR.y + BR.y) / 2;\n        rays.push(\"<line x1=\\\"\".concat(O.x.toFixed(2), \"\\\" y1=\\\"\").concat(O.y.toFixed(2), \"\\\"\\n                           x2=\\\"\").concat(_endX.toFixed(2), \"\\\" y2=\\\"\").concat(_endY.toFixed(2), \"\\\"\\n                           stroke=\\\"white\\\" stroke-width=\\\"\").concat(this.strokeWidth, \"\\\" />\"));\n      }\n\n      // Combine the solid triangle and the ray lines\n      return triangle + '\\n' + rays.join('\\n');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(CornerRays, \"parameters\", {\n  size: {\n    type: 'number',\n    min: 20,\n    max: 198,\n    // Keep within viewBox with some margin\n    step: 1,\n    \"default\": 160,\n    label: 'Square Size'\n  },\n  numRays: {\n    type: 'number',\n    min: 1,\n    max: 30,\n    step: 1,\n    \"default\": 5,\n    label: 'Number of Rays'\n  },\n  strokeWidth: {\n    type: 'number',\n    min: 0.5,\n    max: 10,\n    step: 0.5,\n    \"default\": 2,\n    label: 'Ray Stroke Width'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CornerRays);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/CornerRays.js?");

/***/ }),

/***/ "./src/shapes/CpuChip.js":
/*!*******************************!*\
  !*** ./src/shapes/CpuChip.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a simplified representation of a CPU chip with a central square\n * core and radiating pins on all sides.\n */\nvar CpuChip = /*#__PURE__*/function (_Shape) {\n  function CpuChip() {\n    _classCallCheck(this, CpuChip);\n    return _callSuper(this, CpuChip, arguments);\n  }\n  _inherits(CpuChip, _Shape);\n  return _createClass(CpuChip, [{\n    key: \"generateShape\",\n    value:\n    /**\n     * Generates the SVG elements for the CpuChip shape.\n     * Accesses parameters via `this.parameterName`.\n     * @param {object} params - An object containing the parameter values for this shape instance (available as this.parameterName).\n     * @returns {string} SVG string containing elements like <path>, <circle>, <polyline>, etc.\n     */\n    function generateShape(params) {\n      var halfCore = this.coreSize / 2;\n      // Avoid division by zero if pinCount is 0, though min is 1\n      var pinInterval = this.pinCount > 0 ? this.coreSize / (this.pinCount + 1) : this.coreSize;\n      var elements = [];\n\n      // Central core rectangle\n      elements.push(\"<rect x=\\\"\".concat(-halfCore, \"\\\" y=\\\"\").concat(-halfCore, \"\\\" width=\\\"\").concat(this.coreSize, \"\\\" height=\\\"\").concat(this.coreSize, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\"));\n\n      // Pins radiating from each side\n      for (var i = 1; i <= this.pinCount; i++) {\n        var position = -halfCore + pinInterval * i;\n\n        // Top pins\n        elements.push(\"<line x1=\\\"\".concat(position, \"\\\" y1=\\\"\").concat(-halfCore, \"\\\" x2=\\\"\").concat(position, \"\\\" y2=\\\"\").concat(-halfCore - this.pinLength, \"\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(this.pinWidth, \"\\\" />\"));\n        // Bottom pins\n        elements.push(\"<line x1=\\\"\".concat(position, \"\\\" y1=\\\"\").concat(halfCore, \"\\\" x2=\\\"\").concat(position, \"\\\" y2=\\\"\").concat(halfCore + this.pinLength, \"\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(this.pinWidth, \"\\\" />\"));\n        // Left pins\n        elements.push(\"<line x1=\\\"\".concat(-halfCore, \"\\\" y1=\\\"\").concat(position, \"\\\" x2=\\\"\").concat(-halfCore - this.pinLength, \"\\\" y2=\\\"\").concat(position, \"\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(this.pinWidth, \"\\\" />\"));\n        // Right pins\n        elements.push(\"<line x1=\\\"\".concat(halfCore, \"\\\" y1=\\\"\").concat(position, \"\\\" x2=\\\"\").concat(halfCore + this.pinLength, \"\\\" y2=\\\"\").concat(position, \"\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(this.pinWidth, \"\\\" />\"));\n      }\n      return elements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(CpuChip, \"parameters\", {\n  coreSize: {\n    type: 'number',\n    min: 10,\n    max: 100,\n    step: 2,\n    \"default\": 40\n  },\n  pinLength: {\n    type: 'number',\n    min: 5,\n    max: 50,\n    step: 1,\n    \"default\": 20\n  },\n  pinWidth: {\n    type: 'number',\n    min: 1,\n    max: 10,\n    step: 0.5,\n    \"default\": 2\n  },\n  pinCount: {\n    type: 'number',\n    min: 1,\n    max: 10,\n    step: 1,\n    \"default\": 5\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CpuChip);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/CpuChip.js?");

/***/ }),

/***/ "./src/shapes/CrescentKites.js":
/*!*************************************!*\
  !*** ./src/shapes/CrescentKites.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a symmetrical abstract shape with outer circular crescents and\n * inner curved, kite-like forms.\n */\nvar CrescentKites = /*#__PURE__*/function (_Shape) {\n  function CrescentKites() {\n    _classCallCheck(this, CrescentKites);\n    return _callSuper(this, CrescentKites, arguments);\n  }\n  _inherits(CrescentKites, _Shape);\n  return _createClass(CrescentKites, [{\n    key: \"generateShape\",\n    value:\n    /**\n     * Generates the SVG elements for the CrescentKites shape.\n     * Accesses parameters via `this.parameterName`.\n     * @param {object} params - An object containing the parameter values for this shape instance (available as this.parameterName).\n     * @returns {string} SVG string containing multiple <path> elements.\n     */\n    function generateShape(params) {\n      // Access parameters using `this`\n      var r = this.outerRadius;\n      var yCrescent = this.crescentY;\n      var innerW = this.innerWidth / 2; // Use half-width for calculations\n      var innerH = this.innerHeight / 2; // Use half-height\n      var k = this.innerCurviness; // Curviness factor\n\n      // Clamp crescentY to be within the radius\n      yCrescent = Math.min(yCrescent, r - 0.1);\n      if (yCrescent <= 0) return ''; // Invalid crescents\n\n      var f = function f(num) {\n        return num.toFixed(3);\n      }; // Formatting helper\n\n      // --- Calculate Crescent Points ---\n      // Solve for x: x^2 + y^2 = r^2 => x = sqrt(r^2 - y^2)\n      var xCrescent = Math.sqrt(r * r - yCrescent * yCrescent);\n      var svgElements = [];\n\n      // --- 1. Outer Crescents (Filled Segments) ---\n      // Top Crescent: Arc from (-x, y) to (x, y), sweep 1\n      var dTopCrescent = \"M \".concat(f(-xCrescent), \",\").concat(f(yCrescent), \" A \").concat(f(r), \",\").concat(f(r), \" 0 0 1 \").concat(f(xCrescent), \",\").concat(f(yCrescent), \" L \").concat(f(-xCrescent), \",\").concat(f(yCrescent), \" Z\");\n      svgElements.push(\"<path d=\\\"\".concat(dTopCrescent, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\"/>\"));\n\n      // Bottom Crescent: Arc from (x, -y) to (-x, -y), sweep 1\n      var dBottomCrescent = \"M \".concat(f(xCrescent), \",\").concat(f(-yCrescent), \" A \").concat(f(r), \",\").concat(f(r), \" 0 0 1 \").concat(f(-xCrescent), \",\").concat(f(-yCrescent), \" L \").concat(f(xCrescent), \",\").concat(f(-yCrescent), \" Z\");\n      svgElements.push(\"<path d=\\\"\".concat(dBottomCrescent, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\"/>\"));\n\n      // --- 2. Inner Kite Shapes (Filled) ---\n      if (innerW > 0 && innerH > 0) {\n        // Define points for the right kite shape:\n        var pTop = {\n          x: 0,\n          y: innerH\n        }; // Top vertex on y-axis\n        var pRight = {\n          x: innerW,\n          y: 0\n        }; // Right vertex on x-axis\n        var pBottom = {\n          x: 0,\n          y: -innerH\n        }; // Bottom vertex on y-axis\n        var pCenter = {\n          x: 0,\n          y: 0\n        }; // Center vertex (cusp)\n\n        // Define control points for the outer curved edge using Cubic Bezier\n        // Curve from Top to Right\n        var cp1 = {\n          x: innerW * k,\n          y: innerH\n        }; // Control point near Top\n        var cp2 = {\n          x: innerW,\n          y: innerH * k\n        }; // Control point near Right\n        // Curve from Right to Bottom\n        var cp3 = {\n          x: innerW,\n          y: -innerH * k\n        }; // Control point near Right\n        var cp4 = {\n          x: innerW * k,\n          y: -innerH\n        }; // Control point near Bottom\n\n        // Path data for the right kite shape\n        // M top -> C cp1 cp2 right -> C cp3 cp4 bottom -> L center -> Z\n        var dRightKite = \"\\n                M \".concat(f(pTop.x), \",\").concat(f(pTop.y), \"\\n                C \").concat(f(cp1.x), \",\").concat(f(cp1.y), \" \").concat(f(cp2.x), \",\").concat(f(cp2.y), \" \").concat(f(pRight.x), \",\").concat(f(pRight.y), \"\\n                C \").concat(f(cp3.x), \",\").concat(f(cp3.y), \" \").concat(f(cp4.x), \",\").concat(f(cp4.y), \" \").concat(f(pBottom.x), \",\").concat(f(pBottom.y), \"\\n                L \").concat(f(pCenter.x), \",\").concat(f(pCenter.y), \"\\n                Z\\n            \");\n        svgElements.push(\"<path d=\\\"\".concat(dRightKite.replace(/\\s+/g, ' '), \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\"/>\"));\n\n        // Add the left kite shape by mirroring the right one\n        svgElements.push(\"<path d=\\\"\".concat(dRightKite.replace(/\\s+/g, ' '), \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" transform=\\\"scale(-1, 1)\\\"/>\"));\n      }\n      return svgElements.join('\\n');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(CrescentKites, \"parameters\", {\n  outerRadius: {\n    type: 'number',\n    min: 30,\n    max: 95,\n    step: 1,\n    \"default\": 85,\n    label: 'Outer Radius'\n  },\n  crescentY: {\n    type: 'number',\n    min: 5,\n    max: 90,\n    // Should be less than outerRadius\n    step: 1,\n    \"default\": 60,\n    label: 'Crescent Y-Extent'\n  },\n  innerWidth: {\n    type: 'number',\n    min: 10,\n    max: 150,\n    step: 1,\n    \"default\": 80,\n    label: 'Inner Shapes Width'\n  },\n  innerHeight: {\n    type: 'number',\n    min: 10,\n    max: 150,\n    step: 1,\n    \"default\": 40,\n    label: 'Inner Shapes Height'\n  },\n  innerCurviness: {\n    type: 'number',\n    min: 0.1,\n    max: 1.5,\n    // Allows bulging out or pinching in\n    step: 0.05,\n    \"default\": 0.65,\n    label: 'Inner Curviness Factor'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CrescentKites);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/CrescentKites.js?");

/***/ }),

/***/ "./src/shapes/CrescentShape.js":
/*!*************************************!*\
  !*** ./src/shapes/CrescentShape.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Creates a crescent shape by subtracting one circle from another using an SVG\n * mask, allowing variable thickness and offset.\n */\nvar CrescentShape = /*#__PURE__*/function (_Shape) {\n  function CrescentShape() {\n    _classCallCheck(this, CrescentShape);\n    return _callSuper(this, CrescentShape, arguments);\n  }\n  _inherits(CrescentShape, _Shape);\n  return _createClass(CrescentShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Calculate the offset position for the second circle\n      var angle = this.rotation * Math.PI / 180;\n      var offsetX = this.offset / 100 * this.radius * Math.cos(angle);\n      var offsetY = this.offset / 100 * this.radius * Math.sin(angle);\n\n      // Calculate the radius of the inner circle based on thickness\n      var innerRadius = this.radius - this.thickness;\n\n      // Create unique IDs for the mask elements\n      var maskId = \"crescent-mask-\".concat(Math.random().toString(36).substr(2, 9));\n      return \"\\n            <defs>\\n                <mask id=\\\"\".concat(maskId, \"\\\">\\n                    <circle \\n                        cx=\\\"0\\\" \\n                        cy=\\\"0\\\" \\n                        r=\\\"\").concat(this.radius, \"\\\"\\n                        fill=\\\"white\\\"\\n                    />\\n                    <circle \\n                        cx=\\\"\").concat(offsetX, \"\\\" \\n                        cy=\\\"\").concat(offsetY, \"\\\" \\n                        r=\\\"\").concat(innerRadius, \"\\\"\\n                        fill=\\\"black\\\"\\n                    />\\n                </mask>\\n            </defs>\\n            <rect \\n                x=\\\"-200\\\" \\n                y=\\\"-200\\\" \\n                width=\\\"400\\\" \\n                height=\\\"400\\\"\\n                fill=\\\"white\\\"\\n                mask=\\\"url(#\").concat(maskId, \")\\\"\\n            />\\n        \");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(CrescentShape, \"parameters\", {\n  radius: {\n    min: 20,\n    max: 150,\n    \"default\": 80\n  },\n  thickness: {\n    min: 1,\n    max: 100,\n    \"default\": 18\n  },\n  rotation: {\n    min: -360,\n    max: 360,\n    \"default\": 0\n  },\n  offset: {\n    min: 0,\n    max: 100,\n    \"default\": 57\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CrescentShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/CrescentShape.js?");

/***/ }),

/***/ "./src/shapes/CrossShape.js":
/*!**********************************!*\
  !*** ./src/shapes/CrossShape.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a cross shape with adjustable arm length, width, and optional\n * rounded ends.\n */\nvar CrossShape = /*#__PURE__*/function (_Shape) {\n  function CrossShape() {\n    _classCallCheck(this, CrossShape);\n    return _callSuper(this, CrossShape, arguments);\n  }\n  _inherits(CrossShape, _Shape);\n  return _createClass(CrossShape, [{\n    key: \"generateArmPoints\",\n    value: function generateArmPoints(angle) {\n      var al = this.armLength;\n      var aw = this.armWidth / 2;\n      var er = Math.min(this.endRadius, aw);\n\n      // Generate base points for a vertical arm\n      var points = [\n      // Center connection point\n      [aw, aw],\n      // Arm points with radius consideration\n      [aw, al - er],\n      // Top right before radius\n      [aw - er, al],\n      // Top right after radius\n      [-aw + er, al],\n      // Top left after radius\n      [-aw, al - er],\n      // Top left before radius\n      [-aw, aw] // Back to center\n      ];\n\n      // Apply rotation transformation\n      return points.map(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n          x = _ref2[0],\n          y = _ref2[1];\n        var rad = angle * Math.PI / 180;\n        return [x * Math.cos(rad) - y * Math.sin(rad), x * Math.sin(rad) + y * Math.cos(rad)];\n      });\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var path = [];\n      var armAngles = [0, 90, 180, 270];\n      var er = Math.min(this.endRadius, this.armWidth / 2);\n\n      // Generate each arm of the cross\n      for (var i = 0; i < armAngles.length; i++) {\n        var points = this.generateArmPoints(armAngles[i]);\n\n        // Start path or continue from last position\n        if (i === 0) {\n          path.push(\"M \".concat(points[0][0], \",\").concat(points[0][1]));\n        }\n\n        // Draw arm with optional end radius\n        path.push(\"L \".concat(points[1][0], \",\").concat(points[1][1]));\n        if (er > 0) {\n          // Add rounded corners at the end\n          path.push(\"A \".concat(er, \" \").concat(er, \" 0 0 1 \").concat(points[2][0], \",\").concat(points[2][1]), \"L \".concat(points[3][0], \",\").concat(points[3][1]), \"A \".concat(er, \" \").concat(er, \" 0 0 1 \").concat(points[4][0], \",\").concat(points[4][1]));\n        } else {\n          // Sharp corners\n          path.push(\"L \".concat(points[2][0], \",\").concat(points[2][1]), \"L \".concat(points[3][0], \",\").concat(points[3][1]), \"L \".concat(points[4][0], \",\").concat(points[4][1]));\n        }\n\n        // Connect back to center\n        path.push(\"L \".concat(points[5][0], \",\").concat(points[5][1]));\n      }\n      path.push('Z'); // Close the path\n      return \"<path d=\\\"\".concat(path.join(' '), \"\\\" fill=\\\"white\\\"/>\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(CrossShape, \"parameters\", {\n  armLength: {\n    min: 20,\n    max: 100,\n    \"default\": 60\n  },\n  armWidth: {\n    min: 10,\n    max: 100,\n    \"default\": 30\n  },\n  endRadius: {\n    min: 0,\n    max: 50,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CrossShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/CrossShape.js?");

/***/ }),

/***/ "./src/shapes/CrosshairShape.js":
/*!**************************************!*\
  !*** ./src/shapes/CrosshairShape.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates various crosshair styles (plus, cross, target, radar) within a\n * circular boundary, using SVG masking.\n */\nvar CrosshairShape = /*#__PURE__*/function (_Shape) {\n  function CrosshairShape() {\n    _classCallCheck(this, CrosshairShape);\n    return _callSuper(this, CrosshairShape, arguments);\n  }\n  _inherits(CrosshairShape, _Shape);\n  return _createClass(CrosshairShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var radius = this.radius;\n      var lineThickness = this.lineThickness * this.innerLineWeight;\n      var lineLength = radius * 2 * this.lineRatio;\n      var roundedCenter = this.roundedCenter;\n      var style = this.style;\n      var borderWidth = this.borderWidth;\n\n      // Generate a unique ID for the mask\n      var maskId = \"crosshair-mask-\".concat(Math.floor(Math.random() * 10000));\n\n      // Create mask elements based on the selected style\n      var maskElements = '';\n      if (style === 'plus' || style === 'cross') {\n        // Calculate arm dimensions\n        var halfThickness = lineThickness / 2;\n\n        // Create horizontal line\n        maskElements += \"\\n                <rect \\n                    x=\\\"\".concat(-lineLength / 2, \"\\\" \\n                    y=\\\"\").concat(-halfThickness, \"\\\" \\n                    width=\\\"\").concat(lineLength, \"\\\" \\n                    height=\\\"\").concat(lineThickness, \"\\\"\\n                    fill=\\\"black\\\"\\n                />\");\n\n        // Create vertical line\n        maskElements += \"\\n                <rect \\n                    x=\\\"\".concat(-halfThickness, \"\\\" \\n                    y=\\\"\").concat(-lineLength / 2, \"\\\" \\n                    width=\\\"\").concat(lineThickness, \"\\\" \\n                    height=\\\"\").concat(lineLength, \"\\\"\\n                    fill=\\\"black\\\"\\n                />\");\n\n        // For cross style, add 45-degree rotated lines\n        if (style === 'cross') {\n          var diagonalLength = lineLength * 0.7;\n          var diagonalThickness = lineThickness * 0.8;\n          var halfDiagThickness = diagonalThickness / 2;\n          maskElements += \"\\n                    <rect \\n                        x=\\\"\".concat(-diagonalLength / 2, \"\\\" \\n                        y=\\\"\").concat(-halfDiagThickness, \"\\\" \\n                        width=\\\"\").concat(diagonalLength, \"\\\" \\n                        height=\\\"\").concat(diagonalThickness, \"\\\"\\n                        transform=\\\"rotate(45)\\\"\\n                        fill=\\\"black\\\"\\n                    />\\n                    <rect \\n                        x=\\\"\").concat(-diagonalLength / 2, \"\\\" \\n                        y=\\\"\").concat(-halfDiagThickness, \"\\\" \\n                        width=\\\"\").concat(diagonalLength, \"\\\" \\n                        height=\\\"\").concat(diagonalThickness, \"\\\"\\n                        transform=\\\"rotate(-45)\\\"\\n                        fill=\\\"black\\\"\\n                    />\");\n        }\n      } else if (style === 'target') {\n        // Create concentric circles\n        var ringCount = 3;\n        var ringSpacing = radius / (ringCount + 1);\n        for (var i = 1; i <= ringCount; i++) {\n          var ringRadius = i * ringSpacing;\n          var ringThickness = lineThickness * (1 - (i - 1) * 0.15);\n          maskElements += \"\\n                    <circle \\n                        cx=\\\"0\\\" \\n                        cy=\\\"0\\\" \\n                        r=\\\"\".concat(ringRadius, \"\\\"\\n                        stroke=\\\"black\\\"\\n                        stroke-width=\\\"\").concat(ringThickness, \"\\\"\\n                        fill=\\\"none\\\"\\n                    />\");\n        }\n\n        // Add crosshair lines\n        var _halfThickness = lineThickness / 2;\n        maskElements += \"\\n                <rect \\n                    x=\\\"\".concat(-radius, \"\\\" \\n                    y=\\\"\").concat(-_halfThickness, \"\\\" \\n                    width=\\\"\").concat(radius * 2, \"\\\" \\n                    height=\\\"\").concat(lineThickness, \"\\\"\\n                    fill=\\\"black\\\"\\n                />\\n                <rect \\n                    x=\\\"\").concat(-_halfThickness, \"\\\" \\n                    y=\\\"\").concat(-radius, \"\\\" \\n                    width=\\\"\").concat(lineThickness, \"\\\" \\n                    height=\\\"\").concat(radius * 2, \"\\\"\\n                    fill=\\\"black\\\"\\n                />\");\n      } else if (style === 'radar') {\n        // Create radar sweep lines\n        var lineCount = 6;\n        var angleStep = 360 / lineCount;\n        for (var _i = 0; _i < lineCount; _i++) {\n          var angle = _i * angleStep;\n          maskElements += \"\\n                    <line \\n                        x1=\\\"0\\\" \\n                        y1=\\\"0\\\" \\n                        x2=\\\"\".concat(radius * Math.cos(angle * Math.PI / 180), \"\\\" \\n                        y2=\\\"\").concat(radius * Math.sin(angle * Math.PI / 180), \"\\\"\\n                        stroke=\\\"black\\\"\\n                        stroke-width=\\\"\").concat(lineThickness, \"\\\"\\n                    />\");\n        }\n\n        // Add concentric circles\n        var _ringCount = 2;\n        var _ringSpacing = radius / (_ringCount + 1);\n        for (var _i2 = 1; _i2 <= _ringCount; _i2++) {\n          var _ringRadius = _i2 * _ringSpacing;\n          maskElements += \"\\n                    <circle \\n                        cx=\\\"0\\\" \\n                        cy=\\\"0\\\" \\n                        r=\\\"\".concat(_ringRadius, \"\\\"\\n                        stroke=\\\"black\\\"\\n                        stroke-width=\\\"\").concat(lineThickness, \"\\\"\\n                        fill=\\\"none\\\"\\n                    />\");\n        }\n      }\n\n      // Add rounded center if requested\n      if (roundedCenter > 0) {\n        maskElements += \"\\n                <circle \\n                    cx=\\\"0\\\" \\n                    cy=\\\"0\\\" \\n                    r=\\\"\".concat(roundedCenter, \"\\\"\\n                    fill=\\\"black\\\"\\n                />\");\n      }\n\n      // Define the mask\n      var maskDef = \"\\n        <defs>\\n            <mask id=\\\"\".concat(maskId, \"\\\">\\n                <rect x=\\\"-200\\\" y=\\\"-200\\\" width=\\\"400\\\" height=\\\"400\\\" fill=\\\"white\\\" />\\n                \").concat(maskElements, \"\\n            </mask>\\n        </defs>\");\n\n      // Create the main circle with the mask applied\n      var maskedCircle = \"\\n            <circle \\n                cx=\\\"0\\\" \\n                cy=\\\"0\\\" \\n                r=\\\"\".concat(radius, \"\\\"\\n                fill=\\\"white\\\"\\n                stroke=\\\"\").concat(borderWidth > 0 ? 'black' : 'none', \"\\\"\\n                stroke-width=\\\"\").concat(borderWidth, \"\\\"\\n                mask=\\\"url(#\").concat(maskId, \")\\\"\\n            />\");\n      return \"\".concat(maskDef).concat(maskedCircle);\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(CrosshairShape, \"parameters\", {\n  radius: {\n    min: 50,\n    max: 100,\n    \"default\": 90\n  },\n  lineThickness: {\n    min: 1,\n    max: 30,\n    \"default\": 10\n  },\n  lineRatio: {\n    min: 0.1,\n    max: 1.0,\n    \"default\": 0.5\n  },\n  roundedCenter: {\n    min: 0,\n    max: 30,\n    \"default\": 10\n  },\n  style: {\n    options: ['plus', 'cross', 'target', 'radar'],\n    \"default\": 'plus'\n  },\n  innerLineWeight: {\n    min: 0.1,\n    max: 2.0,\n    \"default\": 1.0\n  },\n  borderWidth: {\n    min: 0,\n    max: 15,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CrosshairShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/CrosshairShape.js?");

/***/ }),

/***/ "./src/shapes/CrystalShard.js":
/*!************************************!*\
  !*** ./src/shapes/CrystalShard.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a crystal-like shape with multiple serrated blades radiating from\n * the center, featuring taper and skew controls.\n */\nvar CrystalShard = /*#__PURE__*/function (_Shape) {\n  function CrystalShard() {\n    _classCallCheck(this, CrystalShard);\n    return _callSuper(this, CrystalShard, arguments);\n  }\n  _inherits(CrystalShard, _Shape);\n  return _createClass(CrystalShard, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      this.blades = Math.round(this.blades);\n      var baseRadius = 100;\n      var angleStep = 2 * Math.PI / this.blades;\n      var points = [];\n\n      // Generate main blade points\n      for (var blade = 0; blade < this.blades; blade++) {\n        var baseAngle = angleStep * blade;\n\n        // Blade generation with serrations\n        for (var s = 0; s <= this.serration; s++) {\n          var t = s / this.serration;\n          var radius = baseRadius * (1 - t * this.taper);\n          var angleOffset = this.skew * (t - 0.5);\n          var angle = baseAngle + angleOffset + Math.PI / 2;\n          var x = radius * Math.cos(angle);\n          var y = radius * Math.sin(angle);\n          points.push([x, y]);\n\n          // Add reverse point for serration\n          if (s < this.serration) {\n            var reverseRadius = radius * 0.85;\n            var reverseAngle = angle + angleStep / (this.serration * 2);\n            points.push([reverseRadius * Math.cos(reverseAngle), reverseRadius * Math.sin(reverseAngle)]);\n          }\n        }\n      }\n\n      // Create SVG path\n      var pathData = \"M \".concat(points[0][0], \" \").concat(points[0][1]);\n      for (var i = 1; i < points.length; i++) {\n        pathData += \" L \".concat(points[i][0], \" \").concat(points[i][1]);\n\n        // Create triangular notch\n        if (i % (this.serration * 2) === 0) {\n          var nextIndex = (i + 1) % points.length;\n          var notchX = (points[i][0] + points[nextIndex][0]) / 2;\n          var notchY = (points[i][1] + points[nextIndex][1]) / 2;\n          pathData += \" L \".concat(notchX, \" \").concat(notchY);\n        }\n      }\n      pathData += ' Z';\n      return \"<path \\n            d=\\\"\".concat(pathData, \"\\\"\\n            fill=\\\"white\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(CrystalShard, \"parameters\", {\n  blades: {\n    min: 3,\n    max: 12,\n    \"default\": 6\n  },\n  serration: {\n    min: 1,\n    max: 8,\n    \"default\": 1\n  },\n  taper: {\n    min: 0.2,\n    max: 1,\n    \"default\": 0.3\n  },\n  skew: {\n    min: -1,\n    max: 1,\n    \"default\": 0.2\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CrystalShard);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/CrystalShard.js?");

/***/ }),

/***/ "./src/shapes/CubeShape.js":
/*!*********************************!*\
  !*** ./src/shapes/CubeShape.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a 3D wireframe representation of a cube with adjustable size and\n * rotation angles (X, Y, Z).\n */\nvar CubeShape = /*#__PURE__*/function (_Shape) {\n  function CubeShape() {\n    _classCallCheck(this, CubeShape);\n    return _callSuper(this, CubeShape, arguments);\n  }\n  _inherits(CubeShape, _Shape);\n  return _createClass(CubeShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var elements = [];\n      var size = this.size;\n      var halfSize = size / 2;\n\n      // Convert rotation angles to radians\n      var rotX = this.rotationX * Math.PI / 180;\n      var rotY = this.rotationY * Math.PI / 180;\n      var rotZ = this.rotationZ * Math.PI / 180;\n\n      // Define the vertices of a cube centered at origin\n      var vertices = [[-halfSize, -halfSize, -halfSize],\n      // 0: back bottom left\n      [halfSize, -halfSize, -halfSize],\n      // 1: back bottom right\n      [halfSize, halfSize, -halfSize],\n      // 2: back top right\n      [-halfSize, halfSize, -halfSize],\n      // 3: back top left\n      [-halfSize, -halfSize, halfSize],\n      // 4: front bottom left\n      [halfSize, -halfSize, halfSize],\n      // 5: front bottom right\n      [halfSize, halfSize, halfSize],\n      // 6: front top right\n      [-halfSize, halfSize, halfSize] // 7: front top left\n      ];\n\n      // Apply 3D rotations and projection to 2D\n      var projectedVertices = vertices.map(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 3),\n          x = _ref2[0],\n          y = _ref2[1],\n          z = _ref2[2];\n        // Apply rotation around X axis (pitch)\n        var x1 = x;\n        var y1 = y * Math.cos(rotX) - z * Math.sin(rotX);\n        var z1 = y * Math.sin(rotX) + z * Math.cos(rotX);\n\n        // Apply rotation around Y axis (yaw)\n        var x2 = x1 * Math.cos(rotY) + z1 * Math.sin(rotY);\n        var y2 = y1;\n        var z2 = -x1 * Math.sin(rotY) + z1 * Math.cos(rotY);\n\n        // Apply rotation around Z axis (roll)\n        var x3 = x2 * Math.cos(rotZ) - y2 * Math.sin(rotZ);\n        var y3 = x2 * Math.sin(rotZ) + y2 * Math.cos(rotZ);\n        var z3 = z2;\n\n        // Round to 3 decimal places to avoid floating point precision issues\n        return {\n          x: Math.round(x3 * 1000) / 1000,\n          y: Math.round(y3 * 1000) / 1000,\n          z: Math.round(z3 * 1000) / 1000\n        };\n      });\n\n      // Define edges of the cube (pairs of vertex indices)\n      var edges = [[0, 1], [1, 2], [2, 3], [3, 0],\n      // back face\n      [4, 5], [5, 6], [6, 7], [7, 4],\n      // front face\n      [0, 4], [1, 5], [2, 6], [3, 7] // connecting edges\n      ];\n\n      // Sort edges by average z-depth for proper rendering order\n      var sortedEdges = [].concat(edges).sort(function (a, b) {\n        var avgZA = (projectedVertices[a[0]].z + projectedVertices[a[1]].z) / 2;\n        var avgZB = (projectedVertices[b[0]].z + projectedVertices[b[1]].z) / 2;\n        return avgZB - avgZA; // Draw back-to-front\n      });\n\n      // Create a group for the entire shape\n      elements.push(\"<g stroke=\\\"white\\\" stroke-width=\\\"\".concat(this.thickness, \"\\\" fill=\\\"none\\\" stroke-linejoin=\\\"round\\\" stroke-linecap=\\\"round\\\">\"));\n\n      // Draw all edges as a single path per visible side to ensure perfect connections\n      // Create paths for connected edges\n      var visibleLines = {};\n\n      // Group edges that should be drawn as a single path\n      var connectedPaths = [];\n\n      // Process edges to form continuous paths\n      var remainingEdges = _toConsumableArray(sortedEdges);\n      while (remainingEdges.length > 0) {\n        var currentPath = [remainingEdges[0]];\n        remainingEdges.splice(0, 1);\n        var foundConnection = true;\n        while (foundConnection) {\n          foundConnection = false;\n\n          // Look for an edge that connects to the last vertex in our current path\n          var lastEdge = currentPath[currentPath.length - 1];\n          var lastVertex = lastEdge[1];\n          for (var i = 0; i < remainingEdges.length; i++) {\n            // If this edge starts with our last vertex\n            if (remainingEdges[i][0] === lastVertex) {\n              currentPath.push(remainingEdges[i]);\n              remainingEdges.splice(i, 1);\n              foundConnection = true;\n              break;\n            }\n            // If this edge ends with our last vertex (need to reverse it)\n            else if (remainingEdges[i][1] === lastVertex) {\n              currentPath.push([remainingEdges[i][1], remainingEdges[i][0]]);\n              remainingEdges.splice(i, 1);\n              foundConnection = true;\n              break;\n            }\n          }\n        }\n        connectedPaths.push(currentPath);\n      }\n\n      // Draw each connected path\n      for (var _i = 0, _connectedPaths = connectedPaths; _i < _connectedPaths.length; _i++) {\n        var path = _connectedPaths[_i];\n        var pathData = path.map(function (edge, i) {\n          var start = projectedVertices[edge[0]];\n          var end = projectedVertices[edge[1]];\n          return \"\".concat(i === 0 ? 'M' : 'L').concat(start.x, \",\").concat(start.y, \" L\").concat(end.x, \",\").concat(end.y);\n        }).join(' ');\n        elements.push(\"<path d=\\\"\".concat(pathData, \"\\\" />\"));\n      }\n\n      // Close the group\n      elements.push(\"</g>\");\n      return elements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(CubeShape, \"parameters\", {\n  size: {\n    min: 20,\n    max: 300,\n    \"default\": 100\n  },\n  rotationX: {\n    min: -60,\n    max: 60,\n    \"default\": 45\n  },\n  rotationY: {\n    min: -60,\n    max: 60,\n    \"default\": 45\n  },\n  rotationZ: {\n    min: -60,\n    max: 60,\n    \"default\": 0\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CubeShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/CubeShape.js?");

/***/ }),

/***/ "./src/shapes/CurvedHourglass.js":
/*!***************************************!*\
  !*** ./src/shapes/CurvedHourglass.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates an hourglass shape with curved sides, adjustable waist/top widths,\n * curvature, and vertical stretch.\n */\nvar CurvedHourglass = /*#__PURE__*/function (_Shape) {\n  function CurvedHourglass() {\n    _classCallCheck(this, CurvedHourglass);\n    return _callSuper(this, CurvedHourglass, arguments);\n  }\n  _inherits(CurvedHourglass, _Shape);\n  return _createClass(CurvedHourglass, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var scale = 200;\n      var width = scale * 0.8; // Adjust to fit viewBox\n      var height = width * this.verticalStretch;\n\n      // Center coordinates\n      var centerX = 0;\n      var centerY = 0;\n\n      // Calculate dimensions\n      var top = centerY - height / 2;\n      var bottom = centerY + height / 2;\n      var waistY = centerY;\n\n      // Calculate widths\n      var waistX = width * this.waistWidth;\n      var topX = width * this.topWidth;\n\n      // Calculate curve control points\n      var curveOffset = height / 4 * this.curvature;\n\n      // Build path commands\n      var commands = [// Start at top left\n      \"M \".concat(centerX - topX / 2, \" \").concat(top), // Left side curve to waist\n      \"C \".concat(centerX - topX / 2, \" \").concat(top + curveOffset, \", \\n               \").concat(centerX - waistX / 2, \" \").concat(waistY - curveOffset, \", \\n               \").concat(centerX - waistX / 2, \" \").concat(waistY), // Left side curve to bottom\n      \"C \".concat(centerX - waistX / 2, \" \").concat(waistY + curveOffset, \",\\n               \").concat(centerX - topX / 2, \" \").concat(bottom - curveOffset, \",\\n               \").concat(centerX - topX / 2, \" \").concat(bottom), // Bottom line\n      \"L \".concat(centerX + topX / 2, \" \").concat(bottom), // Right side curve to waist\n      \"C \".concat(centerX + topX / 2, \" \").concat(bottom - curveOffset, \",\\n               \").concat(centerX + waistX / 2, \" \").concat(waistY + curveOffset, \",\\n               \").concat(centerX + waistX / 2, \" \").concat(waistY), // Right side curve to top\n      \"C \".concat(centerX + waistX / 2, \" \").concat(waistY - curveOffset, \",\\n               \").concat(centerX + topX / 2, \" \").concat(top + curveOffset, \",\\n               \").concat(centerX + topX / 2, \" \").concat(top),\n      // Close path\n      'Z'];\n      return \"<path\\n            d=\\\"\".concat(commands.join(' '), \"\\\"\\n            fill=\\\"white\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(CurvedHourglass, \"parameters\", {\n  waistWidth: {\n    min: 0.1,\n    max: 0.8,\n    \"default\": 0.3\n  },\n  topWidth: {\n    min: 0.3,\n    max: 1.0,\n    \"default\": 0.8\n  },\n  curvature: {\n    min: 0.1,\n    max: 2.0,\n    \"default\": 0.8\n  },\n  verticalStretch: {\n    min: 0.5,\n    max: 1.2,\n    \"default\": 1.0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CurvedHourglass);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/CurvedHourglass.js?");

/***/ }),

/***/ "./src/shapes/CurvedPetalFlower.js":
/*!*****************************************!*\
  !*** ./src/shapes/CurvedPetalFlower.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a flower shape with adjustable petal count, length, width,\n * curvature, and an optional central circle.\n */\nvar CurvedPetalFlower = /*#__PURE__*/function (_Shape) {\n  function CurvedPetalFlower() {\n    _classCallCheck(this, CurvedPetalFlower);\n    return _callSuper(this, CurvedPetalFlower, arguments);\n  }\n  _inherits(CurvedPetalFlower, _Shape);\n  return _createClass(CurvedPetalFlower, [{\n    key: \"generatePetalPath\",\n    value: function generatePetalPath(angle) {\n      this.petalCount = Math.round(this.petalCount);\n      var angleStep = 2 * Math.PI / this.petalCount;\n      var halfAngleStep = angleStep / 2;\n\n      // Base points\n      var baseX = Math.cos(angle) * this.innerRadius;\n      var baseY = Math.sin(angle) * this.innerRadius;\n      var tipX = Math.cos(angle) * this.outerRadius;\n      var tipY = Math.sin(angle) * this.outerRadius;\n\n      // Convert parameters to factors\n      var spreadFactor = this.petalSpread / 100;\n      var pointFactor = this.petalPointiness / 100;\n\n      // Control points calculations - ensure consistent scaling\n      var cp1Dist = this.innerRadius + (this.outerRadius - this.innerRadius) * (0.2 + pointFactor * 0.3);\n      var cp2Dist = this.innerRadius + (this.outerRadius - this.innerRadius) * (0.5 + pointFactor * 0.3);\n\n      // Adjust spread based on petalSpread parameter - ensure symmetry\n      var baseAngle = halfAngleStep * (0.3 + spreadFactor * 0.7);\n      // Use consistent angle calculation for tips\n      var tipAngle = halfAngleStep * (0.1 + spreadFactor * 0.5) * (1 - pointFactor * 0.5);\n\n      // Calculate control points with adjusted angles - ensure symmetry\n      var cp1LeftX = Math.cos(angle - baseAngle) * cp1Dist;\n      var cp1LeftY = Math.sin(angle - baseAngle) * cp1Dist;\n      var cp2LeftX = Math.cos(angle - tipAngle) * cp2Dist;\n      var cp2LeftY = Math.sin(angle - tipAngle) * cp2Dist;\n      var cp1RightX = Math.cos(angle + baseAngle) * cp1Dist;\n      var cp1RightY = Math.sin(angle + baseAngle) * cp1Dist;\n      var cp2RightX = Math.cos(angle + tipAngle) * cp2Dist;\n      var cp2RightY = Math.sin(angle + tipAngle) * cp2Dist;\n\n      // Create SVG path for a single petal using cubic Bzier curves\n      return \"M \".concat(baseX, \" \").concat(baseY, \" \\n                C \").concat(cp1LeftX, \" \").concat(cp1LeftY, \", \").concat(cp2LeftX, \" \").concat(cp2LeftY, \", \").concat(tipX, \" \").concat(tipY, \"\\n                C \").concat(cp2RightX, \" \").concat(cp2RightY, \", \").concat(cp1RightX, \" \").concat(cp1RightY, \", \").concat(baseX, \" \").concat(baseY);\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      this.petalCount = Math.round(this.petalCount);\n      var angleStep = 2 * Math.PI / this.petalCount;\n      // Use consistent starting angle - align with image reference\n      var rotationOffset = Math.PI / 2; // Start from top (90 degrees)\n      var paths = [];\n\n      // Generate petals\n      for (var i = 0; i < this.petalCount; i++) {\n        var angle = i * angleStep + rotationOffset;\n        paths.push(this.generatePetalPath(angle));\n      }\n\n      // Add center circle if centerSize > 0\n      if (this.centerSize > 0) {\n        var actualCenterSize = this.innerRadius * this.centerSize / 100;\n        paths.push(\"\\n                <circle \\n                    cx=\\\"0\\\" \\n                    cy=\\\"0\\\" \\n                    r=\\\"\".concat(actualCenterSize, \"\\\"\\n                    fill=\\\"white\\\"\\n                />\\n            \"));\n      }\n\n      // Combine all paths into a single SVG group\n      return \"\\n            <g>\\n                <path \\n                    d=\\\"\".concat(paths.filter(function (p) {\n        return !p.includes('circle');\n      }).join(' '), \"\\\"\\n                    fill=\\\"white\\\"\\n                />\\n                \").concat(paths.filter(function (p) {\n        return p.includes('circle');\n      }).join(''), \"\\n            </g>\\n        \");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(CurvedPetalFlower, \"parameters\", {\n  petalCount: {\n    min: 3,\n    max: 24,\n    \"default\": 12\n  },\n  outerRadius: {\n    min: 40,\n    max: 100,\n    \"default\": 90\n  },\n  innerRadius: {\n    min: 10,\n    max: 50,\n    \"default\": 35\n  },\n  centerSize: {\n    min: 0,\n    max: 100,\n    \"default\": 25\n  },\n  petalSpread: {\n    min: 0,\n    max: 100,\n    \"default\": 50\n  },\n  petalPointiness: {\n    min: 0,\n    max: 100,\n    \"default\": 50\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CurvedPetalFlower);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/CurvedPetalFlower.js?");

/***/ }),

/***/ "./src/shapes/CurvedSplit.js":
/*!***********************************!*\
  !*** ./src/shapes/CurvedSplit.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a shape split horizontally by a wavy line, with adjustable wave\n * frequency, amplitude, phase, and chaos.\n */\nvar CurvedSplit = /*#__PURE__*/function (_Shape) {\n  function CurvedSplit() {\n    _classCallCheck(this, CurvedSplit);\n    return _callSuper(this, CurvedSplit, arguments);\n  }\n  _inherits(CurvedSplit, _Shape);\n  return _createClass(CurvedSplit, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var scale = 200; // Scale for the viewBox\n      var points = [];\n      var steps = 100;\n\n      // Convert phase to radians\n      var phaseRadians = this.phase * Math.PI / 180;\n\n      // Calculate wave points\n      for (var i = 0; i <= steps; i++) {\n        var t = i / steps;\n\n        // Base wave\n        var angle = t * Math.PI * 2 * this.frequency + phaseRadians;\n        var wave = Math.sin(angle) * this.amplitude;\n\n        // Add chaos using additional high-frequency waves\n        var chaosWave = this.chaos * (Math.sin(t * Math.PI * 7.3) * 0.3 + Math.sin(t * Math.PI * 15.7) * 0.2 + Math.sin(t * Math.PI * 25.1) * 0.1) * this.amplitude;\n        var x = -scale / 2 + scale * t;\n        var y = wave + chaosWave;\n        points.push([x, y]);\n      }\n\n      // Create the SVG path\n      var pathData = \"M \".concat(-scale / 2, \" \").concat(scale / 2); // Start at bottom left\n\n      // Add all wave points\n      for (var _i = 0, _points = points; _i < _points.length; _i++) {\n        var _points$_i = _slicedToArray(_points[_i], 2),\n          _x = _points$_i[0],\n          _y = _points$_i[1];\n        pathData += \" L \".concat(_x, \" \").concat(_y);\n      }\n\n      // Complete the shape\n      pathData += \" L \".concat(scale / 2, \" \").concat(scale / 2); // To bottom right\n      pathData += ' Z'; // Close the path\n\n      return \"<path \\n            d=\\\"\".concat(pathData, \"\\\"\\n            fill=\\\"white\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(CurvedSplit, \"parameters\", {\n  frequency: {\n    min: 0.5,\n    max: 4.0,\n    \"default\": 1.0\n  },\n  amplitude: {\n    min: 0,\n    max: 100,\n    \"default\": 40\n  },\n  phase: {\n    min: -180,\n    max: 180,\n    \"default\": 0\n  },\n  chaos: {\n    min: 0,\n    max: 1.0,\n    \"default\": 0.2\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CurvedSplit);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/CurvedSplit.js?");

/***/ }),

/***/ "./src/shapes/CutPolygon.js":
/*!**********************************!*\
  !*** ./src/shapes/CutPolygon.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a polygonal shape with angled cuts at the top-left and bottom-right\n * corners, and a central rectangular hole.\n */\nvar CutPolygon = /*#__PURE__*/function (_Shape) {\n  function CutPolygon() {\n    _classCallCheck(this, CutPolygon);\n    return _callSuper(this, CutPolygon, arguments);\n  }\n  _inherits(CutPolygon, _Shape);\n  return _createClass(CutPolygon, [{\n    key: \"_rotatePoint\",\n    value: function _rotatePoint(x, y, angleRad) {\n      var cosA = Math.cos(angleRad);\n      var sinA = Math.sin(angleRad);\n      return {\n        x: x * cosA - y * sinA,\n        y: x * sinA + y * cosA\n      };\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      var w = this.width / 2;\n      var h = this.height / 2;\n      // Ensure cuts don't exceed dimensions\n      var cutTL = Math.min(this.cutTopLeft, w, h);\n      var cutBR = Math.min(this.cutBottomRight, w, h);\n      var hs = this.holeSize / 2;\n      var angleRad = this.angle * Math.PI / 180;\n\n      // Define outer polygon points (counter-clockwise) relative to origin\n      var outerPoints = [{\n        x: -w + cutTL,\n        y: -h\n      },\n      // 1. Top edge start\n      {\n        x: w,\n        y: -h\n      },\n      // 2. Top right corner\n      {\n        x: w,\n        y: h - cutBR\n      },\n      // 3. Right edge end\n      {\n        x: w - cutBR,\n        y: h\n      },\n      // 4. Bottom right bevel start\n      {\n        x: -w,\n        y: h\n      },\n      // 5. Bottom left corner\n      {\n        x: -w,\n        y: -h + cutTL\n      } // 6. Left edge start\n      ];\n\n      // Define inner square points (counter-clockwise) relative to origin\n      var innerPoints = [{\n        x: this.holeOffsetX - hs,\n        y: this.holeOffsetY - hs\n      },\n      // Top-left\n      {\n        x: this.holeOffsetX + hs,\n        y: this.holeOffsetY - hs\n      },\n      // Top-right\n      {\n        x: this.holeOffsetX + hs,\n        y: this.holeOffsetY + hs\n      },\n      // Bottom-right\n      {\n        x: this.holeOffsetX - hs,\n        y: this.holeOffsetY + hs\n      } // Bottom-left\n      ];\n\n      // Rotate all points\n      var rotatedOuterPoints = outerPoints.map(function (p) {\n        return _this._rotatePoint(p.x, p.y, angleRad);\n      });\n      var rotatedInnerPoints = innerPoints.map(function (p) {\n        return _this._rotatePoint(p.x, p.y, angleRad);\n      });\n\n      // Format points for SVG path data, rounding to avoid excessive precision\n      var formatPoint = function formatPoint(p) {\n        return \"\".concat(p.x.toFixed(2), \",\").concat(p.y.toFixed(2));\n      };\n      var outerPathData = \"M \".concat(formatPoint(rotatedOuterPoints[0]), \" L \").concat(rotatedOuterPoints.slice(1).map(formatPoint).join(' '), \" Z\");\n      var innerPathData = \"M \".concat(formatPoint(rotatedInnerPoints[0]), \" L \").concat(rotatedInnerPoints.slice(1).map(formatPoint).join(' '), \" Z\");\n\n      // Combine outer and inner paths using fill-rule=\"evenodd\" for the hole\n      return \"<path d=\\\"\".concat(outerPathData, \" \").concat(innerPathData, \"\\\" fill=\\\"white\\\" fill-rule=\\\"evenodd\\\" />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(CutPolygon, \"parameters\", {\n  width: {\n    type: 'number',\n    min: 20,\n    max: 180,\n    \"default\": 120\n  },\n  height: {\n    type: 'number',\n    min: 20,\n    max: 180,\n    \"default\": 160\n  },\n  cutTopLeft: {\n    type: 'number',\n    min: 0,\n    max: 90,\n    \"default\": 40\n  },\n  cutBottomRight: {\n    type: 'number',\n    min: 0,\n    max: 90,\n    \"default\": 50\n  },\n  holeSize: {\n    type: 'number',\n    min: 5,\n    max: 100,\n    \"default\": 40\n  },\n  holeOffsetX: {\n    type: 'number',\n    min: -80,\n    max: 80,\n    \"default\": -25\n  },\n  holeOffsetY: {\n    type: 'number',\n    min: -80,\n    max: 80,\n    \"default\": -5\n  },\n  angle: {\n    type: 'number',\n    min: -180,\n    max: 180,\n    \"default\": -25\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CutPolygon);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/CutPolygon.js?");

/***/ }),

/***/ "./src/shapes/CutoutPill.js":
/*!**********************************!*\
  !*** ./src/shapes/CutoutPill.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a rounded rectangle ('pill') shape with a rectangular cutout in the\n * center.\n */\nvar CutoutPill = /*#__PURE__*/function (_Shape) {\n  function CutoutPill() {\n    _classCallCheck(this, CutoutPill);\n    return _callSuper(this, CutoutPill, arguments);\n  }\n  _inherits(CutoutPill, _Shape);\n  return _createClass(CutoutPill, [{\n    key: \"createRoundedRectPath\",\n    value: function createRoundedRectPath(x, y, width, height, radius) {\n      // Ensure radius isn't too large for the rectangle\n      var actualRadius = Math.min(radius, Math.min(width / 2, height / 2));\n\n      // Create rounded rectangle path\n      return \"M \".concat(x + actualRadius, \" \").concat(y, \"\\n                H \").concat(x + width - actualRadius, \"\\n                A \").concat(actualRadius, \" \").concat(actualRadius, \" 0 0 1 \").concat(x + width, \" \").concat(y + actualRadius, \"\\n                V \").concat(y + height - actualRadius, \"\\n                A \").concat(actualRadius, \" \").concat(actualRadius, \" 0 0 1 \").concat(x + width - actualRadius, \" \").concat(y + height, \"\\n                H \").concat(x + actualRadius, \"\\n                A \").concat(actualRadius, \" \").concat(actualRadius, \" 0 0 1 \").concat(x, \" \").concat(y + height - actualRadius, \"\\n                V \").concat(y + actualRadius, \"\\n                A \").concat(actualRadius, \" \").concat(actualRadius, \" 0 0 1 \").concat(x + actualRadius, \" \").concat(y, \"\\n                Z\");\n    }\n  }, {\n    key: \"createRectPath\",\n    value: function createRectPath(x, y, width, height) {\n      return \"M \".concat(x, \" \").concat(y, \"\\n                H \").concat(x + width, \"\\n                V \").concat(y + height, \"\\n                H \").concat(x, \"\\n                Z\");\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Calculate dimensions\n      var cutoutWidth = Math.min(this.cutoutWidth, this.width * 0.9);\n      var cutoutHeight = Math.min(this.cutoutHeight, this.height * 0.9);\n      var cornerRadius = Math.min(this.cornerRadius, Math.min(this.width, this.height) / 2);\n\n      // Calculate positions (centered)\n      var x = -this.width / 2;\n      var y = -this.height / 2;\n      var cutoutX = -cutoutWidth / 2;\n      var cutoutY = -cutoutHeight / 2;\n\n      // Create the main pill and cutout paths\n      var mainPath = this.createRoundedRectPath(x, y, this.width, this.height, cornerRadius);\n      var cutoutPath = this.createRectPath(cutoutX, cutoutY, cutoutWidth, cutoutHeight);\n\n      // Combine paths using SVG's fill-rule to create cutout effect\n      return \"<path \\n            d=\\\"\".concat(mainPath, \" \").concat(cutoutPath, \"\\\"\\n            fill-rule=\\\"evenodd\\\"\\n            fill=\\\"white\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(CutoutPill, \"parameters\", {\n  width: {\n    min: 100,\n    max: 300,\n    \"default\": 200\n  },\n  height: {\n    min: 50,\n    max: 200,\n    \"default\": 100\n  },\n  cutoutWidth: {\n    min: 20,\n    max: 150,\n    \"default\": 80\n  },\n  cutoutHeight: {\n    min: 20,\n    max: 100,\n    \"default\": 60\n  },\n  cornerRadius: {\n    min: 0,\n    max: 100,\n    \"default\": 50\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CutoutPill);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/CutoutPill.js?");

/***/ }),

/***/ "./src/shapes/CyberCircuitGrid.js":
/*!****************************************!*\
  !*** ./src/shapes/CyberCircuitGrid.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _readOnlyError(r) { throw new TypeError('\"' + r + '\" is read-only'); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates abstract circuit grid structure in cyberpunk style.\n */\n\nfunction vec(x, y) {\n  return {\n    x: x,\n    y: y\n  };\n}\nfunction add(v1, v2) {\n  return vec(v1.x + v2.x, v1.y + v2.y);\n}\nfunction sub(v1, v2) {\n  return vec(v1.x - v2.x, v1.y - v2.y);\n}\nfunction scale(v, s) {\n  return vec(v.x * s, v.y * s);\n}\nfunction len(v) {\n  return Math.sqrt(v.x * v.x + v.y * v.y);\n}\nfunction normalize(v) {\n  var l = len(v);\n  return l > 1e-6 ? scale(v, 1 / l) : vec(0, 0);\n}\nfunction dot(v1, v2) {\n  return v1.x * v2.x + v1.y * v2.y;\n}\nfunction normal(v) {\n  return vec(-v.y, v.x);\n}\nvar CyberCircuitGrid = /*#__PURE__*/function (_Shape) {\n  function CyberCircuitGrid() {\n    _classCallCheck(this, CyberCircuitGrid);\n    return _callSuper(this, CyberCircuitGrid, arguments);\n  }\n  _inherits(CyberCircuitGrid, _Shape);\n  return _createClass(CyberCircuitGrid, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var centerlinePoints = this.generateGridPath();\n      if (centerlinePoints.length < 2) {\n        return ''; // Not enough points to draw anything\n      }\n      var svgPaths = '';\n      var totalPathSpacing = this.gapWidth + this.lineWidth;\n      var effectiveRadius = Math.min(this.cornerRadius, this.gridSpacing * 0.45); // Prevent radius overlapping itself on tight corners\n\n      // Center the layers around the centerline\n      var initialOffset = -(this.numLayers - 1) / 2 * totalPathSpacing;\n      for (var k = 0; k < this.numLayers; k++) {\n        var currentOffset = initialOffset + k * totalPathSpacing;\n        var offsetPoints = this.calculateOffsetPoints(centerlinePoints, currentOffset);\n        if (offsetPoints.length >= 2) {\n          var pathData = this.getPathDataString(offsetPoints, effectiveRadius);\n          svgPaths += \"<path d=\\\"\".concat(pathData, \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(this.lineWidth, \"\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\" />\\n\");\n        }\n      }\n      return svgPaths;\n    }\n\n    /**\n     * Generates a self-avoiding path on a grid.\n     * @returns {Vector[]} Array of points snapped to the grid.\n     */\n  }, {\n    key: \"generateGridPath\",\n    value: function generateGridPath() {\n      var _this = this;\n      var bounds = 100 - this.margin;\n      var maxGridCoord = Math.floor(bounds / this.gridSpacing);\n      var minGridCoord = -maxGridCoord;\n\n      // Start near the center\n      var startGridX = Math.floor(this.random() * 5) - 2; // -2 to +2\n      var startGridY = Math.floor(this.random() * 5) - 2;\n      var currentGridX = Math.max(minGridCoord, Math.min(maxGridCoord, startGridX));\n      var currentGridY = Math.max(minGridCoord, Math.min(maxGridCoord, startGridY));\n      var points = [vec(currentGridX * this.gridSpacing, currentGridY * this.gridSpacing)];\n      var visitedCells = new Set([\"\".concat(currentGridX, \",\").concat(currentGridY)]);\n\n      // Initial random direction (0: +X, 1: +Y, 2: -X, 3: -Y)\n      var currentDirIndex = Math.floor(this.random() * 4);\n      var directions = [vec(1, 0), vec(0, 1), vec(-1, 0), vec(0, -1)]; // E, N, W, S\n      var _loop = function _loop() {\n          var possibleMoves = []; // Stores { nextX, nextY, dirIndex }\n\n          // Check straight, left, right\n          var straightDirIndex = currentDirIndex;\n          var leftDirIndex = (currentDirIndex + 1) % 4;\n          var rightDirIndex = (currentDirIndex + 3) % 4; // (currentDirIndex - 1 + 4) % 4\n\n          var checkMove = function checkMove(dirIndex) {\n            var dirVec = directions[dirIndex];\n            var nextX = currentGridX + dirVec.x;\n            var nextY = currentGridY + dirVec.y;\n            var cellKey = \"\".concat(nextX, \",\").concat(nextY);\n            if (nextX >= minGridCoord && nextX <= maxGridCoord && nextY >= minGridCoord && nextY <= maxGridCoord && !visitedCells.has(cellKey)) {\n              possibleMoves.push({\n                nextX: nextX,\n                nextY: nextY,\n                dirIndex: dirIndex\n              });\n              return true; // Valid move found\n            }\n            return false; // Invalid move\n          };\n          var canGoStraight = checkMove(straightDirIndex);\n          checkMove(leftDirIndex);\n          checkMove(rightDirIndex);\n          if (possibleMoves.length === 0) {\n            return 0; // break\n            // Dead end\n          }\n          var chosenMove;\n          // Prioritize going straight based on straightBias\n          if (canGoStraight && _this.random() < _this.straightBias) {\n            chosenMove = possibleMoves.find(function (move) {\n              return move.dirIndex === straightDirIndex;\n            });\n          } else {\n            // Remove straight option if it existed but wasn't chosen, then pick randomly\n            var availableTurns = canGoStraight && _this.random() >= _this.straightBias ? possibleMoves.filter(function (move) {\n              return move.dirIndex !== straightDirIndex;\n            }) : possibleMoves;\n            if (availableTurns.length > 0) {\n              chosenMove = availableTurns[Math.floor(_this.random() * availableTurns.length)];\n            } else if (canGoStraight) {\n              // Only straight was possible, must take it\n              chosenMove = possibleMoves.find(function (move) {\n                return move.dirIndex === straightDirIndex;\n              });\n            } else {\n              // Should not happen if possibleMoves.length > 0, but as fallback break\n              return 0; // break\n            }\n          }\n          if (!chosenMove) return 0; // break\n          // Should not happen, safety break\n\n          currentGridX = chosenMove.nextX;\n          currentGridY = chosenMove.nextY;\n          currentDirIndex = chosenMove.dirIndex;\n          points.push(vec(currentGridX * _this.gridSpacing, currentGridY * _this.gridSpacing));\n          visitedCells.add(\"\".concat(currentGridX, \",\").concat(currentGridY));\n        },\n        _ret;\n      for (var i = 0; i < this.numSegments; i++) {\n        _ret = _loop();\n        if (_ret === 0) break;\n      }\n      return points;\n    }\n\n    /**\n    * Calculates the points for a path offset from the input points.\n    * Handles sharp corners common in grid paths.\n    * @param {Vector[]} points - The original centerline points.\n    * @param {number} distance - The offset distance.\n    * @returns {Vector[]} Array of offset points.\n    */\n  }, {\n    key: \"calculateOffsetPoints\",\n    value: function calculateOffsetPoints(points, distance) {\n      if (points.length < 2 || Math.abs(distance) < 1e-6) {\n        return points.map(function (p) {\n          return _objectSpread({}, p);\n        }); // Return copy if no offset or too few points\n      }\n      var offsetPoints = [];\n\n      // Offset start point\n      var v01 = sub(points[1], points[0]);\n      if (len(v01) < 1e-6 && points.length > 2) v01 = sub(points[2], points[0]); // Handle coincident start points\n      var n01 = normalize(normal(v01));\n      offsetPoints.push(add(points[0], scale(n01, distance)));\n\n      // Offset intermediate points\n      for (var i = 1; i < points.length - 1; i++) {\n        var pPrev = points[i - 1];\n        var pCurr = points[i];\n        var pNext = points[i + 1];\n        var v1 = sub(pCurr, pPrev);\n        var v2 = sub(pNext, pCurr);\n\n        // Skip if points are coincident\n        if (len(v1) < 1e-6 || len(v2) < 1e-6) {\n          // Attempt to use the next non-coincident point if available\n          if (len(v1) < 1e-6 && i > 1) {\n            sub(pCurr, points[i - 2]), _readOnlyError(\"v1\");\n          }\n          if (len(v2) < 1e-6 && i < points.length - 2) {\n            sub(points[i + 2], pCurr), _readOnlyError(\"v2\");\n          }\n          // If still zero length, we might just skip this point or handle differently\n          // For now, let's try using the normal from the valid vector if one exists\n          if (len(v1) < 1e-6 && len(v2) < 1e-6) continue; // Skip if totally degenerate\n        }\n        var n1 = normalize(normal(v1));\n        var n2 = normalize(normal(v2));\n\n        // Mitre calculation using angle bisector normal\n        var bisectorNormal = normalize(add(n1, n2));\n        var dotProduct = dot(n1, bisectorNormal);\n\n        // Handle colinear segments (dot product close to 1 or -1) and sharp turns\n        if (Math.abs(dotProduct) < 1e-3) {\n          // Very sharp turn (near 180 degrees) or nearly colinear reversed\n          // Fallback: Use average of normals or just one normal if very sharp\n          // For grid paths, this often means a 180 turn. A simple bevel might be better.\n          // Let's try using the normal bisector approach but limit the distance\n          var avgNormal = scale(add(n1, n2), 0.5); // Not normalized\n          offsetPoints.push(add(pCurr, scale(normalize(avgNormal), distance))); // Use normalized average\n        } else if (Math.abs(dotProduct) > 0.999) {\n          // Near colinear (straight)\n          offsetPoints.push(add(pCurr, scale(n1, distance))); // Use either normal\n        } else {\n          // Standard case (e.g., 90-degree grid turn)\n          var adjustedDistance = distance / dotProduct;\n          // Limit mitre length to prevent extreme spikes on sharp angles, though less needed with radius\n          var maxMiterDist = Math.max(Math.abs(distance) * 5, this.gridSpacing);\n          var finalDist = Math.sign(adjustedDistance) * Math.min(Math.abs(adjustedDistance), maxMiterDist);\n          offsetPoints.push(add(pCurr, scale(bisectorNormal, finalDist)));\n        }\n      }\n\n      // Offset end point\n      var vLast = sub(points[points.length - 1], points[points.length - 2]);\n      if (len(vLast) < 1e-6 && points.length > 2) vLast = sub(points[points.length - 1], points[points.length - 3]); // Handle coincident end points\n      var nLast = normalize(normal(vLast));\n      offsetPoints.push(add(points[points.length - 1], scale(nLast, distance)));\n      return offsetPoints;\n    }\n\n    /**\n     * Generates an SVG path data string with rounded corners using Arc commands.\n     * @param {Vector[]} points - The vertices of the polyline.\n     * @param {number} radius - The radius for the rounded corners. Clamped if segments too short.\n     * @returns {string} The SVG path data string (`d` attribute).\n     */\n  }, {\n    key: \"getPathDataString\",\n    value: function getPathDataString(points, radius) {\n      if (points.length < 2) return '';\n      if (radius <= 0) {\n        // No rounding, just use line segments\n        return \"M \".concat(points[0].x.toFixed(3), \",\").concat(points[0].y.toFixed(3), \" \") + points.slice(1).map(function (p) {\n          return \"L \".concat(p.x.toFixed(3), \",\").concat(p.y.toFixed(3));\n        }).join(' ');\n      }\n      var pathData = \"\";\n      var lastPoint = null;\n      for (var i = 0; i < points.length; i++) {\n        var pCurr = points[i];\n        if (i === 0) {\n          // Move to the start point, potentially adjusted for the first corner arc\n          if (points.length > 1) {\n            var pNext = points[1];\n            var v01 = sub(pNext, pCurr);\n            var len01 = len(v01);\n            var r = Math.min(radius, len01 / 2);\n            if (r > 1e-3) {\n              var startOffset = scale(normalize(v01), r);\n              lastPoint = add(pCurr, startOffset);\n              pathData += \"M \".concat(lastPoint.x.toFixed(3), \",\").concat(lastPoint.y.toFixed(3));\n            } else {\n              lastPoint = pCurr;\n              pathData += \"M \".concat(pCurr.x.toFixed(3), \",\").concat(pCurr.y.toFixed(3));\n            }\n          } else {\n            // Only one point\n            pathData += \"M \".concat(pCurr.x.toFixed(3), \",\").concat(pCurr.y.toFixed(3));\n            lastPoint = pCurr;\n          }\n          continue;\n        }\n        var pPrev = points[i - 1];\n        var v1 = sub(pCurr, pPrev); // Vector from previous to current corner candidate\n        var len1 = len(v1);\n        if (i === points.length - 1) {\n          // Last segment, just draw a line to the final point\n          pathData += \" L \".concat(pCurr.x.toFixed(3), \",\").concat(pCurr.y.toFixed(3));\n          lastPoint = pCurr;\n        } else {\n          // Intermediate point, calculate corner arc\n          var _pNext = points[i + 1];\n          var v2 = sub(_pNext, pCurr); // Vector from current corner candidate to next\n          var len2 = len(v2);\n\n          // Clamp radius if segments are too short\n          var _r = Math.min(radius, len1 / 2, len2 / 2);\n          if (_r < 1e-3 || len1 < 1e-3 || len2 < 1e-3) {\n            // Radius too small, segments too short, or coincident points, just draw line segment to corner point\n            pathData += \" L \".concat(pCurr.x.toFixed(3), \",\").concat(pCurr.y.toFixed(3));\n            lastPoint = pCurr;\n          } else {\n            // Calculate points on segments where the arc starts and ends\n            var arcStart = add(pCurr, scale(normalize(v1), -_r)); // Point on incoming segment\n            var arcEnd = add(pCurr, scale(normalize(v2), _r)); // Point on outgoing segment\n\n            // Determine sweep flag based on cross product (z-component)\n            // Ensures the arc turns the correct way (e.g., inside or outside corner)\n            var crossProduct = v1.x * v2.y - v1.y * v2.x;\n            var sweepFlag = crossProduct > 0 ? 1 : 0; // CCW vs CW turn\n\n            pathData += \" L \".concat(arcStart.x.toFixed(3), \",\").concat(arcStart.y.toFixed(3));\n            pathData += \" A \".concat(_r.toFixed(3), \",\").concat(_r.toFixed(3), \" 0 0,\").concat(sweepFlag, \" \").concat(arcEnd.x.toFixed(3), \",\").concat(arcEnd.y.toFixed(3));\n            lastPoint = arcEnd; // Update last point to the end of the arc\n          }\n        }\n      }\n      return pathData;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(CyberCircuitGrid, \"parameters\", {\n  gridSpacing: {\n    type: 'number',\n    min: 5,\n    max: 50,\n    \"default\": 30,\n    step: 1\n  },\n  numSegments: {\n    type: 'number',\n    min: 5,\n    max: 100,\n    \"default\": 50,\n    step: 1\n  },\n  straightBias: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    \"default\": 0.6,\n    step: 0.1\n  },\n  // Probability to go straight if possible\n  cornerRadius: {\n    type: 'number',\n    min: 0,\n    max: 30,\n    \"default\": 5,\n    step: 1\n  },\n  numLayers: {\n    type: 'number',\n    min: 1,\n    max: 5,\n    \"default\": 3,\n    step: 1\n  },\n  gapWidth: {\n    type: 'number',\n    min: 1,\n    max: 15,\n    \"default\": 3,\n    step: 0.5\n  },\n  lineWidth: {\n    type: 'number',\n    min: 0.5,\n    max: 8,\n    \"default\": 1.5,\n    step: 0.5\n  },\n  margin: {\n    type: 'number',\n    min: 0,\n    max: 30,\n    \"default\": 10,\n    step: 1\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CyberCircuitGrid);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/CyberCircuitGrid.js?");

/***/ }),

/***/ "./src/shapes/CycloneCrescents.js":
/*!****************************************!*\
  !*** ./src/shapes/CycloneCrescents.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n// Helper function for linear interpolation\nvar lerp = function lerp(a, b, t) {\n  return a * (1 - t) + b * t;\n};\n\n/**\n * Generates a shape resembling two interlocking, curved crescents rotating\n * around a center point.\n */\nvar CycloneCrescents = /*#__PURE__*/function (_Shape) {\n  function CycloneCrescents() {\n    _classCallCheck(this, CycloneCrescents);\n    return _callSuper(this, CycloneCrescents, arguments);\n  }\n  _inherits(CycloneCrescents, _Shape);\n  return _createClass(CycloneCrescents, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var r_in = this.innerRadius;\n      var r_tip = this.outerRadius;\n      // Calculate the radius at the wider base of the crescent.\n      // Ensure the base radius is logically between inner and tip radii.\n      var r_base = Math.max(r_in + 1, Math.min(r_tip - 1, r_in + this.baseWidth));\n\n      // Prevent invalid radius configurations where inner >= tip or base isn't between them.\n      if (r_in >= r_tip || r_base <= r_in || r_base > r_tip) {\n        // Return an empty string or a minimal shape to avoid errors\n        console.warn(\"CycloneCrescents: Invalid radius configuration.\");\n        return '';\n      }\n      var sweepDeg = this.sweepAngle;\n      var sweepRad = sweepDeg * Math.PI / 180;\n      var rotRad = this.rotation * Math.PI / 180;\n      var sharp = this.tipSharpness; // 0 = rounder curve, 1 = sharper curve towards tip angle\n\n      // Flag for SVG arc command, depends if the sweep angle is > 180 degrees\n      var largeArcFlag = sweepRad > Math.PI ? 1 : 0;\n      var paths = '';\n\n      // Generate two crescents, the second rotated 180 degrees from the first\n      for (var i = 0; i < 2; i++) {\n        // Calculate rotation for the current crescent (0 or PI radians offset)\n        var currentRot = rotRad + i * Math.PI;\n\n        // Calculate start and end angles for the crescent's arc segments\n        // Angles define the span relative to the current rotation\n        var startAngle = currentRot - sweepRad / 2;\n        var endAngle = currentRot + sweepRad / 2;\n\n        // --- Calculate coordinates for the 4 key points defining the crescent ---\n        // P1: Inner arc start point\n        var P1x = r_in * Math.cos(startAngle);\n        var P1y = r_in * Math.sin(startAngle);\n        // P2: Inner arc end point\n        var P2x = r_in * Math.cos(endAngle);\n        var P2y = r_in * Math.sin(endAngle);\n        // P3: Outer curve start point (the sharp tip)\n        var P3x = r_tip * Math.cos(startAngle);\n        var P3y = r_tip * Math.sin(startAngle);\n        // P4: Outer curve end point (at the wider base)\n        var P4x = r_base * Math.cos(endAngle);\n        var P4y = r_base * Math.sin(endAngle);\n\n        // --- Calculate the control point for the outer quadratic Bezier curve (P4 -> P3) ---\n        // The control point determines the curvature of the outer edge.\n        // We place it radially outwards from the angular midpoint between start and end angles.\n        // The amount of outward \"bulge\" is inversely related to tipSharpness.\n        var midAngle = (startAngle + endAngle) / 2;\n        // Base radius for control point calculation (average of base and tip radii)\n        var baseCtrlRadius = lerp(r_base, r_tip, 0.5);\n        // Apply a bulge factor: more bulge (larger radius) when sharpness is low (rounder).\n        // The multiplier '1.0' is a heuristic value, adjust for different curve styles.\n        var bulgeFactor = 1 + (1 - sharp) * 1.0;\n        var ctrlRadius = baseCtrlRadius * bulgeFactor;\n        // Control point coordinates\n        var CPx = ctrlRadius * Math.cos(midAngle);\n        var CPy = ctrlRadius * Math.sin(midAngle);\n\n        // --- Construct the SVG path data string (d attribute) ---\n        var d = [\"M \".concat(P1x.toFixed(3), \" \").concat(P1y.toFixed(3)), // Move to inner start (P1)\n        \"A \".concat(r_in.toFixed(3), \" \").concat(r_in.toFixed(3), \" 0 \").concat(largeArcFlag, \" 1 \").concat(P2x.toFixed(3), \" \").concat(P2y.toFixed(3)), // Draw inner arc (P1 to P2)\n        \"L \".concat(P4x.toFixed(3), \" \").concat(P4y.toFixed(3)), // Draw straight line from inner end (P2) to outer base (P4)\n        \"Q \".concat(CPx.toFixed(3), \" \").concat(CPy.toFixed(3), \" \").concat(P3x.toFixed(3), \" \").concat(P3y.toFixed(3)), // Draw outer curve (P4 to P3) via control point CP\n        \"Z\" // Close the path (draws line from P3 back to P1)\n        ].join(' ');\n\n        // Add the generated path element to the output string\n        paths += \"<path d=\\\"\".concat(d, \"\\\" fill=\\\"white\\\" />\\n\");\n      }\n\n      // Return the SVG string containing both path elements\n      return paths;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(CycloneCrescents, \"parameters\", {\n  innerRadius: {\n    type: 'number',\n    min: 1,\n    max: 45,\n    step: 1,\n    \"default\": 20,\n    label: 'Inner Radius'\n  },\n  outerRadius: {\n    type: 'number',\n    min: 30,\n    max: 100,\n    step: 1,\n    \"default\": 80,\n    label: 'Outer Radius (Tip)'\n  },\n  baseWidth: {\n    type: 'number',\n    min: 5,\n    max: 70,\n    step: 1,\n    \"default\": 40,\n    label: 'Base Thickness'\n  },\n  sweepAngle: {\n    type: 'number',\n    min: 90,\n    max: 270,\n    step: 1,\n    \"default\": 180,\n    label: 'Sweep Angle'\n  },\n  tipSharpness: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    step: 0.05,\n    \"default\": 0.7,\n    label: 'Tip Sharpness'\n  },\n  rotation: {\n    type: 'number',\n    min: 0,\n    max: 360,\n    step: 1,\n    \"default\": 0,\n    label: 'Rotation'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CycloneCrescents);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/CycloneCrescents.js?");

/***/ }),

/***/ "./src/shapes/DNASpiral.js":
/*!*********************************!*\
  !*** ./src/shapes/DNASpiral.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a 3D representation of a DNA double helix spiral with rectangular\n * 'base pair' blocks.\n */\nvar DNASpiral = /*#__PURE__*/function (_Shape) {\n  function DNASpiral() {\n    _classCallCheck(this, DNASpiral);\n    return _callSuper(this, DNASpiral, arguments);\n  }\n  _inherits(DNASpiral, _Shape);\n  return _createClass(DNASpiral, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var elements = [];\n      var height = this.height,\n        width = this.width,\n        segments = this.segments,\n        thickness = this.thickness,\n        boxWidth = this.boxWidth,\n        boxHeight = this.boxHeight,\n        twist = this.twist,\n        rotationX = this.rotationX,\n        rotationY = this.rotationY;\n      var step = height / segments;\n      var angleStep = Math.PI * 2 * twist / segments;\n\n      // Calculate rotations in radians\n      var rotX = rotationX * Math.PI / 180;\n      var rotY = rotationY * Math.PI / 180;\n\n      // Store all rectangles with their z-index for proper stacking\n      var rectangles = [];\n      for (var i = 0; i < segments; i++) {\n        var angle = i * angleStep;\n        var baseY = i * step - height / 2;\n\n        // Calculate base positions for both strands\n        var x1 = Math.sin(angle) * (width / 2);\n        var z1 = Math.cos(angle) * (width / 2);\n        var x2 = Math.sin(angle + Math.PI) * (width / 2);\n        var z2 = Math.cos(angle + Math.PI) * (width / 2);\n\n        // Use consistent width for all rectangles\n        var width1 = boxWidth;\n        var width2 = boxWidth;\n\n        // Apply 3D rotations to positions\n        var pos1 = this.rotate3D(x1, baseY, z1, rotX, rotY);\n        var pos2 = this.rotate3D(x2, baseY, z2, rotX, rotY);\n\n        // Add rectangles with z-index information\n        rectangles.push({\n          svg: this.createProjectedRect(pos1.x, pos1.y, pos1.z, width1, boxHeight, thickness),\n          z: pos1.z\n        });\n        rectangles.push({\n          svg: this.createProjectedRect(pos2.x, pos2.y, pos2.z, width2, boxHeight, thickness),\n          z: pos2.z\n        });\n      }\n\n      // Sort rectangles by z-index (back to front)\n      rectangles.sort(function (a, b) {\n        return a.z - b.z;\n      });\n\n      // Add sorted rectangles to elements array\n      rectangles.forEach(function (rect) {\n        elements.push(rect.svg);\n      });\n      return elements.join('');\n    }\n\n    // Apply 3D rotation to a point\n  }, {\n    key: \"rotate3D\",\n    value: function rotate3D(x, y, z, rotX, rotY) {\n      // First rotate around X axis\n      var cosX = Math.cos(rotX);\n      var sinX = Math.sin(rotX);\n      var y1 = y * cosX - z * sinX;\n      var z1 = y * sinX + z * cosX;\n\n      // Then rotate around Y axis\n      var cosY = Math.cos(rotY);\n      var sinY = Math.sin(rotY);\n      var x2 = x * cosY + z1 * sinY;\n      var z2 = -x * sinY + z1 * cosY;\n      return {\n        x: x2,\n        y: y1,\n        z: z2\n      };\n    }\n\n    // Project a 3D point to 2D with perspective\n  }, {\n    key: \"project\",\n    value: function project(x, y, z) {\n      // Simple perspective projection\n      var focalLength = 400;\n      var scale = focalLength / (focalLength + z);\n      return {\n        x: x * scale,\n        y: y * scale,\n        scale: scale\n      };\n    }\n  }, {\n    key: \"createProjectedRect\",\n    value: function createProjectedRect(x, y, z, width, height, thickness) {\n      // Project center point with perspective\n      var center = this.project(x, y, z);\n\n      // Calculate projected dimensions\n      var projWidth = width * center.scale;\n      var projHeight = height * center.scale;\n\n      // Calculate corners\n      var left = center.x - projWidth / 2;\n      var top = center.y - projHeight / 2;\n\n      // Calculate depth for 3D effect\n      var depth = projHeight * 0.5;\n\n      // Choose style based on z position (darkening for depth)\n      var strokeColor = \"white\";\n      var fillColor = \"white\";\n\n      // Create the rectangle with 3D effect\n      if (z > 0) {\n        // Front-facing rectangle (simple)\n        return \"<rect \\n                x=\\\"\".concat(left, \"\\\" \\n                y=\\\"\").concat(top, \"\\\" \\n                width=\\\"\").concat(projWidth, \"\\\" \\n                height=\\\"\").concat(projHeight, \"\\\" \\n                fill=\\\"\").concat(fillColor, \"\\\" \\n                stroke=\\\"black\\\" \\n                stroke-width=\\\"\").concat(thickness, \"\\\"\\n            />\");\n      } else {\n        // Create 3D box for rectangles facing away\n        // Base rectangle\n        var box = \"<rect \\n                x=\\\"\".concat(left, \"\\\" \\n                y=\\\"\").concat(top, \"\\\" \\n                width=\\\"\").concat(projWidth, \"\\\" \\n                height=\\\"\").concat(projHeight, \"\\\" \\n                fill=\\\"\").concat(fillColor, \"\\\" \\n                stroke=\\\"black\\\" \\n                stroke-width=\\\"\").concat(thickness, \"\\\"\\n            />\");\n\n        // Add perspective lines for depth\n        var backLeft = left - depth * 0.3;\n        var backTop = top - depth * 0.15;\n\n        // Add corner lines\n        box += \"<line \\n                x1=\\\"\".concat(left, \"\\\" \\n                y1=\\\"\").concat(top, \"\\\" \\n                x2=\\\"\").concat(backLeft, \"\\\" \\n                y2=\\\"\").concat(backTop, \"\\\" \\n                stroke=\\\"black\\\" \\n                stroke-width=\\\"\").concat(thickness, \"\\\"\\n            />\");\n        box += \"<line \\n                x1=\\\"\".concat(left + projWidth, \"\\\" \\n                y1=\\\"\").concat(top, \"\\\" \\n                x2=\\\"\").concat(backLeft + projWidth, \"\\\" \\n                y2=\\\"\").concat(backTop, \"\\\" \\n                stroke=\\\"\").concat(strokeColor, \"\\\" \\n                stroke-width=\\\"\").concat(thickness, \"\\\"\\n            />\");\n        box += \"<line \\n                x1=\\\"\".concat(left, \"\\\" \\n                y1=\\\"\").concat(top + projHeight, \"\\\" \\n                x2=\\\"\").concat(backLeft, \"\\\" \\n                y2=\\\"\").concat(backTop + projHeight, \"\\\" \\n                stroke=\\\"\").concat(strokeColor, \"\\\" \\n                stroke-width=\\\"\").concat(thickness, \"\\\"\\n            />\");\n        box += \"<line \\n                x1=\\\"\".concat(left + projWidth, \"\\\" \\n                y1=\\\"\").concat(top + projHeight, \"\\\" \\n                x2=\\\"\").concat(backLeft + projWidth, \"\\\" \\n                y2=\\\"\").concat(backTop + projHeight, \"\\\" \\n                stroke=\\\"\").concat(strokeColor, \"\\\" \\n                stroke-width=\\\"\").concat(thickness, \"\\\"\\n            />\");\n\n        // Back face outline\n        box += \"<rect \\n                x=\\\"\".concat(backLeft, \"\\\" \\n                y=\\\"\").concat(backTop, \"\\\" \\n                width=\\\"\").concat(projWidth, \"\\\" \\n                height=\\\"\").concat(projHeight, \"\\\" \\n                fill=\\\"\").concat(fillColor, \"\\\" \\n                stroke=\\\"black\\\" \\n                stroke-width=\\\"\").concat(thickness, \"\\\"\\n            />\");\n        return box;\n      }\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(DNASpiral, \"parameters\", {\n  height: {\n    min: 50,\n    max: 150,\n    \"default\": 150\n  },\n  width: {\n    min: 10,\n    max: 100,\n    \"default\": 100\n  },\n  segments: {\n    min: 5,\n    max: 60,\n    \"default\": 32\n  },\n  thickness: {\n    min: 1,\n    max: 5,\n    \"default\": 1\n  },\n  boxWidth: {\n    min: 4,\n    max: 50,\n    \"default\": 32\n  },\n  boxHeight: {\n    min: 3,\n    max: 30,\n    \"default\": 12\n  },\n  twist: {\n    min: 1,\n    max: 10,\n    \"default\": 1\n  },\n  rotationX: {\n    min: 0,\n    max: 360,\n    \"default\": 0\n  },\n  rotationY: {\n    min: 0,\n    max: 360,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DNASpiral);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/DNASpiral.js?");

/***/ }),

/***/ "./src/shapes/DandelionShape.js":
/*!**************************************!*\
  !*** ./src/shapes/DandelionShape.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a dandelion seed head with a central core and radiating seeds\n * featuring curved stems and oval fluff.\n */\nvar DandelionShape = /*#__PURE__*/function (_Shape) {\n  function DandelionShape() {\n    _classCallCheck(this, DandelionShape);\n    return _callSuper(this, DandelionShape, arguments);\n  }\n  _inherits(DandelionShape, _Shape);\n  return _createClass(DandelionShape, [{\n    key: \"point\",\n    value: function point(centerX, centerY, radius, angle) {\n      var x = centerX + radius * Math.cos(angle);\n      var y = centerY + radius * Math.sin(angle);\n      return {\n        x: x,\n        y: y\n      };\n    }\n  }, {\n    key: \"createFluff\",\n    value: function createFluff(centerX, centerY, size, angle) {\n      // Create ellipse element for the seed head\n      var rx = size;\n      var ry = size / 2;\n\n      // Apply rotation transformation\n      var transform = \"translate(\".concat(centerX, \" \").concat(centerY, \") rotate(\").concat(angle * 180 / Math.PI, \") translate(\").concat(-centerX, \" \").concat(-centerY, \")\");\n      return \"<ellipse \\n            cx=\\\"\".concat(centerX, \"\\\" \\n            cy=\\\"\").concat(centerY, \"\\\" \\n            rx=\\\"\").concat(rx, \"\\\" \\n            ry=\\\"\").concat(ry, \"\\\"\\n            transform=\\\"\").concat(transform, \"\\\"\\n            fill=\\\"white\\\"\\n        />\");\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var centerX = 0;\n      var centerY = 0;\n      var scale = 1;\n\n      // Scale parameters\n      var seedLength = this.seedLength * scale;\n      var seedCurve = this.seedCurve * (Math.PI / 180);\n      var fluffSize = this.fluffSize * scale;\n      var coreRadius = this.coreRadius * scale;\n      var windPhase = this.windPhase * (Math.PI / 180);\n      var elements = [];\n\n      // Draw core\n      elements.push(\"<circle \\n            cx=\\\"\".concat(centerX, \"\\\" \\n            cy=\\\"\").concat(centerY, \"\\\" \\n            r=\\\"\").concat(coreRadius, \"\\\"\\n            fill=\\\"white\\\"\\n        />\"));\n\n      // Generate seeds\n      for (var i = 0; i < this.seedCount; i++) {\n        var angle = i * 2 * Math.PI / this.seedCount + windPhase;\n\n        // Calculate stem points\n        var start = this.point(centerX, centerY, coreRadius, angle);\n        var end = this.point(centerX, centerY, seedLength, angle);\n\n        // Calculate control point for curve\n        var controlDist = seedLength * 0.6;\n        var controlAngle = angle + seedCurve;\n        var control = this.point(centerX, centerY, controlDist, controlAngle);\n\n        // Create curved stem\n        elements.push(\"<path \\n                d=\\\"M \".concat(start.x, \" \").concat(start.y, \" Q \").concat(control.x, \" \").concat(control.y, \" \").concat(end.x, \" \").concat(end.y, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"1\\\"\\n                fill=\\\"none\\\"\\n            />\"));\n\n        // Add fluffy seed head\n        elements.push(this.createFluff(end.x, end.y, fluffSize, angle));\n      }\n      return elements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(DandelionShape, \"parameters\", {\n  seedCount: {\n    min: 12,\n    max: 48,\n    \"default\": 24\n  },\n  seedLength: {\n    min: 40,\n    max: 120,\n    \"default\": 80\n  },\n  seedCurve: {\n    min: 0,\n    max: 90,\n    \"default\": 45\n  },\n  fluffSize: {\n    min: 2,\n    max: 12,\n    \"default\": 6\n  },\n  coreRadius: {\n    min: 5,\n    max: 25,\n    \"default\": 15\n  },\n  windPhase: {\n    min: -45,\n    max: 45,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DandelionShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/DandelionShape.js?");

/***/ }),

/***/ "./src/shapes/DecoStructure.js":
/*!*************************************!*\
  !*** ./src/shapes/DecoStructure.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates an abstract geometric composition with circles and lines, inspired\n * by modern deco styles.\n */\nvar DecoStructure = /*#__PURE__*/function (_Shape) {\n  function DecoStructure() {\n    _classCallCheck(this, DecoStructure);\n    return _callSuper(this, DecoStructure, arguments);\n  }\n  _inherits(DecoStructure, _Shape);\n  return _createClass(DecoStructure, [{\n    key: \"_clamp\",\n    value: /** Helper to clamp values */\n    function _clamp(val, min, max) {\n      return Math.max(min, Math.min(max, val));\n    }\n\n    /** Helper function to rotate a point around (0,0) */\n  }, {\n    key: \"_rotatePoint\",\n    value: function _rotatePoint(x, y, angleDeg) {\n      var angleRad = angleDeg * Math.PI / 180;\n      var cosA = Math.cos(angleRad);\n      var sinA = Math.sin(angleRad);\n      return {\n        x: x * cosA - y * sinA,\n        y: x * sinA + y * cosA\n      };\n    }\n\n    /**\n     * Generates the SVG elements for the DecoStructure shape.\n     * @returns {string} SVG string containing circle and path elements.\n     */\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      var structureWidth = this.structureWidth,\n        structureHeight = this.structureHeight,\n        rLarge = this.rLarge,\n        rMedium = this.rMedium,\n        rSmall = this.rSmall,\n        arcRadius = this.arcRadius,\n        lineWidth = this.lineWidth,\n        rotation = this.rotation,\n        xMedFactor = this.xMedFactor,\n        yMedFactor = this.yMedFactor,\n        yLargeFactor = this.yLargeFactor,\n        xEndFactor = this.xEndFactor;\n      var hw = structureWidth / 2;\n      var hh = structureHeight / 2;\n      var maxCoord = 99.9; // Viewbox boundary limit\n\n      // --- 1. Calculate Key Positions (Unrotated, relative to 0,0) ---\n      var yL = this._clamp(hh * yLargeFactor, -maxCoord + rLarge, maxCoord - rLarge);\n      var xM = this._clamp(hw * xMedFactor, -maxCoord + rMedium, maxCoord - rMedium);\n      var yM = this._clamp(hh * yMedFactor, -maxCoord + rMedium, maxCoord - rMedium);\n      var cLarge = {\n        x: 0,\n        y: yL\n      };\n      var cMedium = {\n        x: xM,\n        y: yM\n      };\n\n      // Ensure arc radius is reasonable and fits\n      var rArc = this._clamp(arcRadius, 5, Math.abs(hw + xM) / 2);\n\n      // Define path anchor points based on parameters and desired structure\n      // Start near medium circle, go up, arc left (180 deg), line right, line down, line right, line up to end point\n      var yTop = this._clamp(-hh * 0.8, -maxCoord, yM - rMedium - rArc); // Top Y level of the structure\n      var pA = {\n        x: xM,\n        y: this._clamp(yM - rMedium, yTop, maxCoord)\n      }; // Start below medium circle, but not below yTop\n      var pB = {\n        x: xM,\n        y: yTop\n      }; // Top of first vertical line segment\n\n      // Arc from pB leftwards. End point pD after 180 degrees.\n      var pD = {\n        x: xM - 2 * rArc,\n        y: yTop\n      }; // End of arc\n\n      var xRight = this._clamp(hw * 0.5, pD.x + 10, maxCoord); // X coordinate for the right vertical line\n      var pE = {\n        x: xRight,\n        y: yTop\n      }; // End of top horizontal line\n\n      var yBottom = this._clamp(hh * 0.8, yTop + 20, maxCoord); // Bottom Y level\n      var pF = {\n        x: xRight,\n        y: yBottom\n      }; // Bottom of right vertical line\n\n      var xEnd = this._clamp(hw * xEndFactor, xRight + 10, maxCoord); // Final X coordinate\n      var pG = {\n        x: xEnd,\n        y: yBottom\n      }; // End of bottom horizontal line\n\n      // Final point H (center of small circle)\n      var yEnd = this._clamp(yTop + hh * 0.2, -maxCoord + rSmall, maxCoord - rSmall);\n      var pH = {\n        x: xEnd,\n        y: yEnd\n      };\n      var cSmall = pH;\n\n      // --- 2. Rotate Points ---\n      // Rotate all calculated points around the origin (0,0)\n      var pointsToRotate = [cLarge, cMedium, cSmall, pA, pB, pD, pE, pF, pG];\n      var _pointsToRotate$map = pointsToRotate.map(function (p) {\n          return _this._rotatePoint(p.x, p.y, rotation);\n        }),\n        _pointsToRotate$map2 = _slicedToArray(_pointsToRotate$map, 9),\n        rCLarge = _pointsToRotate$map2[0],\n        rCMedium = _pointsToRotate$map2[1],\n        rCSmall = _pointsToRotate$map2[2],\n        rPA = _pointsToRotate$map2[3],\n        rPB = _pointsToRotate$map2[4],\n        rPD = _pointsToRotate$map2[5],\n        rPE = _pointsToRotate$map2[6],\n        rPF = _pointsToRotate$map2[7],\n        rPG = _pointsToRotate$map2[8];\n\n      // --- 3. Build SVG String ---\n      var svg = '';\n\n      // Add circles (filled white as per rules)\n      svg += \"<circle cx=\\\"\".concat(rCLarge.x.toFixed(2), \"\\\" cy=\\\"\").concat(rCLarge.y.toFixed(2), \"\\\" r=\\\"\").concat(rLarge.toFixed(2), \"\\\" fill=\\\"white\\\"/>\\n\");\n      svg += \"<circle cx=\\\"\".concat(rCMedium.x.toFixed(2), \"\\\" cy=\\\"\").concat(rCMedium.y.toFixed(2), \"\\\" r=\\\"\").concat(rMedium.toFixed(2), \"\\\" fill=\\\"white\\\"/>\\n\");\n      svg += \"<circle cx=\\\"\".concat(rCSmall.x.toFixed(2), \"\\\" cy=\\\"\").concat(rCSmall.y.toFixed(2), \"\\\" r=\\\"\").concat(rSmall.toFixed(2), \"\\\" fill=\\\"white\\\"/>\\n\");\n\n      // Add path (stroked white as per rules)\n      // Path: M A L B A(arc) D L E L F L G L H(cSmall)\n      var arcSweep = 0; // 0 for counter-clockwise sweep in SVG standard\n      var largeArcFlag = 0; // 0 because arc is <= 180 degrees\n\n      var pathData = \"M \".concat(rPA.x.toFixed(2), \",\").concat(rPA.y.toFixed(2), \" \") + // Move to start point A\n      \"L \".concat(rPB.x.toFixed(2), \",\").concat(rPB.y.toFixed(2), \" \") + // Line to B\n      // Arc command: rx ry x-axis-rotation large-arc-flag sweep-flag x y\n      \"A \".concat(rArc.toFixed(2), \",\").concat(rArc.toFixed(2), \" 0 \").concat(largeArcFlag, \" \").concat(arcSweep, \" \").concat(rPD.x.toFixed(2), \",\").concat(rPD.y.toFixed(2), \" \") + // Arc to D\n      \"L \".concat(rPE.x.toFixed(2), \",\").concat(rPE.y.toFixed(2), \" \") + // Line to E\n      \"L \".concat(rPF.x.toFixed(2), \",\").concat(rPF.y.toFixed(2), \" \") + // Line to F\n      \"L \".concat(rPG.x.toFixed(2), \",\").concat(rPG.y.toFixed(2), \" \") + // Line to G\n      \"L \".concat(rCSmall.x.toFixed(2), \",\").concat(rCSmall.y.toFixed(2)); // Line to H (small circle center)\n\n      // stroke-linejoin=\"round\" gives a slightly softer look at corners like the reference\n      svg += \"<path d=\\\"\".concat(pathData, \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(lineWidth.toFixed(2), \"\\\" stroke-linecap=\\\"butt\\\" stroke-linejoin=\\\"round\\\"/>\\n\");\n      return svg;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(DecoStructure, \"parameters\", {\n  structureWidth: {\n    type: 'number',\n    min: 80,\n    max: 180,\n    step: 2,\n    \"default\": 130,\n    label: 'Structure Width'\n  },\n  structureHeight: {\n    type: 'number',\n    min: 80,\n    max: 180,\n    step: 2,\n    \"default\": 140,\n    label: 'Structure Height'\n  },\n  rLarge: {\n    type: 'number',\n    min: 10,\n    max: 80,\n    step: 1,\n    \"default\": 40,\n    label: 'Large Radius'\n  },\n  rMedium: {\n    type: 'number',\n    min: 5,\n    max: 50,\n    step: 1,\n    \"default\": 20,\n    label: 'Medium Radius'\n  },\n  rSmall: {\n    type: 'number',\n    min: 2,\n    max: 20,\n    step: 1,\n    \"default\": 8,\n    label: 'Small Radius'\n  },\n  arcRadius: {\n    type: 'number',\n    min: 5,\n    max: 40,\n    step: 1,\n    \"default\": 15,\n    label: 'Arc Radius'\n  },\n  lineWidth: {\n    type: 'number',\n    min: 1,\n    max: 10,\n    step: 1,\n    \"default\": 2,\n    label: 'Line Width'\n  },\n  rotation: {\n    type: 'number',\n    min: 0,\n    max: 360,\n    step: 45,\n    \"default\": 0,\n    label: 'Rotation'\n  },\n  // Relative positioning factors\n  xMedFactor: {\n    type: 'number',\n    min: -0.9,\n    max: -0.1,\n    step: 0.05,\n    \"default\": -0.5,\n    label: 'Med Circle X Pos'\n  },\n  // Factor of structureWidth/2\n  yMedFactor: {\n    type: 'number',\n    min: -0.5,\n    max: 0.5,\n    step: 0.05,\n    \"default\": 0.1,\n    label: 'Med Circle Y Pos'\n  },\n  // Factor of structureHeight/2\n  yLargeFactor: {\n    type: 'number',\n    min: 0.1,\n    max: 0.9,\n    step: 0.05,\n    \"default\": 0.6,\n    label: 'Large Circle Y Pos'\n  },\n  // Factor of structureHeight/2\n  xEndFactor: {\n    type: 'number',\n    min: 0.1,\n    max: 0.9,\n    step: 0.05,\n    \"default\": 0.7,\n    label: 'End Point X Pos'\n  },\n  // Factor of structureWidth/2\n  seed: {\n    type: 'number',\n    min: 1,\n    max: 10000,\n    \"default\": 404\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DecoStructure);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/DecoStructure.js?");

/***/ }),

/***/ "./src/shapes/DendriteShape.js":
/*!*************************************!*\
  !*** ./src/shapes/DendriteShape.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a branching, dendrite-like pattern radiating from the center, with\n * adjustable levels and randomness.\n */\nvar DendriteShape = /*#__PURE__*/function (_Shape) {\n  function DendriteShape() {\n    _classCallCheck(this, DendriteShape);\n    return _callSuper(this, DendriteShape, arguments);\n  }\n  _inherits(DendriteShape, _Shape);\n  return _createClass(DendriteShape, [{\n    key: \"generateRadialPoint\",\n    value: function generateRadialPoint(radius, angle, randomness) {\n      var noise = this.randomness * (this.random() - 0.5);\n      var x = radius * Math.cos(angle) + noise;\n      var y = radius * Math.sin(angle) + noise;\n      return {\n        x: x,\n        y: y\n      };\n    }\n  }, {\n    key: \"findClosestPoint\",\n    value: function findClosestPoint(point, points) {\n      var minDist = Infinity;\n      var closest = null;\n      var _iterator = _createForOfIteratorHelper(points),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var p = _step.value;\n          var distance = Math.hypot(point.x - p.x, point.y - p.y);\n          if (distance < minDist) {\n            minDist = distance;\n            closest = p;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return closest;\n    }\n  }, {\n    key: \"generateLevelPoints\",\n    value: function generateLevelPoints(radius) {\n      var points = [];\n      var pointCount = Math.ceil(radius * this.spawnFactor / 10);\n      for (var i = 0; i < pointCount; i++) {\n        var angle = i / pointCount * 2 * Math.PI + this.random() * 0.2;\n        points.push(this.generateRadialPoint(radius, angle, this.randomness));\n      }\n      return points;\n    }\n  }, {\n    key: \"generateDendrites\",\n    value: function generateDendrites() {\n      var center = {\n        x: 0,\n        y: 0\n      };\n      var currentRadius = this.radiusStep;\n      var previousLevelPoints = [center];\n      var paths = [];\n      for (var level = 0; level < this.levelCount; level++) {\n        var currentLevelPoints = this.generateLevelPoints(currentRadius);\n        var _iterator2 = _createForOfIteratorHelper(currentLevelPoints),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var endPoint = _step2.value;\n            var startPoint = this.findClosestPoint(endPoint, previousLevelPoints);\n            var foundExisting = false;\n            var _iterator3 = _createForOfIteratorHelper(paths),\n              _step3;\n            try {\n              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                var path = _step3.value;\n                var lastPoint = path[path.length - 1];\n                if (Math.abs(lastPoint.x - startPoint.x) < 0.1 && Math.abs(lastPoint.y - startPoint.y) < 0.1) {\n                  path.push(endPoint);\n                  foundExisting = true;\n                  break;\n                }\n              }\n            } catch (err) {\n              _iterator3.e(err);\n            } finally {\n              _iterator3.f();\n            }\n            if (!foundExisting) {\n              paths.push([startPoint, endPoint]);\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        previousLevelPoints = currentLevelPoints;\n        currentRadius += this.radiusStep;\n      }\n      return paths;\n    }\n  }, {\n    key: \"enhancePathWithIntermediatePoints\",\n    value: function enhancePathWithIntermediatePoints(path) {\n      if (path.length < 2) return path;\n      var enhancedPath = [];\n      var numIntermediatePoints = Math.max(1, Math.floor(this.organicFactor / 2));\n      for (var i = 0; i < path.length - 1; i++) {\n        var p1 = path[i];\n        var p2 = path[i + 1];\n        enhancedPath.push(p1);\n        for (var j = 1; j <= numIntermediatePoints; j++) {\n          var t = j / (numIntermediatePoints + 1);\n          var x = p1.x + (p2.x - p1.x) * t;\n          var y = p1.y + (p2.y - p1.y) * t;\n          var dx = p2.x - p1.x;\n          var dy = p2.y - p1.y;\n          var len = Math.sqrt(dx * dx + dy * dy);\n          var perpX = -dy;\n          var perpY = dx;\n          var maxOffset = len * 0.15 * (this.organicFactor / 10);\n          var offset = (this.random() - 0.5) * maxOffset;\n          enhancedPath.push({\n            x: x + perpX / len * offset,\n            y: y + perpY / len * offset\n          });\n        }\n      }\n      enhancedPath.push(path[path.length - 1]);\n      return enhancedPath;\n    }\n  }, {\n    key: \"generateOrganicCurve\",\n    value: function generateOrganicCurve(points) {\n      if (points.length < 2) return '';\n      if (points.length === 2) {\n        return \"M\".concat(points[0].x, \",\").concat(points[0].y, \" L\").concat(points[1].x, \",\").concat(points[1].y);\n      }\n      var pathData = \"M\".concat(points[0].x, \",\").concat(points[0].y);\n      for (var i = 1; i < points.length; i++) {\n        var prev = points[i - 1];\n        var current = points[i];\n        if (i < points.length - 1) {\n          var next = points[i + 1];\n          var cpX = (prev.x + current.x) / 2;\n          var cpY = (prev.y + current.y) / 2;\n          var dx1 = current.x - prev.x;\n          var dy1 = current.y - prev.y;\n          var dx2 = next.x - current.x;\n          var dy2 = next.y - current.y;\n          var organicOffset = this.organicFactor / 20;\n          var offsetX = (this.random() - 0.5) * organicOffset * Math.abs(dx1 + dx2);\n          var offsetY = (this.random() - 0.5) * organicOffset * Math.abs(dy1 + dy2);\n          pathData += \" Q\".concat(cpX + offsetX, \",\").concat(cpY + offsetY, \" \").concat(current.x, \",\").concat(current.y);\n        } else {\n          pathData += \" L\".concat(current.x, \",\").concat(current.y);\n        }\n      }\n      return pathData;\n    }\n  }, {\n    key: \"generateStraightPaths\",\n    value: function generateStraightPaths(paths) {\n      var _this = this;\n      return paths.map(function (path) {\n        var enhancedPath = _this.enhancePathWithIntermediatePoints(path);\n        return enhancedPath.map(function (point, index) {\n          if (index === 0) return \"M\".concat(point.x, \" \").concat(point.y);\n          return \"L\".concat(point.x, \" \").concat(point.y);\n        }).join(' ');\n      });\n    }\n  }, {\n    key: \"generateCurvedPaths\",\n    value: function generateCurvedPaths(paths) {\n      var _this2 = this;\n      return paths.map(function (path) {\n        var enhancedPath = _this2.enhancePathWithIntermediatePoints(path);\n        return _this2.generateOrganicCurve(enhancedPath);\n      });\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this3 = this;\n      this.resetRNG(this.seed);\n      var paths = this.generateDendrites();\n      var pathStrings;\n      if (this.curveStyle === 'curved') {\n        pathStrings = this.generateCurvedPaths(paths);\n      } else {\n        pathStrings = this.generateStraightPaths(paths);\n      }\n      return pathStrings.map(function (pathString) {\n        return \"<path \\n                d=\\\"\".concat(pathString, \"\\\" \\n                fill=\\\"none\\\" \\n                stroke=\\\"white\\\" \\n                stroke-width=\\\"\").concat(_this3.branchThickness, \"\\\"\\n                stroke-linecap=\\\"\").concat(_this3.lineCap, \"\\\"\\n            />\");\n      }).join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(DendriteShape, \"parameters\", {\n  levelCount: {\n    min: 1,\n    max: 15,\n    \"default\": 5\n  },\n  spawnFactor: {\n    min: 1,\n    max: 12,\n    \"default\": 3\n  },\n  radiusStep: {\n    min: 5,\n    max: 20,\n    \"default\": 20\n  },\n  branchThickness: {\n    min: 1,\n    max: 8,\n    \"default\": 2\n  },\n  randomness: {\n    min: 0,\n    max: 10,\n    \"default\": 2\n  },\n  curveStyle: {\n    options: ['straight', 'curved'],\n    \"default\": 'curved'\n  },\n  lineCap: {\n    options: ['butt', 'round'],\n    \"default\": 'round'\n  },\n  organicFactor: {\n    min: 0,\n    max: 10,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DendriteShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/DendriteShape.js?");

/***/ }),

/***/ "./src/shapes/DiagonalCircleShape.js":
/*!*******************************************!*\
  !*** ./src/shapes/DiagonalCircleShape.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Creates a circle with a diagonal line cutout using an SVG mask.\n */\nvar DiagonalCircleShape = /*#__PURE__*/function (_Shape) {\n  function DiagonalCircleShape() {\n    _classCallCheck(this, DiagonalCircleShape);\n    return _callSuper(this, DiagonalCircleShape, arguments);\n  }\n  _inherits(DiagonalCircleShape, _Shape);\n  return _createClass(DiagonalCircleShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var centerX = 0;\n      var centerY = 0;\n\n      // Scale values to match viewBox\n      var viewBoxScale = 1;\n      var circleRadius = this.circleSize / 2 * viewBoxScale;\n      var lineThickness = this.lineThickness * viewBoxScale;\n      var lineAngle = this.lineAngle * (Math.PI / 180); // Convert to radians\n\n      // Calculate line endpoints based on circle size and length parameter\n      var lineHalfLength = circleRadius * this.lineLength;\n      var dx = Math.cos(lineAngle) * lineHalfLength;\n      var dy = Math.sin(lineAngle) * lineHalfLength;\n\n      // Generate a unique ID for the mask\n      var maskId = \"circle-mask-\".concat(Math.random().toString(36).substr(2, 9));\n      return \"\\n            <defs>\\n                <mask id=\\\"\".concat(maskId, \"\\\">\\n                    <!-- Base circle (white) -->\\n                    <circle \\n                        cx=\\\"\").concat(centerX, \"\\\" \\n                        cy=\\\"\").concat(centerY, \"\\\" \\n                        r=\\\"\").concat(circleRadius, \"\\\"\\n                        fill=\\\"white\\\"\\n                    />\\n                    \\n                    <!-- Cutout line (black) -->\\n                    <line \\n                        x1=\\\"\").concat(centerX - dx, \"\\\"\\n                        y1=\\\"\").concat(centerY - dy, \"\\\"\\n                        x2=\\\"\").concat(centerX + dx, \"\\\"\\n                        y2=\\\"\").concat(centerY + dy, \"\\\"\\n                        stroke=\\\"black\\\"\\n                        stroke-width=\\\"\").concat(lineThickness, \"\\\"\\n                        stroke-linecap=\\\"round\\\"\\n                    />\\n                </mask>\\n            </defs>\\n            \\n            <!-- Main shape with mask -->\\n            <g>\\n                <circle \\n                    cx=\\\"\").concat(centerX, \"\\\" \\n                    cy=\\\"\").concat(centerY, \"\\\" \\n                    r=\\\"\").concat(circleRadius, \"\\\"\\n                    fill=\\\"white\\\"\\n                    mask=\\\"url(#\").concat(maskId, \")\\\"\\n                />\\n            </g>\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(DiagonalCircleShape, \"parameters\", {\n  circleSize: {\n    min: 50,\n    max: 200,\n    \"default\": 150\n  },\n  lineThickness: {\n    min: 1,\n    max: 20,\n    \"default\": 10\n  },\n  lineAngle: {\n    min: -45,\n    max: 45,\n    \"default\": -45\n  },\n  lineLength: {\n    min: 0.5,\n    max: 1.2,\n    \"default\": 1.0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DiagonalCircleShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/DiagonalCircleShape.js?");

/***/ }),

/***/ "./src/shapes/DiagonalGrid.js":
/*!************************************!*\
  !*** ./src/shapes/DiagonalGrid.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a grid pattern composed of diagonal squares or triangles, with fill\n * or stroke options.\n */\nvar DiagonalGrid = /*#__PURE__*/function (_Shape) {\n  function DiagonalGrid() {\n    _classCallCheck(this, DiagonalGrid);\n    return _callSuper(this, DiagonalGrid, arguments);\n  }\n  _inherits(DiagonalGrid, _Shape);\n  return _createClass(DiagonalGrid, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      this.baseSize = 150;\n      var cells = [];\n      var cellSize = this.baseSize / this.gridSize;\n      var startX = -this.baseSize / 2;\n      var startY = -this.baseSize / 2;\n\n      // Generate triangular grid pattern\n      for (var i = 0; i < this.gridSize; i++) {\n        for (var j = 0; j <= i; j++) {\n          var x = startX + j * cellSize + cellSize / 2;\n          var y = startY + i * cellSize + cellSize / 2;\n\n          // Apply cell rotation if in rotated mode\n          var cellRotation = this.cellMode === 'rotated' ? 45 : 0;\n          cells.push(\"<g transform=\\\"translate(\".concat(x, \",\").concat(y, \") rotate(\").concat(cellRotation, \")\\\">\\n                    <rect \\n                        x=\\\"\").concat(-cellSize / 2 + this.inset, \"\\\"\\n                        y=\\\"\").concat(-cellSize / 2 + this.inset, \"\\\"\\n                        width=\\\"\").concat(cellSize - this.inset * 2, \"\\\"\\n                        height=\\\"\").concat(cellSize - this.inset * 2, \"\\\"\\n                        fill=\\\"\").concat(this.fillStyle === 'fill' ? 'white' : 'none', \"\\\"\\n                        stroke=\\\"white\\\"\\n                        stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                    />\\n                </g>\"));\n        }\n      }\n      return cells.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(DiagonalGrid, \"parameters\", {\n  gridSize: {\n    min: 2,\n    max: 8,\n    \"default\": 3\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  },\n  cellMode: {\n    options: ['normal', 'rotated'],\n    \"default\": 'normal'\n  },\n  fillStyle: {\n    options: ['stroke', 'fill'],\n    \"default\": 'stroke'\n  },\n  inset: {\n    min: 0,\n    max: 10,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DiagonalGrid);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/DiagonalGrid.js?");

/***/ }),

/***/ "./src/shapes/DiagonalStripes.js":
/*!***************************************!*\
  !*** ./src/shapes/DiagonalStripes.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a pattern of parallel diagonal stripes within a square boundary.\n */\nvar DiagonalStripes = /*#__PURE__*/function (_Shape) {\n  function DiagonalStripes() {\n    _classCallCheck(this, DiagonalStripes);\n    return _callSuper(this, DiagonalStripes, arguments);\n  }\n  _inherits(DiagonalStripes, _Shape);\n  return _createClass(DiagonalStripes, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      this.stripeCount = Math.round(this.stripeCount);\n      var size = this.size;\n      var diagonalLength = Math.sqrt(2) * size * 1.2; // Extended to ensure coverage\n\n      // Calculate base stripe width without spacing\n      var baseStripeWidth = diagonalLength / (this.stripeCount * 2);\n\n      // Calculate pattern width including spacing\n      var totalWidth = baseStripeWidth * this.stripeCount + this.spacing * (this.stripeCount - 1);\n\n      // Center the pattern\n      var startX = -totalWidth / 2;\n\n      // Create clipping path\n      var clipId = \"square-clip-\".concat(Math.random().toString(36).substr(2, 9));\n      var halfSize = size / 2;\n      var clipPath = \"<defs>\\n            <clipPath id=\\\"\".concat(clipId, \"\\\">\\n                <rect \\n                    x=\\\"\").concat(-halfSize, \"\\\" \\n                    y=\\\"\").concat(-halfSize, \"\\\" \\n                    width=\\\"\").concat(size, \"\\\" \\n                    height=\\\"\").concat(size, \"\\\"\\n                />\\n            </clipPath>\\n        </defs>\");\n\n      // Generate stripes\n      var stripes = [];\n      for (var i = 0; i < this.stripeCount; i++) {\n        var x = startX + i * (baseStripeWidth + this.spacing);\n        stripes.push(\"<rect \\n                x=\\\"\".concat(x, \"\\\"\\n                y=\\\"\").concat(-diagonalLength / 2, \"\\\"\\n                width=\\\"\").concat(baseStripeWidth, \"\\\"\\n                height=\\\"\").concat(diagonalLength, \"\\\"\\n                fill=\\\"white\\\"\\n                transform=\\\"rotate(45, 0, 0)\\\"\\n            />\"));\n      }\n      return \"\\n            \".concat(clipPath, \"\\n            <g clip-path=\\\"url(#\").concat(clipId, \")\\\">\\n                \").concat(stripes.join('\\n                '), \"\\n            </g>\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(DiagonalStripes, \"parameters\", {\n  size: {\n    min: 50,\n    max: 200,\n    \"default\": 140\n  },\n  stripeCount: {\n    min: 2,\n    max: 20,\n    \"default\": 5\n  },\n  spacing: {\n    min: 1,\n    max: 50,\n    \"default\": 20\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DiagonalStripes);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/DiagonalStripes.js?");

/***/ }),

/***/ "./src/shapes/DiagonalTechShape.js":
/*!*****************************************!*\
  !*** ./src/shapes/DiagonalTechShape.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Creates a tech-inspired symbol with a central diamond and two diagonal arms\n * extending outwards.\n */\nvar DiagonalTechShape = /*#__PURE__*/function (_Shape) {\n  function DiagonalTechShape() {\n    _classCallCheck(this, DiagonalTechShape);\n    return _callSuper(this, DiagonalTechShape, arguments);\n  }\n  _inherits(DiagonalTechShape, _Shape);\n  return _createClass(DiagonalTechShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Center point (0,0) since we're using the -200,-200,400,400 viewBox\n      var center = {\n        x: 0,\n        y: 0\n      };\n\n      // Convert slant angle to radians\n      var slantRad = this.slantAngle * Math.PI / 180;\n\n      // Create center diamond points\n      var diamondPoints = [\"\".concat(center.x - this.centerSize / 2, \",\").concat(center.y), // Left\n      \"\".concat(center.x, \",\").concat(center.y - this.centerSize / 2), // Top\n      \"\".concat(center.x + this.centerSize / 2, \",\").concat(center.y), // Right\n      \"\".concat(center.x, \",\").concat(center.y + this.centerSize / 2) // Bottom\n      ];\n\n      // Calculate arm offsets using trigonometry\n      var dx = Math.cos(slantRad) * this.armLength;\n      var dy = Math.sin(slantRad) * this.armLength;\n\n      // Upper-left arm points\n      var upperLeftArm = [\"\".concat(center.x - this.centerSize / 2, \",\").concat(center.y), // Start at diamond\n      \"\".concat(center.x - this.centerSize / 2 - dx, \",\").concat(center.y - dy), // Outer point\n      \"\".concat(center.x - this.centerSize / 2 - dx, \",\").concat(center.y - dy + this.armWidth), // Width\n      \"\".concat(center.x - this.centerSize / 2, \",\").concat(center.y + this.armWidth) // Back to diamond\n      ];\n\n      // Lower-right arm points\n      var lowerRightArm = [\"\".concat(center.x + this.centerSize / 2, \",\").concat(center.y), // Start at diamond\n      \"\".concat(center.x + this.centerSize / 2 + dx, \",\").concat(center.y + dy), // Outer point\n      \"\".concat(center.x + this.centerSize / 2 + dx, \",\").concat(center.y + dy - this.armWidth), // Width\n      \"\".concat(center.x + this.centerSize / 2, \",\").concat(center.y - this.armWidth) // Back to diamond\n      ];\n\n      // Construct SVG paths\n      return \"\\n            <path d=\\\"M \".concat(diamondPoints[0], \" L \").concat(diamondPoints[1], \" L \").concat(diamondPoints[2], \" L \").concat(diamondPoints[3], \" Z\\\" \\n                  fill=\\\"white\\\" />\\n            <path d=\\\"M \").concat(upperLeftArm[0], \" L \").concat(upperLeftArm[1], \" L \").concat(upperLeftArm[2], \" L \").concat(upperLeftArm[3], \" Z\\\" \\n                  fill=\\\"white\\\" />\\n            <path d=\\\"M \").concat(lowerRightArm[0], \" L \").concat(lowerRightArm[1], \" L \").concat(lowerRightArm[2], \" L \").concat(lowerRightArm[3], \" Z\\\" \\n                  fill=\\\"white\\\" />\\n        \");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(DiagonalTechShape, \"parameters\", {\n  centerSize: {\n    min: 10,\n    max: 100,\n    \"default\": 40\n  },\n  armLength: {\n    min: 20,\n    max: 150,\n    \"default\": 80\n  },\n  armWidth: {\n    min: 10,\n    max: 80,\n    \"default\": 30\n  },\n  slantAngle: {\n    min: 15,\n    max: 75,\n    \"default\": 45\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DiagonalTechShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/DiagonalTechShape.js?");

/***/ }),

/***/ "./src/shapes/DiamondArrowShape.js":
/*!*****************************************!*\
  !*** ./src/shapes/DiamondArrowShape.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a diamond shape with arrow-like cutouts pointing inwards from the\n * top and bottom vertices.\n */\nvar DiamondArrowShape = /*#__PURE__*/function (_Shape) {\n  function DiamondArrowShape() {\n    _classCallCheck(this, DiamondArrowShape);\n    return _callSuper(this, DiamondArrowShape, arguments);\n  }\n  _inherits(DiamondArrowShape, _Shape);\n  return _createClass(DiamondArrowShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var centerX = 0;\n      var centerY = 0;\n\n      // Scale values\n      var scaledSize = this.size;\n      var arrowWidthSize = scaledSize * this.arrowWidth;\n      var arrowDepthSize = scaledSize * this.arrowDepth;\n\n      // Calculate diamond points\n      var top = \"\".concat(centerX, \",\").concat(centerY - scaledSize / 2);\n      var right = \"\".concat(centerX + scaledSize / 2, \",\").concat(centerY);\n      var bottom = \"\".concat(centerX, \",\").concat(centerY + scaledSize / 2);\n      var left = \"\".concat(centerX - scaledSize / 2, \",\").concat(centerY);\n\n      // Generate a unique ID for the mask\n      var maskId = \"diamond-mask-\".concat(Math.random().toString(36).substr(2, 9));\n      return \"\\n            <defs>\\n                <mask id=\\\"\".concat(maskId, \"\\\">\\n                    <!-- Base diamond (white) -->\\n                    <polygon \\n                        points=\\\"\").concat(top, \" \").concat(right, \" \").concat(bottom, \" \").concat(left, \"\\\"\\n                        fill=\\\"white\\\"\\n                    />\\n                    \\n                    <!-- Arrow cutouts (black) -->\\n                    <polygon \\n                        points=\\\"\").concat(centerX - arrowWidthSize / 2, \",\").concat(centerY - arrowDepthSize, \" \\n                               \").concat(centerX, \",\").concat(centerY, \" \\n                               \").concat(centerX + arrowWidthSize / 2, \",\").concat(centerY - arrowDepthSize, \"\\\"\\n                        fill=\\\"black\\\"\\n                    />\\n                    <polygon \\n                        points=\\\"\").concat(centerX - arrowWidthSize / 2, \",\").concat(centerY + arrowDepthSize, \" \\n                               \").concat(centerX, \",\").concat(centerY, \" \\n                               \").concat(centerX + arrowWidthSize / 2, \",\").concat(centerY + arrowDepthSize, \"\\\"\\n                        fill=\\\"black\\\"\\n                    />\\n                </mask>\\n            </defs>\\n            \\n            <!-- Main shape with mask -->\\n            <polygon \\n                points=\\\"\").concat(top, \" \").concat(right, \" \").concat(bottom, \" \").concat(left, \"\\\"\\n                fill=\\\"white\\\"\\n                mask=\\\"url(#\").concat(maskId, \")\\\"\\n            />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(DiamondArrowShape, \"parameters\", {\n  size: {\n    min: 50,\n    max: 300,\n    \"default\": 200\n  },\n  arrowWidth: {\n    min: 0.1,\n    max: 0.5,\n    \"default\": 0.3\n  },\n  arrowDepth: {\n    min: 0.1,\n    max: 0.5,\n    \"default\": 0.3\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DiamondArrowShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/DiamondArrowShape.js?");

/***/ }),

/***/ "./src/shapes/DiamondHexShape.js":
/*!***************************************!*\
  !*** ./src/shapes/DiamondHexShape.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a hexagonal outline with a diamond-shaped cutout in the center.\n */\nvar DiamondHexShape = /*#__PURE__*/function (_Shape) {\n  function DiamondHexShape() {\n    _classCallCheck(this, DiamondHexShape);\n    return _callSuper(this, DiamondHexShape, arguments);\n  }\n  _inherits(DiamondHexShape, _Shape);\n  return _createClass(DiamondHexShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Center point (0,0) since we're using the -200,-200,400,400 viewBox\n      var center = {\n        x: 0,\n        y: 0\n      };\n\n      // Generate hexagon points\n      var hexPoints = [];\n      for (var i = 0; i < 6; i++) {\n        var angle = i * Math.PI / 3;\n        hexPoints.push({\n          x: center.x + Math.cos(angle) * this.hexSize,\n          y: center.y + Math.sin(angle) * this.hexSize\n        });\n      }\n\n      // Generate diamond points\n      var diamondPoints = [{\n        x: center.x,\n        y: center.y - this.diamondHeight / 2\n      },\n      // Top\n      {\n        x: center.x + this.diamondWidth / 2,\n        y: center.y\n      },\n      // Right\n      {\n        x: center.x,\n        y: center.y + this.diamondHeight / 2\n      },\n      // Bottom\n      {\n        x: center.x - this.diamondWidth / 2,\n        y: center.y\n      } // Left\n      ];\n\n      // Create hexagon path\n      var hexPath = \"M \".concat(hexPoints[0].x, \",\").concat(hexPoints[0].y, \" \") + hexPoints.slice(1).map(function (p) {\n        return \"L \".concat(p.x, \",\").concat(p.y);\n      }).join(' ') + ' Z';\n\n      // Create diamond path with optional rounded corners\n      var diamondPath;\n      // Generate path with sharp corners\n      diamondPath = \"M \".concat(diamondPoints[0].x, \",\").concat(diamondPoints[0].y, \" \") + diamondPoints.slice(1).map(function (p) {\n        return \"L \".concat(p.x, \",\").concat(p.y);\n      }).join(' ') + ' Z';\n\n      // Return combined path using fill-rule to create cutout effect\n      return \"<path \\n            d=\\\"\".concat(hexPath, \" \").concat(diamondPath, \"\\\"\\n            fill=\\\"white\\\"\\n            fill-rule=\\\"evenodd\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(DiamondHexShape, \"parameters\", {\n  hexSize: {\n    min: 50,\n    max: 100,\n    \"default\": 100\n  },\n  diamondWidth: {\n    min: 10,\n    max: 100,\n    \"default\": 40\n  },\n  diamondHeight: {\n    min: 10,\n    max: 150,\n    \"default\": 80\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DiamondHexShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/DiamondHexShape.js?");

/***/ }),

/***/ "./src/shapes/DiamondPairShape.js":
/*!****************************************!*\
  !*** ./src/shapes/DiamondPairShape.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a shape consisting of two adjacent or overlapping diamond shapes.\n */\nvar DiamondPairShape = /*#__PURE__*/function (_Shape) {\n  function DiamondPairShape() {\n    _classCallCheck(this, DiamondPairShape);\n    return _callSuper(this, DiamondPairShape, arguments);\n  }\n  _inherits(DiamondPairShape, _Shape);\n  return _createClass(DiamondPairShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var centerX = 0;\n      var centerY = 0;\n      var scale = 1;\n\n      // Scale values\n      var width = this.width * scale;\n      var height = this.height * scale;\n      var angleRad = this.angle * Math.PI / 180;\n      var separation = this.separation * scale;\n\n      // Calculate points for left diamond\n      var leftCenterX = centerX - width / 2 - separation / 2;\n      var leftPoints = [\"\".concat(leftCenterX, \",\").concat(centerY - height / 2), // top\n      \"\".concat(leftCenterX - width / 2 * Math.cos(angleRad), \",\").concat(centerY), // left\n      \"\".concat(leftCenterX, \",\").concat(centerY + height / 2), // bottom\n      \"\".concat(leftCenterX + width / 2 * Math.cos(angleRad), \",\").concat(centerY) // right\n      ].join(' ');\n\n      // Calculate points for right diamond\n      var rightCenterX = centerX + width / 2 + separation / 2;\n      var rightPoints = [\"\".concat(rightCenterX, \",\").concat(centerY - height / 2), // top\n      \"\".concat(rightCenterX - width / 2 * Math.cos(angleRad), \",\").concat(centerY), // left\n      \"\".concat(rightCenterX, \",\").concat(centerY + height / 2), // bottom\n      \"\".concat(rightCenterX + width / 2 * Math.cos(angleRad), \",\").concat(centerY) // right\n      ].join(' ');\n      return \"\\n            <g>\\n                <!-- Left diamond -->\\n                <polygon \\n                    points=\\\"\".concat(leftPoints, \"\\\"\\n                    fill=\\\"white\\\"\\n                />\\n                \\n                <!-- Right diamond -->\\n                <polygon \\n                    points=\\\"\").concat(rightPoints, \"\\\"\\n                    fill=\\\"white\\\"\\n                />\\n            </g>\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(DiamondPairShape, \"parameters\", {\n  width: {\n    min: 50,\n    max: 200,\n    \"default\": 120\n  },\n  height: {\n    min: 50,\n    max: 200,\n    \"default\": 120\n  },\n  angle: {\n    min: 30,\n    max: 80,\n    \"default\": 60\n  },\n  separation: {\n    min: -50,\n    max: 50,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DiamondPairShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/DiamondPairShape.js?");

/***/ }),

/***/ "./src/shapes/DiamondStarShape.js":
/*!****************************************!*\
  !*** ./src/shapes/DiamondStarShape.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a star-like shape formed by four triangular segments pointing\n * outwards from a central square.\n */\nvar DiamondStarShape = /*#__PURE__*/function (_Shape) {\n  function DiamondStarShape() {\n    _classCallCheck(this, DiamondStarShape);\n    return _callSuper(this, DiamondStarShape, arguments);\n  }\n  _inherits(DiamondStarShape, _Shape);\n  return _createClass(DiamondStarShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Use 100 as our base scale since we're in SVG viewBox coordinates\n      var scale = 100;\n      var center = {\n        x: 0,\n        y: 0\n      }; // Center point in viewBox\n\n      // Calculate four corners of outer diamond\n      var outerPoints = [{\n        x: center.x,\n        y: center.y - scale * this.spread\n      },\n      // Top\n      {\n        x: center.x + scale * this.spread,\n        y: center.y\n      },\n      // Right\n      {\n        x: center.x,\n        y: center.y + scale * this.spread\n      },\n      // Bottom\n      {\n        x: center.x - scale * this.spread,\n        y: center.y\n      } // Left\n      ];\n\n      // Calculate inner square points\n      var innerScale = scale * this.centerSize;\n      var innerPoints = [{\n        x: center.x - innerScale,\n        y: center.y - innerScale\n      },\n      // Top left\n      {\n        x: center.x + innerScale,\n        y: center.y - innerScale\n      },\n      // Top right\n      {\n        x: center.x + innerScale,\n        y: center.y + innerScale\n      },\n      // Bottom right\n      {\n        x: center.x - innerScale,\n        y: center.y + innerScale\n      } // Bottom left\n      ];\n\n      // Generate the four triangular segments\n      var segments = [];\n      for (var i = 0; i < 4; i++) {\n        var trianglePoint = outerPoints[i];\n        var innerPoint1 = innerPoints[i];\n        var innerPoint2 = innerPoints[(i + 1) % 4];\n\n        // Calculate inset point using triangleDepth\n        var insetX = trianglePoint.x * this.triangleDepth + center.x * (1 - this.triangleDepth);\n        var insetY = trianglePoint.y * this.triangleDepth + center.y * (1 - this.triangleDepth);\n\n        // Create path for this segment\n        segments.push(\"\\n                <path d=\\\"\\n                    M \".concat(innerPoint1.x, \",\").concat(innerPoint1.y, \"\\n                    L \").concat(trianglePoint.x, \",\").concat(trianglePoint.y, \"\\n                    L \").concat(innerPoint2.x, \",\").concat(innerPoint2.y, \"\\n                    L \").concat(insetX, \",\").concat(insetY, \"\\n                    Z\\n                \\\" fill=\\\"white\\\" />\\n            \"));\n      }\n      return segments.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(DiamondStarShape, \"parameters\", {\n  spread: {\n    min: 0.1,\n    max: 1.0,\n    \"default\": 0.7\n  },\n  centerSize: {\n    min: 0.1,\n    max: 0.5,\n    \"default\": 0.2\n  },\n  triangleDepth: {\n    min: 0.1,\n    max: 0.8,\n    \"default\": 0.7\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DiamondStarShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/DiamondStarShape.js?");

/***/ }),

/***/ "./src/shapes/Dice.js":
/*!****************************!*\
  !*** ./src/shapes/Dice.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a rounded square representing a die face, with circular cutouts\n * (dots) based on a specified value (1-9).\n */\nvar DiceCutoutShape = /*#__PURE__*/function (_Shape) {\n  function DiceCutoutShape() {\n    _classCallCheck(this, DiceCutoutShape);\n    return _callSuper(this, DiceCutoutShape, arguments);\n  }\n  _inherits(DiceCutoutShape, _Shape);\n  return _createClass(DiceCutoutShape, [{\n    key: \"calculateOptimalParameters\",\n    value: function calculateOptimalParameters() {\n      var halfSize = this.size / 2;\n      var usableSpace = this.size - 2 * this.padding;\n\n      // Calculate the maximum safe dot size based on usable space\n      var maxSafeDotSize = Math.min(usableSpace / 5,\n      // Ensure 5 dots can fit with spacing\n      this.dotSize // User requested size\n      );\n\n      // Set actual dot size\n      this.actualDotSize = maxSafeDotSize;\n\n      // Calculate spacing between dots\n      // Use 2.5 times dot size as minimum spacing to prevent overlap\n      var minSpacing = this.actualDotSize * 2.5;\n\n      // Calculate dot offset ensuring proper spacing\n      this.dotOffset = Math.min((usableSpace - 2 * this.actualDotSize) / 2,\n      // Maximum possible offset\n      Math.max(minSpacing,\n      // Minimum spacing\n      (usableSpace - 2 * this.actualDotSize) / 3 // Optimal spacing for 3x3 grid\n      ));\n    }\n  }, {\n    key: \"getDotPositions\",\n    value: function getDotPositions() {\n      var positions = {\n        1: [[0, 0]],\n        2: [[-1, -1], [1, 1]],\n        3: [[-1, -1], [0, 0], [1, 1]],\n        4: [[-1, -1], [1, -1], [-1, 1], [1, 1]],\n        5: [[-1, -1], [1, -1], [0, 0], [-1, 1], [1, 1]],\n        6: [[-1, -1], [1, -1], [-1, 0], [1, 0], [-1, 1], [1, 1]],\n        7: [[-1, -1], [1, -1], [-1, 0], [0, 0], [1, 0], [-1, 1], [1, 1]],\n        8: [[-1, -1], [0, -1], [1, -1], [-1, 0], [1, 0], [-1, 1], [0, 1], [1, 1]],\n        9: [[-1, -1], [0, -1], [1, -1], [-1, 0], [0, 0], [1, 0], [-1, 1], [0, 1], [1, 1]]\n      };\n      return positions[this.value] || positions[1];\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      // Calculate the parameters before generating the shape\n      this.calculateOptimalParameters();\n      var halfSize = this.size / 2;\n\n      // Create main rounded square\n      var mainPath = [\"M\".concat(-halfSize + this.cornerRadius, \",\").concat(-halfSize), \"h\".concat(this.size - 2 * this.cornerRadius), \"q\".concat(this.cornerRadius, \",0 \").concat(this.cornerRadius, \",\").concat(this.cornerRadius), \"v\".concat(this.size - 2 * this.cornerRadius), \"q0,\".concat(this.cornerRadius, \" \").concat(-this.cornerRadius, \",\").concat(this.cornerRadius), \"h\".concat(-this.size + 2 * this.cornerRadius), \"q\".concat(-this.cornerRadius, \",0 \").concat(-this.cornerRadius, \",\").concat(-this.cornerRadius), \"v\".concat(-this.size + 2 * this.cornerRadius), \"q0,\".concat(-this.cornerRadius, \" \").concat(this.cornerRadius, \",\").concat(-this.cornerRadius), 'Z'].join(' ');\n\n      // Create dots with proper spacing\n      var dotPositions = this.getDotPositions();\n\n      // Generate separate paths for each dot instead of combining them\n      var dotPaths = dotPositions.map(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n          x = _ref2[0],\n          y = _ref2[1];\n        var cx = x * _this.dotOffset;\n        var cy = y * _this.dotOffset;\n        return \"<circle cx=\\\"\".concat(cx, \"\\\" cy=\\\"\").concat(cy, \"\\\" r=\\\"\").concat(_this.actualDotSize, \"\\\" fill=\\\"black\\\" />\");\n      }).join('');\n\n      // Return SVG with main path and dot circles\n      return \"\\n            <path \\n                d=\\\"\".concat(mainPath, \"\\\"\\n                fill=\\\"white\\\"\\n            />\\n            \").concat(dotPaths, \"\\n        \");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(DiceCutoutShape, \"parameters\", {\n  size: {\n    min: 120,\n    max: 250,\n    \"default\": 150\n  },\n  cornerRadius: {\n    min: 0,\n    max: 60,\n    \"default\": 50\n  },\n  padding: {\n    min: 5,\n    max: 50,\n    \"default\": 17\n  },\n  dotSize: {\n    min: 5,\n    max: 40,\n    \"default\": 10\n  },\n  value: {\n    min: 1,\n    max: 9,\n    \"default\": 5\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DiceCutoutShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/Dice.js?");

/***/ }),

/***/ "./src/shapes/DotGrid.js":
/*!*******************************!*\
  !*** ./src/shapes/DotGrid.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a grid of dots where dot sizes vary based on parametric patterns\n * like center focus, waves, or noise.\n */\nvar DotGrid = /*#__PURE__*/function (_Shape) {\n  function DotGrid() {\n    _classCallCheck(this, DotGrid);\n    return _callSuper(this, DotGrid, arguments);\n  }\n  _inherits(DotGrid, _Shape);\n  return _createClass(DotGrid, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var size = this.gridSize;\n      var minR = this.minRadius;\n      var maxR = this.maxRadius;\n      var influence = this.influence;\n      var effect = this.effectType;\n\n      // Ensure maxRadius is always greater than or equal to minRadius\n      var actualMaxR = Math.max(minR, maxR);\n      var radiusRange = actualMaxR - minR;\n\n      // Define the boundary for the grid within the -100 to 100 viewport\n      var totalWidth = 180; // Leave some padding\n      var spacing = size > 1 ? totalWidth / (size - 1) : 0; // Distance between dot centers\n      var startOffset = -totalWidth / 2; // Top-left corner of the grid\n\n      var svgCircles = '';\n      var centerOffset = (size - 1) / 2; // Offset to calculate distance from grid center\n\n      for (var i = 0; i < size; i++) {\n        // Row index\n        for (var j = 0; j < size; j++) {\n          // Column index\n          var cx = size === 1 ? 0 : startOffset + j * spacing;\n          var cy = size === 1 ? 0 : startOffset + i * spacing;\n          var normalizedRadius = 0; // Value between 0 and 1\n\n          // Normalized coordinates relative to grid size (0 to 1)\n          var normX = size > 1 ? j / (size - 1) : 0.5;\n          var normY = size > 1 ? i / (size - 1) : 0.5;\n\n          // Normalized coordinates relative to grid center (-0.5 to 0.5 if size is odd, slightly different if even)\n          var centerX = size > 1 ? (j - centerOffset) / (size - 1) : 0;\n          var centerY = size > 1 ? (i - centerOffset) / (size - 1) : 0;\n          switch (effect) {\n            case 'center_focus':\n              {\n                // Gaussian falloff from the center\n                var distSq = centerX * centerX + centerY * centerY;\n                // Adjust the scaling factor (e.g., * 2) inside exp to control spread\n                normalizedRadius = Math.exp(-distSq * influence * 4); // Scaled influence for better visual effect\n                break;\n              }\n            case 'corner_focus':\n              {\n                // Focus towards a corner (e.g., top-left)\n                // Gaussian falloff from top-left (0,0 normalized)\n                var _distSq = normX * normX + normY * normY;\n                normalizedRadius = Math.exp(-_distSq * influence * 2);\n                break;\n                // Alternative: focus towards bottom-right (1,1 normalized)\n                // const distSq = (1 - normX) * (1 - normX) + (1 - normY) * (1 - normY);\n                // normalizedRadius = Math.exp(-distSq * influence * 2);\n              }\n            case 'diagonal_wave':\n              {\n                // Sinusoidal wave along the diagonal (i + j)\n                var phase = (i + j) * Math.PI * 2 * influence / (size * 2); // Adjust frequency with influence\n                normalizedRadius = (Math.sin(phase) + 1) / 2; // Map sin output (-1 to 1) to (0 to 1)\n                break;\n              }\n            case 'vertical_wave':\n              {\n                // Sinusoidal wave along columns (j)\n                var _phase = j * Math.PI * 2 * influence / size; // Adjust frequency with influence\n                normalizedRadius = (Math.sin(_phase) + 1) / 2; // Map sin output (-1 to 1) to (0 to 1)\n                break;\n              }\n            case 'top_focus':\n              {\n                // Larger dots at the top, decreasing downwards\n                // Using exponential decay based on row index\n                normalizedRadius = Math.exp(-normY * normY * influence * 2);\n                break;\n              }\n            case 'random_noise':\n              {\n                // Random radius for each dot\n                normalizedRadius = this.random(); // this.random() gives 0 to 1\n                // Scale randomness with influence - maybe just use the range directly?\n                // Let's keep it simple: influence here doesn't modify the randomness range directly, just inherited.\n                break;\n              }\n            default:\n              normalizedRadius = 0.5;\n            // Default case\n          }\n\n          // Clamp normalized radius between 0 and 1\n          normalizedRadius = Math.max(0, Math.min(1, normalizedRadius));\n\n          // Calculate final radius\n          var radius = minR + normalizedRadius * radiusRange;\n\n          // Ensure radius is not negative (shouldn't happen with clamping, but good practice)\n          var finalRadius = Math.max(0, radius);\n\n          // Append the circle SVG string\n          // Use toFixed(3) for cleaner SVG output\n          svgCircles += \"<circle cx=\\\"\".concat(cx.toFixed(3), \"\\\" cy=\\\"\").concat(cy.toFixed(3), \"\\\" r=\\\"\").concat(finalRadius.toFixed(3), \"\\\" fill=\\\"white\\\" />\\n\");\n        }\n      }\n      return svgCircles;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(DotGrid, \"parameters\", {\n  gridSize: {\n    type: 'number',\n    min: 3,\n    max: 15,\n    step: 1,\n    \"default\": 5,\n    label: 'Grid Size (NxN)'\n  },\n  minRadius: {\n    type: 'number',\n    min: 0.5,\n    max: 10,\n    step: 0.5,\n    \"default\": 1,\n    label: 'Min Radius'\n  },\n  maxRadius: {\n    type: 'number',\n    min: 2,\n    max: 25,\n    step: 0.5,\n    \"default\": 15,\n    label: 'Max Radius'\n  },\n  influence: {\n    type: 'number',\n    min: 0.5,\n    max: 5.0,\n    step: 0.1,\n    \"default\": 2.0,\n    label: 'Effect Influence'\n  },\n  effectType: {\n    type: 'enum',\n    options: ['center_focus', 'corner_focus', 'diagonal_wave', 'vertical_wave', 'top_focus', 'random_noise'],\n    \"default\": 'center_focus',\n    label: 'Effect Type'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DotGrid);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/DotGrid.js?");

/***/ }),

/***/ "./src/shapes/DotSpiral.js":
/*!*********************************!*\
  !*** ./src/shapes/DotSpiral.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a pattern of dots arranged in multiple spiral arms radiating from\n * the center.\n */\nvar DotSpiral = /*#__PURE__*/function (_Shape) {\n  function DotSpiral() {\n    _classCallCheck(this, DotSpiral);\n    return _callSuper(this, DotSpiral, arguments);\n  }\n  _inherits(DotSpiral, _Shape);\n  return _createClass(DotSpiral, [{\n    key: \"getSpreadAngle\",\n    value: function getSpreadAngle() {\n      return this.spread * (Math.PI / 180);\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var elements = [];\n\n      // Calculate angle step between each segment\n      var angleStep = 2 * Math.PI / this.segments;\n\n      // Generate dots along each segment\n      for (var i = 0; i < this.segments; i++) {\n        // Start position is at the center\n        var x = 0;\n        var y = 0;\n\n        // Calculate starting angle for this segment\n        var startAngle = i * angleStep;\n\n        // Add a few dots per segment\n        for (var j = 0; j < 4; j++) {\n          // Increase radius gradually to create spiral effect\n          var radius = (j + 1) * (this.spiralSize / 5.5); // Adjust divisor for spacing\n\n          // Calculate current angle on the spiral\n          var t = j / 3.0; // Progress through the spiral (0 to 1)\n          var progressAngle = this.getSpreadAngle() * t;\n\n          // Apply rotation and spiral effect\n          var finalAngle = startAngle + progressAngle;\n\n          // Calculate dot position using polar coordinates\n          x = radius * Math.cos(finalAngle);\n          y = radius * Math.sin(finalAngle);\n\n          // Create dot element\n          elements.push(\"<circle \\n                    cx=\\\"\".concat(x, \"\\\" \\n                    cy=\\\"\").concat(y, \"\\\"\\n                    r=\\\"\").concat(this.dotSize, \"\\\"\\n                    fill=\\\"white\\\"\\n                />\"));\n        }\n      }\n      return elements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(DotSpiral, \"parameters\", {\n  dotSize: {\n    min: 1,\n    max: 20,\n    \"default\": 4\n  },\n  spiralSize: {\n    min: 50,\n    max: 120,\n    \"default\": 120\n  },\n  segments: {\n    min: 3,\n    max: 24,\n    \"default\": 6\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 8\n  },\n  spread: {\n    min: 20,\n    max: 120,\n    \"default\": 90\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DotSpiral);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/DotSpiral.js?");

/***/ }),

/***/ "./src/shapes/DoubleArrow.js":
/*!***********************************!*\
  !*** ./src/shapes/DoubleArrow.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a symmetrical shape resembling a double-headed arrow with flared\n * ends.\n */\nvar DoubleArrow = /*#__PURE__*/function (_Shape) {\n  function DoubleArrow() {\n    _classCallCheck(this, DoubleArrow);\n    return _callSuper(this, DoubleArrow, arguments);\n  }\n  _inherits(DoubleArrow, _Shape);\n  return _createClass(DoubleArrow, [{\n    key: \"generateShape\",\n    value: function generateShape(params) {\n      // --- Shape generation logic starts here ---\n      // Use half-values for easier calculation relative to center (0,0)\n      var cw_half = this.centerWidth / 2;\n      var ch_half = this.centerHeight / 2;\n\n      // Ensure geometric integrity by enforcing minimums based on other parameters\n      var fw_half = Math.max(this.flareWidth / 2, cw_half);\n      var fh = Math.max(this.flareHeight, ch_half);\n      var th = Math.max(this.tipHeight, fh);\n\n      // Define key points for one quadrant (top-right)\n      var p_top_tip = {\n        x: 0,\n        y: th\n      };\n      var p_flare_inner = {\n        x: cw_half,\n        y: fh\n      };\n      var p_flare_outer = {\n        x: fw_half,\n        y: fh\n      };\n      var p_cross_outer = {\n        x: fw_half,\n        y: ch_half\n      };\n      var p_cross_inner = {\n        x: cw_half,\n        y: ch_half\n      };\n\n      // Build the path data string using symmetry\n      var pathData = [\"M \".concat(p_top_tip.x, \",\").concat(p_top_tip.y), // A: Top tip\n      \"L \".concat(p_flare_inner.x, \",\").concat(p_flare_inner.y), // B: Inner flare corner (Top-Right)\n      \"L \".concat(p_flare_outer.x, \",\").concat(p_flare_outer.y), // C: Outer flare corner (Top-Right)\n      \"L \".concat(p_cross_outer.x, \",\").concat(p_cross_outer.y), // D: Outer cross corner (Top-Right)\n      \"L \".concat(p_cross_inner.x, \",\").concat(p_cross_inner.y), // E: Inner cross corner (Top-Right)\n      \"L \".concat(p_cross_inner.x, \",\").concat(-p_cross_inner.y), // Mirror E across X-axis (Bottom-Right)\n      \"L \".concat(p_cross_outer.x, \",\").concat(-p_cross_outer.y), // Mirror D across X-axis (Bottom-Right)\n      \"L \".concat(p_flare_outer.x, \",\").concat(-p_flare_outer.y), // Mirror C across X-axis (Bottom-Right)\n      \"L \".concat(p_flare_inner.x, \",\").concat(-p_flare_inner.y), // Mirror B across X-axis (Bottom-Right)\n      \"L \".concat(p_top_tip.x, \",\").concat(-p_top_tip.y), // Mirror A across X-axis (Bottom tip)\n      \"L \".concat(-p_flare_inner.x, \",\").concat(-p_flare_inner.y), // Mirror B across Y then X (Bottom-Left)\n      \"L \".concat(-p_flare_outer.x, \",\").concat(-p_flare_outer.y), // Mirror C across Y then X (Bottom-Left)\n      \"L \".concat(-p_cross_outer.x, \",\").concat(-p_cross_outer.y), // Mirror D across Y then X (Bottom-Left)\n      \"L \".concat(-p_cross_inner.x, \",\").concat(-p_cross_inner.y), // Mirror E across Y then X (Bottom-Left)\n      \"L \".concat(-p_cross_inner.x, \",\").concat(p_cross_inner.y), // Mirror E across Y-axis (Top-Left)\n      \"L \".concat(-p_cross_outer.x, \",\").concat(p_cross_outer.y), // Mirror D across Y-axis (Top-Left)\n      \"L \".concat(-p_flare_outer.x, \",\").concat(p_flare_outer.y), // Mirror C across Y-axis (Top-Left)\n      \"L \".concat(-p_flare_inner.x, \",\").concat(p_flare_inner.y),\n      // Mirror B across Y-axis (Top-Left)\n\n      'Z' // Close the path\n      ].join(' ');\n\n      // Return the path element\n      return \"<path d=\\\"\".concat(pathData, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(DoubleArrow, \"parameters\", {\n  centerWidth: {\n    type: 'number',\n    min: 2,\n    max: 100,\n    step: 1,\n    \"default\": 30,\n    description: 'Width of the central vertical stem.'\n  },\n  centerHeight: {\n    type: 'number',\n    min: 2,\n    max: 100,\n    step: 1,\n    \"default\": 40,\n    description: 'Full height of the horizontal crossbar.'\n  },\n  flareWidth: {\n    type: 'number',\n    min: 2,\n    max: 190,\n    step: 1,\n    \"default\": 60,\n    description: 'Full width of the widest part of the arrow flare.'\n  },\n  flareHeight: {\n    type: 'number',\n    min: 1,\n    max: 98,\n    step: 1,\n    \"default\": 60,\n    description: 'Distance from the center to the base of the flare.'\n  },\n  tipHeight: {\n    type: 'number',\n    min: 2,\n    max: 100,\n    step: 1,\n    \"default\": 90,\n    description: 'Distance from the center to the arrow tip.'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DoubleArrow);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/DoubleArrow.js?");

/***/ }),

/***/ "./src/shapes/DoubleChevronShape.js":
/*!******************************************!*\
  !*** ./src/shapes/DoubleChevronShape.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates two vertically stacked chevron (V-shaped) lines.\n */\nvar DoubleChevronShape = /*#__PURE__*/function (_Shape) {\n  function DoubleChevronShape() {\n    _classCallCheck(this, DoubleChevronShape);\n    return _callSuper(this, DoubleChevronShape, arguments);\n  }\n  _inherits(DoubleChevronShape, _Shape);\n  return _createClass(DoubleChevronShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Center point (0,0) since we're using the -200,-200,400,400 viewBox\n      var center = {\n        x: 0,\n        y: 0\n      };\n\n      // Convert angle to radians and calculate height\n      var angleRad = this.angle * Math.PI / 180;\n      var height = this.width * Math.tan(angleRad) / 2;\n\n      // Calculate points for top chevron\n      var topY = center.y - this.spacing / 2;\n      var topPoints = [{\n        x: center.x - this.width / 2,\n        y: topY + height / 2\n      },\n      // Left\n      {\n        x: center.x,\n        y: topY - height / 2\n      },\n      // Center\n      {\n        x: center.x + this.width / 2,\n        y: topY + height / 2\n      } // Right\n      ];\n\n      // Calculate points for bottom chevron\n      var bottomY = center.y + this.spacing / 2;\n      var bottomPoints = [{\n        x: center.x - this.width / 2,\n        y: bottomY + height / 2\n      },\n      // Left\n      {\n        x: center.x,\n        y: bottomY - height / 2\n      },\n      // Center\n      {\n        x: center.x + this.width / 2,\n        y: bottomY + height / 2\n      } // Right\n      ];\n\n      // Create paths for both chevrons\n      var topPath = \"M \".concat(topPoints[0].x, \",\").concat(topPoints[0].y, \" \\n                        L \").concat(topPoints[1].x, \",\").concat(topPoints[1].y, \" \\n                        L \").concat(topPoints[2].x, \",\").concat(topPoints[2].y);\n      var bottomPath = \"M \".concat(bottomPoints[0].x, \",\").concat(bottomPoints[0].y, \" \\n                           L \").concat(bottomPoints[1].x, \",\").concat(bottomPoints[1].y, \" \\n                           L \").concat(bottomPoints[2].x, \",\").concat(bottomPoints[2].y);\n\n      // Return combined paths with stroke styling\n      return \"<path \\n            d=\\\"\".concat(topPath, \" \").concat(bottomPath, \"\\\"\\n            fill=\\\"none\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            stroke-linecap=\\\"square\\\"\\n            stroke-linejoin=\\\"miter\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(DoubleChevronShape, \"parameters\", {\n  spacing: {\n    min: 10,\n    max: 100,\n    \"default\": 40\n  },\n  // Space between chevrons\n  thickness: {\n    min: 2,\n    max: 50,\n    \"default\": 15\n  },\n  // Thickness of lines\n  angle: {\n    min: 20,\n    max: 50,\n    \"default\": 45\n  },\n  // Angle of points\n  width: {\n    min: 100,\n    max: 300,\n    \"default\": 200\n  } // Width of chevrons\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DoubleChevronShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/DoubleChevronShape.js?");

/***/ }),

/***/ "./src/shapes/DoubleXShape.js":
/*!************************************!*\
  !*** ./src/shapes/DoubleXShape.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a shape resembling two overlapping 'X' characters with adjustable\n * thickness, overlap, and angle.\n */\nvar DoubleXShape = /*#__PURE__*/function (_Shape) {\n  function DoubleXShape() {\n    _classCallCheck(this, DoubleXShape);\n    return _callSuper(this, DoubleXShape, arguments);\n  }\n  _inherits(DoubleXShape, _Shape);\n  return _createClass(DoubleXShape, [{\n    key: \"createX\",\n    value: function createX(center, size, angleRad) {\n      var halfSize = size / 2;\n\n      // Calculate corners of the X shape\n      var topLeft = {\n        x: center.x - halfSize * Math.cos(angleRad),\n        y: center.y - halfSize\n      };\n      var topRight = {\n        x: center.x + halfSize * Math.cos(angleRad),\n        y: center.y - halfSize\n      };\n      var bottomLeft = {\n        x: center.x - halfSize * Math.cos(angleRad),\n        y: center.y + halfSize\n      };\n      var bottomRight = {\n        x: center.x + halfSize * Math.cos(angleRad),\n        y: center.y + halfSize\n      };\n\n      // Create paths for both diagonals\n      return \"M \".concat(topLeft.x, \",\").concat(topLeft.y, \" L \").concat(bottomRight.x, \",\").concat(bottomRight.y, \" \\n                M \").concat(topRight.x, \",\").concat(topRight.y, \" L \").concat(bottomLeft.x, \",\").concat(bottomLeft.y);\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var center = {\n        x: 0,\n        y: 0\n      };\n\n      // Calculate base size to ensure shape stays within bounds\n      var baseSize = 100 * this.scale; // Adjusted for viewBox scale\n\n      // Convert angle to radians\n      var angleRad = this.angle * Math.PI / 180;\n\n      // Create paths for both X shapes\n      var x1 = this.createX({\n        x: center.x - this.overlap / 2,\n        y: center.y\n      }, baseSize, angleRad);\n      var x2 = this.createX({\n        x: center.x + this.overlap / 2,\n        y: center.y\n      }, baseSize, angleRad);\n\n      // Return combined paths with stroke styling\n      return \"<path \\n            d=\\\"\".concat(x1, \" \").concat(x2, \"\\\"\\n            fill=\\\"none\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            stroke-linecap=\\\"square\\\"\\n            stroke-linejoin=\\\"miter\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(DoubleXShape, \"parameters\", {\n  thickness: {\n    min: 1,\n    max: 80,\n    \"default\": 20\n  },\n  overlap: {\n    min: 0,\n    max: 100,\n    \"default\": 50\n  },\n  angle: {\n    min: 0,\n    max: 15,\n    \"default\": 6\n  },\n  scale: {\n    min: 0.2,\n    max: 0.8,\n    \"default\": 0.8\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DoubleXShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/DoubleXShape.js?");

/***/ }),

/***/ "./src/shapes/DroneIcon.js":
/*!*********************************!*\
  !*** ./src/shapes/DroneIcon.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a stylized drone icon with four arms radiating from the center and\n * customizable end elements (arcs, circles, arrows).\n */\nvar DroneIcon = /*#__PURE__*/function (_Shape) {\n  function DroneIcon() {\n    _classCallCheck(this, DroneIcon);\n    return _callSuper(this, DroneIcon, arguments);\n  }\n  _inherits(DroneIcon, _Shape);\n  return _createClass(DroneIcon, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      var svgElements = '';\n      var angles = [45, 135, 225, 315]; // Angles for the 4 arms in degrees\n      var rad = Math.PI / 180;\n\n      // Calculate start and end points for each arm\n      var startOffset = this.centerGap / Math.sqrt(2);\n      var armStartX = angles.map(function (angle) {\n        return startOffset * Math.cos(angle * rad);\n      });\n      var armStartY = angles.map(function (angle) {\n        return startOffset * Math.sin(angle * rad);\n      });\n      var armEndX = angles.map(function (angle) {\n        return _this.armLength * Math.cos(angle * rad);\n      });\n      var armEndY = angles.map(function (angle) {\n        return _this.armLength * Math.sin(angle * rad);\n      });\n\n      // 1. Draw Arms\n      for (var i = 0; i < 4; i++) {\n        svgElements += \"<line x1=\\\"\".concat(armStartX[i], \"\\\" y1=\\\"\").concat(armStartY[i], \"\\\" x2=\\\"\").concat(armEndX[i], \"\\\" y2=\\\"\").concat(armEndY[i], \"\\\"\\n                      stroke=\\\"white\\\" stroke-width=\\\"\").concat(this.armWidth, \"\\\" stroke-linecap=\\\"round\\\" />\");\n      }\n\n      // 2. Draw Arm Ends based on style\n      switch (this.endStyle) {\n        case 'Arc':\n          svgElements += this._drawArcEnds(armEndX, armEndY, angles);\n          break;\n        case 'Circle':\n          svgElements += this._drawCircleEnds(armEndX, armEndY);\n          break;\n        case 'ArrowOut':\n          svgElements += this._drawArrowOutEnds(armEndX, armEndY, angles);\n          break;\n      }\n\n      // 3. Draw Optional Frame\n      // if (this.hasFrame) {\n      //     svgElements += this._drawFrame(angles);\n      // }\n\n      return svgElements;\n    }\n\n    /**\n     * Helper to generate arc paths for arm ends.\n     */\n  }, {\n    key: \"_drawArcEnds\",\n    value: function _drawArcEnds(endX, endY, angles) {\n      var paths = '';\n      var radius = this.endSize;\n      var sweepAngle = this.arcSweep;\n      var sweepFlag = sweepAngle <= 180 ? 0 : 1;\n      var angleOffset = (360 - sweepAngle) / 2; // Center the arc opening\n      var rad = Math.PI / 180;\n      for (var i = 0; i < 4; i++) {\n        var cx = endX[i]; // Arc center is arm end point\n        var cy = endY[i];\n\n        // Calculate arc start and end points relative to the arm end (cx, cy)\n        var startAngle = angles[i] + 90 + angleOffset; // Start angle for the arc\n        var endAngle = startAngle + sweepAngle; // End angle for the arc\n\n        var arcStartX = cx + radius * Math.cos(startAngle * rad);\n        var arcStartY = cy + radius * Math.sin(startAngle * rad);\n        var arcEndX = cx + radius * Math.cos(endAngle * rad);\n        var arcEndY = cy + radius * Math.sin(endAngle * rad);\n        paths += \"<path d=\\\"M \".concat(arcStartX, \" \").concat(arcStartY, \" A \").concat(radius, \" \").concat(radius, \" 0 \").concat(sweepFlag, \" 1 \").concat(arcEndX, \" \").concat(arcEndY, \"\\\"\\n                        fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(this.strokeWidth, \"\\\" stroke-linecap=\\\"round\\\" />\");\n      }\n      return paths;\n    }\n\n    /**\n     * Helper to generate circle elements for arm ends.\n     */\n  }, {\n    key: \"_drawCircleEnds\",\n    value: function _drawCircleEnds(endX, endY) {\n      var circles = '';\n      var radius = this.endSize / 2; // endSize controls diameter\n      for (var i = 0; i < 4; i++) {\n        circles += \"<circle cx=\\\"\".concat(endX[i], \"\\\" cy=\\\"\").concat(endY[i], \"\\\" r=\\\"\").concat(radius, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\");\n      }\n      return circles;\n    }\n\n    /**\n     * Helper to generate outward-pointing arrow paths for arm ends.\n     */\n  }, {\n    key: \"_drawArrowOutEnds\",\n    value: function _drawArrowOutEnds(endX, endY, angles) {\n      var paths = '';\n      var size = this.endSize; // Size of the arrow/bracket element\n      var halfWidth = size * 0.7; // Width of the arrow base/bracket opening\n      var depth = size * 0.6; // Depth of the arrow point/bracket side\n      var rad = Math.PI / 180;\n      for (var i = 0; i < 4; i++) {\n        var angle = angles[i] * rad;\n        var tipX = endX[i];\n        var tipY = endY[i];\n\n        // Calculate base points relative to the tip, rotated by arm angle\n        // Point 1 (left base)\n        var baseX1Rel = -depth;\n        var baseY1Rel = -halfWidth / 2;\n        var baseX1 = tipX + baseX1Rel * Math.cos(angle) - baseY1Rel * Math.sin(angle);\n        var baseY1 = tipY + baseX1Rel * Math.sin(angle) + baseY1Rel * Math.cos(angle);\n\n        // Point 2 (right base)\n        var baseX2Rel = -depth;\n        var baseY2Rel = halfWidth / 2;\n        var baseX2 = tipX + baseX2Rel * Math.cos(angle) - baseY2Rel * Math.sin(angle);\n        var baseY2 = tipY + baseX2Rel * Math.sin(angle) + baseY2Rel * Math.cos(angle);\n        paths += \"<polyline points=\\\"\".concat(baseX1, \",\").concat(baseY1, \" \").concat(tipX, \",\").concat(tipY, \" \").concat(baseX2, \",\").concat(baseY2, \"\\\"\\n                        fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(this.strokeWidth, \"\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\" />\");\n      }\n      return paths;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(DroneIcon, \"parameters\", {\n  armLength: {\n    type: 'number',\n    min: 10,\n    max: 60,\n    // Adjusted max slightly\n    step: 1,\n    \"default\": 35,\n    label: 'Arm Length'\n  },\n  armWidth: {\n    type: 'number',\n    min: 1,\n    max: 10,\n    // Adjusted max slightly\n    step: 0.5,\n    \"default\": 4,\n    label: 'Arm Width'\n  },\n  centerGap: {\n    type: 'number',\n    min: 0,\n    max: 15,\n    step: 1,\n    \"default\": 0,\n    label: 'Center Gap'\n  },\n  endStyle: {\n    type: 'enum',\n    options: ['Arc', 'Circle', 'ArrowOut'],\n    \"default\": 'Arc',\n    label: 'Arm End Style'\n  },\n  endSize: {\n    type: 'number',\n    min: 5,\n    max: 30,\n    // Adjusted max slightly\n    step: 1,\n    \"default\": 15,\n    label: 'End Element Size'\n  },\n  arcSweep: {\n    type: 'number',\n    min: 90,\n    max: 330,\n    // Allow slightly more sweep\n    step: 5,\n    \"default\": 270,\n    label: 'Arc Sweep Angle' // Only applies if endStyle is 'Arc'\n  },\n  framePadding: {\n    type: 'number',\n    min: 3,\n    max: 25,\n    // Adjusted max slightly\n    step: 1,\n    \"default\": 8,\n    label: 'Frame Padding' // Only applies if hasFrame is true\n  },\n  frameCornerRadius: {\n    type: 'number',\n    min: 0,\n    max: 30,\n    // Adjusted max slightly\n    step: 1,\n    \"default\": 10,\n    label: 'Frame Corner Radius' // Only applies if hasFrame is true\n  },\n  frameBreakGap: {\n    type: 'number',\n    min: 0,\n    max: 40,\n    step: 1,\n    \"default\": 15,\n    label: 'Frame Break Gap' // Only applies if hasFrame is true, 0 = no break\n  },\n  strokeWidth: {\n    type: 'number',\n    min: 1,\n    max: 8,\n    // Adjusted max slightly\n    step: 0.5,\n    \"default\": 2,\n    label: 'Stroke Width' // Applies to arms, arcs, arrows, frame\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DroneIcon);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/DroneIcon.js?");

/***/ }),

/***/ "./src/shapes/DroneSymbol.js":
/*!***********************************!*\
  !*** ./src/shapes/DroneSymbol.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a symbol with a central 'X' and customizable elements (arrow, loop,\n * circle, line) at the arm ends.\n */\nvar DroneSymbol = /*#__PURE__*/function (_Shape) {\n  function DroneSymbol() {\n    _classCallCheck(this, DroneSymbol);\n    return _callSuper(this, DroneSymbol, arguments);\n  }\n  _inherits(DroneSymbol, _Shape);\n  return _createClass(DroneSymbol, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var svgElements = [];\n      var sw = this.strokeWidth;\n      var sqrt2 = Math.sqrt(2);\n\n      // Determine start and end points for the main X lines based on center element\n      var startRadius = 0;\n      // If center element is present and stroked (not filled), start lines outside its radius\n      if (this.centerSize > 0 && !this.centerFill) {\n        startRadius = this.centerSize + sw / 2; // Adjust start based on center radius and stroke width\n        // Ensure startRadius doesn't exceed armLength to avoid inverted lines\n        if (startRadius >= this.armLength) {\n          startRadius = this.armLength - sw; // Put a small gap if they overlap\n          if (startRadius < 0) startRadius = 0; // Cannot be negative\n        }\n      }\n      var endRadius = this.armLength; // The visible line ends here\n\n      var startX = startRadius / sqrt2;\n      var startY = startRadius / sqrt2;\n      var endX = endRadius / sqrt2;\n      var endY = endRadius / sqrt2;\n\n      // Draw the central 'X' arms\n      if (startRadius > 0) {\n        // Use paths with gaps for the stroked center element\n        // Path for first diagonal (bottom-left section and top-right section)\n        var d1 = \"M \".concat(-startX.toFixed(3), \",\").concat(-startY.toFixed(3), \" L \").concat(-endX.toFixed(3), \",\").concat(-endY.toFixed(3), \" M \").concat(startX.toFixed(3), \",\").concat(startY.toFixed(3), \" L \").concat(endX.toFixed(3), \",\").concat(endY.toFixed(3));\n        svgElements.push(\"<path d=\\\"\".concat(d1, \"\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(sw, \"\\\" stroke-linecap=\\\"round\\\" fill=\\\"none\\\"/>\"));\n\n        // Path for second diagonal (top-left section and bottom-right section)\n        var d2 = \"M \".concat(-startX.toFixed(3), \",\").concat(startY.toFixed(3), \" L \").concat(-endX.toFixed(3), \",\").concat(endY.toFixed(3), \" M \").concat(startX.toFixed(3), \",\").concat(-startY.toFixed(3), \" L \").concat(endX.toFixed(3), \",\").concat(-endY.toFixed(3));\n        svgElements.push(\"<path d=\\\"\".concat(d2, \"\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(sw, \"\\\" stroke-linecap=\\\"round\\\" fill=\\\"none\\\"/>\"));\n      } else {\n        // No gap needed (no center element or it's filled, covering the middle)\n        svgElements.push(\"<line x1=\\\"\".concat(-endX.toFixed(3), \"\\\" y1=\\\"\").concat(-endY.toFixed(3), \"\\\" x2=\\\"\").concat(endX.toFixed(3), \"\\\" y2=\\\"\").concat(endY.toFixed(3), \"\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(sw, \"\\\" stroke-linecap=\\\"round\\\"/>\"));\n        svgElements.push(\"<line x1=\\\"\".concat(-endX.toFixed(3), \"\\\" y1=\\\"\").concat(endY.toFixed(3), \"\\\" x2=\\\"\").concat(endX.toFixed(3), \"\\\" y2=\\\"\").concat(-endY.toFixed(3), \"\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(sw, \"\\\" stroke-linecap=\\\"round\\\"/>\"));\n      }\n\n      // Draw the end elements\n      for (var i = 0; i < 4; i++) {\n        var angleDeg = 45 + i * 90;\n        var angleRad = angleDeg * Math.PI / 180;\n        var cosAngle = Math.cos(angleRad);\n        var sinAngle = Math.sin(angleRad);\n\n        // Calculate attachment point (base/center of the end element)\n        var attachRadius = this.armLength + this.endGap;\n        var ax = attachRadius * cosAngle;\n        var ay = attachRadius * sinAngle;\n        switch (this.endStyle) {\n          case 'arrow':\n            {\n              var sweepRad = this.arrowSweep * Math.PI / 360; // Half sweep angle in radians\n              // Calculate points relative to attachment point 'a'\n              // Point where arrow wings start (same as attachment point for simplicity here)\n              var arrowBaseX = ax;\n              var arrowBaseY = ay;\n              // Angle for the vector pointing back towards center\n              var backAngle = angleRad + Math.PI;\n              // Wing endpoint 1\n              var angle1 = backAngle - sweepRad;\n              var x1 = arrowBaseX + this.endSize * Math.cos(angle1);\n              var y1 = arrowBaseY + this.endSize * Math.sin(angle1);\n              // Wing endpoint 2\n              var angle2 = backAngle + sweepRad;\n              var x2 = arrowBaseX + this.endSize * Math.cos(angle2);\n              var y2 = arrowBaseY + this.endSize * Math.sin(angle2);\n              svgElements.push(\"<polyline points=\\\"\".concat(x1.toFixed(3), \",\").concat(y1.toFixed(3), \" \").concat(arrowBaseX.toFixed(3), \",\").concat(arrowBaseY.toFixed(3), \" \").concat(x2.toFixed(3), \",\").concat(y2.toFixed(3), \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(sw, \"\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\"/>\"));\n              break;\n            }\n          case 'loop':\n            {\n              var loopRadius = this.endSize / 2;\n              // Adjust center distance so the circle is positioned relative to the attachment point\n              var centerDist = attachRadius + loopRadius;\n              var cx = centerDist * cosAngle;\n              var cy = centerDist * sinAngle;\n              svgElements.push(\"<circle cx=\\\"\".concat(cx.toFixed(3), \"\\\" cy=\\\"\").concat(cy.toFixed(3), \"\\\" r=\\\"\").concat(loopRadius.toFixed(3), \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(sw, \"\\\"/>\"));\n              break;\n            }\n          case 'circle':\n            {\n              var circleRadius = this.endSize / 2;\n              // Adjust center distance so the circle is positioned relative to the attachment point\n              var _centerDist = attachRadius + circleRadius;\n              var _cx = _centerDist * cosAngle;\n              var _cy = _centerDist * sinAngle;\n              svgElements.push(\"<circle cx=\\\"\".concat(_cx.toFixed(3), \"\\\" cy=\\\"\").concat(_cy.toFixed(3), \"\\\" r=\\\"\").concat(circleRadius.toFixed(3), \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\"/>\"));\n              break;\n            }\n          case 'line':\n            {\n              var halfSize = this.endSize / 2;\n              // Perpendicular vector components: (-sin(angle), cos(angle))\n              var perpX = -sinAngle;\n              var perpY = cosAngle;\n              // Calculate end points of the line segment centered at (ax, ay)\n              var _x = ax + halfSize * perpX;\n              var _y = ay + halfSize * perpY;\n              var _x2 = ax - halfSize * perpX;\n              var _y2 = ay - halfSize * perpY;\n              svgElements.push(\"<line x1=\\\"\".concat(_x.toFixed(3), \"\\\" y1=\\\"\").concat(_y.toFixed(3), \"\\\" x2=\\\"\").concat(_x2.toFixed(3), \"\\\" y2=\\\"\").concat(_y2.toFixed(3), \"\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(sw, \"\\\" stroke-linecap=\\\"round\\\"/>\"));\n              break;\n            }\n        }\n      }\n\n      // Draw optional central element (drawn last to be on top if filled)\n      if (this.centerSize > 0) {\n        var fillAttr = this.centerFill ? 'fill=\"white\" stroke=\"none\"' : \"fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"\".concat(sw, \"\\\"\");\n        svgElements.push(\"<circle cx=\\\"0\\\" cy=\\\"0\\\" r=\\\"\".concat(this.centerSize.toFixed(3), \"\\\" \").concat(fillAttr, \"/>\"));\n      }\n      return svgElements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(DroneSymbol, \"parameters\", {\n  armLength: {\n    type: 'number',\n    min: 10,\n    max: 60,\n    // Max length for arms before end elements\n    step: 1,\n    \"default\": 40,\n    label: 'Arm Length'\n  },\n  strokeWidth: {\n    type: 'number',\n    min: 1,\n    max: 15,\n    step: 0.5,\n    \"default\": 4,\n    label: 'Stroke Width'\n  },\n  endStyle: {\n    type: 'enum',\n    options: ['arrow', 'loop', 'circle', 'line'],\n    \"default\": 'loop',\n    label: 'End Style'\n  },\n  endSize: {\n    type: 'number',\n    min: 5,\n    max: 25,\n    // Size of the element at the arm's end\n    step: 1,\n    \"default\": 15,\n    label: 'End Element Size'\n  },\n  endGap: {\n    type: 'number',\n    min: 0,\n    max: 10,\n    // Gap between arm end and start of end element\n    step: 1,\n    \"default\": 2,\n    label: 'End Gap'\n  },\n  arrowSweep: {\n    type: 'number',\n    min: 20,\n    max: 90,\n    step: 1,\n    \"default\": 45,\n    label: 'Arrow Sweep Angle ()' // Only applies to 'arrow' style\n  },\n  centerSize: {\n    type: 'number',\n    min: 0,\n    // Set to 0 to disable center element\n    max: 30,\n    step: 1,\n    \"default\": 0,\n    label: 'Center Element Radius'\n  },\n  centerFill: {\n    type: 'boolean',\n    \"default\": false,\n    label: 'Fill Center Element' // Only applies if centerSize > 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DroneSymbol);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/DroneSymbol.js?");

/***/ }),

/***/ "./src/shapes/DualLensShape.js":
/*!*************************************!*\
  !*** ./src/shapes/DualLensShape.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a shape resembling two overlapping, horizontally oriented pill or\n * lens shapes.\n */\nvar DualLensShape = /*#__PURE__*/function (_Shape) {\n  function DualLensShape() {\n    _classCallCheck(this, DualLensShape);\n    return _callSuper(this, DualLensShape, arguments);\n  }\n  _inherits(DualLensShape, _Shape);\n  return _createClass(DualLensShape, [{\n    key: \"createPillPath\",\n    value: function createPillPath(centerY) {\n      var center = {\n        x: 0,\n        y: centerY\n      }; // Using 0 as center.x in viewBox\n\n      // Calculate control points for curves\n      var leftPoint = {\n        x: center.x - this.width / 2,\n        y: center.y\n      };\n      var rightPoint = {\n        x: center.x + this.width / 2,\n        y: center.y\n      };\n      var topControl1 = {\n        x: center.x - this.width / 4,\n        y: center.y - this.height / 2\n      };\n      var topControl2 = {\n        x: center.x + this.width / 4,\n        y: center.y - this.height / 2\n      };\n      var bottomControl1 = {\n        x: center.x + this.width / 4,\n        y: center.y + this.height / 2\n      };\n      var bottomControl2 = {\n        x: center.x - this.width / 4,\n        y: center.y + this.height / 2\n      };\n\n      // Create path using cubic Bzier curves\n      return \"M \".concat(leftPoint.x, \",\").concat(leftPoint.y, \"\\n                C \").concat(topControl1.x, \",\").concat(topControl1.y, \" \\n                  \").concat(topControl2.x, \",\").concat(topControl2.y, \" \\n                  \").concat(rightPoint.x, \",\").concat(rightPoint.y, \"\\n                C \").concat(bottomControl1.x, \",\").concat(bottomControl1.y, \" \\n                  \").concat(bottomControl2.x, \",\").concat(bottomControl2.y, \" \\n                  \").concat(leftPoint.x, \",\").concat(leftPoint.y);\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Calculate vertical positions for both pills\n      var topPillY = -this.spacing / 2 - this.height / 2;\n      var bottomPillY = this.spacing / 2 + this.height / 2;\n\n      // Create paths for both pills\n      var topPill = this.createPillPath(topPillY);\n      var bottomPill = this.createPillPath(bottomPillY);\n\n      // Return combined paths\n      return \"<path \\n            d=\\\"\".concat(topPill, \" \").concat(bottomPill, \"\\\"\\n            fill=\\\"white\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(DualLensShape, \"parameters\", {\n  width: {\n    min: 100,\n    max: 200,\n    \"default\": 200\n  },\n  height: {\n    min: 50,\n    max: 150,\n    \"default\": 90\n  },\n  spacing: {\n    min: -50,\n    max: 50,\n    \"default\": 5\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DualLensShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/DualLensShape.js?");

/***/ }),

/***/ "./src/shapes/EllipseGrid.js":
/*!***********************************!*\
  !*** ./src/shapes/EllipseGrid.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a grid of ellipses with adjustable rows, columns, aspect ratio,\n * spacing, and optional skew.\n */\nvar EllipseGrid = /*#__PURE__*/function (_Shape) {\n  function EllipseGrid() {\n    _classCallCheck(this, EllipseGrid);\n    return _callSuper(this, EllipseGrid, arguments);\n  }\n  _inherits(EllipseGrid, _Shape);\n  return _createClass(EllipseGrid, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var ellipses = [];\n      var baseSize = 150;\n      var cellWidth = baseSize / this.columns;\n      var cellHeight = baseSize / this.rows * this.heightRatio;\n      var startX = -baseSize / 2;\n      var startY = -(baseSize * this.heightRatio) / 2;\n\n      // Add minimum size check to prevent disappearing\n      var minSize = Math.max(this.thickness * 2, 1);\n\n      // Calculate ellipse dimensions with spacing and minimum size protection\n      var radiusX = Math.max(cellWidth / 2 * (1 - this.spacing), minSize);\n      var radiusY = Math.max(cellHeight / 2 * (1 - this.spacing), minSize);\n\n      // Convert skew to radians\n      var skewRad = this.skew * Math.PI / 180;\n      for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n          var centerX = startX + j * cellWidth + cellWidth / 2;\n          var centerY = startY + i * cellHeight + cellHeight / 2;\n\n          // Apply skew transformation matrix\n          var transform = \"matrix(1 0 \".concat(Math.tan(skewRad), \" 1 \").concat(centerX, \" \").concat(centerY, \")\");\n\n          // Only add ellipse if it has positive dimensions\n          if (radiusX > 0 && radiusY > 0) {\n            ellipses.push(\"<ellipse \\n                        rx=\\\"\".concat(radiusX, \"\\\" \\n                        ry=\\\"\").concat(radiusY, \"\\\"\\n                        fill=\\\"\").concat(this.mode === 'fill' ? 'white' : 'none', \"\\\"\\n                        stroke=\\\"white\\\"\\n                        stroke-width=\\\"\").concat(this.mode === 'stroke' ? this.thickness : 0, \"\\\"\\n                        transform=\\\"\").concat(transform, \"\\\"\\n                    />\"));\n          }\n        }\n      }\n      return ellipses.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(EllipseGrid, \"parameters\", {\n  skew: {\n    min: -45,\n    max: 45,\n    \"default\": 0\n  },\n  rows: {\n    min: 1,\n    max: 8,\n    \"default\": 3\n  },\n  columns: {\n    min: 1,\n    max: 8,\n    \"default\": 3\n  },\n  heightRatio: {\n    min: 0.2,\n    max: 2,\n    \"default\": 1\n  },\n  spacing: {\n    min: 0,\n    max: 0.5,\n    \"default\": 0.2\n  },\n  mode: {\n    options: ['fill', 'stroke'],\n    \"default\": 'fill'\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EllipseGrid);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/EllipseGrid.js?");

/***/ }),

/***/ "./src/shapes/EllipsePacking.js":
/*!**************************************!*\
  !*** ./src/shapes/EllipsePacking.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a packing of ellipses with varying sizes and aspect ratios within a\n * circular boundary.\n */\nvar EllipsePacking = /*#__PURE__*/function (_Shape) {\n  function EllipsePacking() {\n    _classCallCheck(this, EllipsePacking);\n    return _callSuper(this, EllipsePacking, arguments);\n  }\n  _inherits(EllipsePacking, _Shape);\n  return _createClass(EllipsePacking, [{\n    key: \"generateSizes\",\n    value:\n    // Create a distribution of ellipse sizes with a bias toward a few larger ones\n    function generateSizes() {\n      // Create a distribution of sizes that favors a few large and several small\n      var sizes = [];\n\n      // First ellipse is large (30-100% of max size)\n      var firstSize = this.minRadius + (this.maxRadius - this.minRadius) * (0.3 + this.random() * 0.7);\n      sizes.push(firstSize);\n\n      // Second is medium-large (50-90% of first)\n      if (this.ellipseCount > 1) {\n        var secondSize = firstSize * (0.5 + this.random() * 0.4);\n        sizes.push(secondSize);\n      }\n\n      // Rest follow a power distribution (smaller ones more common)\n      for (var i = 2; i < this.ellipseCount; i++) {\n        var sizeFactor = Math.pow(this.random(), 1.5); // Power curve biases toward smaller values\n        var size = this.minRadius + (this.maxRadius * 0.6 - this.minRadius) * sizeFactor;\n        sizes.push(size);\n      }\n      return sizes.sort(function (a, b) {\n        return b - a;\n      }); // Sort largest to smallest\n    }\n\n    // Try to place an ellipse with balanced distribution\n  }, {\n    key: \"tryPlaceEllipse\",\n    value: function tryPlaceEllipse(placedEllipses, baseRadius, order) {\n      // Generate the ellipse dimensions\n      var ratio = this.minRatio + (this.maxRatio - this.minRatio) * this.random();\n      var rx = baseRadius;\n      var ry = baseRadius / ratio;\n\n      // Properly apply centerBias\n      // Lower values = more ellipses in center, higher values = more at edges\n      var distanceFromCenter;\n      var angle;\n      if (order === 0) {\n        // First ellipse (largest) - apply centerBias\n        // If centerBias is low, place closer to center\n        distanceFromCenter = this.containerRadius * 0.5 * this.centerBias * this.random();\n        angle = this.random() * 2 * Math.PI;\n      } else if (order === 1 && this.ellipseCount > 2) {\n        // Second ellipse - place with consideration for both centerBias and balance\n        var firstEllipse = placedEllipses[0];\n        var firstAngle = Math.atan2(firstEllipse.y, firstEllipse.x);\n        angle = firstAngle + Math.PI + (this.random() - 0.5) * Math.PI * 0.5;\n\n        // Apply centerBias - low values keep it closer to center\n        distanceFromCenter = this.containerRadius * (0.3 * this.centerBias + this.random() * 0.2);\n      } else {\n        // Golden angle for distribution\n        var goldenAngle = Math.PI * (3 - Math.sqrt(5)); // ~137.5 degrees\n\n        // Get the last placed ellipse's angle\n        var lastAngle = 0;\n        if (placedEllipses.length > 0) {\n          var lastEllipse = placedEllipses[placedEllipses.length - 1];\n          lastAngle = Math.atan2(lastEllipse.y, lastEllipse.x);\n        }\n\n        // Add golden angle plus some randomness\n        angle = lastAngle + goldenAngle + (this.random() - 0.5) * 0.5;\n\n        // Apply centerBias to distance calculation\n        // Lower centerBias = stay closer to center, higher = move more toward edge\n        var biasedRandom = Math.pow(this.random(), 1 - this.centerBias);\n        distanceFromCenter = this.containerRadius * biasedRandom * 0.7;\n      }\n      var x = distanceFromCenter * Math.cos(angle);\n      var y = distanceFromCenter * Math.sin(angle);\n\n      // Random rotation\n      var rotation = this.random() * 2 * Math.PI;\n\n      // Check for valid placement\n      if (this.isValidPlacement(placedEllipses, x, y, rx, ry, rotation)) {\n        return {\n          x: x,\n          y: y,\n          rx: rx,\n          ry: ry,\n          rotation: rotation\n        };\n      }\n      return null;\n    }\n\n    // Improved ellipse overlap detection\n  }, {\n    key: \"isValidPlacement\",\n    value: function isValidPlacement(placedEllipses, x, y, rx, ry, rotation) {\n      // Check container bounds - ensure ellipse is fully contained\n      // Use a simplified approach for checking if ellipse fits in container\n      var effectiveRadius = Math.max(rx, ry);\n      var distToCenter = Math.sqrt(x * x + y * y);\n      if (distToCenter + effectiveRadius > this.containerRadius) {\n        return false;\n      }\n\n      // Check overlap with other ellipses using improved spacing\n      var _iterator = _createForOfIteratorHelper(placedEllipses),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var ellipse = _step.value;\n          var dx = ellipse.x - x;\n          var dy = ellipse.y - y;\n          var distanceBetweenCenters = Math.sqrt(dx * dx + dy * dy);\n\n          // Calculate required minimum distance:\n          // Sum of the semi-major axes of both ellipses, plus spacing\n          var ellipse1Max = Math.max(rx, ry);\n          var ellipse2Max = Math.max(ellipse.rx, ellipse.ry);\n          var minRequiredDistance = ellipse1Max + ellipse2Max + this.spacing;\n          if (distanceBetweenCenters < minRequiredDistance) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return true;\n    }\n\n    // Generate all ellipse placements with balanced distribution\n  }, {\n    key: \"getEllipsePlacements\",\n    value: function getEllipsePlacements() {\n      // Reset RNG\n      this.resetRNG(this.seed);\n\n      // Generate size distribution\n      var sizes = this.generateSizes();\n      var ellipses = [];\n      var maxAttempts = 50;\n\n      // Place ellipses in order of size\n      for (var i = 0; i < sizes.length; i++) {\n        var placed = false;\n        for (var attempt = 0; attempt < maxAttempts && !placed; attempt++) {\n          var ellipse = this.tryPlaceEllipse(ellipses, sizes[i], i);\n          if (ellipse) {\n            ellipses.push(ellipse);\n            placed = true;\n          }\n        }\n\n        // If we couldn't place this one after many attempts, just skip it\n        if (!placed) {\n          continue;\n        }\n      }\n      return ellipses;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Generate new placements each time\n      var ellipses = this.getEllipsePlacements();\n      return this.renderShape(ellipses);\n    }\n  }, {\n    key: \"renderShape\",\n    value: function renderShape(ellipses) {\n      // Generate SVG with mask for the cut-out effect\n      var maskId = \"ellipse-mask-\".concat(Math.floor(Math.random() * 10000));\n\n      // Create ellipses as cut-outs (black to cut through the white circle)\n      var ellipsesElements = ellipses.map(function (ellipse) {\n        return \"<ellipse \\n                cx=\\\"\".concat(ellipse.x, \"\\\" \\n                cy=\\\"\").concat(ellipse.y, \"\\\" \\n                rx=\\\"\").concat(ellipse.rx, \"\\\" \\n                ry=\\\"\").concat(ellipse.ry, \"\\\"\\n                transform=\\\"rotate(\").concat(ellipse.rotation * (180 / Math.PI), \" \").concat(ellipse.x, \" \").concat(ellipse.y, \")\\\"\\n                fill=\\\"black\\\"\\n            />\");\n      });\n\n      // Use a mask to combine all elements\n      return \"\\n            <defs>\\n                <mask id=\\\"\".concat(maskId, \"\\\">\\n                    <rect x=\\\"-\").concat(this.containerRadius * 2, \"\\\" y=\\\"-\").concat(this.containerRadius * 2, \"\\\" \\n                          width=\\\"\").concat(this.containerRadius * 4, \"\\\" height=\\\"\").concat(this.containerRadius * 4, \"\\\" \\n                          fill=\\\"white\\\" />\\n                    \").concat(ellipsesElements.join(''), \"\\n                </mask>\\n            </defs>\\n            <circle \\n                cx=\\\"0\\\" \\n                cy=\\\"0\\\" \\n                r=\\\"\").concat(this.containerRadius, \"\\\"\\n                fill=\\\"white\\\"\\n                mask=\\\"url(#\").concat(maskId, \")\\\"\\n            />\\n        \");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(EllipsePacking, \"parameters\", {\n  containerRadius: {\n    min: 50,\n    max: 200,\n    \"default\": 100\n  },\n  ellipseCount: {\n    min: 3,\n    max: 30,\n    \"default\": 6\n  },\n  minRadius: {\n    min: 5,\n    max: 15,\n    \"default\": 5\n  },\n  maxRadius: {\n    min: 15,\n    max: 30,\n    \"default\": 40\n  },\n  minRatio: {\n    min: 0.3,\n    max: 1,\n    \"default\": 0.6\n  },\n  maxRatio: {\n    min: 1,\n    max: 2.5,\n    \"default\": 1.8\n  },\n  spacing: {\n    min: 0,\n    max: 20,\n    \"default\": 2\n  },\n  centerBias: {\n    min: 0,\n    max: 1,\n    \"default\": 0.4\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EllipsePacking);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/EllipsePacking.js?");

/***/ }),

/***/ "./src/shapes/EllipsesStackShape.js":
/*!******************************************!*\
  !*** ./src/shapes/EllipsesStackShape.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a vertical stack of ellipses with heights varying based on a biased\n * distribution pattern.\n */\nvar EllipsesStackShape = /*#__PURE__*/function (_Shape) {\n  function EllipsesStackShape() {\n    _classCallCheck(this, EllipsesStackShape);\n    return _callSuper(this, EllipsesStackShape, arguments);\n  }\n  _inherits(EllipsesStackShape, _Shape);\n  return _createClass(EllipsesStackShape, [{\n    key: \"calculateHeights\",\n    value: function calculateHeights() {\n      var heights = new Array(this.count).fill(0);\n      var mid = (this.count - 1) / 2;\n      var heightDiff = this.maxHeight - this.minHeight;\n\n      // Calculate blend factor based on direction\n      var blendToCenterPeak = 1 - Math.min(1, Math.abs(this.direction) * 3);\n      for (var i = 0; i < this.count; i++) {\n        // Calculate center peak height\n        var distFromCenter = Math.abs(i - mid) / mid;\n        var centerPeakHeight = this.maxHeight - distFromCenter * heightDiff;\n\n        // Calculate directional height\n        var directionalProgress = this.direction > 0 ? i / (this.count - 1) : 1 - i / (this.count - 1);\n        var directionalHeight = this.minHeight + directionalProgress * heightDiff;\n\n        // Blend between the two patterns\n        heights[i] = centerPeakHeight * blendToCenterPeak + directionalHeight * (1 - blendToCenterPeak);\n      }\n      return heights;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var heights = this.calculateHeights();\n\n      // Calculate total pattern dimensions\n      var totalHeight = (this.count - 1) * this.spacing + heights.reduce(function (sum, height) {\n        return sum + height;\n      }, 0);\n      var boundSize = 200;\n      var scaleX = boundSize / this.width;\n      var scaleY = boundSize / totalHeight;\n      var scale = Math.min(scaleX, scaleY) * 0.8; // 80% of available space for margin\n\n      // Scale dimensions\n      var scaledWidth = this.width * scale;\n      var scaledSpacing = this.spacing * scale;\n      var scaledHeights = heights.map(function (h) {\n        return h * scale;\n      });\n\n      // Calculate start position to center the shape\n      var scaledTotalHeight = (this.count - 1) * scaledSpacing + scaledHeights.reduce(function (sum, height) {\n        return sum + height;\n      }, 0);\n      var startX = -scaledWidth / 2; // Center horizontally\n      var startY = -scaledTotalHeight / 2; // Center vertically\n\n      // Generate ellipses\n      var currentY = startY;\n      var ellipses = [];\n      for (var i = 0; i < scaledHeights.length; i++) {\n        var height = scaledHeights[i];\n        ellipses.push(\"<ellipse\\n                cx=\\\"\".concat(startX + scaledWidth / 2, \"\\\"\\n                cy=\\\"\").concat(currentY + height / 2, \"\\\"\\n                rx=\\\"\").concat(scaledWidth / 2, \"\\\"\\n                ry=\\\"\").concat(height / 2, \"\\\"\\n                fill=\\\"white\\\"\\n            />\"));\n        currentY += height + scaledSpacing;\n      }\n      return ellipses.join('\\n');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(EllipsesStackShape, \"parameters\", {\n  count: {\n    min: 2,\n    max: 12,\n    \"default\": 5\n  },\n  spacing: {\n    min: 5,\n    max: 50,\n    \"default\": 24\n  },\n  width: {\n    min: 100,\n    max: 300,\n    \"default\": 169\n  },\n  direction: {\n    min: -0.5,\n    max: 0.5,\n    \"default\": 0.5\n  },\n  minHeight: {\n    min: 2,\n    max: 20,\n    \"default\": 9\n  },\n  maxHeight: {\n    min: 20,\n    max: 80,\n    \"default\": 80\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EllipsesStackShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/EllipsesStackShape.js?");

/***/ }),

/***/ "./src/shapes/ExpandArrowsShape.js":
/*!*****************************************!*\
  !*** ./src/shapes/ExpandArrowsShape.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a symbol resembling four corner brackets pointing outwards, often\n * used for expand/fullscreen icons, combined with a central 'X'.\n */\nvar ExpandArrowsShape = /*#__PURE__*/function (_Shape) {\n  function ExpandArrowsShape() {\n    _classCallCheck(this, ExpandArrowsShape);\n    return _callSuper(this, ExpandArrowsShape, arguments);\n  }\n  _inherits(ExpandArrowsShape, _Shape);\n  return _createClass(ExpandArrowsShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var halfSize = this.size / 2;\n      var cl = this.cornerLength; // Corner length\n      var elements = [];\n\n      // Top left corner\n      elements.push(\"<path\\n            d=\\\"M \".concat(-halfSize, \" \").concat(-halfSize + cl, \" L \").concat(-halfSize, \" \").concat(-halfSize, \" L \").concat(-halfSize + cl, \" \").concat(-halfSize, \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            fill=\\\"none\\\"\\n            stroke-linejoin=\\\"miter\\\"\\n        />\"));\n\n      // Top right corner\n      elements.push(\"<path\\n            d=\\\"M \".concat(halfSize - cl, \" \").concat(-halfSize, \" L \").concat(halfSize, \" \").concat(-halfSize, \" L \").concat(halfSize, \" \").concat(-halfSize + cl, \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            fill=\\\"none\\\"\\n            stroke-linejoin=\\\"miter\\\"\\n        />\"));\n\n      // Bottom right corner\n      elements.push(\"<path\\n            d=\\\"M \".concat(halfSize, \" \").concat(halfSize - cl, \" L \").concat(halfSize, \" \").concat(halfSize, \" L \").concat(halfSize - cl, \" \").concat(halfSize, \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            fill=\\\"none\\\"\\n            stroke-linejoin=\\\"miter\\\"\\n        />\"));\n\n      // Bottom left corner\n      elements.push(\"<path\\n            d=\\\"M \".concat(-halfSize + cl, \" \").concat(halfSize, \" L \").concat(-halfSize, \" \").concat(halfSize, \" L \").concat(-halfSize, \" \").concat(halfSize - cl, \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            fill=\\\"none\\\"\\n            stroke-linejoin=\\\"miter\\\"\\n        />\"));\n\n      // Diagonal X in the middle\n      elements.push(\"<path\\n            d=\\\"M \".concat(-halfSize, \" \").concat(-halfSize, \" L \").concat(halfSize, \" \").concat(halfSize, \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            fill=\\\"none\\\"\\n        />\"));\n      elements.push(\"<path\\n            d=\\\"M \".concat(halfSize, \" \").concat(-halfSize, \" L \").concat(-halfSize, \" \").concat(halfSize, \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            fill=\\\"none\\\"\\n        />\"));\n      return elements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(ExpandArrowsShape, \"parameters\", {\n  size: {\n    min: 50,\n    max: 200,\n    \"default\": 150\n  },\n  // Overall size of the shape\n  cornerLength: {\n    min: 20,\n    max: 80,\n    \"default\": 40\n  },\n  // Length of corner sections\n  thickness: {\n    min: 1,\n    max: 20,\n    \"default\": 10\n  } // Line thickness\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ExpandArrowsShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/ExpandArrowsShape.js?");

/***/ }),

/***/ "./src/shapes/EyeShape.js":
/*!********************************!*\
  !*** ./src/shapes/EyeShape.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a stylized eye shape with adjustable width, height, and openness\n * (pupil size relative to outer shape).\n */\nvar EyeShape = /*#__PURE__*/function (_Shape) {\n  function EyeShape() {\n    _classCallCheck(this, EyeShape);\n    return _callSuper(this, EyeShape, arguments);\n  }\n  _inherits(EyeShape, _Shape);\n  return _createClass(EyeShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var scale = Math.min(400, 400) / 400;\n      var width = this.width * scale;\n      var height = this.height * scale;\n      var halfWidth = width / 2;\n      var halfHeight = height / 2;\n      var innerWidth = width * this.openness;\n      var innerHalfWidth = innerWidth / 2;\n      var innerHeight = height * this.openness;\n      var outerPath = \"M \".concat(-halfWidth, \" 0 \\n           Q 0 \").concat(-halfHeight, \" \").concat(halfWidth, \" 0\\n           Q 0 \").concat(halfHeight, \" \").concat(-halfWidth, \" 0\");\n      var innerPath = \"M \".concat(-innerHalfWidth, \" 0\\n           Q 0 \").concat(-innerHeight / 2, \" \").concat(innerHalfWidth, \" 0\\n           Q 0 \").concat(innerHeight / 2, \" \").concat(-innerHalfWidth, \" 0\");\n      return \"<path d=\\\"\".concat(outerPath, \"\\\" fill=\\\"white\\\" />\\n               <path d=\\\"\").concat(innerPath, \"\\\" fill=\\\"black\\\" />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(EyeShape, \"parameters\", {\n  width: {\n    min: 50,\n    max: 150,\n    \"default\": 150\n  },\n  height: {\n    min: 50,\n    max: 200,\n    \"default\": 100\n  },\n  openness: {\n    min: 0.1,\n    max: 0.9,\n    \"default\": 0.4\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EyeShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/EyeShape.js?");

/***/ }),

/***/ "./src/shapes/FiberConnector.js":
/*!**************************************!*\
  !*** ./src/shapes/FiberConnector.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a symmetrical shape resembling connected fibers or strands,\n * converging in the middle and diverging outwards, like an optical coupler.\n * Uses explicit cubic Bezier curves for precise symmetrical transitions.\n */\nvar FiberConnector = /*#__PURE__*/function (_Shape) {\n  function FiberConnector() {\n    _classCallCheck(this, FiberConnector);\n    return _callSuper(this, FiberConnector, arguments);\n  }\n  _inherits(FiberConnector, _Shape);\n  return _createClass(FiberConnector, [{\n    key: \"generateShape\",\n    value:\n    /**\n     * Generates the SVG path elements for the symmetrical fiber connector shape.\n     * @returns {string} SVG string containing multiple <path> elements.\n     */\n    function generateShape() {\n      var paths = [];\n      var halfWidth = this.totalWidth / 2;\n\n      // Calculate vertical spacing between strands at the ends and the center\n      var edgeSpacing = this.numStrands > 1 ? this.spread / (this.numStrands - 1) : 0;\n      var centerSpacing = this.numStrands > 1 ? this.constriction / (this.numStrands - 1) : 0;\n\n      // Determine the horizontal distance for Bezier control points based on intensity\n      var controlPointHorizontalOffset = halfWidth * this.curveIntensity;\n      for (var i = 0; i < this.numStrands; i++) {\n        // Calculate start Y (left edge) and mid Y (center) positions for the current strand\n        var startY = this.numStrands === 1 ? 0 : -this.spread / 2 + i * edgeSpacing;\n        var midY = this.numStrands === 1 ? 0 : -this.constriction / 2 + i * centerSpacing;\n\n        // Define the anchor points\n        var p0 = {\n          x: -halfWidth,\n          y: startY\n        }; // Start point (left edge)\n        var pMid = {\n          x: 0,\n          y: midY\n        }; // Mid point (center)\n        var pEnd = {\n          x: halfWidth,\n          y: startY\n        }; // End point (right edge)\n\n        // Define the control points for the first Bezier curve (left to center)\n        // Control point near start, pulling horizontally inward\n        var c1Start = {\n          x: p0.x + controlPointHorizontalOffset,\n          y: p0.y\n        };\n        // Control point near mid, pulling horizontally from the center towards left\n        var c1End = {\n          x: pMid.x - controlPointHorizontalOffset,\n          y: pMid.y\n        };\n\n        // Define the control points for the second Bezier curve (center to right)\n        // These are horizontal reflections of the first curve's control points\n        // Control point near mid, pulling horizontally from the center towards right\n        var c2Start = {\n          x: pMid.x + controlPointHorizontalOffset,\n          y: pMid.y\n        }; // Reflection of c1End across Y-axis\n        // Control point near end, pulling horizontally inward\n        var c2End = {\n          x: pEnd.x - controlPointHorizontalOffset,\n          y: pEnd.y\n        }; // Reflection of c1Start across Y-axis\n\n        // Construct the SVG path data string using two Cubic Bezier (C) commands\n        var pathData = \"M \".concat(p0.x.toFixed(2), \",\").concat(p0.y.toFixed(2), \" \") + // Move to start point\n        \"C \".concat(c1Start.x.toFixed(2), \",\").concat(c1Start.y.toFixed(2), \" \") + // First control point (near start)\n        \"\".concat(c1End.x.toFixed(2), \",\").concat(c1End.y.toFixed(2), \" \") + // Second control point (near mid)\n        \"\".concat(pMid.x.toFixed(2), \",\").concat(pMid.y.toFixed(2), \" \") + // Mid point\n        \"C \".concat(c2Start.x.toFixed(2), \",\").concat(c2Start.y.toFixed(2), \" \") + // Third control point (near mid, reflected)\n        \"\".concat(c2End.x.toFixed(2), \",\").concat(c2End.y.toFixed(2), \" \") + // Fourth control point (near end, reflected)\n        \"\".concat(pEnd.x.toFixed(2), \",\").concat(pEnd.y.toFixed(2)); // End point\n\n        // Create the SVG path element string\n        paths.push(\"<path d=\\\"\".concat(pathData, \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(this.strokeWidth, \"\\\" stroke-linecap=\\\"round\\\" />\"));\n      }\n\n      // Join all path strings into a single SVG output\n      return paths.join('\\n');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(FiberConnector, \"parameters\", {\n  numStrands: {\n    type: 'number',\n    min: 4,\n    max: 16,\n    step: 2,\n    // Prefer odd numbers for a central strand\n    \"default\": 8,\n    label: 'Number of Strands'\n  },\n  strokeWidth: {\n    type: 'number',\n    min: 0.5,\n    max: 10,\n    step: 0.5,\n    \"default\": 2,\n    // Slightly thinner default\n    label: 'Stroke Width'\n  },\n  spread: {\n    type: 'number',\n    min: 10,\n    max: 100,\n    step: 1,\n    \"default\": 90,\n    // Increased default spread\n    label: 'Vertical Spread at Ends'\n  },\n  constriction: {\n    type: 'number',\n    min: 0,\n    max: 60,\n    step: 1,\n    \"default\": 5,\n    // Smaller default constriction for tighter center\n    label: 'Vertical Spread at Center'\n  },\n  totalWidth: {\n    type: 'number',\n    min: 50,\n    max: 200,\n    step: 2,\n    \"default\": 160,\n    // Increased default width\n    label: 'Total Horizontal Width'\n  },\n  curveIntensity: {\n    type: 'number',\n    min: 0.1,\n    max: 0.9,\n    // Avoid 0 or 1 for better curve control\n    step: 0.05,\n    \"default\": 0.65,\n    // Adjusted curve intensity\n    label: 'Curve Intensity (Handle Length)'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FiberConnector);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/FiberConnector.js?");

/***/ }),

/***/ "./src/shapes/FingerprintShape.js":
/*!****************************************!*\
  !*** ./src/shapes/FingerprintShape.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a stylized fingerprint pattern composed of concentric semi-circular\n * arcs and vertical lines within a circular boundary.\n */\nvar FingerprintShape = /*#__PURE__*/function (_Shape) {\n  function FingerprintShape() {\n    _classCallCheck(this, FingerprintShape);\n    return _callSuper(this, FingerprintShape, arguments);\n  }\n  _inherits(FingerprintShape, _Shape);\n  return _createClass(FingerprintShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var elements = [];\n      var maxRadius = this.radius;\n\n      // Define a unique ID for the clip path\n      var clipPathId = \"fingerprint-clip-\".concat(Date.now());\n\n      // Create a clip path to contain everything within a circle\n      elements.push(\"\\n            <defs>\\n                <clipPath id=\\\"\".concat(clipPathId, \"\\\">\\n                    <circle cx=\\\"0\\\" cy=\\\"0\\\" r=\\\"\").concat(maxRadius, \"\\\" />\\n                </clipPath>\\n            </defs>\\n        \"));\n\n      // Start a group with the clip path applied\n      elements.push(\"<g clip-path=\\\"url(#\".concat(clipPathId, \")\\\">\"));\n\n      // Calculate adaptive gap based on radius and lineCount\n      var adaptiveGap = maxRadius / this.lineCount;\n\n      // Create each arc and its vertical lines\n      for (var i = 0; i < this.lineCount; i++) {\n        var currentRadius = maxRadius - i * adaptiveGap;\n        if (currentRadius <= 0) continue;\n\n        // Add the semicircular arc at top\n        elements.push(\"\\n                <path\\n                    d=\\\"M \".concat(-currentRadius, \",0 \\n                       A \").concat(currentRadius, \" \").concat(currentRadius, \" 0 0 1 \").concat(currentRadius, \",0\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(this.strokeWidth, \"\\\"\\n                    fill=\\\"none\\\"\\n                    stroke-linecap=\\\"round\\\"\\n                />\\n            \"));\n\n        // Add vertical lines extending past the bottom of the circle\n        // (they'll be clipped by the clipPath)\n        elements.push(\"\\n                <line\\n                    x1=\\\"\".concat(-currentRadius, \"\\\"\\n                    y1=\\\"0\\\"\\n                    x2=\\\"\").concat(-currentRadius, \"\\\"\\n                    y2=\\\"\").concat(maxRadius * 2, \"\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(this.strokeWidth, \"\\\"\\n                    stroke-linecap=\\\"round\\\"\\n                />\\n            \"));\n        elements.push(\"\\n                <line\\n                    x1=\\\"\".concat(currentRadius, \"\\\"\\n                    y1=\\\"0\\\"\\n                    x2=\\\"\").concat(currentRadius, \"\\\"\\n                    y2=\\\"\").concat(maxRadius * 2, \"\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(this.strokeWidth, \"\\\"\\n                    stroke-linecap=\\\"round\\\"\\n                />\\n            \"));\n      }\n\n      // Add center line\n      elements.push(\"\\n            <line\\n                x1=\\\"0\\\"\\n                y1=\\\"0\\\"\\n                x2=\\\"0\\\"\\n                y2=\\\"\".concat(maxRadius * 2, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.strokeWidth, \"\\\"\\n                stroke-linecap=\\\"round\\\"\\n            />\\n        \"));\n\n      // Close the group\n      elements.push(\"</g>\");\n      return elements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(FingerprintShape, \"parameters\", {\n  radius: {\n    min: 50,\n    max: 100,\n    \"default\": 100\n  },\n  lineCount: {\n    min: 3,\n    max: 8,\n    \"default\": 5\n  },\n  strokeWidth: {\n    min: 1,\n    max: 20,\n    \"default\": 10\n  },\n  gap: {\n    min: 5,\n    max: 30,\n    \"default\": 18\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FingerprintShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/FingerprintShape.js?");

/***/ }),

/***/ "./src/shapes/FlaredCross.js":
/*!***********************************!*\
  !*** ./src/shapes/FlaredCross.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a cross shape where the ends of the arms are wider than the center\n * (flared).\n */\nvar FlaredCross = /*#__PURE__*/function (_Shape) {\n  function FlaredCross() {\n    _classCallCheck(this, FlaredCross);\n    return _callSuper(this, FlaredCross, arguments);\n  }\n  _inherits(FlaredCross, _Shape);\n  return _createClass(FlaredCross, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Access parameters using `this`\n      var outerWidth = this.outerWidth;\n      var outerHeight = this.outerHeight;\n      // Ensure inner dimensions do not exceed outer dimensions visually if desired,\n      // although parameters allow it for potentially interesting shapes.\n      // For a strict cross shape, you might add:\n      // const innerWidth = Math.min(this.innerWidth, outerWidth);\n      // const innerHeight = Math.min(this.innerHeight, outerHeight);\n      // But we'll use the direct values as per parameters for more flexibility.\n      var innerWidth = this.innerWidth;\n      var innerHeight = this.innerHeight;\n      var rotation = this.rotation;\n\n      // Calculate half dimensions for easier coordinate calculation\n      var w = outerWidth / 2; // Half of the outer width (extent of horizontal arms)\n      var h = outerHeight / 2; // Half of the outer height (extent of vertical arms)\n      var nw = innerWidth / 2; // Half of the inner width (neck of vertical arms)\n      var nh = innerHeight / 2; // Half of the inner height (neck of horizontal arms)\n\n      // Define the 12 vertices of the polygon path clockwise, starting from top-right of vertical arm\n      var points = [{\n        x: nw,\n        y: h\n      },\n      // P1: Top-right corner of top arm\n      {\n        x: nw,\n        y: nh\n      },\n      // P2: Inner top-right corner (neck)\n      {\n        x: w,\n        y: nh\n      },\n      // P3: Top-right corner of right arm\n      {\n        x: w,\n        y: -nh\n      },\n      // P4: Bottom-right corner of right arm\n      {\n        x: nw,\n        y: -nh\n      },\n      // P5: Inner bottom-right corner (neck)\n      {\n        x: nw,\n        y: -h\n      },\n      // P6: Bottom-right corner of bottom arm\n      {\n        x: -nw,\n        y: -h\n      },\n      // P7: Bottom-left corner of bottom arm\n      {\n        x: -nw,\n        y: -nh\n      },\n      // P8: Inner bottom-left corner (neck)\n      {\n        x: -w,\n        y: -nh\n      },\n      // P9: Bottom-left corner of left arm\n      {\n        x: -w,\n        y: nh\n      },\n      // P10: Top-left corner of left arm\n      {\n        x: -nw,\n        y: nh\n      },\n      // P11: Inner top-left corner (neck)\n      {\n        x: -nw,\n        y: h\n      } // P12: Top-left corner of top arm\n      ];\n\n      // Construct the SVG path data string (d attribute)\n      var pathData = \"M \".concat(points[0].x, \",\").concat(points[0].y, \" \") + points.slice(1).map(function (p) {\n        return \"L \".concat(p.x, \",\").concat(p.y);\n      }).join(' ') + ' Z'; // Z closes the path\n\n      // Apply rotation transform around the center (0,0)\n      var transform = \"rotate(\".concat(rotation, \")\");\n\n      // Return the SVG path element\n      return \"<path d=\\\"\".concat(pathData, \"\\\" transform=\\\"\").concat(transform, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(FlaredCross, \"parameters\", {\n  outerWidth: {\n    type: 'number',\n    min: 10,\n    max: 190,\n    step: 1,\n    \"default\": 120,\n    label: 'Outer Width' // Adding label for clarity\n  },\n  outerHeight: {\n    type: 'number',\n    min: 10,\n    max: 190,\n    step: 1,\n    \"default\": 120,\n    label: 'Outer Height'\n  },\n  innerWidth: {\n    type: 'number',\n    min: 2,\n    max: 190,\n    // Allow inner > outer for varied effects, capped near viewbox edge\n    step: 1,\n    \"default\": 40,\n    label: 'Inner Width (Neck)'\n  },\n  innerHeight: {\n    type: 'number',\n    min: 2,\n    max: 190,\n    // Allow inner > outer for varied effects, capped near viewbox edge\n    step: 1,\n    \"default\": 40,\n    label: 'Inner Height (Neck)'\n  },\n  rotation: {\n    type: 'number',\n    min: 0,\n    max: 360,\n    step: 1,\n    \"default\": 0,\n    label: 'Rotation'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FlaredCross);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/FlaredCross.js?");

/***/ }),

/***/ "./src/shapes/FlatWave.js":
/*!********************************!*\
  !*** ./src/shapes/FlatWave.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a filled shape bounded by a flat bottom edge and a wavy top edge\n * with various waveform styles.\n */\nvar FlatWave = /*#__PURE__*/function (_Shape) {\n  function FlatWave() {\n    _classCallCheck(this, FlatWave);\n    return _callSuper(this, FlatWave, arguments);\n  }\n  _inherits(FlatWave, _Shape);\n  return _createClass(FlatWave, [{\n    key: \"getWaveValue\",\n    value: function getWaveValue(t, type) {\n      // Normalize t to [0, 1] range\n      t = (t % 1 + 1) % 1;\n\n      // Apply balance (horizontal shift)\n      t = t + this.balance * 0.2;\n      t = (t % 1 + 1) % 1;\n\n      // Apply pinch effect\n      if (this.pinch > 0) {\n        var pinchFactor = 1 + this.pinch * 2;\n        t = Math.pow(t, pinchFactor) / Math.pow(1, pinchFactor - 1);\n      }\n      var value = 0;\n      switch (type) {\n        case 'sine':\n          value = Math.sin(t * Math.PI * 2);\n          break;\n        case 'smooth':\n          {\n            // Pure mathematical smooth curve\n            var baseWave = Math.sin(t * Math.PI * 2);\n            var tension = 0.5 + this.tension * 1.5;\n            var modulator = Math.pow(Math.abs(Math.sin(t * Math.PI)), tension);\n            value = baseWave * (1 + modulator * 0.5);\n            break;\n          }\n        case 'sharp':\n          {\n            // Sharp peaks with curve control\n            var sharpness = 1 + this.curve * 4;\n            value = Math.pow(Math.sin(t * Math.PI * 2), sharpness);\n            break;\n          }\n        case 'bounce':\n          {\n            // Bouncy wave with variable curve\n            var bounciness = 1 + this.curve * 3;\n            value = Math.sin(t * Math.PI * 2) * (1 - Math.pow(Math.sin(t * Math.PI), bounciness));\n            break;\n          }\n        case 'clean':\n          {\n            // Clean wave with minimal distortion\n            var cleanness = 0.5 + this.tension * 0.5;\n            value = Math.sin(t * Math.PI * 2) * Math.pow(Math.sin(t * Math.PI), cleanness);\n            break;\n          }\n        case 'fluid':\n          {\n            // Fluid wave with variable smoothness\n            var fluidity = 1 + this.curve * 2;\n            var base = Math.sin(t * Math.PI * 2);\n            var mod = Math.sin(t * Math.PI * 4);\n            value = base * (1 - mod * mod * this.tension);\n            break;\n          }\n        default:\n          value = Math.sin(t * Math.PI * 2);\n      }\n\n      // Apply curve transformation\n      if (this.curve > 0) {\n        var sign = Math.sign(value);\n        value = sign * Math.pow(Math.abs(value), 1 - this.curve * 0.5);\n      }\n      return value;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var width = 120;\n      var steps = 400; // Increased resolution for smoother curves\n      var phaseRad = this.phase * Math.PI / 180;\n      var points = [];\n\n      // Generate top wave points\n      for (var i = 0; i <= steps; i++) {\n        var t = i / steps;\n        var x = -width / 2 + width * t;\n\n        // Calculate wave value\n        var waveT = t * this.frequency + phaseRad / (Math.PI * 2);\n        var y = this.getWaveValue(waveT, this.waveform);\n        y *= this.amplitude;\n        points.push([x, y]);\n      }\n\n      // Generate path\n      var d = \"M \".concat(-width / 2, \" 0\"); // Start at bottom left\n\n      // Add top wave points with smooth curve\n      for (var _i = 0; _i < points.length; _i++) {\n        var curr = points[_i];\n        var prev = points[Math.max(0, _i - 1)];\n        if (_i === 0) {\n          d += \" L \".concat(curr[0], \" \").concat(curr[1]);\n        } else {\n          var cp1x = prev[0] + (curr[0] - prev[0]) / 3;\n          var cp2x = curr[0] - (curr[0] - prev[0]) / 3;\n          d += \" C \".concat(cp1x, \" \").concat(prev[1], \" \").concat(cp2x, \" \").concat(curr[1], \" \").concat(curr[0], \" \").concat(curr[1]);\n        }\n      }\n\n      // Complete the path\n      d += \" L \".concat(width / 2, \" 0 Z\");\n      return \"<path \\n            d=\\\"\".concat(d, \"\\\"\\n            fill=\\\"white\\\"\\n            stroke=\\\"none\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(FlatWave, \"parameters\", {\n  amplitude: {\n    min: 10,\n    max: 150,\n    \"default\": 50\n  },\n  frequency: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  },\n  phase: {\n    min: -180,\n    max: 180,\n    \"default\": 0\n  },\n  waveform: {\n    options: ['sine', 'smooth', 'sharp', 'bounce', 'clean', 'fluid'],\n    \"default\": 'sine'\n  },\n  curve: {\n    min: 0,\n    max: 1,\n    \"default\": 0.5\n  },\n  pinch: {\n    min: 0,\n    max: 1,\n    \"default\": 0\n  },\n  balance: {\n    min: -1,\n    max: 1,\n    \"default\": 0\n  },\n  tension: {\n    min: 0,\n    max: 1,\n    \"default\": 0.5\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FlatWave);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/FlatWave.js?");

/***/ }),

/***/ "./src/shapes/FloralSprayShape.js":
/*!****************************************!*\
  !*** ./src/shapes/FloralSprayShape.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a floral spray pattern with a central curved stem and multiple\n * branches ending in circular bulbs.\n */\nvar FloralSprayShape = /*#__PURE__*/function (_Shape) {\n  function FloralSprayShape() {\n    _classCallCheck(this, FloralSprayShape);\n    return _callSuper(this, FloralSprayShape, arguments);\n  }\n  _inherits(FloralSprayShape, _Shape);\n  return _createClass(FloralSprayShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Calculate stem\n      this.branchCount = Math.round(this.branchCount);\n      var stemHeight = this.branchLength * 0.25;\n      var verticalOffset = +this.branchLength * 0.4;\n      var stemStartY = stemHeight * 0.6 + verticalOffset;\n      var stemStart = {\n        x: 0,\n        y: stemStartY\n      };\n      var stemEnd = {\n        x: 0,\n        y: verticalOffset\n      };\n      var stemCP1 = {\n        x: stemStart.x,\n        y: stemStart.y - stemHeight * 0.3\n      };\n      var stemCP2 = {\n        x: stemEnd.x,\n        y: stemEnd.y + stemHeight * 0.1\n      };\n\n      // Generate stem path\n      var stem = \"M \".concat(stemStart.x, \" \").concat(stemStart.y, \" \\n                     C \").concat(stemCP1.x, \" \").concat(stemCP1.y, \", \\n                       \").concat(stemCP2.x, \" \").concat(stemCP2.y, \", \\n                       \").concat(stemEnd.x, \" \").concat(stemEnd.y);\n\n      // Generate branches\n      var branches = [];\n      if (this.branchCount > 0) {\n        var spreadRad = this.spread * Math.PI / 180.0;\n        var startAngle = -Math.PI / 2 - spreadRad / 2;\n        for (var i = 0; i < this.branchCount; i++) {\n          var progress = i / Math.max(1, this.branchCount - 1);\n          var angle = startAngle + progress * spreadRad;\n\n          // Calculate length with tapering at edges\n          var edgeFactor = 1.0 - Math.pow(2 * (progress - 0.5), 2) * 0.15;\n          var thisLength = this.branchLength * edgeFactor;\n\n          // Adjust bulb size based on position\n          var bulbFactor = 1.0 - Math.pow(2 * (progress - 0.5), 2) * 0.2;\n          var thisBulbSize = this.bulbSize * bulbFactor;\n          var branch = this.createBranch(stemEnd, angle, thisLength, this.thickness * (0.9 + edgeFactor * 0.1), thisBulbSize);\n          branches.push(branch);\n        }\n      }\n      return \"\\n            <g>\\n                <path \\n                    d=\\\"\".concat(stem, \"\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(this.thickness * 2.5, \"\\\"\\n                    stroke-linecap=\\\"round\\\"\\n                    stroke-linejoin=\\\"round\\\"\\n                    fill=\\\"none\\\"\\n                />\\n                \").concat(branches.join('\\n'), \"\\n            </g>\\n        \");\n    }\n  }, {\n    key: \"createBranch\",\n    value: function createBranch(start, angle, length, thickness, bulbSize) {\n      // Calculate end point\n      var end = {\n        x: start.x + length * Math.cos(angle),\n        y: start.y + length * Math.sin(angle)\n      };\n\n      // Create control points for smooth curve\n      var cp1 = {\n        x: start.x + length * 0.35 * Math.cos(angle),\n        y: start.y + length * 0.35 * Math.sin(angle)\n      };\n      var cp2 = {\n        x: start.x + length * 0.65 * Math.cos(angle),\n        y: start.y + length * 0.65 * Math.sin(angle)\n      };\n\n      // Create branch and bulb paths\n      var branchPath = \"M \".concat(start.x, \" \").concat(start.y, \" \\n                           C \").concat(cp1.x, \" \").concat(cp1.y, \", \\n                             \").concat(cp2.x, \" \").concat(cp2.y, \", \\n                             \").concat(end.x, \" \").concat(end.y);\n      return \"\\n            <path \\n                d=\\\"\".concat(branchPath, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(thickness, \"\\\"\\n                stroke-linecap=\\\"round\\\"\\n                stroke-linejoin=\\\"round\\\"\\n                fill=\\\"none\\\"\\n            />\\n            <circle \\n                cx=\\\"\").concat(end.x, \"\\\"\\n                cy=\\\"\").concat(end.y, \"\\\"\\n                r=\\\"\").concat(bulbSize, \"\\\"\\n                fill=\\\"white\\\"\\n            />\\n        \");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(FloralSprayShape, \"parameters\", {\n  branchLength: {\n    min: 40,\n    max: 150,\n    \"default\": 80\n  },\n  branchCount: {\n    min: 3,\n    max: 8,\n    \"default\": 5\n  },\n  thickness: {\n    min: 2,\n    max: 12,\n    \"default\": 6\n  },\n  spread: {\n    min: 30,\n    max: 120,\n    \"default\": 75\n  },\n  bulbSize: {\n    min: 5,\n    max: 25,\n    \"default\": 15\n  }\n});\nwindow.Shape = FloralSprayShape;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FloralSprayShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/FloralSprayShape.js?");

/***/ }),

/***/ "./src/shapes/FloralSprout.js":
/*!************************************!*\
  !*** ./src/shapes/FloralSprout.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a stylized, symmetrical plant sprout shape with multiple leaves\n * radiating from a base point.\n */\nvar FloralSprout = /*#__PURE__*/function (_Shape) {\n  function FloralSprout() {\n    _classCallCheck(this, FloralSprout);\n    return _callSuper(this, FloralSprout, arguments);\n  }\n  _inherits(FloralSprout, _Shape);\n  return _createClass(FloralSprout, [{\n    key: \"createLeafPath\",\n    value: function createLeafPath(tip, base, width, controlFactor) {\n      var vx = tip.x - base.x;\n      var vy = tip.y - base.y;\n      var len = Math.sqrt(vx * vx + vy * vy);\n      if (len < 1e-6) return ''; // Avoid division by zero or tiny leaves\n\n      // Normalized vector perpendicular to base->tip vector\n      var nx = -vy / len;\n      var ny = vx / len;\n\n      // Midpoint between base and tip\n      var midX = (base.x + tip.x) / 2;\n      var midY = (base.y + tip.y) / 2;\n\n      // Calculate control points relative to the midpoint, offset by the normal vector\n      // The distance is proportional to the leaf width and the control factor\n      var offsetX = nx * width * 0.5 * controlFactor; // Use width/2 as base offset distance\n      var offsetY = ny * width * 0.5 * controlFactor;\n\n      // Control point 1 (for curve Base -> Tip)\n      var cp1x = midX + offsetX;\n      var cp1y = midY + offsetY;\n      // Control point 2 (for curve Tip -> Base)\n      var cp2x = midX - offsetX;\n      var cp2y = midY - offsetY;\n\n      // Ensure numbers have limited precision for cleaner SVG output\n      var fix = function fix(n) {\n        return n.toFixed(2);\n      };\n\n      // Path: Move to base, Quadratic curve via cp1 to tip, Quadratic curve via cp2 back to base, Close path\n      return \"M \".concat(fix(base.x), \",\").concat(fix(base.y), \" Q \").concat(fix(cp1x), \",\").concat(fix(cp1y), \" \").concat(fix(tip.x), \",\").concat(fix(tip.y), \" Q \").concat(fix(cp2x), \",\").concat(fix(cp2y), \" \").concat(fix(base.x), \",\").concat(fix(base.y), \" Z\");\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape(params) {\n      // Use parameter values from `this`\n      var height = this.height;\n      var topWidth = this.topWidth;\n      var sideWidth = topWidth * this.sideWidthRatio;\n      var upperSpreadDeg = this.upperSpread;\n      var lowerSpreadDeg = Math.max(upperSpreadDeg + 1, this.lowerSpread); // Ensure lower is wider than upper\n      var upperHeightRatio = this.upperHeightRatio;\n      var lowerHeightRatio = Math.min(upperHeightRatio - 0.01, this.lowerHeightRatio); // Ensure lower is below upper\n      var controlFactor = this.controlFactor;\n\n      // Define base point near the bottom center\n      // Adjust base vertically so the shape is roughly centered in the viewBox\n      var baseY = height * 0.5 * 0.8; // Place base slightly below center (0,0)\n      var base = {\n        x: 0,\n        y: baseY\n      };\n\n      // Calculate tip positions relative to the base point\n      var topTip = {\n        x: 0,\n        y: base.y - height\n      };\n\n      // Convert spread angles to radians\n      var upperAngleRad = upperSpreadDeg * Math.PI / 180;\n      var lowerAngleRad = lowerSpreadDeg * Math.PI / 180;\n\n      // Calculate vertical distances for tips from the base\n      var upperH = height * upperHeightRatio;\n      var lowerH = height * lowerHeightRatio;\n\n      // Calculate upper leaf tip coordinates\n      var upperTipLeft = {\n        x: -upperH * Math.sin(upperAngleRad),\n        y: base.y - upperH * Math.cos(upperAngleRad)\n      };\n      var upperTipRight = {\n        x: upperH * Math.sin(upperAngleRad),\n        y: base.y - upperH * Math.cos(upperAngleRad)\n      };\n\n      // Calculate lower leaf tip coordinates\n      var lowerTipLeft = {\n        x: -lowerH * Math.sin(lowerAngleRad),\n        y: base.y - lowerH * Math.cos(lowerAngleRad)\n      };\n      var lowerTipRight = {\n        x: lowerH * Math.sin(lowerAngleRad),\n        y: base.y - lowerH * Math.cos(lowerAngleRad)\n      };\n\n      // Generate path data for each leaf using the helper function\n      var topLeafPath = this.createLeafPath(topTip, base, topWidth, controlFactor);\n      var upperLeftLeafPath = this.createLeafPath(upperTipLeft, base, sideWidth, controlFactor);\n      var upperRightLeafPath = this.createLeafPath(upperTipRight, base, sideWidth, controlFactor);\n      var lowerLeftLeafPath = this.createLeafPath(lowerTipLeft, base, sideWidth, controlFactor);\n      var lowerRightLeafPath = this.createLeafPath(lowerTipRight, base, sideWidth, controlFactor);\n\n      // Combine all leaf path data strings\n      var allPathsData = [topLeafPath, upperLeftLeafPath, upperRightLeafPath, lowerLeftLeafPath, lowerRightLeafPath].join(' ');\n\n      // Return a single path element containing all combined leaf shapes\n      return \"<path d=\\\"\".concat(allPathsData, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(FloralSprout, \"parameters\", {\n  height: {\n    type: 'number',\n    min: 50,\n    max: 180,\n    step: 1,\n    \"default\": 150,\n    description: 'Overall height from base point to top leaf tip.'\n  },\n  topWidth: {\n    type: 'number',\n    min: 10,\n    max: 90,\n    step: 1,\n    \"default\": 50,\n    description: 'Maximum width of the central top leaf.'\n  },\n  sideWidthRatio: {\n    type: 'number',\n    min: 0.5,\n    max: 1.2,\n    step: 0.05,\n    \"default\": 0.85,\n    description: 'Ratio of side leaf width relative to top leaf width.'\n  },\n  upperSpread: {\n    type: 'number',\n    min: 10,\n    max: 60,\n    step: 1,\n    \"default\": 30,\n    description: 'Angle (degrees) from vertical for the upper pair of leaves.'\n  },\n  lowerSpread: {\n    type: 'number',\n    min: 20,\n    max: 85,\n    step: 1,\n    \"default\": 65,\n    description: 'Angle (degrees) from vertical for the lower pair of leaves (should be > upperSpread).'\n  },\n  upperHeightRatio: {\n    type: 'number',\n    min: 0.4,\n    max: 0.95,\n    step: 0.01,\n    \"default\": 0.75,\n    description: 'Relative height of upper leaf tips compared to total height (0-1).'\n  },\n  lowerHeightRatio: {\n    type: 'number',\n    min: 0.1,\n    max: 0.7,\n    step: 0.01,\n    \"default\": 0.45,\n    description: 'Relative height of lower leaf tips compared to total height (0-1, should be < upperHeightRatio).'\n  },\n  controlFactor: {\n    type: 'number',\n    min: 0.5,\n    max: 1.5,\n    step: 0.05,\n    \"default\": 0.8,\n    description: 'Adjusts the fullness/roundness of the leaves (Bezier control point distance).'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FloralSprout);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/FloralSprout.js?");

/***/ }),

/***/ "./src/shapes/FlowFieldShape.js":
/*!**************************************!*\
  !*** ./src/shapes/FlowFieldShape.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a visual representation of a flow field using lines originating\n * from grid points and following noise-based vectors.\n */\nvar FlowFieldShape = /*#__PURE__*/function (_Shape) {\n  function FlowFieldShape() {\n    _classCallCheck(this, FlowFieldShape);\n    return _callSuper(this, FlowFieldShape, arguments);\n  }\n  _inherits(FlowFieldShape, _Shape);\n  return _createClass(FlowFieldShape, [{\n    key: \"getGridPoints\",\n    value: function getGridPoints() {\n      var points = [];\n      var cellSize = this.fieldSize / this.gridSize;\n      for (var row = 0; row <= this.gridSize; row++) {\n        for (var col = 0; col <= this.gridSize; col++) {\n          var x = -this.fieldSize / 2 + col * cellSize;\n          var y = -this.fieldSize / 2 + row * cellSize;\n          points.push({\n            x: x,\n            y: y\n          });\n        }\n      }\n      return points;\n    }\n  }, {\n    key: \"calculateFlowVectors\",\n    value: function calculateFlowVectors(points) {\n      var vectors = [];\n      for (var i = 0; i < points.length; i++) {\n        var p = points[i];\n        var xNoise = Math.sin((p.x + this.seed) * 0.01 + this.noiseScale);\n        var yNoise = Math.cos((p.y + this.seed) * 0.01 + this.noiseScale);\n        if (i > 0) {\n          var prevPoint = points[i - 1];\n          xNoise += Math.sin((prevPoint.x + this.seed) * 0.01 + this.noiseScale);\n          yNoise += Math.cos((prevPoint.y + this.seed) * 0.01 + this.noiseScale);\n        }\n        var angle = Math.atan2(yNoise, xNoise) + Math.PI / 4;\n        var vector = {\n          x: Math.cos(angle) * this.flowStrength,\n          y: Math.sin(angle) * this.flowStrength\n        };\n        vectors.push(vector);\n      }\n      return vectors;\n    }\n  }, {\n    key: \"createParticleLines\",\n    value: function createParticleLines(points, vectors) {\n      var lines = [];\n      var cellSize = this.fieldSize / this.gridSize;\n      for (var i = 0; i < points.length; i++) {\n        var p = points[i];\n        var v = vectors[i];\n\n        // Calculate particle positions based on flow vectors\n        var particles = [];\n        for (var step = 0; step <= this.gridSize; step++) {\n          var t = step / this.gridSize;\n          var px = p.x + v.x * t * cellSize;\n          var py = p.y + v.y * t * cellSize;\n          particles.push({\n            x: px,\n            y: py\n          });\n        }\n\n        // Create lines connecting particles\n        var color = 'white';\n        for (var j = 0; j < particles.length - 1; j++) {\n          var angle = i / this.gridSize * Math.PI * 2;\n          var hue = angle / (Math.PI * 2) * 360;\n          color = \"hsl(\".concat(hue, \", 80%, 60%)\");\n          lines.push(\"<line \\n                    x1=\\\"\".concat(particles[j].x, \"\\\" \\n                    y1=\\\"\").concat(particles[j].y, \"\\\" \\n                    x2=\\\"\").concat(particles[j + 1].x, \"\\\" \\n                    y2=\\\"\").concat(particles[j + 1].y, \"\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"2\\\"\\n                    stroke-linecap=\\\"round\\\"\\n                />\"));\n        }\n      }\n      return lines.join('');\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      this.flowStrength = 1.0;\n      var points = this.getGridPoints();\n      var vectors = this.calculateFlowVectors(points);\n      var particleLines = this.createParticleLines(points, vectors);\n      return \"<g>\\n            \".concat(particleLines, \"\\n        </g>\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(FlowFieldShape, \"parameters\", {\n  fieldSize: {\n    min: 60,\n    max: 150,\n    \"default\": 150\n  },\n  gridSize: {\n    min: 4,\n    max: 16,\n    \"default\": 16\n  },\n  // Number of grid cells\n  noiseScale: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  },\n  // Scale of noise field\n  seed: {\n    min: 0,\n    max: 1000,\n    \"default\": 123\n  } // Seed for consistent random generation\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FlowFieldShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/FlowFieldShape.js?");

/***/ }),

/***/ "./src/shapes/FlowerMandala.js":
/*!*************************************!*\
  !*** ./src/shapes/FlowerMandala.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a mandala-like flower pattern with multiple layers of petals\n * radiating from the center.\n */\nvar FlowerMandala = /*#__PURE__*/function (_Shape) {\n  function FlowerMandala() {\n    _classCallCheck(this, FlowerMandala);\n    return _callSuper(this, FlowerMandala, arguments);\n  }\n  _inherits(FlowerMandala, _Shape);\n  return _createClass(FlowerMandala, [{\n    key: \"generatePetalPath\",\n    value: function generatePetalPath(centerX, centerY, innerRadius, outerRadius, startAngle, endAngle) {\n      var midAngle = (startAngle + endAngle) / 2;\n      var controlDistance = (outerRadius - innerRadius) * 0;\n\n      // Calculate points\n      var innerX = centerX + innerRadius * Math.cos(startAngle);\n      var innerY = centerY + innerRadius * Math.sin(startAngle);\n      var outerX = centerX + outerRadius * Math.cos(midAngle);\n      var outerY = centerY + outerRadius * Math.sin(midAngle);\n      var endX = centerX + innerRadius * Math.cos(endAngle);\n      var endY = centerY + innerRadius * Math.sin(endAngle);\n\n      // Calculate control points\n      var controlX1 = innerX + controlDistance * Math.cos(midAngle);\n      var controlY1 = innerY + controlDistance * Math.sin(midAngle);\n      var controlX2 = outerX - controlDistance * Math.cos(midAngle);\n      var controlY2 = outerY - controlDistance * Math.sin(midAngle);\n      return \"M \".concat(innerX, \" \").concat(innerY, \"\\n                Q \").concat(controlX1, \" \").concat(controlY1, \" \").concat(outerX, \" \").concat(outerY, \"\\n                Q \").concat(controlX2, \" \").concat(controlY2, \" \").concat(endX, \" \").concat(endY);\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var paths = [];\n      var baseRotation = Math.PI / 180;\n      this.petals = Math.round(this.petals);\n\n      // Generate each layer\n      for (var layer = 0; layer < this.layers; layer++) {\n        var layerInnerRadius = this.innerRadius + layer * (this.outerRadius - this.innerRadius) / this.layers;\n        var layerOuterRadius = layerInnerRadius + (this.outerRadius - this.innerRadius) / this.layers;\n\n        // Calculate petal angles for this layer\n        var angleStep = 2 * Math.PI / this.petals;\n        var layerRotation = baseRotation + layer * Math.PI / this.petals;\n\n        // Generate petals for this layer\n        for (var i = 0; i < this.petals; i++) {\n          var startAngle = i * angleStep + layerRotation;\n          var endAngle = startAngle + angleStep;\n          var petalPath = this.generatePetalPath(0, 0, layerInnerRadius, layerOuterRadius, startAngle, endAngle);\n          paths.push(\"<path d=\\\"\".concat(petalPath, \"\\\" fill=\\\"white\\\"/>\"));\n        }\n      }\n      return paths.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(FlowerMandala, \"parameters\", {\n  petals: {\n    min: 5,\n    max: 24,\n    \"default\": 12\n  },\n  layers: {\n    min: 2,\n    max: 6,\n    \"default\": 4\n  },\n  innerRadius: {\n    min: 10,\n    max: 80,\n    \"default\": 30\n  },\n  outerRadius: {\n    min: 50,\n    max: 150,\n    \"default\": 100\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FlowerMandala);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/FlowerMandala.js?");

/***/ }),

/***/ "./src/shapes/FlowerPetalsShape.js":
/*!*****************************************!*\
  !*** ./src/shapes/FlowerPetalsShape.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a simple four-petal flower shape with adjustable petal size, width,\n * curvature, and center gap.\n */\nvar FlowerPetalsShape = /*#__PURE__*/function (_Shape) {\n  function FlowerPetalsShape() {\n    _classCallCheck(this, FlowerPetalsShape);\n    return _callSuper(this, FlowerPetalsShape, arguments);\n  }\n  _inherits(FlowerPetalsShape, _Shape);\n  return _createClass(FlowerPetalsShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var petals = [];\n\n      // Create four petals\n      for (var i = 0; i < 4; i++) {\n        var angle = i * Math.PI / 2;\n        var startPoint = {\n          x: this.centerGap * Math.cos(angle),\n          y: this.centerGap * Math.sin(angle)\n        };\n        var endPoint = {\n          x: this.petalSize * Math.cos(angle),\n          y: this.petalSize * Math.sin(angle)\n        };\n        var controlPoint1 = {\n          x: startPoint.x + this.petalSize * this.petalCurve * Math.cos(angle + Math.PI / 2 * this.petalWidth),\n          y: startPoint.y + this.petalSize * this.petalCurve * Math.sin(angle + Math.PI / 2 * this.petalWidth)\n        };\n        var controlPoint2 = {\n          x: startPoint.x + this.petalSize * this.petalCurve * Math.cos(angle - Math.PI / 2 * this.petalWidth),\n          y: startPoint.y + this.petalSize * this.petalCurve * Math.sin(angle - Math.PI / 2 * this.petalWidth)\n        };\n\n        // Create petal path using quadratic Bzier curves\n        var petalPath = \"\\n                M \".concat(startPoint.x, \" \").concat(startPoint.y, \"\\n                Q \").concat(controlPoint1.x, \" \").concat(controlPoint1.y, \", \").concat(endPoint.x, \" \").concat(endPoint.y, \"\\n                Q \").concat(controlPoint2.x, \" \").concat(controlPoint2.y, \", \").concat(startPoint.x, \" \").concat(startPoint.y, \"\\n            \");\n        petals.push(petalPath);\n      }\n      return \"\\n            <path \\n                d=\\\"\".concat(petals.join(' '), \"\\\"\\n                fill=\\\"white\\\"\\n            />\\n        \");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(FlowerPetalsShape, \"parameters\", {\n  petalSize: {\n    min: 50,\n    max: 100,\n    \"default\": 80\n  },\n  petalWidth: {\n    min: 0.2,\n    max: 1.0,\n    \"default\": 0.5\n  },\n  centerGap: {\n    min: 0,\n    max: 50,\n    \"default\": 0\n  },\n  petalCurve: {\n    min: 0.1,\n    max: 2.0,\n    \"default\": 0.8\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FlowerPetalsShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/FlowerPetalsShape.js?");

/***/ }),

/***/ "./src/shapes/FourCirclesCross.js":
/*!****************************************!*\
  !*** ./src/shapes/FourCirclesCross.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a shape consisting of four circles placed at the corners of a\n * square, overlapping a central cross.\n */\nvar FourCirclesCross = /*#__PURE__*/function (_Shape) {\n  function FourCirclesCross() {\n    _classCallCheck(this, FourCirclesCross);\n    return _callSuper(this, FourCirclesCross, arguments);\n  }\n  _inherits(FourCirclesCross, _Shape);\n  return _createClass(FourCirclesCross, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Access parameters using `this`:\n      var radius = this.circleRadius;\n      var offset = this.centerOffset;\n      var crossLen = this.crossLength / 2; // Half length for calculations from center\n      var strokeWidth = this.crossStrokeWidth;\n\n      // --- Shape generation logic starts here ---\n\n      // 1. Calculate circle center positions\n      var centers = [{\n        x: offset,\n        y: offset\n      },\n      // Top right\n      {\n        x: -offset,\n        y: offset\n      },\n      // Top left\n      {\n        x: -offset,\n        y: -offset\n      },\n      // Bottom left\n      {\n        x: offset,\n        y: -offset\n      } // Bottom right\n      ];\n\n      // 2. Generate SVG circle elements\n      var circlesSvg = centers.map(function (center) {\n        return \"<circle cx=\\\"\".concat(center.x, \"\\\" cy=\\\"\").concat(center.y, \"\\\" r=\\\"\").concat(radius, \"\\\" fill=\\\"white\\\" />\");\n      }).join('\\n');\n\n      // 3. Calculate cross line endpoints\n      var line1 = {\n        x1: -crossLen,\n        y1: -crossLen,\n        x2: crossLen,\n        y2: crossLen\n      };\n      var line2 = {\n        x1: -crossLen,\n        y1: crossLen,\n        x2: crossLen,\n        y2: -crossLen\n      };\n\n      // 4. Generate SVG line elements for the cross\n      var crossSvg = \"\\n            <line x1=\\\"\".concat(line1.x1, \"\\\" y1=\\\"\").concat(line1.y1, \"\\\" x2=\\\"\").concat(line1.x2, \"\\\" y2=\\\"\").concat(line1.y2, \"\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(strokeWidth, \"\\\" />\\n            <line x1=\\\"\").concat(line2.x1, \"\\\" y1=\\\"\").concat(line2.y1, \"\\\" x2=\\\"\").concat(line2.x2, \"\\\" y2=\\\"\").concat(line2.y2, \"\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(strokeWidth, \"\\\" />\\n        \");\n\n      // 5. Combine SVG elements\n      return \"\\n            \".concat(circlesSvg, \"\\n            \").concat(crossSvg, \"\\n        \");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(FourCirclesCross, \"parameters\", {\n  circleRadius: {\n    type: 'number',\n    min: 10,\n    max: 80,\n    // Keep radius small enough so offset+radius < 100\n    step: 1,\n    \"default\": 50,\n    label: 'Circle Radius'\n  },\n  centerOffset: {\n    type: 'number',\n    min: 5,\n    max: 70,\n    // Keep offset small enough so offset+radius < 100\n    step: 1,\n    \"default\": 40,\n    label: 'Center Offset'\n  },\n  crossLength: {\n    type: 'number',\n    min: 10,\n    max: 141,\n    // Max diagonal length within approx offset\n    step: 1,\n    \"default\": 70,\n    label: 'Cross Length'\n  },\n  crossStrokeWidth: {\n    type: 'number',\n    min: 1,\n    max: 10,\n    step: 0.5,\n    \"default\": 2,\n    label: 'Cross Stroke Width'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FourCirclesCross);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/FourCirclesCross.js?");

/***/ }),

/***/ "./src/shapes/FractalFlowerShape.js":
/*!******************************************!*\
  !*** ./src/shapes/FractalFlowerShape.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a fractal pattern resembling a snowflake or ice crystal, with\n * recursive branches and crystal details.\n */\nvar FractalFlowerShape = /*#__PURE__*/function (_Shape) {\n  function FractalFlowerShape() {\n    _classCallCheck(this, FractalFlowerShape);\n    return _callSuper(this, FractalFlowerShape, arguments);\n  }\n  _inherits(FractalFlowerShape, _Shape);\n  return _createClass(FractalFlowerShape, [{\n    key: \"drawFrostBranch\",\n    value: function drawFrostBranch(start, angle, length, depth, spread, complexity, maxRadius) {\n      var _this = this;\n      var paths = [];\n\n      // Calculate end point\n      var startToCenter = Math.hypot(start.x - start.x, start.y - start.y);\n      var remainingRadius = maxRadius - startToCenter;\n      var currentLength = Math.min(length, remainingRadius);\n      var end = {\n        x: start.x + currentLength * Math.cos(angle),\n        y: start.y + currentLength * Math.sin(angle)\n      };\n\n      // Draw main branch\n      paths.push(\"M \".concat(start.x, \",\").concat(start.y, \" L \").concat(end.x, \",\").concat(end.y));\n      if (depth > 0) {\n        // Calculate sub-branch properties\n        var subLength = currentLength * (0.6 - complexity * 0.2);\n        var spreadRad = spread * Math.PI / 180.0 * (1.0 - depth * 0.1);\n\n        // Draw sub-branches\n        [-spreadRad, spreadRad].forEach(function (subAngle) {\n          var subPaths = _this.drawFrostBranch(end, angle + subAngle, subLength, depth - 1, spread, complexity, maxRadius);\n          paths.push.apply(paths, _toConsumableArray(subPaths));\n        });\n\n        // Add crystal details\n        var crystalSize = currentLength * 0.15 * (1.0 + complexity * 0.5);\n        var crystalPoints = [];\n        for (var i = 0; i < 4; i++) {\n          var pointAngle = angle + i * Math.PI / 2;\n          crystalPoints.push(\"\".concat(end.x + crystalSize * Math.cos(pointAngle), \",\").concat(end.y + crystalSize * Math.sin(pointAngle)));\n        }\n        paths.push(\"M \".concat(crystalPoints[0], \" L \").concat(crystalPoints[1], \" L \").concat(crystalPoints[2], \" L \").concat(crystalPoints[3], \" Z\"));\n      }\n      return paths;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var maxSize = 200;\n      var scale = maxSize / 400;\n      var center = {\n        x: 0,\n        y: 0\n      };\n      var maxRadius = maxSize * 0.45;\n      var baseLength = Math.min(this.crystalSize * scale, maxRadius);\n      var paths = [];\n\n      // Generate evenly distributed branches\n      for (var branch = 0; branch < this.branches; branch++) {\n        var baseAngle = branch * 2 * Math.PI / this.branches;\n        var branchPaths = this.drawFrostBranch(center, baseAngle, baseLength, this.depth, this.spread, this.complexity, maxRadius);\n        paths.push.apply(paths, _toConsumableArray(branchPaths));\n      }\n      return \"<path \\n            d=\\\"\".concat(paths.join(' '), \"\\\"\\n            fill=\\\"none\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            stroke-linecap=\\\"round\\\"\\n            stroke-linejoin=\\\"round\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(FractalFlowerShape, \"parameters\", {\n  branches: {\n    min: 4,\n    max: 12,\n    \"default\": 6\n  },\n  depth: {\n    min: 2,\n    max: 7,\n    \"default\": 4\n  },\n  spread: {\n    min: 15,\n    max: 60,\n    \"default\": 30\n  },\n  crystalSize: {\n    min: 40,\n    max: 120,\n    \"default\": 80\n  },\n  complexity: {\n    min: 0,\n    max: 1,\n    \"default\": 0.5\n  },\n  thickness: {\n    min: 1,\n    max: 8,\n    \"default\": 2\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FractalFlowerShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/FractalFlowerShape.js?");

/***/ }),

/***/ "./src/shapes/FractalTreeShape.js":
/*!****************************************!*\
  !*** ./src/shapes/FractalTreeShape.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a simple fractal tree structure using recursive branching with\n * adjustable angle, length ratio, and depth.\n */\nvar FractalTreeShape = /*#__PURE__*/function (_Shape) {\n  function FractalTreeShape() {\n    _classCallCheck(this, FractalTreeShape);\n    return _callSuper(this, FractalTreeShape, arguments);\n  }\n  _inherits(FractalTreeShape, _Shape);\n  return _createClass(FractalTreeShape, [{\n    key: \"calculateBoundingBox\",\n    value: function calculateBoundingBox(depth, angle, lengthRatio) {\n      var width = 0;\n      var currentLength = 100.0;\n      var currentWidth = 0;\n      for (var i = 0; i < depth; i++) {\n        currentWidth = currentLength * Math.sin(angle * Math.PI / 180) * 2;\n        width = Math.max(width, currentWidth);\n        currentLength *= lengthRatio;\n      }\n      return width;\n    }\n  }, {\n    key: \"drawBranch\",\n    value: function drawBranch(start, length, angle, depth, paths) {\n      if (depth <= 0) return;\n      var end = {\n        x: start.x + length * Math.cos(angle * Math.PI / 180),\n        y: start.y - length * Math.sin(angle * Math.PI / 180)\n      };\n      paths.push(\"M \".concat(start.x, \",\").concat(start.y, \" L \").concat(end.x, \",\").concat(end.y));\n      var newLength = length * this.lengthRatio;\n      this.drawBranch(end, newLength, angle + this.branchAngle, depth - 1, paths);\n      this.drawBranch(end, newLength, angle - this.branchAngle, depth - 1, paths);\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var boundingWidth = this.calculateBoundingBox(this.depth, this.branchAngle, this.lengthRatio);\n      var totalHeight = 100.0 * (1 - Math.pow(this.lengthRatio, this.depth)) / (1 - this.lengthRatio);\n\n      // Calculate scale to fit within bounds with padding\n      var maxDimension = Math.max(boundingWidth, totalHeight) * 1.2; // Add 20% padding\n      var scale = 200 / maxDimension;\n\n      // Start from bottom center\n      var startY = totalHeight / 2 * scale;\n      var startPoint = {\n        x: 0,\n        y: startY\n      };\n      var paths = [];\n      this.drawBranch(startPoint, 100 * scale, 90, this.depth, paths);\n      return \"<path \\n            d=\\\"\".concat(paths.join(' '), \"\\\"\\n            fill=\\\"none\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            stroke-linecap=\\\"round\\\"\\n            stroke-linejoin=\\\"round\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(FractalTreeShape, \"parameters\", {\n  branchAngle: {\n    min: 10,\n    max: 45,\n    \"default\": 30\n  },\n  lengthRatio: {\n    min: 0.5,\n    max: 0.8,\n    \"default\": 0.7\n  },\n  depth: {\n    min: 2,\n    max: 8,\n    \"default\": 5\n  },\n  thickness: {\n    min: 1,\n    max: 5,\n    \"default\": 2\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FractalTreeShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/FractalTreeShape.js?");

/***/ }),

/***/ "./src/shapes/FragmentedStructure.js":
/*!*******************************************!*\
  !*** ./src/shapes/FragmentedStructure.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates an angular, abstract structure outline with randomized vertex\n * positions and internal connecting struts.\n */\nvar FragmentedStructure = /*#__PURE__*/function (_Shape) {\n  function FragmentedStructure() {\n    _classCallCheck(this, FragmentedStructure);\n    return _callSuper(this, FragmentedStructure, arguments);\n  }\n  _inherits(FragmentedStructure, _Shape);\n  return _createClass(FragmentedStructure, [{\n    key: \"_clamp\",\n    value: /** Helper to clamp values */\n    function _clamp(val, min, max) {\n      return Math.max(min, Math.min(max, val));\n    }\n\n    /** Helper function to rotate a point around (0,0) */\n  }, {\n    key: \"_rotatePoint\",\n    value: function _rotatePoint(x, y, angleDeg) {\n      var angleRad = angleDeg * Math.PI / 180;\n      var cosA = Math.cos(angleRad);\n      var sinA = Math.sin(angleRad);\n      return {\n        x: x * cosA - y * sinA,\n        y: x * sinA + y * cosA\n      };\n    }\n\n    /** Helper to get a random point on a line segment, avoiding ends */\n  }, {\n    key: \"_getRandomPointOnEdge\",\n    value: function _getRandomPointOnEdge(p1, p2, margin) {\n      // Ensure margin is less than 0.5 to allow for a point selection range\n      var safeMargin = this._clamp(margin, 0.01, 0.49);\n      var t = safeMargin + this.random() * (1 - 2 * safeMargin);\n      return {\n        x: p1.x + (p2.x - p1.x) * t,\n        y: p1.y + (p2.y - p1.y) * t\n      };\n    }\n\n    /**\n     * Generates the SVG path for the FragmentedStructure shape using strokes.\n     */\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      var width = this.width,\n        height = this.height,\n        irregularity = this.irregularity,\n        thickness = this.thickness,\n        numStruts = this.numStruts,\n        rotation = this.rotation,\n        strutEdgeMargin = this.strutEdgeMargin;\n      var hw = width / 2;\n      var hh = height / 2;\n      var maxCoord = 99.9; // Stay slightly within bounds\n\n      // --- 1. Generate Base Quadrilateral Vertices (slightly irregular) ---\n      var baseVertices = [{\n        x: -hw,\n        y: -hh\n      }, {\n        x: hw,\n        y: -hh\n      }, {\n        x: hw,\n        y: hh\n      }, {\n        x: -hw,\n        y: hh\n      }];\n      var vertices = baseVertices.map(function (v) {\n        // Apply irregularity, scaling offset by dimension\n        var rx = hw * irregularity * (_this.random() - 0.5) * 2;\n        var ry = hh * irregularity * (_this.random() - 0.5) * 2;\n        return {\n          x: _this._clamp(v.x + rx, -maxCoord, maxCoord),\n          y: _this._clamp(v.y + ry, -maxCoord, maxCoord)\n        };\n      });\n\n      // --- 2. Rotate Base Vertices ---\n      var rotatedVertices = vertices.map(function (v) {\n        return _this._rotatePoint(v.x, v.y, rotation);\n      });\n\n      // --- 3. Build Outer Path String ---\n      var pathData = \"M \".concat(rotatedVertices[0].x.toFixed(2), \",\").concat(rotatedVertices[0].y.toFixed(2), \" \");\n      for (var i = 1; i < rotatedVertices.length; i++) {\n        pathData += \"L \".concat(rotatedVertices[i].x.toFixed(2), \",\").concat(rotatedVertices[i].y.toFixed(2), \" \");\n      }\n      pathData += 'Z '; // Close the outer loop\n\n      // --- 4. Generate Internal Struts ---\n      var edges = [];\n      for (var _i = 0; _i < vertices.length; _i++) {\n        // Store original unrotated vertices for edge point calculation\n        edges.push({\n          p1: vertices[_i],\n          p2: vertices[(_i + 1) % vertices.length],\n          index: _i\n        });\n      }\n      var usedEdgePairs = new Set(); // Prevent connecting the exact same two edges\n\n      for (var k = 0; k < numStruts; k++) {\n        var edge1Index = void 0,\n          edge2Index = void 0;\n        var attempts = 0;\n        var maxAttempts = 30; // Limit attempts to find a suitable edge pair\n\n        // Select two distinct, non-adjacent edges\n        do {\n          edge1Index = Math.floor(this.random() * edges.length);\n          edge2Index = Math.floor(this.random() * edges.length);\n          var pairKey = Math.min(edge1Index, edge2Index) + '-' + Math.max(edge1Index, edge2Index);\n          // Check if adjacent (handles wrap-around: 0 and 3 are adjacent)\n          var isAdjacent = Math.abs(edge1Index - edge2Index) === 1 || Math.abs(edge1Index - edge2Index) === edges.length - 1;\n\n          // Ensure distinct, not adjacent, and pair not already used\n          if (edge1Index !== edge2Index && !isAdjacent && !usedEdgePairs.has(pairKey)) {\n            usedEdgePairs.add(pairKey);\n            break; // Found a valid pair\n          }\n          attempts++;\n        } while (attempts < maxAttempts);\n\n        // If no suitable pair found after several attempts, skip this strut\n        if (attempts >= maxAttempts) continue;\n        var edge1 = edges[edge1Index];\n        var edge2 = edges[edge2Index];\n\n        // Get random points on the selected edges (using original vertices)\n        var strutP1 = this._getRandomPointOnEdge(edge1.p1, edge1.p2, strutEdgeMargin);\n        var strutP2 = this._getRandomPointOnEdge(edge2.p1, edge2.p2, strutEdgeMargin);\n\n        // Rotate the calculated strut points\n        var rStrutP1 = this._rotatePoint(strutP1.x, strutP1.y, rotation);\n        var rStrutP2 = this._rotatePoint(strutP2.x, strutP2.y, rotation);\n\n        // Add strut path data as a separate move/line segment\n        pathData += \"M \".concat(rStrutP1.x.toFixed(2), \",\").concat(rStrutP1.y.toFixed(2), \" L \").concat(rStrutP2.x.toFixed(2), \",\").concat(rStrutP2.y.toFixed(2), \" \");\n      }\n\n      // --- 5. Return SVG Path Element ---\n      // Using fill=\"none\" and a thick stroke with miter joins creates the desired visual effect\n      // where the lines appear as filled areas connected at corners.\n      return \"<path d=\\\"\".concat(pathData, \"\\\"\\n                      fill=\\\"none\\\"\\n                      stroke=\\\"white\\\"\\n                      stroke-width=\\\"\").concat(thickness, \"\\\"\\n                      stroke-linecap=\\\"butt\\\"\\n                      stroke-linejoin=\\\"miter\\\"\\n                      stroke-miterlimit=\\\"10\\\"/>\"); // Miter limit prevents excessively long spikes at sharp corners\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(FragmentedStructure, \"parameters\", {\n  width: {\n    type: 'number',\n    min: 80,\n    max: 190,\n    step: 2,\n    \"default\": 120,\n    label: 'Width'\n  },\n  height: {\n    type: 'number',\n    min: 80,\n    max: 190,\n    step: 2,\n    \"default\": 140,\n    label: 'Height'\n  },\n  irregularity: {\n    type: 'number',\n    min: 0,\n    max: 0.5,\n    // Max deviation factor for vertices\n    step: 0.05,\n    \"default\": 0.15,\n    label: 'Irregularity'\n  },\n  thickness: {\n    type: 'number',\n    min: 4,\n    max: 16,\n    // Stroke width\n    step: 1,\n    \"default\": 10,\n    label: 'Thickness'\n  },\n  numStruts: {\n    type: 'number',\n    min: 0,\n    max: 6,\n    // Number of internal connecting lines\n    step: 1,\n    \"default\": 4,\n    label: 'Internal Struts'\n  },\n  rotation: {\n    type: 'number',\n    min: 0,\n    max: 360,\n    step: 1,\n    \"default\": 35,\n    label: 'Rotation'\n  },\n  strutEdgeMargin: {\n    type: 'number',\n    min: 0.05,\n    // Minimum distance from corners for strut connections (as fraction of edge length)\n    max: 0.4,\n    step: 0.05,\n    \"default\": 0.15,\n    label: 'Strut Edge Margin'\n  },\n  seed: {\n    // Inherited, override default if needed\n    type: 'number',\n    min: 1,\n    max: 10000,\n    \"default\": 303\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FragmentedStructure);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/FragmentedStructure.js?");

/***/ }),

/***/ "./src/shapes/FramedComposition.js":
/*!*****************************************!*\
  !*** ./src/shapes/FramedComposition.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _readOnlyError(r) { throw new TypeError('\"' + r + '\" is read-only'); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Creates a composition featuring an outer frame, an inner square, two vertical\n * dots, and a horizontal arrow.\n */\nvar FramedComposition = /*#__PURE__*/function (_Shape) {\n  function FramedComposition() {\n    _classCallCheck(this, FramedComposition);\n    return _callSuper(this, FramedComposition, arguments);\n  }\n  _inherits(FramedComposition, _Shape);\n  return _createClass(FramedComposition, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var outerHalf = this.outerSize / 2;\n      var innerHalf = this.innerSize / 2;\n\n      // Outer Frame\n      var frame = \"<rect\\n            x=\\\"\".concat(-outerHalf, \"\\\"\\n            y=\\\"\").concat(-outerHalf, \"\\\"\\n            width=\\\"\").concat(this.outerSize, \"\\\"\\n            height=\\\"\").concat(this.outerSize, \"\\\"\\n            fill=\\\"none\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.frameThickness, \"\\\"\\n        />\");\n\n      // Inner Square\n      var innerSquare = \"<rect\\n            x=\\\"\".concat(-innerHalf, \"\\\"\\n            y=\\\"\").concat(-innerHalf, \"\\\"\\n            width=\\\"\").concat(this.innerSize, \"\\\"\\n            height=\\\"\").concat(this.innerSize, \"\\\"\\n            fill=\\\"white\\\"\\n            stroke=\\\"none\\\"\\n        />\");\n\n      // Dots\n      var dot1 = \"<circle\\n            cx=\\\"\".concat(this.dotXOffset, \"\\\"\\n            cy=\\\"\").concat(-this.dotSpacing / 2, \"\\\"\\n            r=\\\"\").concat(this.dotRadius, \"\\\"\\n            fill=\\\"white\\\"\\n            stroke=\\\"none\\\"\\n        />\");\n      var dot2 = \"<circle\\n            cx=\\\"\".concat(this.dotXOffset, \"\\\"\\n            cy=\\\"\").concat(this.dotSpacing / 2, \"\\\"\\n            r=\\\"\").concat(this.dotRadius, \"\\\"\\n            fill=\\\"white\\\"\\n            stroke=\\\"none\\\"\\n        />\");\n\n      // Arrow Path Calculation\n      var y = this.arrowYOffset;\n      var halfArrowLen = this.arrowLength / 2;\n      var halfThick = this.arrowThickness / 2;\n      var headLen = this.arrowHeadSize;\n      var headWidth = this.arrowHeadSize; // Total width of the head base\n\n      var startX = -halfArrowLen;\n      var endX = halfArrowLen;\n      var shaftEndX = endX - headLen; // Point where shaft meets head base\n\n      // Ensure shaftEndX doesn't go beyond startX\n      if (shaftEndX < startX) {\n        startX, _readOnlyError(\"shaftEndX\");\n      }\n      var p1x = startX,\n        p1y = y - halfThick;\n      var p2x = shaftEndX,\n        p2y = y - halfThick;\n      var p3x = shaftEndX,\n        p3y = y - headWidth / 2;\n      var p4x = endX,\n        p4y = y;\n      var p5x = shaftEndX,\n        p5y = y + headWidth / 2;\n      var p6x = shaftEndX,\n        p6y = y + halfThick;\n      var p7x = startX,\n        p7y = y + halfThick;\n      var arrowPathData = \"M \".concat(p1x, \" \").concat(p1y, \" L \").concat(p2x, \" \").concat(p2y, \" L \").concat(p3x, \" \").concat(p3y, \" L \").concat(p4x, \" \").concat(p4y, \" L \").concat(p5x, \" \").concat(p5y, \" L \").concat(p6x, \" \").concat(p6y, \" L \").concat(p7x, \" \").concat(p7y, \" Z\");\n      var arrow = \"<path d=\\\"\".concat(arrowPathData, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\");\n      return \"\".concat(frame).concat(innerSquare).concat(dot1).concat(dot2).concat(arrow);\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(FramedComposition, \"parameters\", {\n  outerSize: {\n    type: 'number',\n    min: 50,\n    max: 198,\n    step: 1,\n    \"default\": 180\n  },\n  innerSize: {\n    type: 'number',\n    min: 20,\n    max: 150,\n    step: 1,\n    \"default\": 90\n  },\n  frameThickness: {\n    type: 'number',\n    min: 1,\n    max: 30,\n    step: 1,\n    \"default\": 8\n  },\n  dotRadius: {\n    type: 'number',\n    min: 1,\n    max: 20,\n    step: 0.5,\n    \"default\": 6\n  },\n  dotSpacing: {\n    type: 'number',\n    min: 10,\n    max: 100,\n    step: 1,\n    \"default\": 40\n  },\n  dotXOffset: {\n    type: 'number',\n    min: -90,\n    max: 90,\n    step: 1,\n    \"default\": -65\n  },\n  arrowYOffset: {\n    type: 'number',\n    min: -90,\n    max: 90,\n    step: 1,\n    \"default\": 65\n  },\n  arrowLength: {\n    type: 'number',\n    min: 30,\n    max: 180,\n    step: 1,\n    \"default\": 100\n  },\n  arrowThickness: {\n    type: 'number',\n    min: 1,\n    max: 25,\n    step: 0.5,\n    \"default\": 6\n  },\n  arrowHeadSize: {\n    type: 'number',\n    min: 5,\n    max: 40,\n    step: 1,\n    \"default\": 18\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FramedComposition);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/FramedComposition.js?");

/***/ }),

/***/ "./src/shapes/FrostRaysShape.js":
/*!**************************************!*\
  !*** ./src/shapes/FrostRaysShape.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a frost or ice crystal pattern with rays radiating from the center,\n * featuring smaller sub-crystals along each ray.\n */\nvar FrostRaysShape = /*#__PURE__*/function (_Shape) {\n  function FrostRaysShape() {\n    _classCallCheck(this, FrostRaysShape);\n    return _callSuper(this, FrostRaysShape, arguments);\n  }\n  _inherits(FrostRaysShape, _Shape);\n  return _createClass(FrostRaysShape, [{\n    key: \"createBranch\",\n    value: function createBranch(center, angle, innerRadius, outerRadius, branchWidth, segmentCount, subCrystalSize) {\n      var paths = [];\n\n      // Calculate main branch points\n      var startX = center.x + innerRadius * Math.cos(angle);\n      var startY = center.y + innerRadius * Math.sin(angle);\n      var endX = center.x + outerRadius * Math.cos(angle);\n      var endY = center.y + outerRadius * Math.sin(angle);\n\n      // Draw main branch line\n      paths.push(\"M \".concat(startX, \",\").concat(startY, \" L \").concat(endX, \",\").concat(endY));\n      this.points = Math.round(this.points);\n\n      // Add segments along the branch\n      var segmentLength = (outerRadius - innerRadius) / segmentCount;\n      for (var i = 1; i <= segmentCount; i++) {\n        var segmentRadius = innerRadius + segmentLength * i;\n        var segmentCenter = {\n          x: center.x + segmentRadius * Math.cos(angle),\n          y: center.y + segmentRadius * Math.sin(angle)\n        };\n\n        // Add side crystals\n        var sideAngle1 = angle + Math.PI / 3;\n        var sideAngle2 = angle - Math.PI / 3;\n        var sideLength = segmentLength * subCrystalSize;\n        var side1End = {\n          x: segmentCenter.x + sideLength * Math.cos(sideAngle1),\n          y: segmentCenter.y + sideLength * Math.sin(sideAngle1)\n        };\n        var side2End = {\n          x: segmentCenter.x + sideLength * Math.cos(sideAngle2),\n          y: segmentCenter.y + sideLength * Math.sin(sideAngle2)\n        };\n        paths.push(\"M \".concat(segmentCenter.x, \",\").concat(segmentCenter.y, \" L \").concat(side1End.x, \",\").concat(side1End.y), \"M \".concat(segmentCenter.x, \",\").concat(segmentCenter.y, \" L \").concat(side2End.x, \",\").concat(side2End.y));\n      }\n      return paths;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var scale = 0.8;\n      var center = {\n        x: 0,\n        y: 0\n      };\n      var innerRadius = this.innerRadius * 100 * scale;\n      var outerRadius = 120 * scale;\n      var phase = this.phase * (Math.PI / 180.0);\n      var paths = [];\n\n      // Draw main branches\n      for (var i = 0; i < this.points; i++) {\n        var angle = i * 2 * Math.PI / this.points + phase;\n        var branchPaths = this.createBranch(center, angle, innerRadius, outerRadius, this.branchWidth * scale, this.segmentCount, this.subCrystalSize);\n        paths.push.apply(paths, _toConsumableArray(branchPaths));\n      }\n\n      // Draw central core\n      var coreRadius = innerRadius * 0.3;\n      paths.push(\"M \".concat(center.x + coreRadius, \",\").concat(center.y, \" A \").concat(coreRadius, \",\").concat(coreRadius, \" 0 1,0 \").concat(center.x - coreRadius, \",\").concat(center.y, \" A \").concat(coreRadius, \",\").concat(coreRadius, \" 0 1,0 \").concat(center.x + coreRadius, \",\").concat(center.y));\n      return \"<path \\n           d=\\\"\".concat(paths.join(' '), \"\\\"\\n           fill=\\\"none\\\"\\n           stroke=\\\"white\\\"\\n           stroke-width=\\\"\").concat(this.branchWidth * scale, \"\\\"\\n           stroke-linecap=\\\"round\\\"\\n           stroke-linejoin=\\\"round\\\"\\n       />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(FrostRaysShape, \"parameters\", {\n  points: {\n    min: 4,\n    max: 12,\n    \"default\": 6\n  },\n  innerRadius: {\n    min: 0.2,\n    max: 0.8,\n    \"default\": 0.4\n  },\n  branchWidth: {\n    min: 2,\n    max: 15,\n    \"default\": 8\n  },\n  segmentCount: {\n    min: 2,\n    max: 8,\n    \"default\": 4\n  },\n  subCrystalSize: {\n    min: 0.1,\n    max: 2.0,\n    \"default\": 0.25\n  },\n  phase: {\n    min: -180,\n    max: 180,\n    \"default\": -180\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FrostRaysShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/FrostRaysShape.js?");

/***/ }),

/***/ "./src/shapes/FunnelShape.js":
/*!***********************************!*\
  !*** ./src/shapes/FunnelShape.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a simple funnel shape composed of a wider top section tapering down\n * to a narrower neck section.\n */\nvar FunnelShape = /*#__PURE__*/function (_Shape) {\n  function FunnelShape() {\n    _classCallCheck(this, FunnelShape);\n    return _callSuper(this, FunnelShape, arguments);\n  }\n  _inherits(FunnelShape, _Shape);\n  return _createClass(FunnelShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var scale = 0.8;\n      var center = {\n        x: 0,\n        y: 0\n      };\n\n      // Scale the parameters\n      var topWidth = this.topWidth * scale;\n      var neckWidth = this.neckWidth * scale;\n      var neckHeight = this.neckHeight * scale;\n      var topHeight = this.topHeight * scale;\n\n      // Calculate key points\n      var totalHeight = topHeight + neckHeight;\n      var topY = center.y - totalHeight / 2;\n      var neckY = topY + topHeight;\n\n      // Build the path\n      var path = [// Top rectangle - start at top left\n      \"M \".concat(center.x - topWidth / 2, \",\").concat(topY), // Top line to right\n      \"L \".concat(center.x + topWidth / 2, \",\").concat(topY), // Right side down to neck\n      \"L \".concat(center.x + neckWidth / 2, \",\").concat(neckY), // Right neck line\n      \"L \".concat(center.x + neckWidth / 2, \",\").concat(neckY + neckHeight), // Bottom line\n      \"L \".concat(center.x - neckWidth / 2, \",\").concat(neckY + neckHeight), // Left neck line\n      \"L \".concat(center.x - neckWidth / 2, \",\").concat(neckY), // Left side up to top\n      \"L \".concat(center.x - topWidth / 2, \",\").concat(topY),\n      // Close path\n      'Z'].join(' ');\n      return \"<path \\n           d=\\\"\".concat(path, \"\\\"\\n           fill=\\\"white\\\"\\n           stroke=\\\"none\\\"\\n       />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(FunnelShape, \"parameters\", {\n  topWidth: {\n    min: 50,\n    max: 200,\n    \"default\": 120\n  },\n  neckWidth: {\n    min: 20,\n    max: 100,\n    \"default\": 40\n  },\n  neckHeight: {\n    min: 20,\n    max: 100,\n    \"default\": 50\n  },\n  topHeight: {\n    min: 20,\n    max: 150,\n    \"default\": 80\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FunnelShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/FunnelShape.js?");

/***/ }),

/***/ "./src/shapes/GenerativeGrid.js":
/*!**************************************!*\
  !*** ./src/shapes/GenerativeGrid.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates an abstract grid composition featuring various shapes (square,\n * circle, etc.) within cells, with optional connecting and diagonal lines.\n */\nvar GenerativeGrid = /*#__PURE__*/function (_Shape) {\n  function GenerativeGrid() {\n    _classCallCheck(this, GenerativeGrid);\n    return _callSuper(this, GenerativeGrid, arguments);\n  }\n  _inherits(GenerativeGrid, _Shape);\n  return _createClass(GenerativeGrid, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var svgElements = [];\n      var gridSize = this.gridSize;\n      // Use a slightly smaller area than the full viewBox for aesthetics\n      var totalSize = 180;\n      var cellSize = totalSize / gridSize;\n      // Calculate top-left corner for centering the grid at (0,0)\n      var startOffset = -totalSize / 2;\n\n      // Define available shapes\n      var availableShapes = ['square', 'circle', 'triangle', 'diamond', 'cross'];\n      // Select a subset of shapes based on diversity parameter using seeded random shuffle\n      var shapesToUse = this._selectShapes(availableShapes, this.shapeDiversity);\n      var cellData = []; // Store info about each cell for connection lines\n\n      // 1. Generate shapes in cells\n      for (var r = 0; r < gridSize; r++) {\n        cellData[r] = [];\n        for (var c = 0; c < gridSize; c++) {\n          var cx = startOffset + (c + 0.5) * cellSize;\n          var cy = startOffset + (r + 0.5) * cellSize;\n\n          // Calculate actual size available for the element after padding\n          var elementSize = Math.max(0, cellSize - 2 * this.cellPadding);\n          cellData[r][c] = {\n            cx: cx,\n            cy: cy,\n            elementSize: elementSize\n          }; // Store center and size\n\n          // Only draw if there's space and shapes are selected\n          if (elementSize > 0 && shapesToUse.length > 0) {\n            // Select a shape type randomly from the chosen subset\n            var shapeType = shapesToUse[Math.floor(this.random() * shapesToUse.length)];\n            cellData[r][c].shapeType = shapeType; // Store shape type\n\n            var rotation = this._getRotation(shapeType);\n            svgElements.push(this._generateElement(shapeType, cx, cy, elementSize, rotation));\n            if (this.diagonalLines) {\n              svgElements.push(this._generateDiagonals(cx, cy, elementSize));\n            }\n          } else {\n            cellData[r][c].shapeType = 'empty'; // Mark as empty if size is too small\n          }\n        }\n      }\n\n      // 2. Generate connection lines between cell centers\n      if (this.connectionLines) {\n        svgElements.push(this._generateConnections(cellData, gridSize));\n      }\n\n      // Wrap everything in a group to apply common stroke styles\n      // Individual styles like diagonal stroke width are applied within helpers\n      return \"<g stroke=\\\"white\\\" fill=\\\"none\\\" stroke-width=\\\"\".concat(this.strokeWidth.toFixed(2), \"\\\">\\n\").concat(svgElements.join('\\n'), \"\\n</g>\");\n    }\n\n    /**\n     * Selects a subset of available shapes randomly using the seeded RNG.\n     * @param {string[]} available - Array of available shape names.\n     * @param {number} count - Number of shapes to select.\n     * @returns {string[]} - Array of selected shape names.\n     */\n  }, {\n    key: \"_selectShapes\",\n    value: function _selectShapes(available, count) {\n      var _this = this;\n      // Create a copy and shuffle it using the instance's random method\n      var shuffled = _toConsumableArray(available).sort(function () {\n        return _this.random() - 0.5;\n      });\n      // Return the first 'count' elements\n      return shuffled.slice(0, Math.min(count, available.length));\n    }\n\n    /**\n     * Determines the rotation angle based on the rotationType parameter and shape type.\n     * @param {string} shapeType - The type of shape being drawn ('square', 'diamond', etc.).\n     * @returns {number} - Rotation angle in degrees.\n     */\n  }, {\n    key: \"_getRotation\",\n    value: function _getRotation(shapeType) {\n      switch (this.rotationType) {\n        case 'aligned':\n          // Diamonds are squares rotated 45 degrees in aligned mode\n          if (shapeType === 'diamond') return 45;\n          // Square, Circle, Triangle, Cross remain unrotated\n          return 0;\n        case 'random':\n          // Random discrete rotation (multiples of 45 degrees)\n          var angles = [0, 45, 90, 135, 180, 225, 270, 315];\n          return angles[Math.floor(this.random() * angles.length)];\n        case 'none':\n        default:\n          return 0;\n        // No rotation\n      }\n    }\n\n    /**\n     * Generates SVG string for a specific shape element.\n     * Stroke attributes are inherited from the parent <g> unless overridden.\n     * @param {string} type - Shape type ('square', 'circle', etc.).\n     * @param {number} cx - Center X coordinate.\n     * @param {number} cy - Center Y coordinate.\n     * @param {number} size - Available size for the element.\n     * @param {number} rotation - Rotation angle in degrees.\n     * @returns {string} - SVG element string.\n     */\n  }, {\n    key: \"_generateElement\",\n    value: function _generateElement(type, cx, cy, size, rotation) {\n      var halfSize = size / 2;\n      // Apply rotation transform if necessary\n      var transform = rotation !== 0 ? \"transform=\\\"rotate(\".concat(rotation.toFixed(2), \" \").concat(cx.toFixed(2), \" \").concat(cy.toFixed(2), \")\\\"\") : '';\n      // Helper to format numbers for cleaner SVG output\n      var format = function format(num) {\n        return num.toFixed(2);\n      };\n      switch (type) {\n        case 'square':\n        case 'diamond':\n          // Diamond is just a square with rotation handled by transform\n          return \"<rect x=\\\"\".concat(format(cx - halfSize), \"\\\" y=\\\"\").concat(format(cy - halfSize), \"\\\" width=\\\"\").concat(format(size), \"\\\" height=\\\"\").concat(format(size), \"\\\" \").concat(transform, \"/>\");\n        case 'circle':\n          // Rotation doesn't visually affect a simple circle\n          return \"<circle cx=\\\"\".concat(format(cx), \"\\\" cy=\\\"\").concat(format(cy), \"\\\" r=\\\"\").concat(format(halfSize), \"\\\" />\");\n        case 'triangle':\n          {\n            // Equilateral triangle pointing up initially, fitting within the size box\n            var R = halfSize; // Circumradius fits within halfSize\n            // Vertices calculated using trigonometry based on circumradius\n            var p1x = format(cx);\n            var p1y = format(cy - R); // Top vertex\n            var p2x = format(cx - R * Math.cos(Math.PI / 6)); // Bottom left vertex (cos(30deg))\n            var p2y = format(cy + R * Math.sin(Math.PI / 6)); // Bottom left vertex (sin(30deg))\n            var p3x = format(cx + R * Math.cos(Math.PI / 6)); // Bottom right vertex\n            var p3y = format(cy + R * Math.sin(Math.PI / 6)); // Bottom right vertex\n            return \"<polygon points=\\\"\".concat(p1x, \",\").concat(p1y, \" \").concat(p2x, \",\").concat(p2y, \" \").concat(p3x, \",\").concat(p3y, \"\\\" \").concat(transform, \"/>\");\n          }\n        case 'cross':\n          {\n            // Draw two lines forming a '+' shape\n            var p1 = \"\".concat(format(cx - halfSize), \",\").concat(format(cy)); // Left mid\n            var p2 = \"\".concat(format(cx + halfSize), \",\").concat(format(cy)); // Right mid\n            var p3 = \"\".concat(format(cx), \",\").concat(format(cy - halfSize)); // Top mid\n            var p4 = \"\".concat(format(cx), \",\").concat(format(cy + halfSize)); // Bottom mid\n            // Group the lines and apply transform to the group\n            return \"<g \".concat(transform, \">\") + \"<line x1=\\\"\".concat(p1.split(',')[0], \"\\\" y1=\\\"\").concat(p1.split(',')[1], \"\\\" x2=\\\"\").concat(p2.split(',')[0], \"\\\" y2=\\\"\").concat(p2.split(',')[1], \"\\\" />\") + \"<line x1=\\\"\".concat(p3.split(',')[0], \"\\\" y1=\\\"\").concat(p3.split(',')[1], \"\\\" x2=\\\"\").concat(p4.split(',')[0], \"\\\" y2=\\\"\").concat(p4.split(',')[1], \"\\\" />\") + \"</g>\";\n          }\n        default:\n          return '';\n        // Should not happen with current logic\n      }\n    }\n\n    /**\n     * Generates diagonal lines (X) within a cell's bounds using a potentially thinner stroke.\n     * @param {number} cx - Center X.\n     * @param {number} cy - Center Y.\n     * @param {number} size - Size of the cell element area.\n     * @returns {string} - SVG lines string for the diagonals.\n     */\n  }, {\n    key: \"_generateDiagonals\",\n    value: function _generateDiagonals(cx, cy, size) {\n      var halfSize = size / 2;\n      // Use a thinner stroke for diagonals relative to the main stroke width\n      var diagonalStrokeWidth = Math.max(0.5, this.strokeWidth / 1.5); // Ensure minimum width 0.5\n      // Override the group stroke-width for these lines\n      var strokeStyle = \"stroke=\\\"white\\\" stroke-width=\\\"\".concat(diagonalStrokeWidth.toFixed(2), \"\\\"\");\n      var format = function format(num) {\n        return num.toFixed(2);\n      };\n      var x1 = format(cx - halfSize); // Top-left X\n      var y1 = format(cy - halfSize); // Top-left Y\n      var x2 = format(cx + halfSize); // Bottom-right X\n      var y2 = format(cy + halfSize); // Bottom-right Y\n      // Line from top-left to bottom-right and top-right to bottom-left\n      return \"<line x1=\\\"\".concat(x1, \"\\\" y1=\\\"\").concat(y1, \"\\\" x2=\\\"\").concat(x2, \"\\\" y2=\\\"\").concat(y2, \"\\\" \").concat(strokeStyle, \" />\") + \"<line x1=\\\"\".concat(x1, \"\\\" y1=\\\"\").concat(y2, \"\\\" x2=\\\"\").concat(x2, \"\\\" y2=\\\"\").concat(y1, \"\\\" \").concat(strokeStyle, \" />\");\n    }\n\n    /**\n     * Generates lines connecting the centers of adjacent cells in the grid.\n     * @param {object[][]} cellData - 2D array holding data {cx, cy} for each cell.\n     * @param {number} gridSize - The size of the grid (number of rows/columns).\n     * @returns {string} - SVG lines string for the connections.\n     */\n  }, {\n    key: \"_generateConnections\",\n    value: function _generateConnections(cellData, gridSize) {\n      var lines = [];\n      // Connection lines use the main stroke width inherited from the parent <g>\n      var format = function format(num) {\n        return num.toFixed(2);\n      };\n      for (var r = 0; r < gridSize; r++) {\n        for (var c = 0; c < gridSize; c++) {\n          var current = cellData[r][c];\n          // Connect horizontally to the right neighbor if it exists\n          if (c < gridSize - 1) {\n            var right = cellData[r][c + 1];\n            lines.push(\"<line x1=\\\"\".concat(format(current.cx), \"\\\" y1=\\\"\").concat(format(current.cy), \"\\\" x2=\\\"\").concat(format(right.cx), \"\\\" y2=\\\"\").concat(format(right.cy), \"\\\" />\"));\n          }\n          // Connect vertically to the bottom neighbor if it exists\n          if (r < gridSize - 1) {\n            var bottom = cellData[r + 1][c];\n            lines.push(\"<line x1=\\\"\".concat(format(current.cx), \"\\\" y1=\\\"\").concat(format(current.cy), \"\\\" x2=\\\"\").concat(format(bottom.cx), \"\\\" y2=\\\"\").concat(format(bottom.cy), \"\\\" />\"));\n          }\n        }\n      }\n      return lines.join('\\n');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(GenerativeGrid, \"parameters\", {\n  gridSize: {\n    type: 'number',\n    min: 2,\n    max: 8,\n    // Grid dimensions (e.g., 3x3, 4x4)\n    step: 1,\n    \"default\": 3\n  },\n  strokeWidth: {\n    type: 'number',\n    min: 0.5,\n    max: 10,\n    // Thickness of the lines/outlines\n    step: 0.1,\n    \"default\": 2\n  },\n  cellPadding: {\n    type: 'number',\n    min: 0,\n    max: 25,\n    // Space between shapes and cell boundaries\n    step: 1,\n    \"default\": 5\n  },\n  shapeDiversity: {\n    // Controls how many different shapes appear\n    type: 'number',\n    min: 1,\n    // At least one shape type\n    max: 5,\n    // Max available shape types (square, circle, triangle, diamond, cross)\n    step: 1,\n    \"default\": 3 // Use 3 different types randomly chosen by default\n  },\n  rotationType: {\n    type: 'enum',\n    options: ['none', 'aligned', 'random'],\n    // How shapes are rotated\n    // none: 0 deg\n    // aligned: 0 deg for most, 45 deg for diamond\n    // random: Multiples of 45 degrees randomly\n    \"default\": 'random'\n  },\n  connectionLines: {\n    type: 'boolean',\n    \"default\": true // Draw lines connecting centers of adjacent cells\n  },\n  diagonalLines: {\n    type: 'boolean',\n    \"default\": true // Draw diagonal 'X' lines within each cell's bounds\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GenerativeGrid);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/GenerativeGrid.js?");

/***/ }),

/***/ "./src/shapes/GeometricEmblem.js":
/*!***************************************!*\
  !*** ./src/shapes/GeometricEmblem.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a segmented polygon emblem, where each segment connects the outer\n * and inner vertices of a regular polygon.\n */\nvar GeometricEmblem = /*#__PURE__*/function (_Shape) {\n  function GeometricEmblem() {\n    _classCallCheck(this, GeometricEmblem);\n    return _callSuper(this, GeometricEmblem, arguments);\n  }\n  _inherits(GeometricEmblem, _Shape);\n  return _createClass(GeometricEmblem, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var points = [];\n      var scale = 0.8;\n      var outerRadius = 100 * scale;\n      var innerRadius = this.innerRadius * 100 * scale;\n      var rotationRad = 0.0;\n      this.points = Math.round(this.points);\n      for (var i = 0; i < this.points; i++) {\n        var angle1 = i * 2 * Math.PI / this.points + rotationRad;\n        var angle2 = (i + 1) * 2 * Math.PI / this.points + rotationRad;\n        var outer1 = {\n          x: outerRadius * Math.cos(angle1),\n          y: outerRadius * Math.sin(angle1)\n        };\n        var outer2 = {\n          x: outerRadius * Math.cos(angle2),\n          y: outerRadius * Math.sin(angle2)\n        };\n        var inner1 = {\n          x: innerRadius * Math.cos(angle1),\n          y: innerRadius * Math.sin(angle1)\n        };\n        var inner2 = {\n          x: innerRadius * Math.cos(angle2),\n          y: innerRadius * Math.sin(angle2)\n        };\n\n        // Create a complete segment path\n        points.push(\"\\n                <path d=\\\"\\n                    M \".concat(outer1.x, \",\").concat(outer1.y, \"\\n                    L \").concat(outer2.x, \",\").concat(outer2.y, \"\\n                    L \").concat(inner2.x, \",\").concat(inner2.y, \"\\n                    L \").concat(inner1.x, \",\").concat(inner1.y, \"\\n                    Z\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                    stroke-linejoin=\\\"round\\\"\\n                    fill=\\\"none\\\"\\n                />\\n            \"));\n      }\n      return points.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(GeometricEmblem, \"parameters\", {\n  points: {\n    min: 3,\n    max: 12,\n    \"default\": 6\n  },\n  innerRadius: {\n    min: 0.1,\n    max: 0.9,\n    \"default\": 0.4\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GeometricEmblem);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/GeometricEmblem.js?");

/***/ }),

/***/ "./src/shapes/GeometricPetalFlower.js":
/*!********************************************!*\
  !*** ./src/shapes/GeometricPetalFlower.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a flower shape with geometrically defined petals radiating from a\n * central point, controlled by width and pointiness.\n */\nvar GeometricPetalFlower = /*#__PURE__*/function (_Shape) {\n  function GeometricPetalFlower() {\n    _classCallCheck(this, GeometricPetalFlower);\n    return _callSuper(this, GeometricPetalFlower, arguments);\n  }\n  _inherits(GeometricPetalFlower, _Shape);\n  return _createClass(GeometricPetalFlower, [{\n    key: \"generatePetal\",\n    value: function generatePetal(centerAngle, halfAngleStep) {\n      // Calculate angles for start and end of petal\n      var startAngle = centerAngle - halfAngleStep;\n      var endAngle = centerAngle + halfAngleStep;\n\n      // Calculate points for the petal\n      var startPoint = {\n        x: this.innerRadius * Math.cos(startAngle),\n        y: this.innerRadius * Math.sin(startAngle)\n      };\n      var endPoint = {\n        x: this.innerRadius * Math.cos(endAngle),\n        y: this.innerRadius * Math.sin(endAngle)\n      };\n      var petalTip = {\n        x: this.petalLength * Math.cos(centerAngle),\n        y: this.petalLength * Math.sin(centerAngle)\n      };\n\n      // Calculate control points for the curves (symmetrically)\n      var controlPoint1 = {\n        x: startPoint.x + this.petalWidth * 0.7 * Math.cos(centerAngle + Math.PI / 2) + this.petalLength * this.petalPointiness * Math.cos(centerAngle),\n        y: startPoint.y + this.petalWidth * 0.7 * Math.sin(centerAngle + Math.PI / 2) + this.petalLength * this.petalPointiness * Math.sin(centerAngle)\n      };\n      var controlPoint2 = {\n        x: endPoint.x + this.petalWidth * 0.7 * Math.cos(centerAngle - Math.PI / 2) + this.petalLength * this.petalPointiness * Math.cos(centerAngle),\n        y: endPoint.y + this.petalWidth * 0.7 * Math.sin(centerAngle - Math.PI / 2) + this.petalLength * this.petalPointiness * Math.sin(centerAngle)\n      };\n\n      // Create the petal path\n      return {\n        startPoint: startPoint,\n        endPoint: endPoint,\n        path: \"C \".concat(controlPoint1.x, \",\").concat(controlPoint1.y, \" \\n                   \").concat(petalTip.x * (1 - this.petalPointiness * 0.3), \",\").concat(petalTip.y * (1 - this.petalPointiness * 0.3), \" \\n                   \").concat(petalTip.x, \",\").concat(petalTip.y, \"\\n                   C \").concat(petalTip.x * (1 - this.petalPointiness * 0.3), \",\").concat(petalTip.y * (1 - this.petalPointiness * 0.3), \"\\n                   \").concat(controlPoint2.x, \",\").concat(controlPoint2.y, \" \\n                   \").concat(endPoint.x, \",\").concat(endPoint.y)\n      };\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Round to ensure integer number of petals\n      this.petalCount = Math.round(this.petalCount);\n\n      // Calculate angle step between petals\n      var angleStep = 2 * Math.PI / this.petalCount;\n      var halfAngleStep = angleStep / 2;\n      var pathData = '';\n\n      // Start at the first petal's starting point\n      var startAngle = 0 - halfAngleStep;\n      var firstPoint = {\n        x: this.innerRadius * Math.cos(startAngle),\n        y: this.innerRadius * Math.sin(startAngle)\n      };\n      pathData = \"M \".concat(firstPoint.x, \",\").concat(firstPoint.y);\n\n      // For each petal\n      for (var i = 0; i < this.petalCount; i++) {\n        var centerAngle = i * angleStep;\n        var petal = this.generatePetal(centerAngle, halfAngleStep);\n        pathData += ' ' + petal.path;\n      }\n\n      // Close the path\n      pathData += ' Z';\n      return \"\\n            <path \\n                d=\\\"\".concat(pathData, \"\\\"\\n                fill=\\\"white\\\"\\n            />\\n        \");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(GeometricPetalFlower, \"parameters\", {\n  petalCount: {\n    min: 4,\n    max: 24,\n    \"default\": 12\n  },\n  petalLength: {\n    min: 50,\n    max: 100,\n    \"default\": 100\n  },\n  petalWidth: {\n    min: 10,\n    max: 100,\n    \"default\": 35\n  },\n  petalPointiness: {\n    min: 0.2,\n    max: 1.0,\n    \"default\": 0.5\n  },\n  innerRadius: {\n    min: 0,\n    max: 50,\n    \"default\": 15\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GeometricPetalFlower);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/GeometricPetalFlower.js?");

/***/ }),

/***/ "./src/shapes/GlitchPattern.js":
/*!*************************************!*\
  !*** ./src/shapes/GlitchPattern.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a grid-based pattern resembling digital glitches or tech readouts,\n * with control over fill, complexity, and symmetry.\n */\nvar GlitchPattern = /*#__PURE__*/function (_Shape) {\n  function GlitchPattern() {\n    _classCallCheck(this, GlitchPattern);\n    return _callSuper(this, GlitchPattern, arguments);\n  }\n  _inherits(GlitchPattern, _Shape);\n  return _createClass(GlitchPattern, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      // Reset RNG for consistent results\n      this.resetRNG();\n      var size = 180;\n      var cellSize = (size - (this.gridSize - 1) * this.gapSize) / this.gridSize;\n      var startPos = -size / 2;\n\n      // Prepare cell occupancy grid\n      var grid = Array(this.gridSize).fill().map(function () {\n        return Array(_this.gridSize).fill(false);\n      });\n\n      // Generate pattern based on complexity\n      this.generateTechPattern(grid);\n\n      // Create shapes from the pattern\n      var elements = [];\n      for (var y = 0; y < this.gridSize; y++) {\n        for (var x = 0; x < this.gridSize; x++) {\n          if (grid[y][x]) {\n            // Calculate position\n            var xPos = startPos + x * (cellSize + this.gapSize);\n            var yPos = startPos + y * (cellSize + this.gapSize);\n\n            // Check for merged cells (horizontal)\n            var width = cellSize;\n            var height = cellSize;\n\n            // Try to extend horizontally and vertically based on emphasis\n            if (this.emphasis !== 'vertical') {\n              width = this.extendHorizontally(grid, x, y) * (cellSize + this.gapSize) - this.gapSize;\n            }\n            if (this.emphasis !== 'horizontal') {\n              height = this.extendVertically(grid, x, y) * (cellSize + this.gapSize) - this.gapSize;\n            }\n\n            // Add rect element\n            elements.push(\"<rect \\n                        x=\\\"\".concat(xPos, \"\\\" \\n                        y=\\\"\").concat(yPos, \"\\\" \\n                        width=\\\"\").concat(width, \"\\\" \\n                        height=\\\"\").concat(height, \"\\\"\\n                        rx=\\\"\").concat(this.cornerRadius, \"\\\"\\n                        ry=\\\"\").concat(this.cornerRadius, \"\\\"\\n                        fill=\\\"white\\\"\\n                    />\"));\n\n            // Mark extended cells as processed\n            var extendX = width / (cellSize + this.gapSize) + 0.1;\n            var extendY = height / (cellSize + this.gapSize) + 0.1;\n            for (var j = 0; j < extendY; j++) {\n              for (var i = 0; i < extendX; i++) {\n                if (x + i < this.gridSize && y + j < this.gridSize) {\n                  grid[y + j][x + i] = false;\n                }\n              }\n            }\n\n            // Re-mark current cell to continue iteration\n            grid[y][x] = true;\n          }\n        }\n      }\n      return elements.join('');\n    }\n  }, {\n    key: \"generateTechPattern\",\n    value: function generateTechPattern(grid) {\n      // Apply base fill percentage\n      for (var y = 0; y < this.gridSize; y++) {\n        for (var x = 0; x < this.gridSize; x++) {\n          // Apply symmetry if enabled\n          if (this.symmetry > 0 && this.random() * 100 < this.symmetry) {\n            // Determine symmetry type (quadrant, axial, etc.)\n            var centerX = this.gridSize / 2;\n            var centerY = this.gridSize / 2;\n            var reflectX = Math.floor(centerX * 2) - x;\n            var reflectY = Math.floor(centerY * 2) - y;\n            if (reflectX >= 0 && reflectX < this.gridSize && reflectY >= 0 && reflectY < this.gridSize) {\n              // Apply mirrored value\n              grid[y][x] = grid[reflectY][reflectX];\n              continue;\n            }\n          }\n\n          // Generate weighted pattern based on uniformity\n          var fillChance = this.fillPercentage;\n\n          // Apply non-uniformity adjustments\n          if (this.uniformity < 100) {\n            var noiseAmount = (100 - this.uniformity) / 100;\n            var patternFactor = this.getPatternFactor(x, y);\n            fillChance = this.fillPercentage * (1 - noiseAmount) + patternFactor * noiseAmount * 100;\n          }\n          grid[y][x] = this.random() * 100 < fillChance;\n        }\n      }\n\n      // Add complexity elements based on complexity parameter\n      this.addComplexityFeatures(grid);\n    }\n  }, {\n    key: \"getPatternFactor\",\n    value: function getPatternFactor(x, y) {\n      // Different pattern factors to create tech-like arrangements\n      var centerX = this.gridSize / 2;\n      var centerY = this.gridSize / 2;\n\n      // Distance from center\n      var dx = (x - centerX) / this.gridSize;\n      var dy = (y - centerY) / this.gridSize;\n      var dist = Math.sqrt(dx * dx + dy * dy) * 2;\n\n      // Angular component\n      var angle = Math.atan2(dy, dx) / Math.PI;\n\n      // Tech pattern factors\n      var linearGradient = 1 - y / this.gridSize;\n      var radialGradient = 1 - dist;\n      var angularPattern = (Math.sin(angle * 4) + 1) / 2;\n      var gridPattern = x % 2 * 0.5 + y % 3 * 0.3;\n\n      // Combine factors based on seed for variety\n      var seed = this.seed % 4;\n      switch (seed) {\n        case 0:\n          return linearGradient * 0.6 + angularPattern * 0.4;\n        case 1:\n          return radialGradient * 0.7 + gridPattern * 0.3;\n        case 2:\n          return angularPattern * 0.5 + gridPattern * 0.5;\n        case 3:\n          return linearGradient * 0.4 + radialGradient * 0.6;\n        default:\n          return linearGradient;\n      }\n    }\n  }, {\n    key: \"addComplexityFeatures\",\n    value: function addComplexityFeatures(grid) {\n      if (this.complexity <= 1) return;\n\n      // Add L-shapes and other tech patterns based on complexity\n      var featureCount = Math.max(1, Math.floor((this.complexity - 1) * this.gridSize / 2));\n      for (var i = 0; i < featureCount; i++) {\n        var featureType = Math.floor(this.random() * 4);\n        var x = Math.floor(this.random() * (this.gridSize - 2));\n        var y = Math.floor(this.random() * (this.gridSize - 2));\n        switch (featureType) {\n          case 0:\n            // L-shape\n            grid[y][x] = true;\n            grid[y + 1][x] = true;\n            grid[y + 1][x + 1] = true;\n            break;\n          case 1:\n            // T-shape\n            grid[y][x] = true;\n            grid[y][x + 1] = true;\n            grid[y + 1][x + 1] = true;\n            break;\n          case 2:\n            // Plus-shape\n            if (x > 0 && y > 0 && x < this.gridSize - 1 && y < this.gridSize - 1) {\n              grid[y][x] = true;\n              grid[y - 1][x] = true;\n              grid[y + 1][x] = true;\n              grid[y][x - 1] = true;\n              grid[y][x + 1] = true;\n            }\n            break;\n          case 3:\n            // Block\n            grid[y][x] = true;\n            grid[y][x + 1] = true;\n            grid[y + 1][x] = true;\n            grid[y + 1][x + 1] = true;\n            break;\n        }\n      }\n    }\n  }, {\n    key: \"extendHorizontally\",\n    value: function extendHorizontally(grid, startX, startY) {\n      var width = 1;\n      var x = startX + 1;\n      while (x < this.gridSize && grid[startY][x]) {\n        width++;\n        x++;\n      }\n      return width;\n    }\n  }, {\n    key: \"extendVertically\",\n    value: function extendVertically(grid, startX, startY) {\n      var height = 1;\n      var y = startY + 1;\n      while (y < this.gridSize && grid[y][startX]) {\n        height++;\n        y++;\n      }\n      return height;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(GlitchPattern, \"parameters\", {\n  gridSize: {\n    min: 4,\n    max: 12,\n    \"default\": 8\n  },\n  fillPercentage: {\n    min: 20,\n    max: 80,\n    \"default\": 60\n  },\n  cornerRadius: {\n    min: 0,\n    max: 8,\n    \"default\": 2\n  },\n  gapSize: {\n    min: 2,\n    max: 10,\n    \"default\": 4\n  },\n  uniformity: {\n    min: 0,\n    max: 100,\n    \"default\": 30\n  },\n  complexity: {\n    min: 1,\n    max: 5,\n    \"default\": 3\n  },\n  emphasis: {\n    options: ['horizontal', 'vertical', 'balanced'],\n    \"default\": 'balanced'\n  },\n  symmetry: {\n    min: 0,\n    max: 100,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GlitchPattern);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/GlitchPattern.js?");

/***/ }),

/***/ "./src/shapes/Globe.js":
/*!*****************************!*\
  !*** ./src/shapes/Globe.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a wireframe globe with optional meridian (vertical) and parallel\n * (horizontal) lines represented by ellipses.\n */\nvar GlobeShape = /*#__PURE__*/function (_Shape) {\n  function GlobeShape() {\n    _classCallCheck(this, GlobeShape);\n    return _callSuper(this, GlobeShape, arguments);\n  }\n  _inherits(GlobeShape, _Shape);\n  return _createClass(GlobeShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var elements = [];\n\n      // Generate meridians (vertical ellipses)\n      if (this.meridians > 0) {\n        var meridianStep = Math.PI / (this.meridians + 1);\n        for (var i = 1; i <= this.meridians; i++) {\n          var angle = meridianStep * i;\n          // Use absolute value of cosine to prevent negative radius\n          var compression = Math.abs(Math.cos(angle));\n          elements.push(\"<ellipse\\n                    cx=\\\"0\\\"\\n                    cy=\\\"0\\\"\\n                    rx=\\\"\".concat(this.radius, \"\\\"\\n                    ry=\\\"\").concat(this.radius * compression, \"\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                    fill=\\\"none\\\"\\n                />\"));\n        }\n      }\n\n      // Generate parallels (horizontal ellipses)\n      if (this.parallels > 0) {\n        var parallelStep = Math.PI / (this.parallels + 1);\n        for (var _i = 1; _i <= this.parallels; _i++) {\n          var _angle = parallelStep * _i;\n          // Use absolute value of cosine to prevent negative radius\n          var _compression = Math.abs(Math.cos(_angle));\n          elements.push(\"<ellipse\\n                    cx=\\\"0\\\"\\n                    cy=\\\"0\\\"\\n                    rx=\\\"\".concat(this.radius * _compression, \"\\\"\\n                    ry=\\\"\").concat(this.radius, \"\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                    fill=\\\"none\\\"\\n                />\"));\n        }\n      }\n\n      // Add outer circle last so it's on top\n      elements.push(\"<circle \\n            cx=\\\"0\\\" \\n            cy=\\\"0\\\" \\n            r=\\\"\".concat(this.radius, \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            fill=\\\"none\\\"\\n        />\"));\n      return elements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(GlobeShape, \"parameters\", {\n  radius: {\n    min: 50,\n    max: 100,\n    \"default\": 100\n  },\n  meridians: {\n    min: 0,\n    max: 24,\n    \"default\": 0\n  },\n  // Vertical lines\n  parallels: {\n    min: 0,\n    max: 24,\n    \"default\": 7\n  },\n  // Horizontal lines\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 3\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GlobeShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/Globe.js?");

/***/ }),

/***/ "./src/shapes/Goblet.js":
/*!******************************!*\
  !*** ./src/shapes/Goblet.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a symmetrical goblet or vase profile with modulated width and\n * different style options (smooth, organic, minimal).\n */\nvar GobletShape = /*#__PURE__*/function (_Shape) {\n  function GobletShape() {\n    _classCallCheck(this, GobletShape);\n    return _callSuper(this, GobletShape, arguments);\n  }\n  _inherits(GobletShape, _Shape);\n  return _createClass(GobletShape, [{\n    key: \"generateProfilePoints\",\n    value: function generateProfilePoints() {\n      var points = [];\n      var steps = this.resolution;\n      var size = 80;\n      var normalizedStemHeight = this.stemHeight / this.height;\n      var totalHeight = size * 2;\n      for (var i = 0; i <= steps; i++) {\n        var t = i / steps;\n        var x = void 0,\n          y = void 0;\n\n        // Y coordinate with slight curve adjustment for minimal style\n        y = size - t * totalHeight;\n\n        // X coordinate calculation with style variations\n        if (t < normalizedStemHeight) {\n          // Stem section with style-specific modulation\n          var stemT = t / normalizedStemHeight;\n          var stemShape = void 0;\n          switch (this.style) {\n            case 'minimal':\n              // Straight lines with subtle curves\n              stemShape = Math.sin(stemT * Math.PI * 0.5) * this.modulation * 0.05;\n              break;\n            case 'organic':\n              // More natural, flowing curves\n              stemShape = Math.sin(stemT * Math.PI) * this.modulation * Math.sin(stemT * 3 * Math.PI) * 0.15;\n              break;\n            default:\n              // smooth\n              // Classic smooth curves\n              stemShape = Math.sin(stemT * Math.PI) * this.modulation * 0.1;\n          }\n          x = this.baseWidth / 100 * size + stemShape * size;\n        } else {\n          // Bowl section with enhanced style variations\n          var bowlT = (t - normalizedStemHeight) / (1 - normalizedStemHeight);\n          var width = this.baseWidth / 100 + (this.width / 100 - this.baseWidth / 100) * this.getBowlProfile(bowlT);\n\n          // Style-specific modulation\n          switch (this.style) {\n            case 'minimal':\n              // Subtle, clean modulation\n              for (var j = 1; j <= this.complexity; j++) {\n                width += Math.sin(bowlT * j * Math.PI) * this.modulation * 0.05 * (1 - bowlT);\n              }\n              break;\n            case 'organic':\n              // More dramatic, natural variations\n              for (var _j = 1; _j <= this.complexity; _j++) {\n                width += Math.sin(bowlT * _j * Math.PI) * Math.cos(bowlT * _j * 0.5 * Math.PI) * this.modulation * 0.15;\n              }\n              break;\n            default:\n              // smooth\n              // Classic smooth variations\n              for (var _j2 = 1; _j2 <= this.complexity; _j2++) {\n                width += Math.sin(bowlT * _j2 * Math.PI) * this.modulation * 0.1;\n              }\n          }\n          x = width * size;\n        }\n        points.push([x, y]);\n      }\n      return points;\n    }\n  }, {\n    key: \"getBowlProfile\",\n    value: function getBowlProfile(t) {\n      // Style-specific bowl profiles\n      switch (this.style) {\n        case 'minimal':\n          // More linear profile with subtle curve\n          return t * (1.2 - t * 0.2);\n        case 'organic':\n          // More dramatic curve\n          return 0.6 * (1 - Math.cos(t * Math.PI));\n        default:\n          // smooth\n          // Classic smooth curve\n          return 0.5 * (1 - Math.cos(t * Math.PI));\n      }\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var points = this.generateProfilePoints();\n\n      // Generate right side\n      var rightSide = points.map(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n          x = _ref2[0],\n          y = _ref2[1];\n        return \"\".concat(x, \",\").concat(y);\n      }).join(' L');\n\n      // Mirror for left side\n      var leftSide = points.map(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n          x = _ref4[0],\n          y = _ref4[1];\n        return \"\".concat(-x, \",\").concat(y);\n      }).reverse().join(' L');\n\n      // Combine into complete path\n      var pathData = \"M\".concat(leftSide, \" L\").concat(rightSide, \"Z\");\n      return \"<g transform=\\\"translate(0,0)\\\">\\n            <path \\n                d=\\\"\".concat(pathData, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"1.5\\\"\\n                fill=\\\"white\\\"\\n            />\\n        </g>\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(GobletShape, \"parameters\", {\n  height: {\n    min: 50,\n    max: 200,\n    \"default\": 140\n  },\n  width: {\n    min: 20,\n    max: 120,\n    \"default\": 80\n  },\n  // Increased max width\n  baseWidth: {\n    min: 10,\n    max: 80,\n    \"default\": 30\n  },\n  // More dramatic base options\n  stemHeight: {\n    min: 10,\n    max: 140,\n    \"default\": 50\n  },\n  // Increased range\n  modulation: {\n    min: 0,\n    max: 1.5,\n    \"default\": 0.5\n  },\n  // Increased max modulation\n  complexity: {\n    min: 1,\n    max: 8,\n    \"default\": 3\n  },\n  // More complexity options\n  resolution: {\n    min: 10,\n    max: 100,\n    \"default\": 50\n  },\n  style: {\n    options: ['smooth', 'organic', 'minimal'],\n    \"default\": 'minimal'\n  } // Added minimal style\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GobletShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/Goblet.js?");

/***/ }),

/***/ "./src/shapes/Grid2Blocks.js":
/*!***********************************!*\
  !*** ./src/shapes/Grid2Blocks.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a 2x2 grid of blocks, each featuring randomized triangular cuts\n * along its sides.\n */\nvar Grid2Blocks = /*#__PURE__*/function (_Shape) {\n  function Grid2Blocks() {\n    _classCallCheck(this, Grid2Blocks);\n    return _callSuper(this, Grid2Blocks, arguments);\n  }\n  _inherits(Grid2Blocks, _Shape);\n  return _createClass(Grid2Blocks, [{\n    key: \"_getRandomOffset\",\n    value:\n    // Helper to generate a random offset, scaled by the variation parameter\n    function _getRandomOffset(range) {\n      // Returns a value between -range * variation and +range * variation\n      // Uses the seeded RNG from the base Shape class via this.random()\n      return (this.random() - 0.5) * 2 * this.variation * range;\n    }\n\n    // Helper function to clamp a value between a minimum and maximum\n  }, {\n    key: \"_clamp\",\n    value: function _clamp(value, min, max) {\n      return Math.max(min, Math.min(value, max));\n    }\n\n    /**\n     * Generates the SVG path data string for a single block with randomized cuts.\n     * The path traces the outline of the block, including the indentations for cuts.\n     * @param {number} cx - Center x-coordinate of the block.\n     * @param {number} cy - Center y-coordinate of the block.\n     * @returns {string} SVG <path> element string for the block.\n     */\n  }, {\n    key: \"generateBlockShape\",\n    value: function generateBlockShape(cx, cy) {\n      var _this = this;\n      var halfSize = this.gridSize / 2;\n      var maxCutDepth = halfSize * this.cutDepthRatio; // Absolute max depth for cuts\n      var sideLength = this.gridSize;\n\n      // Calculate the coordinates of the four corners of the block\n      var tl = {\n        x: cx - halfSize,\n        y: cy - halfSize\n      }; // Top-left\n      var tr = {\n        x: cx + halfSize,\n        y: cy - halfSize\n      }; // Top-right\n      var br = {\n        x: cx + halfSize,\n        y: cy + halfSize\n      }; // Bottom-right\n      var bl = {\n        x: cx - halfSize,\n        y: cy + halfSize\n      }; // Bottom-left\n\n      // Start the SVG path data at the top-left corner\n      var pathData = \"M \".concat(tl.x.toFixed(2), \",\").concat(tl.y.toFixed(2));\n      var currentPos = _objectSpread({}, tl); // Keep track of the current point on the path\n\n      // Calculate the nominal length of edge segment allocated to each cut (including spacing)\n      var segmentLength = sideLength / (this.numCuts + 1);\n      // Define variation range factors for cut dimensions to add randomness\n      var minVarFactor = 1 - this.variation * 0.8; // Avoid overly shrinking cuts\n      var maxVarFactor = 1 + this.variation * 0.8; // Allow cuts to grow slightly\n\n      // Helper function to generate randomized cut dimensions for width and depth\n      var getRandomCutDimensions = function getRandomCutDimensions() {\n        // Introduce randomness to baseWidth and depth using variation factors\n        var variationFactor = _this.random() * (maxVarFactor - minVarFactor) + minVarFactor;\n        var baseWidth = _this._clamp(segmentLength * _this.cutWidthRatio * variationFactor, segmentLength * 0.1, segmentLength * 0.9);\n        var depth = _this._clamp(maxCutDepth * variationFactor, maxCutDepth * 0.1, maxCutDepth * 1.5); // Allow depth to vary more\n        return {\n          baseWidth: baseWidth,\n          depth: depth\n        };\n      };\n\n      // --- Top Edge (Moving Left to Right) ---\n      for (var i = 1; i <= this.numCuts; i++) {\n        var idealCutCenter = tl.x + i * segmentLength; // Ideal x-position for the cut center\n        var centerOffset = this._getRandomOffset(segmentLength / 3); // Random offset for position\n        var cutCenterX = idealCutCenter + centerOffset;\n        var _getRandomCutDimensio = getRandomCutDimensions(),\n          baseWidth = _getRandomCutDimensio.baseWidth,\n          depth = _getRandomCutDimensio.depth; // Get randomized width and depth\n\n        // Calculate the three points of the triangular cut (P1 -> Tip -> P2)\n        var p1_x = this._clamp(cutCenterX - baseWidth / 2, currentPos.x + 0.1, tr.x - 0.1); // Cut start X, ensure it's after currentPos\n        var p1_y = tl.y; // Y is on the top edge\n        var tip_x = cutCenterX; // Tip's X aligns with center\n        var tip_y = tl.y + depth; // Tip's Y goes downwards into the shape\n        var p2_x = this._clamp(cutCenterX + baseWidth / 2, p1_x, tr.x - 0.1); // Cut end X, ensure it's after P1\n        var p2_y = tl.y; // Y is on the top edge\n\n        // Add path segments if the cut points are valid and ordered correctly along the edge\n        if (p1_x > currentPos.x && p2_x > p1_x) {\n          pathData += \" L \".concat(p1_x.toFixed(2), \",\").concat(p1_y.toFixed(2)); // Line from current pos to cut start\n          pathData += \" L \".concat(tip_x.toFixed(2), \",\").concat(tip_y.toFixed(2)); // Line to cut tip\n          pathData += \" L \".concat(p2_x.toFixed(2), \",\").concat(p2_y.toFixed(2)); // Line from tip back to edge\n          currentPos = {\n            x: p2_x,\n            y: p2_y\n          }; // Update current position to the end of the cut\n        }\n      }\n      pathData += \" L \".concat(tr.x.toFixed(2), \",\").concat(tr.y.toFixed(2)); // Line to top-right corner\n      currentPos = _objectSpread({}, tr); // Update current position\n\n      // --- Right Edge (Moving Top to Bottom) ---\n      for (var _i = 1; _i <= this.numCuts; _i++) {\n        var _idealCutCenter = tr.y + _i * segmentLength; // Ideal y-position for the cut center\n        var _centerOffset = this._getRandomOffset(segmentLength / 3);\n        var cutCenterY = _idealCutCenter + _centerOffset;\n        var _getRandomCutDimensio2 = getRandomCutDimensions(),\n          _baseWidth = _getRandomCutDimensio2.baseWidth,\n          _depth = _getRandomCutDimensio2.depth;\n\n        // Calculate cut points (P1 -> Tip -> P2)\n        var _p1_x = tr.x; // X is on the right edge\n        var _p1_y = this._clamp(cutCenterY - _baseWidth / 2, currentPos.y + 0.1, br.y - 0.1); // Cut start Y, ensure after currentPos\n        var _tip_x = tr.x - _depth; // Tip's X goes inwards (left)\n        var _tip_y = cutCenterY; // Tip's Y aligns with center\n        var _p2_x = tr.x; // X is on the right edge\n        var _p2_y = this._clamp(cutCenterY + _baseWidth / 2, _p1_y, br.y - 0.1); // Cut end Y, ensure after P1\n\n        // Add path segments if valid and ordered\n        if (_p1_y > currentPos.y && _p2_y > _p1_y) {\n          pathData += \" L \".concat(_p1_x.toFixed(2), \",\").concat(_p1_y.toFixed(2));\n          pathData += \" L \".concat(_tip_x.toFixed(2), \",\").concat(_tip_y.toFixed(2));\n          pathData += \" L \".concat(_p2_x.toFixed(2), \",\").concat(_p2_y.toFixed(2));\n          currentPos = {\n            x: _p2_x,\n            y: _p2_y\n          };\n        }\n      }\n      pathData += \" L \".concat(br.x.toFixed(2), \",\").concat(br.y.toFixed(2)); // Line to bottom-right corner\n      currentPos = _objectSpread({}, br);\n\n      // --- Bottom Edge (Moving Right to Left) ---\n      for (var _i2 = 1; _i2 <= this.numCuts; _i2++) {\n        var _idealCutCenter2 = br.x - _i2 * segmentLength; // Ideal x-position (moving right-to-left)\n        var _centerOffset2 = this._getRandomOffset(segmentLength / 3);\n        var _cutCenterX = _idealCutCenter2 + _centerOffset2;\n        var _getRandomCutDimensio3 = getRandomCutDimensions(),\n          _baseWidth2 = _getRandomCutDimensio3.baseWidth,\n          _depth2 = _getRandomCutDimensio3.depth;\n\n        // Calculate cut points (P1 -> Tip -> P2), note P1/P2 x-coords are reversed compared to top edge\n        var _p1_x2 = this._clamp(_cutCenterX + _baseWidth2 / 2, bl.x + 0.1, currentPos.x - 0.1); // Cut start X (rightmost point), ensure before currentPos\n        var _p1_y2 = br.y; // Y is on the bottom edge\n        var _tip_x2 = _cutCenterX; // Tip's X aligns with center\n        var _tip_y2 = br.y - _depth2; // Tip's Y goes upwards into the shape\n        var _p2_x2 = this._clamp(_cutCenterX - _baseWidth2 / 2, bl.x + 0.1, _p1_x2); // Cut end X (leftmost point), ensure before P1\n        var _p2_y2 = br.y; // Y is on the bottom edge\n\n        // Add path segments if valid and ordered (moving right-to-left)\n        if (_p1_x2 < currentPos.x && _p2_x2 < _p1_x2) {\n          pathData += \" L \".concat(_p1_x2.toFixed(2), \",\").concat(_p1_y2.toFixed(2));\n          pathData += \" L \".concat(_tip_x2.toFixed(2), \",\").concat(_tip_y2.toFixed(2));\n          pathData += \" L \".concat(_p2_x2.toFixed(2), \",\").concat(_p2_y2.toFixed(2));\n          currentPos = {\n            x: _p2_x2,\n            y: _p2_y2\n          };\n        }\n      }\n      pathData += \" L \".concat(bl.x.toFixed(2), \",\").concat(bl.y.toFixed(2)); // Line to bottom-left corner\n      currentPos = _objectSpread({}, bl);\n\n      // --- Left Edge (Moving Bottom to Top) ---\n      for (var _i3 = 1; _i3 <= this.numCuts; _i3++) {\n        var _idealCutCenter3 = bl.y - _i3 * segmentLength; // Ideal y-position (moving bottom-to-top)\n        var _centerOffset3 = this._getRandomOffset(segmentLength / 3);\n        var _cutCenterY = _idealCutCenter3 + _centerOffset3;\n        var _getRandomCutDimensio4 = getRandomCutDimensions(),\n          _baseWidth3 = _getRandomCutDimensio4.baseWidth,\n          _depth3 = _getRandomCutDimensio4.depth;\n\n        // Calculate cut points (P1 -> Tip -> P2), note P1/P2 y-coords are reversed compared to right edge\n        var _p1_x3 = bl.x; // X is on the left edge\n        var _p1_y3 = this._clamp(_cutCenterY + _baseWidth3 / 2, tl.y + 0.1, currentPos.y - 0.1); // Cut start Y (lower point), ensure before currentPos\n        var _tip_x3 = bl.x + _depth3; // Tip's X goes inwards (right)\n        var _tip_y3 = _cutCenterY; // Tip's Y aligns with center\n        var _p2_x3 = bl.x; // X is on the left edge\n        var _p2_y3 = this._clamp(_cutCenterY - _baseWidth3 / 2, tl.y + 0.1, _p1_y3); // Cut end Y (upper point), ensure before P1\n\n        // Add path segments if valid and ordered (moving bottom-to-top)\n        if (_p1_y3 < currentPos.y && _p2_y3 < _p1_y3) {\n          pathData += \" L \".concat(_p1_x3.toFixed(2), \",\").concat(_p1_y3.toFixed(2));\n          pathData += \" L \".concat(_tip_x3.toFixed(2), \",\").concat(_tip_y3.toFixed(2));\n          pathData += \" L \".concat(_p2_x3.toFixed(2), \",\").concat(_p2_y3.toFixed(2));\n          currentPos = {\n            x: _p2_x3,\n            y: _p2_y3\n          };\n        }\n      }\n      pathData += \" Z\"; // Close the path by drawing a line back to the starting point (tl)\n\n      // Return the complete path element string for this block, filled white, no stroke\n      return \"<path d=\\\"\".concat(pathData, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\");\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this2 = this;\n      var svgPaths = ''; // Initialize empty string to accumulate SVG paths\n      var halfGridSize = this.gridSize / 2;\n      var halfGap = this.gap / 2;\n\n      // Calculate the center coordinates for each of the four blocks in the 2x2 grid\n      // These are offset from the main (0,0) center based on block size and gap\n      var centers = [{\n        x: -halfGridSize - halfGap,\n        y: -halfGridSize - halfGap\n      },\n      // Top-left block center\n      {\n        x: halfGridSize + halfGap,\n        y: -halfGridSize - halfGap\n      },\n      // Top-right block center\n      {\n        x: -halfGridSize - halfGap,\n        y: halfGridSize + halfGap\n      },\n      // Bottom-left block center\n      {\n        x: halfGridSize + halfGap,\n        y: halfGridSize + halfGap\n      } // Bottom-right block center\n      ];\n\n      // Iterate through the calculated center points and generate a block shape for each\n      // The seeded RNG ensures that each block gets a unique (but deterministic for a given seed)\n      // sequence of random numbers, leading to visual variation between blocks when variation > 0.\n      centers.forEach(function (center) {\n        svgPaths += _this2.generateBlockShape(center.x, center.y);\n      });\n      return svgPaths; // Return the combined SVG strings of all four blocks\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(Grid2Blocks, \"parameters\", {\n  gridSize: {\n    type: 'number',\n    min: 30,\n    max: 95,\n    step: 1,\n    \"default\": 80,\n    label: 'Block Size' // Defines the width and height of each block\n  },\n  gap: {\n    type: 'number',\n    min: 0,\n    max: 40,\n    step: 1,\n    \"default\": 15,\n    label: 'Gap Size' // Defines the space between adjacent blocks\n  },\n  numCuts: {\n    type: 'number',\n    min: 1,\n    max: 5,\n    step: 1,\n    \"default\": 2,\n    label: 'Cuts per Side' // Number of triangular cuts on each side of a block\n  },\n  cutDepthRatio: {\n    type: 'number',\n    min: 0.1,\n    max: 0.9,\n    step: 0.05,\n    \"default\": 0.4,\n    label: 'Cut Depth' // Maximum depth of cuts relative to half the block size\n  },\n  cutWidthRatio: {\n    type: 'number',\n    min: 0.1,\n    max: 0.9,\n    step: 0.05,\n    \"default\": 0.5,\n    label: 'Cut Width' // Base width of cuts relative to the space allocated per cut\n  },\n  variation: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    step: 0.05,\n    \"default\": 0.35,\n    label: 'Variation Amount' // Controls randomness in cut position, depth, and width (0=none, 1=max)\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Grid2Blocks);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/Grid2Blocks.js?");

/***/ }),

/***/ "./src/shapes/GridAbstract.js":
/*!************************************!*\
  !*** ./src/shapes/GridAbstract.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates an abstract composition of thick lines connecting random points on\n * a grid within the viewbox.\n */\nvar GridAbstract = /*#__PURE__*/function (_Shape) {\n  function GridAbstract() {\n    _classCallCheck(this, GridAbstract);\n    return _callSuper(this, GridAbstract, arguments);\n  }\n  _inherits(GridAbstract, _Shape);\n  return _createClass(GridAbstract, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var width = 200; // ViewBox width\n      var height = 200; // ViewBox height\n      var minCoord = -100;\n      var maxCoord = 100;\n      var cellSize = width / this.gridSize;\n      var numPointsPerAxis = this.gridSize + 1;\n      var totalGridPoints = numPointsPerAxis * numPointsPerAxis;\n      var svgPolygons = '';\n\n      // Helper to get coordinates from grid indices (i, j)\n      var getCoords = function getCoords(i, j) {\n        return {\n          x: minCoord + i * cellSize,\n          y: minCoord + j * cellSize\n        };\n      };\n\n      // Helper to clamp coordinates\n      var clamp = function clamp(val) {\n        var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minCoord;\n        var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : maxCoord;\n        return Math.max(min, Math.min(max, val));\n      };\n\n      // Keep track of used point pairs to avoid identical lines\n      var usedPairs = new Set();\n      for (var k = 0; k < this.numLines; k++) {\n        var p1Index = void 0,\n          p2Index = void 0;\n        var attempts = 0;\n        var maxAttempts = 50; // Prevent infinite loop if grid is small\n\n        // Select two distinct random grid points\n        do {\n          p1Index = Math.floor(this.random() * totalGridPoints);\n          p2Index = Math.floor(this.random() * totalGridPoints);\n          // Ensure indices are different and the pair (order doesn't matter) hasn't been used\n          var pairKey = Math.min(p1Index, p2Index) + '-' + Math.max(p1Index, p2Index);\n          if (p1Index !== p2Index && !usedPairs.has(pairKey)) {\n            usedPairs.add(pairKey);\n            break;\n          }\n          attempts++;\n        } while (attempts < maxAttempts);\n        if (attempts >= maxAttempts) continue; // Skip if couldn't find a unique pair\n\n        // Convert indices to grid coordinates (i, j)\n        var p1_i = p1Index % numPointsPerAxis;\n        var p1_j = Math.floor(p1Index / numPointsPerAxis);\n        var p2_i = p2Index % numPointsPerAxis;\n        var p2_j = Math.floor(p2Index / numPointsPerAxis);\n\n        // Get Cartesian coordinates\n        var startPt = getCoords(p1_i, p1_j);\n        var endPt = getCoords(p2_i, p2_j);\n\n        // Calculate direction vector and its length\n        var dx = endPt.x - startPt.x;\n        var dy = endPt.y - startPt.y;\n        var len = Math.sqrt(dx * dx + dy * dy);\n        if (len < 1e-6) continue; // Skip if points are identical\n\n        // Normalize direction vector\n        dx /= len;\n        dy /= len;\n\n        // Calculate perpendicular vector (normalized)\n        var nx = -dy;\n        var ny = dx;\n\n        // Calculate half line width\n        var halfWidth = this.lineWidth / 2;\n\n        // Calculate the 4 polygon vertices, clamping each coordinate\n        var p1 = {\n          x: clamp(startPt.x + nx * halfWidth),\n          y: clamp(startPt.y + ny * halfWidth)\n        };\n        var p2 = {\n          x: clamp(endPt.x + nx * halfWidth),\n          y: clamp(endPt.y + ny * halfWidth)\n        };\n        var p3 = {\n          x: clamp(endPt.x - nx * halfWidth),\n          y: clamp(endPt.y - ny * halfWidth)\n        };\n        var p4 = {\n          x: clamp(startPt.x - nx * halfWidth),\n          y: clamp(startPt.y - ny * halfWidth)\n        };\n\n        // Create polygon string\n        var pointsStr = \"\".concat(p1.x, \",\").concat(p1.y, \" \").concat(p2.x, \",\").concat(p2.y, \" \").concat(p3.x, \",\").concat(p3.y, \" \").concat(p4.x, \",\").concat(p4.y);\n        svgPolygons += \"<polygon points=\\\"\".concat(pointsStr, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\\n\");\n      }\n      if (!svgPolygons) {\n        // Return a default placeholder if no polygons were generated (e.g., numLines = 0 or points too close)\n        // You could return an empty string or a small indicator\n        return \"<circle cx=\\\"0\\\" cy=\\\"0\\\" r=\\\"1\\\" fill=\\\"white\\\"/>\"; // Example placeholder\n      }\n      return svgPolygons;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(GridAbstract, \"parameters\", {\n  gridSize: {\n    type: 'number',\n    min: 2,\n    max: 12,\n    step: 1,\n    \"default\": 6,\n    label: 'Grid Size'\n  },\n  numLines: {\n    type: 'number',\n    min: 1,\n    max: 10,\n    step: 1,\n    \"default\": 3,\n    label: 'Number of Lines'\n  },\n  lineWidth: {\n    type: 'number',\n    min: 2,\n    max: 40,\n    step: 1,\n    \"default\": 20,\n    label: 'Line Width'\n  },\n  seed: {\n    // Keep seed parameter from base class\n    type: 'number',\n    min: 1,\n    max: 10000,\n    \"default\": 1 // Use a different default from base if desired\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GridAbstract);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/GridAbstract.js?");

/***/ }),

/***/ "./src/shapes/GridBlocks.js":
/*!**********************************!*\
  !*** ./src/shapes/GridBlocks.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a grid of rounded blocks arranged according to patterns like\n * checkerboard, random, frame, etc.\n */\nvar GridBlocks = /*#__PURE__*/function (_Shape) {\n  function GridBlocks() {\n    _classCallCheck(this, GridBlocks);\n    return _callSuper(this, GridBlocks, arguments);\n  }\n  _inherits(GridBlocks, _Shape);\n  return _createClass(GridBlocks, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var grid = this._createGrid();\n      var blocks = [];\n      // Calculate the size of each block, considering the gap\n      var effectiveCellSize = this.cellSize - this.gap;\n      // Total dimension of the grid layout (centers of blocks spread across this size)\n      var totalGridDimension = this.gridSize * this.cellSize;\n      // Offset to center the grid at (0,0)\n      var offset = -totalGridDimension / 2;\n      // Calculate the actual corner radius in pixels, ensuring it doesn't exceed half the block size\n      var blockCr = Math.max(0, Math.min(effectiveCellSize * this.cornerRadiusRatio, effectiveCellSize / 2));\n      // Ensure block size is not negative if gap is larger than cell size\n      var blockSize = Math.max(0, effectiveCellSize);\n\n      // Helper to format numbers for SVG path data (limits decimal places)\n      var format = function format(n) {\n        return n.toFixed(3);\n      };\n      for (var r = 0; r < this.gridSize; r++) {\n        for (var c = 0; c < this.gridSize; c++) {\n          // Check if the grid cell should be filled according to the pattern\n          if (grid[r][c]) {\n            // Calculate the top-left corner of the space allocated to this cell (including gap)\n            var cellX = offset + c * this.cellSize;\n            var cellY = offset + r * this.cellSize;\n            // Calculate the top-left corner of the actual block, centered within the cell space\n            var blockX = cellX + this.gap / 2;\n            var blockY = cellY + this.gap / 2;\n\n            // Add a rounded rectangle element if the block size is positive\n            if (blockSize > 0) {\n              blocks.push(\"<rect x=\\\"\".concat(format(blockX), \"\\\" y=\\\"\").concat(format(blockY), \"\\\" width=\\\"\").concat(format(blockSize), \"\\\" height=\\\"\").concat(format(blockSize), \"\\\" rx=\\\"\").concat(format(blockCr), \"\\\" ry=\\\"\").concat(format(blockCr), \"\\\" fill=\\\"white\\\" />\"));\n            }\n          }\n        }\n      }\n\n      // Return the blocks wrapped in a group element, or an empty string if no blocks were generated\n      return blocks.length > 0 ? \"<g>\\n\".concat(blocks.join('\\n'), \"\\n</g>\") : '';\n    }\n\n    /**\n     * Creates the boolean grid based on the selected pattern and grid size.\n     * Uses `this.random()` for random patterns, accessing the seeded RNG from the base Shape class.\n     * @returns {boolean[][]} A 2D array representing the grid fill status (true = filled, false = empty).\n     */\n  }, {\n    key: \"_createGrid\",\n    value: function _createGrid() {\n      var grid = [];\n      var size = this.gridSize;\n      // Calculate center indices, handles both odd and even sizes correctly for patterns like 'center' and 'cross'\n      var centerR1 = Math.floor((size - 1) / 2);\n      var centerC1 = Math.floor((size - 1) / 2);\n      // For even sized grids, there's a second \"center\" index adjacent to the first\n      var centerR2 = Math.ceil((size - 1) / 2);\n      var centerC2 = Math.ceil((size - 1) / 2);\n      for (var r = 0; r < size; r++) {\n        grid[r] = [];\n        for (var c = 0; c < size; c++) {\n          var fill = false;\n          switch (this.pattern) {\n            case 'checkerboard':\n              // Standard alternating pattern\n              fill = (r + c) % 2 === 0;\n              break;\n            case 'inverse_checkerboard':\n              // Inverted alternating pattern\n              fill = (r + c) % 2 !== 0;\n              break;\n            case 'random':\n              // Use the seeded random number generator from the base class\n              fill = this.random() < this.randomDensity;\n              break;\n            case 'center':\n              // Fill the single center cell for odd sizes, or the 2x2 center cells for even sizes\n              fill = r >= centerR1 && r <= centerR2 && c >= centerC1 && c <= centerC2;\n              break;\n            case 'cross':\n              // Fill the center row(s) and center column(s)\n              fill = r >= centerR1 && r <= centerR2 || c >= centerC1 && c <= centerC2;\n              break;\n            case 'frame':\n              // Fill only the cells on the outer border of the grid\n              fill = r === 0 || r === size - 1 || c === 0 || c === size - 1;\n              break;\n            case 'all':\n              // Fill all cells in the grid\n              fill = true;\n              break;\n          }\n          grid[r][c] = fill;\n        }\n      }\n      return grid;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(GridBlocks, \"parameters\", {\n  gridSize: {\n    type: 'number',\n    min: 2,\n    max: 12,\n    step: 1,\n    \"default\": 3\n  },\n  cellSize: {\n    type: 'number',\n    min: 10,\n    max: 80,\n    step: 1,\n    \"default\": 50\n  },\n  cornerRadiusRatio: {\n    type: 'number',\n    min: 0,\n    max: 0.5,\n    step: 0.05,\n    \"default\": 0.5\n  },\n  // Radius as ratio of cellSize, max 0.5 for full roundness\n  gap: {\n    type: 'number',\n    min: 0,\n    max: 20,\n    step: 1,\n    \"default\": 4\n  },\n  // Gap between cells\n  pattern: {\n    type: 'enum',\n    options: ['checkerboard', 'random', 'center', 'cross', 'inverse_checkerboard', 'frame', 'all'],\n    \"default\": 'checkerboard'\n  },\n  randomDensity: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    step: 0.1,\n    \"default\": 0.5\n  } // Used only when pattern is 'random'\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GridBlocks);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/GridBlocks.js?");

/***/ }),

/***/ "./src/shapes/GridConnector.js":
/*!*************************************!*\
  !*** ./src/shapes/GridConnector.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a grid network with nodes (circles/squares) placed randomly and\n * connected by potentially extended lines.\n */\nvar GridConnector = /*#__PURE__*/function (_Shape) {\n  function GridConnector() {\n    _classCallCheck(this, GridConnector);\n    return _callSuper(this, GridConnector, arguments);\n  }\n  _inherits(GridConnector, _Shape);\n  return _createClass(GridConnector, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var svgElements = [];\n      var size = this.gridSize;\n      var maxViewBoxDim = 190; // Max dimension to fit within -100 to 100 with margin\n\n      // Dynamically adjust spacing to ensure the grid fits within the viewBox\n      var actualSpacing = Math.min(this.spacing, maxViewBoxDim / (size > 1 ? size - 1 : 1));\n      var totalGridSize = (size - 1) * actualSpacing;\n\n      // Calculate top-left corner coordinates for centering\n      var startX = -totalGridSize / 2;\n      var startY = -totalGridSize / 2;\n\n      // Store which grid points will have a node\n      var nodeGrid = Array(size).fill(null).map(function () {\n        return Array(size).fill(false);\n      });\n      for (var i = 0; i < size; i++) {\n        for (var j = 0; j < size; j++) {\n          if (this.random() < this.nodeProbability) {\n            nodeGrid[i][j] = true;\n          }\n        }\n      }\n\n      // --- Generate Connections (Lines) ---\n      for (var _i = 0; _i < size; _i++) {\n        for (var _j = 0; _j < size; _j++) {\n          var x = startX + _j * actualSpacing;\n          var y = startY + _i * actualSpacing;\n\n          // Horizontal connection to the right neighbor\n          if (_j < size - 1 && this.random() < this.connectionProbability) {\n            // Add random extension/retraction to line ends based on extendLineFactor\n            var extension1 = actualSpacing * this.extendLineFactor * (this.random() * 1.5 - 0.5); // Random value between -0.5 and +1.0 factor\n            var extension2 = actualSpacing * this.extendLineFactor * (this.random() * 1.5 - 0.5);\n            var x1 = x - extension1; // Start point slightly offset\n            var x2 = startX + (_j + 1) * actualSpacing + extension2; // End point slightly offset\n            svgElements.push(\"<line x1=\\\"\".concat(x1.toFixed(2), \"\\\" y1=\\\"\").concat(y.toFixed(2), \"\\\" x2=\\\"\").concat(x2.toFixed(2), \"\\\" y2=\\\"\").concat(y.toFixed(2), \"\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(this.lineWidth, \"\\\" />\"));\n          }\n\n          // Vertical connection to the bottom neighbor\n          if (_i < size - 1 && this.random() < this.connectionProbability) {\n            // Add random extension/retraction to line ends\n            var _extension = actualSpacing * this.extendLineFactor * (this.random() * 1.5 - 0.5);\n            var _extension2 = actualSpacing * this.extendLineFactor * (this.random() * 1.5 - 0.5);\n            var y1 = y - _extension; // Start point slightly offset\n            var y2 = startY + (_i + 1) * actualSpacing + _extension2; // End point slightly offset\n            svgElements.push(\"<line x1=\\\"\".concat(x.toFixed(2), \"\\\" y1=\\\"\").concat(y1.toFixed(2), \"\\\" x2=\\\"\").concat(x.toFixed(2), \"\\\" y2=\\\"\").concat(y2.toFixed(2), \"\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(this.lineWidth, \"\\\" />\"));\n          }\n        }\n      }\n\n      // --- Generate Nodes (Circles/Squares) ---\n      // Draw nodes after lines so they appear on top\n      for (var _i2 = 0; _i2 < size; _i2++) {\n        for (var _j2 = 0; _j2 < size; _j2++) {\n          if (nodeGrid[_i2][_j2]) {\n            // Check if a node should be placed here\n            var _x = startX + _j2 * actualSpacing;\n            var _y = startY + _i2 * actualSpacing;\n            // Add a slight random variation to node size\n            var currentSize = this.nodeSize * (1 + (this.random() - 0.5) * 0.3);\n            if (this.random() < this.squareRatio) {\n              // Draw square\n              var halfSize = currentSize / 2;\n              svgElements.push(\"<rect x=\\\"\".concat((_x - halfSize).toFixed(2), \"\\\" y=\\\"\").concat((_y - halfSize).toFixed(2), \"\\\" width=\\\"\").concat(currentSize.toFixed(2), \"\\\" height=\\\"\").concat(currentSize.toFixed(2), \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\"));\n            } else {\n              // Draw circle\n              var radius = currentSize / 2;\n              svgElements.push(\"<circle cx=\\\"\".concat(_x.toFixed(2), \"\\\" cy=\\\"\").concat(_y.toFixed(2), \"\\\" r=\\\"\").concat(radius.toFixed(2), \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\"));\n            }\n          }\n        }\n      }\n\n      // Combine all SVG elements into a single string\n      return svgElements.join('\\n');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(GridConnector, \"parameters\", {\n  gridSize: {\n    type: 'number',\n    min: 3,\n    max: 15,\n    step: 1,\n    \"default\": 7,\n    label: 'Grid Size'\n  },\n  spacing: {\n    type: 'number',\n    min: 10,\n    max: 50,\n    step: 1,\n    \"default\": 25,\n    label: 'Spacing'\n  },\n  lineWidth: {\n    type: 'number',\n    min: 1,\n    max: 6,\n    step: 0.5,\n    \"default\": 2,\n    label: 'Line Width'\n  },\n  nodeSize: {\n    type: 'number',\n    min: 2,\n    max: 15,\n    step: 1,\n    \"default\": 6,\n    label: 'Node Size'\n  },\n  nodeProbability: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    step: 0.05,\n    \"default\": 0.7,\n    label: 'Node Probability'\n  },\n  squareRatio: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    step: 0.05,\n    \"default\": 0.3,\n    label: 'Square Ratio' // Ratio of squares vs circles among placed nodes\n  },\n  connectionProbability: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    step: 0.05,\n    \"default\": 0.6,\n    label: 'Connection Probability' // Chance of drawing a line between adjacent potential points\n  },\n  extendLineFactor: {\n    type: 'number',\n    min: 0,\n    max: 0.6,\n    step: 0.05,\n    \"default\": 0.2,\n    label: 'Line Extension Factor' // How much lines extend beyond nodes (as fraction of spacing)\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GridConnector);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/GridConnector.js?");

/***/ }),

/***/ "./src/shapes/GridDots.js":
/*!********************************!*\
  !*** ./src/shapes/GridDots.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a pattern of dots placed precisely on grid cells or intersections,\n * with optional grid lines shown.\n */\nvar GridDots = /*#__PURE__*/function (_Shape) {\n  function GridDots() {\n    _classCallCheck(this, GridDots);\n    return _callSuper(this, GridDots, arguments);\n  }\n  _inherits(GridDots, _Shape);\n  return _createClass(GridDots, [{\n    key: \"generateShape\",\n    value:\n    /**\n     * Generates the SVG elements for the GridDots shape.\n     * Accesses parameters via `this.parameterName`.\n     * @param {object} params - Parameter values (available on `this`).\n     * @returns {string} SVG string containing grid lines (<path>) and dots (<circle>).\n     */\n    function generateShape(params) {\n      var gridDivisions = this.gridDivisions,\n        radiusRatio = this.radiusRatio,\n        placementMode = this.placementMode,\n        showGrid = this.showGrid,\n        gridStrokeWidth = this.gridStrokeWidth;\n      var viewBoxSize = 200; // Corresponds to -100 to +100 range\n      var minCoord = -viewBoxSize / 2;\n      var maxCoord = viewBoxSize / 2;\n      var gridStep = viewBoxSize / gridDivisions;\n      var halfGridStep = gridStep / 2;\n\n      // Calculate actual radius - ensure dots don't overlap by clamping radiusRatio effect\n      // The maximum radius to avoid overlap is halfGridStep.\n      var radius = Math.min(radiusRatio, 1.0) * halfGridStep;\n\n      // Format numbers function\n      var fmt = function fmt(n) {\n        return parseFloat(n.toFixed(3));\n      };\n      var svgElements = '';\n\n      // --- Generate Grid Lines (if requested) ---\n      if (showGrid && gridDivisions > 0) {\n        var gridPathData = '';\n        // Vertical lines\n        for (var i = 0; i <= gridDivisions; i++) {\n          var x = minCoord + i * gridStep;\n          gridPathData += \"M \".concat(fmt(x), \",\").concat(fmt(minCoord), \" L \").concat(fmt(x), \",\").concat(fmt(maxCoord), \" \");\n        }\n        // Horizontal lines\n        for (var _i = 0; _i <= gridDivisions; _i++) {\n          var y = minCoord + _i * gridStep;\n          gridPathData += \"M \".concat(fmt(minCoord), \",\").concat(fmt(y), \" L \").concat(fmt(maxCoord), \",\").concat(fmt(y), \" \");\n        }\n        svgElements += \"<path d=\\\"\".concat(gridPathData.trim(), \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(fmt(gridStrokeWidth), \"\\\" />\\n\");\n      }\n\n      // --- Generate potential dot placement coordinates ---\n      var potentialCoords = [];\n      if (placementMode === 'cell') {\n        // Calculate cell centers\n        var startOffset = minCoord + halfGridStep; // Center of the first cell\n        for (var row = 0; row < gridDivisions; row++) {\n          for (var col = 0; col < gridDivisions; col++) {\n            potentialCoords.push({\n              x: startOffset + col * gridStep,\n              y: startOffset + row * gridStep\n            });\n          }\n        }\n      } else {\n        // placementMode === 'intersection'\n        // Calculate grid intersections\n        for (var _row = 0; _row <= gridDivisions; _row++) {\n          for (var _col = 0; _col <= gridDivisions; _col++) {\n            potentialCoords.push({\n              x: minCoord + _col * gridStep,\n              y: minCoord + _row * gridStep\n            });\n          }\n        }\n      }\n\n      // --- Select coordinates randomly ---\n      // Shuffle the potential coordinates using the seeded RNG\n      this.shuffleArray(potentialCoords);\n\n      // Clamp the number of circles to the available unique spots and the parameter\n      var actualNumCircles = Math.min(this.numCircles, potentialCoords.length);\n\n      // Take the first 'actualNumCircles' coordinates from the shuffled list\n      var selectedCoords = potentialCoords.slice(0, actualNumCircles);\n\n      // --- Generate SVG circle elements (Dots) ---\n      selectedCoords.forEach(function (coord) {\n        // No jitter applied, use exact coordinates\n        var finalX = coord.x;\n        var finalY = coord.y;\n        svgElements += \"<circle cx=\\\"\".concat(fmt(finalX), \"\\\" cy=\\\"\").concat(fmt(finalY), \"\\\" r=\\\"\").concat(fmt(radius), \"\\\" fill=\\\"white\\\" />\\n\");\n      });\n      return svgElements.trim();\n    }\n\n    /**\n     * Shuffles an array in place using the Fisher-Yates algorithm and the seeded RNG.\n     * @param {Array} array - The array to shuffle.\n     */\n  }, {\n    key: \"shuffleArray\",\n    value: function shuffleArray(array) {\n      for (var i = array.length - 1; i > 0; i--) {\n        // Generate a random index j such that 0 <= j <= i\n        var j = Math.floor(this.random() * (i + 1));\n        // Swap elements at indices i and j\n        var _ref = [array[j], array[i]];\n        array[i] = _ref[0];\n        array[j] = _ref[1];\n      }\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(GridDots, \"parameters\", {\n  gridDivisions: {\n    type: 'number',\n    min: 2,\n    max: 20,\n    step: 1,\n    \"default\": 8,\n    label: 'Grid Divisions' // Defines the N x N grid size\n  },\n  numCircles: {\n    type: 'number',\n    min: 0,\n    // Allow zero circles\n    max: 441,\n    // Max for intersection placement (20+1)^2\n    step: 1,\n    \"default\": 10,\n    label: 'Number of Dots'\n  },\n  radiusRatio: {\n    type: 'number',\n    min: 0.05,\n    // Smallest visible dot\n    max: 1.0,\n    // Max radius relative to half grid step, 1.0 means dots touch if adjacent\n    step: 0.05,\n    \"default\": 0.7,\n    label: 'Dot Radius Ratio'\n  },\n  placementMode: {\n    type: 'enum',\n    options: ['cell', 'intersection'],\n    \"default\": 'intersection',\n    // Changed default to match image better\n    label: 'Dot Placement' // Center dots in grid cells or on grid intersections\n  },\n  showGrid: {\n    type: 'boolean',\n    \"default\": true,\n    label: 'Show Grid Lines'\n  },\n  gridStrokeWidth: {\n    type: 'number',\n    min: 0.1,\n    max: 5,\n    step: 0.1,\n    \"default\": 0.5,\n    // Thinner default for grid lines\n    label: 'Grid Line Width'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GridDots);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/GridDots.js?");

/***/ }),

/***/ "./src/shapes/HexagonalCluster.js":
/*!****************************************!*\
  !*** ./src/shapes/HexagonalCluster.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a cluster shape composed of connected hexagonal cells, with\n * adjustable corner rounding and distortion.\n */\nvar HexagonalCluster = /*#__PURE__*/function (_Shape) {\n  function HexagonalCluster() {\n    _classCallCheck(this, HexagonalCluster);\n    return _callSuper(this, HexagonalCluster, arguments);\n  }\n  _inherits(HexagonalCluster, _Shape);\n  return _createClass(HexagonalCluster, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      // Reset RNG to ensure consistent results with the same seed\n      this.resetRNG();\n\n      // Core constants\n      var sqrt3 = Math.sqrt(3);\n      var baseScale = 1.2; // Scale factor for SVG viewBox\n      var hexSize = this.hexSize * baseScale;\n      var gridRadius = Math.round(this.complexity);\n      var numPoints = Math.max(3, Math.round(this.points));\n      var cornerRadius = this.cornerRadius * baseScale;\n      // const rotationAngle = this.rotation * (Math.PI / 180);\n      var rotationAngle = 0.0;\n\n      // Hex point class with neighbor tracking\n      var HexPoint = /*#__PURE__*/function () {\n        function HexPoint(q, r, s) {\n          _classCallCheck(this, HexPoint);\n          this.q = q;\n          this.r = r;\n          this.s = s;\n          this.neighbors = [];\n        }\n        return _createClass(HexPoint, [{\n          key: \"equals\",\n          value: function equals(other) {\n            return this.q === other.q && this.r === other.r && this.s === other.s;\n          }\n        }]);\n      }(); // Generate hex grid\n      var generateHexGrid = function generateHexGrid(radius) {\n        var points = new Map();\n        for (var q = -radius; q <= radius; q++) {\n          var rMin = Math.max(-radius, -q - radius);\n          var rMax = Math.min(radius, -q + radius);\n          for (var r = rMin; r <= rMax; r++) {\n            var s = -q - r;\n            var key = \"\".concat(q, \",\").concat(r);\n            points.set(key, new HexPoint(q, r, s));\n          }\n        }\n\n        // Add neighbors\n        var directions = [[1, 0], [1, -1], [0, -1], [-1, 0], [-1, 1], [0, 1]];\n        points.forEach(function (point) {\n          directions.forEach(function (_ref) {\n            var _ref2 = _slicedToArray(_ref, 2),\n              dq = _ref2[0],\n              dr = _ref2[1];\n            var key = \"\".concat(point.q + dq, \",\").concat(point.r + dr);\n            var neighbor = points.get(key);\n            if (neighbor) {\n              point.neighbors.push(neighbor);\n            }\n          });\n        });\n        return Array.from(points.values());\n      };\n\n      // Generate shape via random walk\n      var generateShapePoints = function generateShapePoints(grid, count) {\n        var start = grid[Math.floor(_this.random() * grid.length)];\n        var visited = new Set([start]);\n        var shape = [start];\n        var current = start;\n        while (shape.length < count) {\n          var available = current.neighbors.filter(function (n) {\n            return !visited.has(n);\n          });\n          if (available.length > 0) {\n            current = available[Math.floor(_this.random() * available.length)];\n            visited.add(current);\n            shape.push(current);\n          } else {\n            current = shape[Math.floor(_this.random() * shape.length)];\n          }\n        }\n        return shape;\n      };\n\n      // Convert hex coordinates to pixel coordinates\n      var hexToPixel = function hexToPixel(hex) {\n        return {\n          x: hexSize * (sqrt3 * hex.q + sqrt3 / 2 * hex.r),\n          y: hexSize * (3 / 2 * hex.r)\n        };\n      };\n\n      // Apply rotation to a point\n      var rotatePoint = function rotatePoint(point, angle) {\n        var cos = Math.cos(angle);\n        var sin = Math.sin(angle);\n        return {\n          x: point.x * cos - point.y * sin,\n          y: point.x * sin + point.y * cos\n        };\n      };\n\n      // Apply distortion to a point\n      var distortPoint = function distortPoint(point, factor) {\n        if (factor <= 0) return point;\n        var distortX = (_this.random() - 0.5) * factor;\n        var distortY = (_this.random() - 0.5) * factor;\n        return {\n          x: point.x + distortX,\n          y: point.y + distortY\n        };\n      };\n\n      // Generate and process shape points\n      var grid = generateHexGrid(gridRadius);\n      var shapeHexes = generateShapePoints(grid, numPoints);\n      var points = shapeHexes.map(function (hex) {\n        return hexToPixel(hex);\n      });\n\n      // Calculate bounds\n      var bounds = points.reduce(function (acc, pt) {\n        return {\n          minX: Math.min(acc.minX, pt.x),\n          maxX: Math.max(acc.maxX, pt.x),\n          minY: Math.min(acc.minY, pt.y),\n          maxY: Math.max(acc.maxY, pt.y)\n        };\n      }, {\n        minX: Infinity,\n        maxX: -Infinity,\n        minY: Infinity,\n        maxY: -Infinity\n      });\n\n      // Center the points\n      var centerX = (bounds.maxX + bounds.minX) / 2;\n      var centerY = (bounds.maxY + bounds.minY) / 2;\n      points = points.map(function (pt) {\n        return {\n          x: pt.x - centerX,\n          y: pt.y - centerY\n        };\n      });\n\n      // Calculate centroid for angle sorting\n      var centroid = points.reduce(function (sum, pt) {\n        return {\n          x: sum.x + pt.x / points.length,\n          y: sum.y + pt.y / points.length\n        };\n      }, {\n        x: 0,\n        y: 0\n      });\n\n      // Sort points by angle around centroid\n      points.sort(function (a, b) {\n        return Math.atan2(a.y - centroid.y, a.x - centroid.x) - Math.atan2(b.y - centroid.y, b.x - centroid.x);\n      });\n\n      // Apply distortion if needed\n      if (this.distortion > 0) {\n        points = points.map(function (pt) {\n          return distortPoint(pt, _this.distortion);\n        });\n      }\n\n      // Apply rotation if needed\n      if (rotationAngle !== 0) {\n        points = points.map(function (pt) {\n          return rotatePoint(pt, rotationAngle);\n        });\n      }\n\n      // Determine corner radii based on style\n      var determineCornerRadii = function determineCornerRadii(points, baseRadius, style) {\n        var count = points.length;\n        var radii = new Array(count);\n        switch (style) {\n          case 0:\n            // All rounded\n            for (var i = 0; i < count; i++) {\n              radii[i] = baseRadius;\n            }\n            break;\n          case 1:\n            // None rounded\n            for (var _i = 0; _i < count; _i++) {\n              radii[_i] = 0;\n            }\n            break;\n          case 2:\n            // Alternating\n            for (var _i2 = 0; _i2 < count; _i2++) {\n              radii[_i2] = _i2 % 2 === 0 ? baseRadius : 0;\n            }\n            break;\n          case 3:\n            // Random\n            for (var _i3 = 0; _i3 < count; _i3++) {\n              radii[_i3] = _this.random() < 0.5 ? baseRadius : 0;\n            }\n            break;\n          default:\n            for (var _i4 = 0; _i4 < count; _i4++) {\n              radii[_i4] = baseRadius;\n            }\n        }\n        return radii;\n      };\n\n      // Create path with variable corner radii\n      var createVaryingRadiiPath = function createVaryingRadiiPath(points, radii) {\n        var count = points.length;\n        var parts = [];\n        for (var i = 0; i < count; i++) {\n          var curr = points[i];\n          var prev = points[(i - 1 + count) % count];\n          var next = points[(i + 1) % count];\n          var radius = radii[i];\n          var v1 = {\n            x: curr.x - prev.x,\n            y: curr.y - prev.y\n          };\n          var v2 = {\n            x: next.x - curr.x,\n            y: next.y - curr.y\n          };\n          var len1 = Math.hypot(v1.x, v1.y);\n          var len2 = Math.hypot(v2.x, v2.y);\n          if (len1 === 0 || len2 === 0) continue;\n          if (radius <= 0) {\n            // Sharp corner\n            if (i === 0) {\n              parts.push(\"M \".concat(curr.x, \" \").concat(curr.y));\n            } else {\n              parts.push(\"L \".concat(curr.x, \" \").concat(curr.y));\n            }\n          } else {\n            // Rounded corner\n            var distance = Math.min(radius, Math.min(len1, len2) / 2);\n            var p1 = {\n              x: curr.x - v1.x / len1 * distance,\n              y: curr.y - v1.y / len1 * distance\n            };\n            var p2 = {\n              x: curr.x + v2.x / len2 * distance,\n              y: curr.y + v2.y / len2 * distance\n            };\n            if (i === 0) {\n              parts.push(\"M \".concat(p1.x, \" \").concat(p1.y));\n            } else {\n              parts.push(\"L \".concat(p1.x, \" \").concat(p1.y));\n            }\n            parts.push(\"Q \".concat(curr.x, \" \").concat(curr.y, \" \").concat(p2.x, \" \").concat(p2.y));\n          }\n        }\n        parts.push('Z');\n        return parts.join(' ');\n      };\n\n      // Determine corner radii based on selected style\n      var cornerRadii = determineCornerRadii(points, cornerRadius, this.cornerStyle);\n\n      // Generate the main path\n      var mainPath = createVaryingRadiiPath(points, cornerRadii);\n      return \"<path \\n            d=\\\"\".concat(mainPath, \"\\\"\\n            fill=\\\"white\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(HexagonalCluster, \"parameters\", {\n  complexity: {\n    min: 4,\n    max: 12,\n    \"default\": 5\n  },\n  // Grid radius\n  points: {\n    min: 5,\n    max: 16,\n    \"default\": 8\n  },\n  // Number of hex cells used\n  hexSize: {\n    min: 20,\n    max: 40,\n    \"default\": 28\n  },\n  // Base size of a hex cell\n  cornerRadius: {\n    min: 0,\n    max: 60,\n    \"default\": 10\n  },\n  // Base rounding at vertices\n  cornerStyle: {\n    min: 0,\n    max: 3,\n    \"default\": 0\n  },\n  // 0: all, 1: none, 2: alternating, 3: random\n  distortion: {\n    min: 0,\n    max: 30,\n    \"default\": 0\n  } // Add irregularity to shape\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HexagonalCluster);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/HexagonalCluster.js?");

/***/ }),

/***/ "./src/shapes/HollowEllipse.js":
/*!*************************************!*\
  !*** ./src/shapes/HollowEllipse.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Creates a hollow ellipse (annulus) by masking an inner ellipse from an outer\n * one, allowing offset placement of the inner ellipse.\n */\nvar HollowEllipse = /*#__PURE__*/function (_Shape) {\n  function HollowEllipse() {\n    _classCallCheck(this, HollowEllipse);\n    return _callSuper(this, HollowEllipse, arguments);\n  }\n  _inherits(HollowEllipse, _Shape);\n  return _createClass(HollowEllipse, [{\n    key: \"validateInnerEllipseBounds\",\n    value: function validateInnerEllipseBounds() {\n      // Ensure inner ellipse is not larger than outer ellipse\n      this.innerRadiusX = Math.min(this.innerRadiusX, this.outerRadiusX * 0.9);\n      this.innerRadiusY = Math.min(this.innerRadiusY, this.outerRadiusY * 0.9);\n\n      // Calculate the maximum allowed offset to keep inner ellipse within outer\n      // Using a more conservative approach based on the formula for ellipse containment\n      var maxOffsetX = Math.max(1, this.outerRadiusX - this.innerRadiusX);\n      var maxOffsetY = Math.max(1, this.outerRadiusY - this.innerRadiusY);\n\n      // Constrain the inner ellipse offsets more strictly to ensure containment\n      // The constraint is tighter than before to address the visual issue\n      var safetyFactor = 0.9; // Add a safety margin to ensure visual containment\n      this.innerOffsetX = Math.max(-maxOffsetX * safetyFactor, Math.min(maxOffsetX * safetyFactor, this.innerOffsetX));\n      this.innerOffsetY = Math.max(-maxOffsetY * safetyFactor, Math.min(maxOffsetY * safetyFactor, this.innerOffsetY));\n\n      // Additional check: if offset is large, reduce radius to ensure containment\n      var offsetRatio = Math.sqrt(Math.pow(this.innerOffsetX / maxOffsetX, 2) + Math.pow(this.innerOffsetY / maxOffsetY, 2));\n      if (offsetRatio > 0.7) {\n        // If we're using a large portion of available offset, reduce inner radius accordingly\n        var reductionFactor = 1 - (offsetRatio - 0.7) * 0.5;\n        this.innerRadiusX *= reductionFactor;\n        this.innerRadiusY *= reductionFactor;\n      }\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Validate inner ellipse is within bounds\n      this.validateInnerEllipseBounds();\n\n      // Generate a unique ID for this mask instance\n      var maskId = \"hollow-ellipse-mask-\".concat(Math.floor(Math.random() * 10000));\n\n      // Create the mask with outer ellipse (white) and inner ellipse (black)\n      var defs = \"\\n            <defs>\\n                <mask id=\\\"\".concat(maskId, \"\\\">\\n                    <rect x=\\\"-200\\\" y=\\\"-200\\\" width=\\\"400\\\" height=\\\"400\\\" fill=\\\"black\\\" />\\n                    <ellipse \\n                        cx=\\\"0\\\" \\n                        cy=\\\"0\\\" \\n                        rx=\\\"\").concat(this.outerRadiusX, \"\\\" \\n                        ry=\\\"\").concat(this.outerRadiusY, \"\\\"\\n                        fill=\\\"white\\\"\\n                    />\\n                    <ellipse \\n                        cx=\\\"\").concat(this.innerOffsetX, \"\\\" \\n                        cy=\\\"\").concat(this.innerOffsetY, \"\\\" \\n                        rx=\\\"\").concat(this.innerRadiusX, \"\\\" \\n                        ry=\\\"\").concat(this.innerRadiusY, \"\\\"\\n                        fill=\\\"black\\\"\\n                    />\\n                </mask>\\n            </defs>\\n        \");\n\n      // Create the main ellipse shape and apply the mask\n      var shape = \"\\n            <ellipse \\n                cx=\\\"0\\\" \\n                cy=\\\"0\\\" \\n                rx=\\\"\".concat(this.outerRadiusX, \"\\\" \\n                ry=\\\"\").concat(this.outerRadiusY, \"\\\"\\n                fill=\\\"white\\\"\\n                mask=\\\"url(#\").concat(maskId, \")\\\"\\n            />\\n        \");\n      return defs + shape;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(HollowEllipse, \"parameters\", {\n  outerRadiusX: {\n    min: 50,\n    max: 100,\n    \"default\": 100\n  },\n  outerRadiusY: {\n    min: 50,\n    max: 100,\n    \"default\": 100\n  },\n  innerRadiusX: {\n    min: 25,\n    max: 50,\n    \"default\": 40\n  },\n  innerRadiusY: {\n    min: 25,\n    max: 50,\n    \"default\": 40\n  },\n  innerOffsetX: {\n    min: -50,\n    max: 50,\n    \"default\": 0\n  },\n  innerOffsetY: {\n    min: -50,\n    max: 50,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HollowEllipse);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/HollowEllipse.js?");

/***/ }),

/***/ "./src/shapes/HomeIcon.js":
/*!********************************!*\
  !*** ./src/shapes/HomeIcon.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a stylized house icon shape with an inverted (pointed downwards)\n * roof and a rectangular door cutout.\n */\nvar InvertedHomeIcon = /*#__PURE__*/function (_Shape) {\n  function InvertedHomeIcon() {\n    _classCallCheck(this, InvertedHomeIcon);\n    return _callSuper(this, InvertedHomeIcon, arguments);\n  }\n  _inherits(InvertedHomeIcon, _Shape);\n  return _createClass(InvertedHomeIcon, [{\n    key: \"generateShape\",\n    value:\n    /**\n     * Generates the SVG elements for the InvertedHomeIcon shape.\n     * Accesses parameters via `this.parameterName`.\n     * @param {object} params - An object containing the parameter values for this shape instance (available as this.parameterName).\n     * @returns {string} SVG string containing elements like <path>, <circle>, <polyline>, etc.\n     */\n    function generateShape(params) {\n      var w = this.houseWidth;\n      var h = this.houseHeight;\n      var rh = this.roofHeight;\n      // Ensure door dimensions are constrained by house dimensions, leaving a small margin\n      var dw = Math.min(this.doorWidth, w * 0.8);\n      var dh = Math.min(this.doorHeight, h * 0.8);\n\n      // Calculate vertical center offset to center the entire shape around y=0\n      // Total height = h + rh\n      // Midpoint = (top_y + bottom_y) / 2 = (h + (-rh)) / 2 = (h - rh) / 2\n      // We shift the shape down by this amount\n      var yOffset = (h - rh) / 2;\n\n      // --- Calculate Coordinates (shifted for centering) ---\n\n      // House body (rectangle) coordinates\n      var houseTopY = h - yOffset;\n      var houseBottomY = 0 - yOffset; // This is also the join line with the roof\n      var houseLeftX = -w / 2;\n      var houseRightX = w / 2;\n\n      // Roof (inverted triangle) coordinates\n      var roofTopY = houseBottomY; // Same as house bottom\n      var roofApexY = -rh - yOffset;\n      var roofApexX = 0;\n\n      // Door (rectangle) coordinates\n      // Place door relative to the house body's bottom edge\n      var doorTopY = dh - yOffset;\n      var doorBottomY = 0 - yOffset; // Aligned with house bottom\n      var doorLeftX = -dw / 2;\n      var doorRightX = dw / 2;\n\n      // --- Construct SVG Path ---\n\n      // Main house outline path: starts from roof apex, goes around the shape\n      var mainPath = \"M \".concat(roofApexX, \",\").concat(roofApexY, \" L \").concat(houseLeftX, \",\").concat(roofTopY, \" L \").concat(houseLeftX, \",\").concat(houseTopY, \" L \").concat(houseRightX, \",\").concat(houseTopY, \" L \").concat(houseRightX, \",\").concat(roofTopY, \" Z\");\n\n      // Door path (wound in reverse for evenodd fill rule)\n      var doorPath = \"M \".concat(doorLeftX, \",\").concat(doorBottomY, \" L \").concat(doorRightX, \",\").concat(doorBottomY, \" L \").concat(doorRightX, \",\").concat(doorTopY, \" L \").concat(doorLeftX, \",\").concat(doorTopY, \" Z\");\n\n      // Combine paths for a single element with a cutout\n      var combinedPathData = \"\".concat(mainPath, \" \").concat(doorPath);\n\n      // Return the path element with the evenodd fill rule to create the door cutout effect\n      return \"<path d=\\\"\".concat(combinedPathData, \"\\\" fill=\\\"white\\\" fill-rule=\\\"evenodd\\\" stroke=\\\"none\\\" />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(InvertedHomeIcon, \"parameters\", {\n  houseWidth: {\n    type: 'number',\n    min: 20,\n    max: 150,\n    step: 1,\n    \"default\": 80,\n    label: 'House Width'\n  },\n  houseHeight: {\n    type: 'number',\n    min: 20,\n    max: 120,\n    step: 1,\n    \"default\": 60,\n    label: 'House Height'\n  },\n  roofHeight: {\n    type: 'number',\n    min: 10,\n    max: 80,\n    step: 1,\n    \"default\": 40,\n    label: 'Roof Height'\n  },\n  doorWidth: {\n    type: 'number',\n    min: 5,\n    max: 60,\n    // Should be practically less than houseWidth\n    step: 1,\n    \"default\": 20,\n    label: 'Door Width'\n  },\n  doorHeight: {\n    type: 'number',\n    min: 10,\n    max: 80,\n    // Should be practically less than houseHeight\n    step: 1,\n    \"default\": 30,\n    label: 'Door Height'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (InvertedHomeIcon);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/HomeIcon.js?");

/***/ }),

/***/ "./src/shapes/HorizontalRects.js":
/*!***************************************!*\
  !*** ./src/shapes/HorizontalRects.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a vertical stack of horizontal rectangles with varying heights\n * based on a directional bias pattern.\n */\nvar HorizontalRects = /*#__PURE__*/function (_Shape) {\n  function HorizontalRects() {\n    _classCallCheck(this, HorizontalRects);\n    return _callSuper(this, HorizontalRects, arguments);\n  }\n  _inherits(HorizontalRects, _Shape);\n  return _createClass(HorizontalRects, [{\n    key: \"calculateHeights\",\n    value: function calculateHeights() {\n      var heights = new Array(this.count);\n      var heightDiff = this.maxHeight - this.minHeight;\n      if (Math.abs(this.direction) <= 0.1) {\n        // Center peak pattern\n        var mid = Math.floor((this.count - 1) / 2);\n        for (var i = 0; i < this.count; i++) {\n          var distFromCenter = Math.abs(i - mid) / (this.count - 1);\n          heights[i] = this.maxHeight - distFromCenter * heightDiff * 2;\n        }\n      } else {\n        // Ascending or descending pattern\n        for (var _i = 0; _i < this.count; _i++) {\n          var progress = this.direction > 0 ? _i / (this.count - 1) : 1 - _i / (this.count - 1);\n          heights[_i] = this.minHeight + progress * heightDiff;\n        }\n      }\n      return heights;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      this.boundary = 200;\n      var heights = this.calculateHeights();\n\n      // Calculate total pattern height for scaling\n      var totalHeight = (this.count - 1) * this.spacing + heights.reduce(function (sum, h) {\n        return sum + h;\n      }, 0);\n\n      // Scale to fit within boundary\n      var scale = Math.min(1, this.boundary / totalHeight);\n\n      // Calculate scaled dimensions\n      var scaledTotalHeight = totalHeight * scale;\n      var scaledSpacing = this.spacing * scale;\n\n      // Start from vertical center\n      var currentY = -scaledTotalHeight / 2;\n\n      // Generate rectangles\n      var rects = heights.map(function (height) {\n        var scaledHeight = height * scale;\n        var rect = \"<rect \\n                x=\\\"\".concat(-_this.width / 2, \"\\\"\\n                y=\\\"\").concat(currentY, \"\\\"\\n                width=\\\"\").concat(_this.width, \"\\\"\\n                height=\\\"\").concat(scaledHeight, \"\\\"\\n                fill=\\\"\").concat(_this.mode === 'fill' ? 'white' : 'none', \"\\\"\\n                stroke=\\\"\").concat(_this.mode === 'stroke' ? 'white' : 'none', \"\\\"\\n                stroke-width=\\\"\").concat(_this.mode === 'stroke' ? _this.thickness : 0, \"\\\"\\n            />\");\n        currentY += scaledHeight + scaledSpacing;\n        return rect;\n      });\n      return rects.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(HorizontalRects, \"parameters\", {\n  count: {\n    min: 3,\n    max: 12,\n    \"default\": 5\n  },\n  spacing: {\n    min: 5,\n    max: 50,\n    \"default\": 24\n  },\n  width: {\n    min: 100,\n    max: 200,\n    \"default\": 169\n  },\n  direction: {\n    min: -1,\n    max: 1,\n    \"default\": 0.9,\n    step: 0.1\n  },\n  minHeight: {\n    min: 2,\n    max: 20,\n    \"default\": 9\n  },\n  maxHeight: {\n    min: 20,\n    max: 80,\n    \"default\": 80\n  },\n  mode: {\n    options: ['fill', 'stroke'],\n    \"default\": 'fill'\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HorizontalRects);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/HorizontalRects.js?");

/***/ }),

/***/ "./src/shapes/Hourglass.js":
/*!*********************************!*\
  !*** ./src/shapes/Hourglass.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates an hourglass shape with curved sides defined by quadratic Bezier\n * curves, allowing adjustable curve factor and waist position.\n */\nvar HourglassShape = /*#__PURE__*/function (_Shape) {\n  function HourglassShape() {\n    _classCallCheck(this, HourglassShape);\n    return _callSuper(this, HourglassShape, arguments);\n  }\n  _inherits(HourglassShape, _Shape);\n  return _createClass(HourglassShape, [{\n    key: \"validateParams\",\n    value: function validateParams(options) {\n      var validated = _objectSpread({}, options);\n\n      // Ensure waist is narrower than ends\n      if ('waistWidth' in options) {\n        var minEndWidth = options.endWidth || this.endWidth;\n        validated.waistWidth = Math.min(options.waistWidth, minEndWidth - 20 // Ensure at least 20% difference\n        );\n      }\n\n      // Ensure ends are wider than waist\n      if ('endWidth' in options) {\n        validated.endWidth = Math.max(options.endWidth, (options.waistWidth || this.waistWidth) + 20);\n      }\n      return validated;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      this.waistWidth = this.waistWidth / 100;\n      this.endWidth = this.endWidth / 100;\n      this.rounding = this.rounding / 100;\n      var size = 150;\n      var halfSize = size / 2;\n\n      // Base points for the hourglass (centered waist)\n      var points = [{\n        x: -halfSize * this.endWidth,\n        y: -halfSize\n      },\n      // Top left\n      {\n        x: -halfSize * this.waistWidth,\n        y: 0\n      },\n      // Waist left\n      {\n        x: -halfSize * this.endWidth,\n        y: halfSize\n      },\n      // Bottom left\n      {\n        x: halfSize * this.endWidth,\n        y: halfSize\n      },\n      // Bottom right\n      {\n        x: halfSize * this.waistWidth,\n        y: 0\n      },\n      // Waist right\n      {\n        x: halfSize * this.endWidth,\n        y: -halfSize\n      } // Top right\n      ];\n\n      // If no rounding, return straight path\n      if (this.rounding === 0) {\n        return \"<path d=\\\"\".concat(points.map(function (p, i) {\n          return (i === 0 ? 'M' : 'L') + \" \".concat(p.x, \" \").concat(p.y);\n        }).join(''), \" Z\\\" fill=\\\"white\\\" />\");\n      }\n\n      // Calculate maximum allowed corner radius based on smallest segment\n      var minSegmentLength = Math.min(Math.abs(points[0].y - points[1].y), Math.abs(points[1].y - points[2].y));\n      var maxRadius = minSegmentLength * 0.5;\n      var cornerRadius = maxRadius * this.rounding;\n\n      // Generate rounded corners path\n      var path = \"M \".concat(points[0].x, \" \").concat(points[0].y);\n      for (var i = 0; i < points.length; i++) {\n        var current = points[i];\n        var next = points[(i + 1) % points.length];\n        var prev = points[i === 0 ? points.length - 1 : i - 1];\n\n        // Calculate vectors\n        var toPrev = {\n          x: prev.x - current.x,\n          y: prev.y - current.y\n        };\n        var toNext = {\n          x: next.x - current.x,\n          y: next.y - current.y\n        };\n\n        // Normalize vectors\n        var toPrevLength = Math.sqrt(toPrev.x * toPrev.x + toPrev.y * toPrev.y);\n        var toNextLength = Math.sqrt(toNext.x * toNext.x + toNext.y * toNext.y);\n        var normPrev = {\n          x: toPrev.x / toPrevLength,\n          y: toPrev.y / toPrevLength\n        };\n        var normNext = {\n          x: toNext.x / toNextLength,\n          y: toNext.y / toNextLength\n        };\n\n        // Calculate control points\n        var cp1 = {\n          x: current.x + normPrev.x * cornerRadius,\n          y: current.y + normPrev.y * cornerRadius\n        };\n        var cp2 = {\n          x: current.x + normNext.x * cornerRadius,\n          y: current.y + normNext.y * cornerRadius\n        };\n\n        // Add to path\n        path += \" L \".concat(cp1.x, \" \").concat(cp1.y);\n        path += \" Q \".concat(current.x, \" \").concat(current.y, \" \").concat(cp2.x, \" \").concat(cp2.y);\n      }\n      return \"<path d=\\\"\".concat(path, \" Z\\\" fill=\\\"white\\\" />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(HourglassShape, \"parameters\", {\n  waistWidth: {\n    min: 0,\n    max: 100,\n    \"default\": 30\n  },\n  endWidth: {\n    min: 25,\n    max: 100,\n    \"default\": 80\n  },\n  rounding: {\n    min: 0,\n    max: 100,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HourglassShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/Hourglass.js?");

/***/ }),

/***/ "./src/shapes/HourglassEllipse.js":
/*!****************************************!*\
  !*** ./src/shapes/HourglassEllipse.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a shape combining a central ellipse (waist) with two triangles\n * forming the top and bottom ends.\n */\nvar HourglassEllipseShape = /*#__PURE__*/function (_Shape) {\n  function HourglassEllipseShape() {\n    _classCallCheck(this, HourglassEllipseShape);\n    return _callSuper(this, HourglassEllipseShape, arguments);\n  }\n  _inherits(HourglassEllipseShape, _Shape);\n  return _createClass(HourglassEllipseShape, [{\n    key: \"validateParams\",\n    value: function validateParams(options) {\n      var validated = _objectSpread({}, options);\n\n      // Ensure waist width is appropriate\n      if ('waistWidth' in options) {\n        validated.waistWidth = Math.min(options.waistWidth, options.endWidth || this.endWidth);\n      }\n      return validated;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Convert percentages to actual values\n      this.waistWidth = this.waistWidth / 100;\n      this.waistHeight = this.waistHeight / 100;\n      this.endWidth = this.endWidth / 100;\n      var size = 150;\n      var halfSize = size / 2;\n\n      // Calculate dimensions\n      var endWidth = halfSize * this.endWidth;\n      var ellipseRx = halfSize * this.waistWidth;\n      var ellipseRy = halfSize * this.waistHeight;\n      var triangleHeight = halfSize - ellipseRy;\n\n      // Generate the shape combining paths and ellipse\n      return \"\\n            <path d=\\\"M \".concat(-endWidth, \" \").concat(-halfSize, \" \\n                     L 0 \").concat(-ellipseRy, \"\\n                     L \").concat(endWidth, \" \").concat(-halfSize, \" Z\\\" \\n                  fill=\\\"white\\\" />\\n            <ellipse cx=\\\"0\\\" cy=\\\"0\\\" \\n                     rx=\\\"\").concat(ellipseRx, \"\\\" ry=\\\"\").concat(ellipseRy, \"\\\" \\n                     fill=\\\"white\\\" />\\n            <path d=\\\"M \").concat(-endWidth, \" \").concat(halfSize, \"\\n                     L 0 \").concat(ellipseRy, \"\\n                     L \").concat(endWidth, \" \").concat(halfSize, \" Z\\\" \\n                  fill=\\\"white\\\" />\\n        \");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(HourglassEllipseShape, \"parameters\", {\n  waistWidth: {\n    min: 10,\n    max: 100,\n    \"default\": 60\n  },\n  // Width of the ellipse\n  waistHeight: {\n    min: 10,\n    max: 100,\n    \"default\": 30\n  },\n  // Height of the ellipse\n  endWidth: {\n    min: 25,\n    max: 100,\n    \"default\": 80\n  } // Width of triangular ends\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HourglassEllipseShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/HourglassEllipse.js?");

/***/ }),

/***/ "./src/shapes/HourglassShape.js":
/*!**************************************!*\
  !*** ./src/shapes/HourglassShape.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates an hourglass shape with curved sides defined by quadratic Bezier\n * curves, allowing adjustable curve factor and waist position.\n */\nvar HourglassShape = /*#__PURE__*/function (_Shape) {\n  function HourglassShape() {\n    _classCallCheck(this, HourglassShape);\n    return _callSuper(this, HourglassShape, arguments);\n  }\n  _inherits(HourglassShape, _Shape);\n  return _createClass(HourglassShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var h = this.height;\n      var tw = this.topWidth;\n      // Ensure waistWidth is always less than topWidth and at least 2\n      var ww = Math.max(2, Math.min(this.waistWidth, tw - 2));\n      var cf = this.curveFactor;\n      var halfH = h / 2;\n      // Clamp waistOffsetY to be safely within vertical bounds\n      var safeOffsetYLimit = halfH > 1 ? halfH - 1 : 0; // Prevent reaching exact top/bottom\n      var wy = Math.max(-safeOffsetYLimit, Math.min(safeOffsetYLimit, this.waistOffsetY));\n      var af = 0.0; // asymmetryFactor\n\n      var halfTW = tw / 2;\n      var baseHalfWW = ww / 2;\n\n      // Calculate asymmetric waist horizontal positions, ensuring minimum width constraint\n      var maxDeltaW = Math.max(0, baseHalfWW - 1); // Max deviation ensuring half-waist is at least 1\n      var deltaW = Math.max(-maxDeltaW, Math.min(maxDeltaW, baseHalfWW * af));\n      var halfWWL = baseHalfWW + deltaW; // Left side waist x magnitude (will be negative coord)\n      var halfWWR = baseHalfWW - deltaW; // Right side waist x magnitude (will be positive coord)\n\n      // Define key points\n      var waistLeftX = -halfWWL;\n      var waistRightX = halfWWR;\n      var waistY = wy;\n\n      // Calculate control points' Y coordinates based on curveFactor and waistOffsetY\n      var hTop = Math.max(0, halfH - waistY); // Vertical distance from waist to top\n      var hBottom = Math.max(0, halfH + waistY); // Vertical distance from waist to bottom\n\n      // Y coordinates for the quadratic Bezier control points\n      var controlYTop = waistY + hTop * cf;\n      var controlYBottom = waistY - hBottom * cf;\n\n      // Construct the SVG path data string using quadratic Bezier curves (Q)\n      // Using toFixed(3) for cleaner output and reduced floating point inaccuracies\n      var pathData = \"\\n            M \".concat(halfTW.toFixed(3), \", \").concat(halfH.toFixed(3), \"\\n            Q \").concat(waistRightX.toFixed(3), \", \").concat(controlYTop.toFixed(3), \", \").concat(waistRightX.toFixed(3), \", \").concat(waistY.toFixed(3), \"\\n            Q \").concat(waistRightX.toFixed(3), \", \").concat(controlYBottom.toFixed(3), \", \").concat(halfTW.toFixed(3), \", \").concat((-halfH).toFixed(3), \"\\n            L \").concat((-halfTW).toFixed(3), \", \").concat((-halfH).toFixed(3), \"\\n            Q \").concat(waistLeftX.toFixed(3), \", \").concat(controlYBottom.toFixed(3), \", \").concat(waistLeftX.toFixed(3), \", \").concat(waistY.toFixed(3), \"\\n            Q \").concat(waistLeftX.toFixed(3), \", \").concat(controlYTop.toFixed(3), \", \").concat((-halfTW).toFixed(3), \", \").concat(halfH.toFixed(3), \"\\n            Z\\n        \").trim().replace(/\\s+/g, ' '); // Minify path data string for compactness\n\n      // Return the SVG path element\n      return \"<path d=\\\"\".concat(pathData, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(HourglassShape, \"parameters\", {\n  height: {\n    type: 'number',\n    min: 10,\n    max: 198,\n    step: 1,\n    \"default\": 180\n  },\n  topWidth: {\n    type: 'number',\n    min: 10,\n    max: 198,\n    step: 1,\n    \"default\": 160\n  },\n  waistWidth: {\n    type: 'number',\n    min: 2,\n    max: 196,\n    // Max is slightly less than topWidth max\n    step: 1,\n    \"default\": 40\n  },\n  curveFactor: {\n    type: 'number',\n    // Controls the curve intensity (0=sharp waist, 1=smooth C-curve)\n    min: 0,\n    max: 1,\n    step: 0.01,\n    \"default\": 1\n  },\n  waistOffsetY: {\n    type: 'number',\n    // Vertical position of the narrowest point\n    min: -90,\n    // Should be kept within +/- height/2\n    max: 90,\n    step: 1,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HourglassShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/HourglassShape.js?");

/***/ }),

/***/ "./src/shapes/HyperbolicLines.js":
/*!***************************************!*\
  !*** ./src/shapes/HyperbolicLines.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a pattern resembling an hourglass or funnel using multiple vertical\n * lines curved via quadratic Beziers.\n */\nvar HyperbolicLines = /*#__PURE__*/function (_Shape) {\n  function HyperbolicLines() {\n    _classCallCheck(this, HyperbolicLines);\n    return _callSuper(this, HyperbolicLines, arguments);\n  }\n  _inherits(HyperbolicLines, _Shape);\n  return _createClass(HyperbolicLines, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var size = this.size;\n      var numLines = Math.max(2, Math.round(this.numberOfLines)); // Ensure at least 2 lines\n      var pinchRatio = this.pinchRatio;\n      var strokeWidth = this.strokeWidth;\n      var width = size;\n      var height = size;\n      var halfWidth = width / 2;\n      var halfHeight = height / 2;\n\n      // Determine the x-coordinate of the control point for the quadratic Bezier curve.\n      // This factor determines how much the curve bends inwards.\n      // factor = 1 means straight line (cx = x).\n      // factor = 0 means control point is at x=0.\n      // factor = -1 means control point is at x=-x (maximum pinch).\n      // We want the curve to pass through x * pinchRatio at y=0.\n      // For a quadratic Bezier P0, P1, P2, the point at t=0.5 is 0.25*P0 + 0.5*P1 + 0.25*P2.\n      // Mid-point x: 0.25*x + 0.5*cx + 0.25*x = 0.5*x + 0.5*cx\n      // We want mid-point x = x * pinchRatio.\n      // x * pinchRatio = 0.5*x + 0.5*cx\n      // 0.5*cx = x * pinchRatio - 0.5*x\n      // cx = 2 * x * pinchRatio - x = x * (2 * pinchRatio - 1)\n      var controlPointFactor = 2 * pinchRatio - 1;\n      var paths = '';\n      for (var i = 0; i < numLines; i++) {\n        // Calculate the horizontal position (x) for this line's endpoints.\n        // Distribute lines evenly across the width.\n        var t = numLines === 1 ? 0.5 : i / (numLines - 1); // Normalized position (0 to 1)\n        var x = -halfWidth + t * width;\n\n        // Calculate the control point's x-coordinate based on the pinch factor\n        var controlX = x * controlPointFactor;\n        var controlY = 0; // Control point is on the y-axis (center vertically)\n\n        // Define the start, control, and end points for the quadratic Bezier curve\n        var startX = x.toFixed(3);\n        var startY = (-halfHeight).toFixed(3);\n        var controlXPath = controlX.toFixed(3);\n        var controlYPath = controlY.toFixed(3);\n        var endX = x.toFixed(3);\n        var endY = halfHeight.toFixed(3);\n\n        // Create the SVG path string for this line\n        var d = \"M \".concat(startX, \" \").concat(startY, \" Q \").concat(controlXPath, \" \").concat(controlYPath, \" \").concat(endX, \" \").concat(endY);\n        paths += \"<path d=\\\"\".concat(d, \"\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(strokeWidth, \"\\\" fill=\\\"none\\\" />\");\n      }\n      return paths;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(HyperbolicLines, \"parameters\", {\n  size: {\n    type: 'number',\n    min: 20,\n    max: 200,\n    step: 1,\n    \"default\": 150 // Overall size (width and height) of the bounding box\n  },\n  numberOfLines: {\n    type: 'number',\n    min: 2,\n    max: 32,\n    step: 1,\n    \"default\": 16 // Number of lines to draw\n  },\n  pinchRatio: {\n    type: 'number',\n    min: 0.0,\n    // How much the lines pinch inwards (0 = max pinch, 1 = straight lines)\n    max: 1.0,\n    step: 0.01,\n    \"default\": 0.1 // Default pinch factor for a noticeable hourglass shape\n  },\n  strokeWidth: {\n    type: 'number',\n    min: 0.5,\n    max: 5,\n    step: 0.1,\n    \"default\": 3 // Thickness of each line\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HyperbolicLines);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/HyperbolicLines.js?");

/***/ }),

/***/ "./src/shapes/IncreasingRadialShape.js":
/*!*********************************************!*\
  !*** ./src/shapes/IncreasingRadialShape.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a radial burst of lines originating from the center, where line\n * thickness increases with angle.\n */\nvar IncreasingRadialShape = /*#__PURE__*/function (_Shape) {\n  function IncreasingRadialShape() {\n    _classCallCheck(this, IncreasingRadialShape);\n    return _callSuper(this, IncreasingRadialShape, arguments);\n  }\n  _inherits(IncreasingRadialShape, _Shape);\n  return _createClass(IncreasingRadialShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var lines = [];\n      var startAngle = -Math.PI / 2 + this.rotation * Math.PI / 180; // Start from top\n      var spreadRad = this.spread * Math.PI / 180;\n      for (var i = 0; i < this.lineCount; i++) {\n        // Calculate progression (0 to 1)\n        var progress = i / (this.lineCount - 1);\n\n        // Calculate angle using spread parameter\n        var angle = startAngle + spreadRad * progress;\n\n        // Calculate increasing radius (kept constant for perfect circle)\n        var radius = this.minRadius;\n\n        // Calculate start point (always at center)\n        var x1 = 0;\n        var y1 = 0;\n\n        // Calculate end point\n        var x2 = radius * Math.cos(angle);\n        var y2 = radius * Math.sin(angle);\n\n        // Calculate increasing thickness\n        var thickness = this.minThickness + (this.maxThickness - this.minThickness) * progress;\n        lines.push(\"<line \\n                x1=\\\"\".concat(x1, \"\\\" \\n                y1=\\\"\").concat(y1, \"\\\" \\n                x2=\\\"\").concat(x2, \"\\\" \\n                y2=\\\"\").concat(y2, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(thickness, \"\\\"\\n                stroke-linecap=\\\"\").concat(this.lineCap, \"\\\"\\n            />\"));\n      }\n      return lines.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(IncreasingRadialShape, \"parameters\", {\n  minRadius: {\n    min: 0,\n    max: 100,\n    \"default\": 100\n  },\n  lineCount: {\n    min: 4,\n    max: 72,\n    \"default\": 26\n  },\n  minThickness: {\n    min: 1,\n    max: 10,\n    \"default\": 1\n  },\n  maxThickness: {\n    min: 1,\n    max: 20,\n    \"default\": 13\n  },\n  lineCap: {\n    options: ['butt', 'round'],\n    \"default\": 'butt'\n  },\n  rotation: {\n    min: -180,\n    max: 180,\n    \"default\": 0\n  },\n  // Overall rotation\n  spread: {\n    min: 0,\n    max: 360,\n    \"default\": 360\n  } // How far lines spread around circle\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IncreasingRadialShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/IncreasingRadialShape.js?");

/***/ }),

/***/ "./src/shapes/InterlockingArcs.js":
/*!****************************************!*\
  !*** ./src/shapes/InterlockingArcs.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a shape of multiple thick, circular arcs arranged symmetrically\n * around the center, appearing to interlock.\n */\nvar InterlockingArcs = /*#__PURE__*/function (_Shape) {\n  function InterlockingArcs() {\n    _classCallCheck(this, InterlockingArcs);\n    return _callSuper(this, InterlockingArcs, arguments);\n  }\n  _inherits(InterlockingArcs, _Shape);\n  return _createClass(InterlockingArcs, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Access parameters using `this`:\n      var numArms = this.numArms;\n      var radius = this.radius;\n      var thickness = this.thickness;\n      var arcAngle = this.arcAngle;\n      var rotationOffset = this.rotationOffset;\n\n      // --- Shape generation logic starts here ---\n      var paths = [];\n      var angleStep = 360 / numArms; // Angle between the logical placement axis of adjacent arms\n\n      // Check for potential radius/thickness issue, though limits should prevent it\n      // The maximum extent of the shape is roughly radius + thickness / 2.\n      // Parameter limits (max radius 75, max thickness 45) ensure 75 + 45/2 = 97.5 < 100.\n\n      for (var i = 0; i < numArms; i++) {\n        // Calculate the effective end angle for this arm's centerline based on its index and the overall rotation.\n        // Angles are measured counter-clockwise from the positive X-axis in a standard Cartesian system.\n        var endAngleDeg = i * angleStep + rotationOffset;\n\n        // Calculate the effective start angle based on the end angle and the desired arc sweep angle.\n        // Since the SVG arc sweep is clockwise (sweepFlag=0), the start angle value needs to be\n        // mathematically larger than the end angle (representing an earlier point in CCW measurement).\n        var startAngleDeg = endAngleDeg + arcAngle;\n\n        // Convert degrees to radians for use in trigonometric functions (Math.cos, Math.sin)\n        var startAngleRad = startAngleDeg * Math.PI / 180;\n        var endAngleRad = endAngleDeg * Math.PI / 180;\n\n        // Calculate the SVG path start point (M) on the centerline circle\n        var startX = radius * Math.cos(startAngleRad);\n        var startY = radius * Math.sin(startAngleRad);\n\n        // Calculate the SVG path end point (where the arc command 'A' goes to) on the centerline circle\n        var endX = radius * Math.cos(endAngleRad);\n        var endY = radius * Math.sin(endAngleRad);\n\n        // Determine the large-arc-flag based on the arcAngle.\n        // This flag is 1 if the angle sweep is greater than 180 degrees, 0 otherwise.\n        var largeArcFlag = arcAngle > 180 ? 1 : 0;\n\n        // Define the sweep-flag. For clockwise arcs (as seen in the reference image), this flag is 0.\n        // A sweep-flag of 1 would draw the arc counter-clockwise.\n        var sweepFlag = 0;\n\n        // Construct the SVG path data string ('d' attribute) for this arc segment\n        // Format: M startX,startY A rx,ry x-axis-rotation large-arc-flag sweep-flag endX,endY\n        // Using equal rx and ry (this.radius) makes it a circular arc segment.\n        // x-axis-rotation is 0 for non-rotated ellipses/circles.\n        // Using .toFixed(3) for cleaner SVG output with reasonable precision.\n        var pathData = \"M \".concat(startX.toFixed(3), \",\").concat(startY.toFixed(3), \" A \").concat(radius.toFixed(3), \",\").concat(radius.toFixed(3), \" 0 \").concat(largeArcFlag, \" \").concat(sweepFlag, \" \").concat(endX.toFixed(3), \",\").concat(endY.toFixed(3));\n\n        // Create the SVG <path> element string for this arm\n        // - fill=\"none\": We only want the stroke to be visible.\n        // - stroke=\"white\": The color of the arm.\n        // - stroke-width: Determines the thickness of the arm, using the 'thickness' parameter.\n        // - stroke-linecap=\"butt\": Makes the ends of the thick stroke flat and square, matching the reference image.\n        //   Other options include \"round\" or \"square\" (which extends beyond the endpoint).\n        paths.push(\"<path d=\\\"\".concat(pathData, \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(thickness, \"\\\" stroke-linecap=\\\"butt\\\" />\"));\n      }\n\n      // Join all individual path strings into a single SVG string output.\n      // Each path represents one arm of the shape.\n      return paths.join('\\n');\n      // --- Shape generation logic ends here ---\n    }\n\n    // No helper methods needed for this shape's calculations.\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(InterlockingArcs, \"parameters\", {\n  numArms: {\n    type: 'number',\n    min: 2,\n    max: 8,\n    // Allow 2 to 8 arms for variation\n    step: 1,\n    \"default\": 4,\n    label: 'Number of Arms' // Descriptive label for UI\n  },\n  radius: {\n    type: 'number',\n    min: 10,\n    max: 75,\n    // Max centerline radius, adjusted to stay within bounds (-100 to 100) with max thickness\n    step: 1,\n    \"default\": 55,\n    label: 'Center Radius' // Radius of the centerline path for the arcs\n  },\n  thickness: {\n    type: 'number',\n    min: 2,\n    max: 45,\n    // Max arm thickness, adjusted to stay within bounds with max radius\n    step: 1,\n    \"default\": 30,\n    label: 'Arm Thickness' // Thickness of each arc (stroke-width)\n  },\n  arcAngle: {\n    type: 'number',\n    min: 30,\n    max: 170,\n    // Max angle for each arc segment to prevent excessive visual overlap, especially with fewer arms\n    step: 1,\n    \"default\": 90,\n    label: 'Arc Angle ()' // Angular extent of each arm in degrees\n  },\n  rotationOffset: {\n    type: 'number',\n    min: 0,\n    max: 360,\n    step: 1,\n    \"default\": 0,\n    label: 'Rotation ()' // Overall rotation of the figure in degrees\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (InterlockingArcs);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/InterlockingArcs.js?");

/***/ }),

/***/ "./src/shapes/JaggedSquircle.js":
/*!**************************************!*\
  !*** ./src/shapes/JaggedSquircle.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a shape merging a squircle (superellipse) with a star, creating\n * jagged, curved points.\n */\nvar JaggedSquircle = /*#__PURE__*/function (_Shape) {\n  function JaggedSquircle() {\n    _classCallCheck(this, JaggedSquircle);\n    return _callSuper(this, JaggedSquircle, arguments);\n  }\n  _inherits(JaggedSquircle, _Shape);\n  return _createClass(JaggedSquircle, [{\n    key: \"getSquirclePoint\",\n    value:\n    /**\n     * Calculates a point on a superellipse (squircle when power > 2).\n     * This uses the form where radius corresponds to the maximum extent.\n     * @param {number} angle - The angle in radians.\n     * @param {number} radius - The radius parameter for the superellipse.\n     * @returns {{x: number, y: number}} The coordinates of the point.\n     */\n    function getSquirclePoint(angle, radius) {\n      // Use instance parameters\n      var power = this.power;\n      var cosT = Math.cos(angle);\n      var sinT = Math.sin(angle);\n      var absCosT = Math.abs(cosT);\n      var absSinT = Math.abs(sinT);\n\n      // Calculate terms for the superellipse equation |x/r|^n + |y/r|^n = 1\n      // Using parametric form derived from this: x = r*scale*cosT, y = r*scale*sinT\n      var term1 = Math.pow(absCosT, power);\n      var term2 = Math.pow(absSinT, power);\n      var sumTerms = term1 + term2;\n\n      // Avoid division by zero or potential issues if sumTerms is 0\n      // (Can happen if angle is 0, pi/2, etc. AND power is Infinity, but power is capped at 10)\n      // Or if cosT and sinT are both extremely close to zero (not possible).\n      // If sumTerms is very small, scale could become very large.\n      if (sumTerms < 1e-9) {\n        // Check for near-zero sum\n        // This case is unlikely with power >= 2 unless radius is 0\n        // If radius is 0, return {0,0}. Otherwise, might indicate an issue.\n        // Let's assume radius > 0. If we are at an angle where both cos/sin are effectively 0 based on power,\n        // maybe return the point on the axis?\n        // However, mathematically, sumTerms should only be 0 if power is infinite and angle is not on axis/diagonal.\n        // Given constraints, let's return 0,0 as a safe fallback.\n        return {\n          x: 0,\n          y: 0\n        };\n      }\n\n      // Calculate the scaling factor\n      var scale = Math.pow(sumTerms, -1 / power);\n      var x = radius * scale * cosT;\n      var y = radius * scale * sinT;\n\n      // Final check for NaN/Infinity which might occur with edge cases like power=2 and angle=pi/4 etc.\n      // Although the math seems okay, floating point issues can arise.\n      if (!isFinite(x) || !isFinite(y)) {\n        // Fallback: Use simpler circle calculation if scale fails\n        // console.warn(`Non-finite value detected: x=${x}, y=${y}. Falling back.`);\n        x = radius * cosT;\n        y = radius * sinT;\n        // Or return 0,0\n        // return { x: 0, y: 0 };\n      }\n      return {\n        x: x,\n        y: y\n      };\n    }\n\n    /**\n     * Generates the SVG elements for the JaggedSquircle shape.\n     * Accesses parameters via `this.parameterName`.\n     * @returns {string} SVG string containing a <path> element.\n     */\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Access parameters via `this`\n      var outerRadius = this.radius;\n      var innerRadius = this.radius * this.innerRadiusRatio;\n      // Ensure numBlades is an integer and at least 1\n      var numBlades = Math.max(1, Math.round(this.numBlades));\n      var outerPoints = [];\n      var innerPoints = []; // These will be the control points for the quadratic Beziers\n\n      // Calculate points for the peaks (outer) and valleys (inner/control)\n      for (var i = 0; i < numBlades; i++) {\n        // Angle for the peak (outer point)\n        var angleOuter = i * 2 * Math.PI / numBlades;\n        // Angle for the valley (inner point, used as control point)\n        var angleInner = (i + 0.5) * 2 * Math.PI / numBlades;\n        outerPoints.push(this.getSquirclePoint(angleOuter, outerRadius));\n        innerPoints.push(this.getSquirclePoint(angleInner, innerRadius));\n      }\n\n      // Check if points were generated successfully\n      if (outerPoints.length === 0 || innerPoints.length === 0) {\n        console.error(\"Failed to generate points for JaggedSquircle\");\n        return ''; // Return empty string if point generation failed\n      }\n\n      // Construct the SVG path data using quadratic Bezier curves\n      // Start at the first outer point\n      var d = \"M \".concat(outerPoints[0].x.toFixed(3), \" \").concat(outerPoints[0].y.toFixed(3), \" \");\n\n      // Add quadratic Bezier segments: Q controlPoint endPoint\n      for (var _i = 0; _i < numBlades; _i++) {\n        var nextOuterIdx = (_i + 1) % numBlades; // Loop back to the first point\n        var controlPoint = innerPoints[_i];\n        var endPoint = outerPoints[nextOuterIdx];\n\n        // Ensure points are valid numbers before adding to path\n        if (isFinite(controlPoint.x) && isFinite(controlPoint.y) && isFinite(endPoint.x) && isFinite(endPoint.y)) {\n          d += \"Q \".concat(controlPoint.x.toFixed(3), \" \").concat(controlPoint.y.toFixed(3), \" \").concat(endPoint.x.toFixed(3), \" \").concat(endPoint.y.toFixed(3), \" \");\n        } else {\n          console.warn(\"Skipping segment due to invalid point data at index \".concat(_i));\n          // Optionally, draw a line segment as fallback?\n          // d += `L ${endPoint.x.toFixed(3)} ${endPoint.y.toFixed(3)} `;\n        }\n      }\n      d += \"Z\"; // Close the path\n\n      // Return the path element\n      return \"<path d=\\\"\".concat(d, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(JaggedSquircle, \"parameters\", {\n  radius: {\n    type: 'number',\n    min: 10,\n    max: 100,\n    step: 1,\n    \"default\": 90,\n    label: 'Radius'\n  },\n  innerRadiusRatio: {\n    type: 'number',\n    min: 0.1,\n    max: 0.99,\n    step: 0.01,\n    \"default\": 0.75,\n    label: 'Jaggedness (Inner Ratio)' // Renamed for clarity\n  },\n  numBlades: {\n    type: 'number',\n    min: 3,\n    max: 60,\n    step: 1,\n    \"default\": 16,\n    label: 'Number of Blades'\n  },\n  power: {\n    type: 'number',\n    min: 2,\n    // Circle\n    max: 10,\n    // Very square\n    step: 0.1,\n    \"default\": 4,\n    // Squircle\n    label: 'Shape Power (2=Circle)'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (JaggedSquircle);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/JaggedSquircle.js?");

/***/ }),

/***/ "./src/shapes/KandinskyLines.js":
/*!**************************************!*\
  !*** ./src/shapes/KandinskyLines.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates an abstract composition of randomly placed and oriented lines with\n * varying lengths and widths, inspired by Kandinsky.\n */\nvar KandinskyLines = /*#__PURE__*/function (_Shape) {\n  function KandinskyLines() {\n    _classCallCheck(this, KandinskyLines);\n    return _callSuper(this, KandinskyLines, arguments);\n  }\n  _inherits(KandinskyLines, _Shape);\n  return _createClass(KandinskyLines, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var lines = [];\n      var maxBoundary = 100; // ViewBox half-width/height (-100 to +100)\n\n      for (var i = 0; i < this.numLines; i++) {\n        // 1. Generate random properties for the line using instance parameters\n        var length = this.minLength + this.random() * (this.maxLength - this.minLength);\n        var strokeWidth = this.minWidth + this.random() * (this.maxWidth - this.minWidth);\n        var angle = this.random() * 2 * Math.PI; // Random orientation angle for the line\n\n        // 2. Generate a random center point (cx, cy) for the line\n        // Use polar coordinates to distribute points within the 'spread' radius\n        var centerRadius = this.random() * this.spread;\n        var centerAngle = this.random() * 2 * Math.PI;\n        var cx = centerRadius * Math.cos(centerAngle);\n        var cy = centerRadius * Math.sin(centerAngle);\n\n        // 3. Calculate start (x1, y1) and end (x2, y2) points based on center, length, and orientation angle\n        var halfLength = length / 2;\n        var dx = halfLength * Math.cos(angle);\n        var dy = halfLength * Math.sin(angle);\n        var x1 = cx - dx;\n        var y1 = cy - dy;\n        var x2 = cx + dx;\n        var y2 = cy + dy;\n\n        // 4. Create SVG <line> element string\n        // Use .toFixed(2) for cleaner SVG output\n        // stroke-linecap=\"butt\" makes the line ends flat, matching the reference style\n        lines.push(\"<line x1=\\\"\".concat(x1.toFixed(2), \"\\\" y1=\\\"\").concat(y1.toFixed(2), \"\\\" x2=\\\"\").concat(x2.toFixed(2), \"\\\" y2=\\\"\").concat(y2.toFixed(2), \"\\\"\\n                      stroke=\\\"white\\\" stroke-width=\\\"\").concat(strokeWidth.toFixed(2), \"\\\" fill=\\\"none\\\" stroke-linecap=\\\"butt\\\" />\"));\n      }\n\n      // 5. Join all line strings into a single SVG group or directly return joined strings\n      // Adding a <g> element isn't strictly necessary but can be useful for applying group transforms later if needed.\n      // return `<g>${lines.join('\\n')}</g>`;\n      return lines.join('\\n'); // Return just the line elements as per requirement\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(KandinskyLines, \"parameters\", {\n  numLines: {\n    type: 'number',\n    min: 3,\n    max: 25,\n    step: 1,\n    \"default\": 10,\n    description: 'Number of lines in the composition'\n  },\n  minLength: {\n    type: 'number',\n    min: 5,\n    max: 80,\n    step: 1,\n    \"default\": 20,\n    description: 'Minimum length of a line'\n  },\n  maxLength: {\n    type: 'number',\n    min: 30,\n    max: 160,\n    step: 1,\n    \"default\": 80,\n    description: 'Maximum length of a line'\n  },\n  minWidth: {\n    type: 'number',\n    min: 1,\n    max: 10,\n    step: 0.5,\n    \"default\": 2,\n    description: 'Minimum stroke width (weight) of a line'\n  },\n  maxWidth: {\n    type: 'number',\n    min: 2,\n    max: 20,\n    step: 0.5,\n    \"default\": 6,\n    description: 'Maximum stroke width (weight) of a line'\n  },\n  spread: {\n    type: 'number',\n    min: 10,\n    max: 95,\n    // Keep slightly within bounds to avoid lines being perfectly centered on edge\n    step: 1,\n    \"default\": 65,\n    description: 'Controls how far from the center lines can originate'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (KandinskyLines);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/KandinskyLines.js?");

/***/ }),

/***/ "./src/shapes/Keyhole.js":
/*!*******************************!*\
  !*** ./src/shapes/Keyhole.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a keyhole shape combining a circular top part (with optional inner\n * hole) and a trapezoidal slot below.\n */\nvar KeyholeShape = /*#__PURE__*/function (_Shape) {\n  function KeyholeShape() {\n    _classCallCheck(this, KeyholeShape);\n    return _callSuper(this, KeyholeShape, arguments);\n  }\n  _inherits(KeyholeShape, _Shape);\n  return _createClass(KeyholeShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var shapes = [];\n\n      // Generate the outer circular top part\n      shapes.push(\"<circle \\n            cx=\\\"\".concat(this.circleOffset, \"\\\" \\n            cy=\\\"\").concat(-this.slotLength / 2, \"\\\" \\n            r=\\\"\").concat(this.circleRadius, \"\\\"\\n            fill=\\\"white\\\"\\n        />\"));\n\n      // Inner circle (hole)\n      if (this.innerCircleRadius > 0) {\n        shapes.push(\"<circle \\n                cx=\\\"\".concat(this.circleOffset, \"\\\" \\n                cy=\\\"\").concat(-this.slotLength / 2, \"\\\" \\n                r=\\\"\").concat(this.innerCircleRadius, \"\\\"\\n                fill=\\\"black\\\"\\n            />\"));\n      }\n\n      // Generate the straight slot using a path\n      var slotPath = \"\\n            M \".concat(-this.slotTopWidth / 2 + this.circleOffset, \" \").concat(-this.slotLength / 2, \"\\n            L \").concat(-this.slotBottomWidth / 2, \" \").concat(this.slotLength / 2, \"\\n            L \").concat(this.slotBottomWidth / 2, \" \").concat(this.slotLength / 2, \"\\n            L \").concat(this.slotTopWidth / 2 + this.circleOffset, \" \").concat(-this.slotLength / 2, \"\\n            Z\");\n      shapes.push(\"<path \\n            d=\\\"\".concat(slotPath, \"\\\"\\n            fill=\\\"white\\\"\\n        />\"));\n      return shapes.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(KeyholeShape, \"parameters\", {\n  circleRadius: {\n    min: 10,\n    max: 50,\n    \"default\": 40\n  },\n  slotLength: {\n    min: 20,\n    max: 150,\n    \"default\": 80\n  },\n  slotTopWidth: {\n    min: 5,\n    max: 50,\n    \"default\": 20\n  },\n  slotBottomWidth: {\n    min: 5,\n    max: 50,\n    \"default\": 30\n  },\n  circleOffset: {\n    min: -30,\n    max: 30,\n    \"default\": 0\n  },\n  innerCircleRadius: {\n    min: 0,\n    max: 50,\n    \"default\": 25\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (KeyholeShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/Keyhole.js?");

/***/ }),

/***/ "./src/shapes/KochCurve.js":
/*!*********************************!*\
  !*** ./src/shapes/KochCurve.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a Koch snowflake fractal curve with adjustable iterations, size,\n * angle factor, and optional rounding.\n */\nvar KochCurve = /*#__PURE__*/function (_Shape) {\n  function KochCurve() {\n    _classCallCheck(this, KochCurve);\n    return _callSuper(this, KochCurve, arguments);\n  }\n  _inherits(KochCurve, _Shape);\n  return _createClass(KochCurve, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var startSize = this.baseSize;\n\n      // Create base shape - an equilateral triangle\n      var height = startSize * Math.sqrt(3) / 2;\n      var startPoints = [{\n        x: -startSize / 2,\n        y: height / 3\n      }, {\n        x: startSize / 2,\n        y: height / 3\n      }, {\n        x: 0,\n        y: -height * 2 / 3\n      }];\n\n      // Reset RNG to ensure consistent results with the same seed\n      this.resetRNG();\n\n      // Generate the Koch snowflake\n      var paths = [];\n      for (var i = 0; i < 3; i++) {\n        var start = startPoints[i];\n        var end = startPoints[(i + 1) % 3];\n        var segmentPoints = this.generateKochSegment(start.x, start.y, end.x, end.y, this.iterations, this.outwardFactor, this.segmentRatio);\n        var pathData = \"M \".concat(segmentPoints[0].x, \" \").concat(segmentPoints[0].y);\n        if (this.roundness > 0 && segmentPoints.length > 2) {\n          // Create a smoother curve if roundness is enabled\n          for (var j = 1; j < segmentPoints.length - 1; j++) {\n            var cp1 = segmentPoints[j];\n            var p2 = segmentPoints[j + 1];\n            var prevPoint = segmentPoints[j - 1];\n            var curPoint = segmentPoints[j];\n            var nextPoint = segmentPoints[j + 1];\n\n            // Blend between straight lines and curves based on roundness\n            if (this.roundness > 0) {\n              var tension = this.roundness * 0.4;\n              var dx1 = curPoint.x - prevPoint.x;\n              var dy1 = curPoint.y - prevPoint.y;\n              var dx2 = nextPoint.x - curPoint.x;\n              var dy2 = nextPoint.y - curPoint.y;\n              var cp1x = curPoint.x - dx1 * tension;\n              var cp1y = curPoint.y - dy1 * tension;\n              var cp2x = curPoint.x + dx2 * tension;\n              var cp2y = curPoint.y + dy2 * tension;\n              pathData += \" C \".concat(cp1x, \",\").concat(cp1y, \" \").concat(cp2x, \",\").concat(cp2y, \" \").concat(nextPoint.x, \",\").concat(nextPoint.y);\n              j++; // Skip the next point as we've already used it\n            } else {\n              pathData += \" L \".concat(curPoint.x, \",\").concat(curPoint.y);\n            }\n          }\n\n          // Add the last point if we haven't already\n          if (segmentPoints.length % 2 === 0) {\n            var lastPoint = segmentPoints[segmentPoints.length - 1];\n            pathData += \" L \".concat(lastPoint.x, \",\").concat(lastPoint.y);\n          }\n        } else {\n          // Use straight lines\n          for (var _j = 1; _j < segmentPoints.length; _j++) {\n            pathData += \" L \".concat(segmentPoints[_j].x, \",\").concat(segmentPoints[_j].y);\n          }\n        }\n        paths.push(pathData);\n      }\n      return \"<path \\n            d=\\\"\".concat(paths.join(' '), \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            fill=\\\"none\\\"\\n            stroke-linecap=\\\"round\\\"\\n            stroke-linejoin=\\\"round\\\"\\n        />\");\n    }\n  }, {\n    key: \"generateKochSegment\",\n    value: function generateKochSegment(x1, y1, x2, y2, depth, outwardFactor, segmentRatio) {\n      if (depth <= 0) {\n        return [{\n          x: x1,\n          y: y1\n        }, {\n          x: x2,\n          y: y2\n        }];\n      }\n\n      // Calculate the points\n      var points = [];\n\n      // First point\n      points.push({\n        x: x1,\n        y: y1\n      });\n\n      // Koch curve construction\n      var dx = x2 - x1;\n      var dy = y2 - y1;\n      var dist = Math.sqrt(dx * dx + dy * dy);\n\n      // Calculate segment ratio\n      var baseRatio = segmentRatio;\n\n      // Point at 1/3 of the distance\n      var p1x = x1 + dx * baseRatio;\n      var p1y = y1 + dy * baseRatio;\n\n      // Point at 2/3 of the distance\n      var p3x = x1 + dx * (1 - baseRatio);\n      var p3y = y1 + dy * (1 - baseRatio);\n\n      // The apex of the equilateral triangle\n      var angle = Math.atan2(dy, dx) - Math.PI / 2; // Perpendicular to the line\n      var apexDist = dist * baseRatio * outwardFactor;\n      var p2x = (p1x + p3x) / 2 + Math.cos(angle) * apexDist;\n      var p2y = (p1y + p3y) / 2 + Math.sin(angle) * apexDist;\n\n      // Recursively compute the four line segments\n      var segment1 = this.generateKochSegment(x1, y1, p1x, p1y, depth - 1, outwardFactor, segmentRatio);\n      var segment2 = this.generateKochSegment(p1x, p1y, p2x, p2y, depth - 1, outwardFactor, segmentRatio);\n      var segment3 = this.generateKochSegment(p2x, p2y, p3x, p3y, depth - 1, outwardFactor, segmentRatio);\n      var segment4 = this.generateKochSegment(p3x, p3y, x2, y2, depth - 1, outwardFactor, segmentRatio);\n\n      // Combine segments (avoid duplicates)\n      points.push.apply(points, _toConsumableArray(segment1.slice(1)));\n      points.push.apply(points, _toConsumableArray(segment2.slice(1)));\n      points.push.apply(points, _toConsumableArray(segment3.slice(1)));\n      points.push.apply(points, _toConsumableArray(segment4.slice(1)));\n      return points;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(KochCurve, \"parameters\", {\n  iterations: {\n    min: 1,\n    max: 5,\n    \"default\": 3\n  },\n  baseSize: {\n    min: 50,\n    max: 200,\n    \"default\": 150\n  },\n  outwardFactor: {\n    min: 0.1,\n    max: 1.5,\n    \"default\": 0.58\n  },\n  segmentRatio: {\n    min: 0.25,\n    max: 0.45,\n    \"default\": 0.33\n  },\n  roundness: {\n    min: 0,\n    max: 1,\n    \"default\": 0\n  },\n  thickness: {\n    min: 1,\n    max: 8,\n    \"default\": 2\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (KochCurve);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/KochCurve.js?");

/***/ }),

/***/ "./src/shapes/LadderShape.js":
/*!***********************************!*\
  !*** ./src/shapes/LadderShape.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a simple ladder shape with one vertical bar and multiple horizontal\n * rungs (segments).\n */\nvar LadderShape = /*#__PURE__*/function (_Shape) {\n  function LadderShape() {\n    _classCallCheck(this, LadderShape);\n    return _callSuper(this, LadderShape, arguments);\n  }\n  _inherits(LadderShape, _Shape);\n  return _createClass(LadderShape, [{\n    key: \"validateOptions\",\n    value: function validateOptions(options) {\n      var validated = _objectSpread({}, options);\n\n      // Ensure verticalWidth is never larger than horizontalWidth\n      if ('verticalWidth' in options && 'horizontalWidth' in options) {\n        if (options.verticalWidth >= options.horizontalWidth) {\n          validated.verticalWidth = Math.min(options.verticalWidth, options.horizontalWidth * 0.5);\n        }\n      } else if ('verticalWidth' in options) {\n        validated.verticalWidth = Math.min(options.verticalWidth, this.horizontalWidth * 0.5);\n      }\n\n      // Ensure spacing is proportional to thickness\n      if ('thickness' in options && 'spacing' in options) {\n        validated.spacing = Math.max(options.spacing, options.thickness * 1.2);\n      } else if ('thickness' in options) {\n        validated.spacing = Math.max(this.spacing, options.thickness * 1.2);\n      }\n      return validated;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var parts = [];\n\n      // Calculate total height to center the shape\n      var totalHeight = (this.segments - 1) * this.spacing;\n      var startY = -totalHeight / 2;\n\n      // Add vertical bar\n      var verticalBar = \"<rect \\n            x=\\\"\".concat(-this.verticalWidth / 2, \"\\\"\\n            y=\\\"\").concat(startY - this.thickness / 2, \"\\\"\\n            width=\\\"\").concat(this.verticalWidth, \"\\\"\\n            height=\\\"\").concat(totalHeight + this.thickness, \"\\\"\\n            fill=\\\"white\\\"\\n        />\");\n      parts.push(verticalBar);\n\n      // Add horizontal segments\n      for (var i = 0; i < this.segments; i++) {\n        var y = startY + i * this.spacing;\n        var horizontalSegment = \"<rect \\n                x=\\\"\".concat(-this.horizontalWidth / 2, \"\\\"\\n                y=\\\"\").concat(y - this.thickness / 2, \"\\\"\\n                width=\\\"\").concat(this.horizontalWidth, \"\\\"\\n                height=\\\"\").concat(this.thickness, \"\\\"\\n                fill=\\\"white\\\"\\n            />\");\n        parts.push(horizontalSegment);\n      }\n      return parts.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(LadderShape, \"parameters\", {\n  segments: {\n    min: 2,\n    max: 8,\n    \"default\": 5\n  },\n  verticalWidth: {\n    min: 20,\n    max: 60,\n    \"default\": 40\n  },\n  // Narrower range to ensure good proportions\n  horizontalWidth: {\n    min: 60,\n    max: 200,\n    \"default\": 135\n  },\n  // Must be larger than verticalWidth\n  thickness: {\n    min: 10,\n    max: 50,\n    \"default\": 20\n  },\n  // Increased minimum to avoid thin lines\n  spacing: {\n    min: 30,\n    max: 80,\n    \"default\": 40\n  } // Relative to thickness for good spacing\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LadderShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/LadderShape.js?");

/***/ }),

/***/ "./src/shapes/LanternShape.js":
/*!************************************!*\
  !*** ./src/shapes/LanternShape.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a shape resembling a stylized lantern with a central outlined\n * circle and two flanking outlined arcs.\n */\nvar LanternShape = /*#__PURE__*/function (_Shape) {\n  function LanternShape() {\n    _classCallCheck(this, LanternShape);\n    return _callSuper(this, LanternShape, arguments);\n  }\n  _inherits(LanternShape, _Shape);\n  return _createClass(LanternShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Generate center circle with outline instead of fill\n      var circle = \"<circle \\n            cx=\\\"0\\\" \\n            cy=\\\"0\\\" \\n            r=\\\"\".concat(this.radius, \"\\\"\\n            fill=\\\"none\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n        />\");\n\n      // Calculate positions for left and right arcs with gap consideration\n      var leftArc = this.createArc(-90 + this.arcStart, this.arcLength, -this.gap / 2);\n      var rightArc = this.createArc(90 + this.arcStart, this.arcLength, this.gap / 2);\n      return \"\\n            \".concat(circle, \"\\n            \").concat(leftArc, \"\\n            \").concat(rightArc, \"\\n        \");\n    }\n  }, {\n    key: \"createArc\",\n    value: function createArc(baseAngle, arcLength, offset) {\n      var startAngle = (baseAngle - arcLength / 2) * (Math.PI / 180);\n      var endAngle = (baseAngle + arcLength / 2) * (Math.PI / 180);\n\n      // Add offset to arc position\n      var arcCenterX = offset;\n      var startX = arcCenterX + this.arcRadius * Math.cos(startAngle);\n      var startY = this.arcRadius * Math.sin(startAngle);\n      var endX = arcCenterX + this.arcRadius * Math.cos(endAngle);\n      var endY = this.arcRadius * Math.sin(endAngle);\n      var largeArcFlag = arcLength > 180 ? 1 : 0;\n      return \"<path \\n            d=\\\"M \".concat(startX, \" \").concat(startY, \" A \").concat(this.arcRadius, \" \").concat(this.arcRadius, \" 0 \").concat(largeArcFlag, \" 1 \").concat(endX, \" \").concat(endY, \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            stroke-linecap=\\\"round\\\"\\n            fill=\\\"none\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(LanternShape, \"parameters\", {\n  radius: {\n    min: 20,\n    max: 100,\n    \"default\": 31\n  },\n  arcRadius: {\n    min: 30,\n    max: 120,\n    \"default\": 51\n  },\n  thickness: {\n    min: 1,\n    max: 20,\n    \"default\": 8\n  },\n  arcStart: {\n    min: -90,\n    max: 90,\n    \"default\": -90\n  },\n  arcLength: {\n    min: 10,\n    max: 180,\n    \"default\": 60\n  },\n  gap: {\n    min: 0,\n    max: 100,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LanternShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/LanternShape.js?");

/***/ }),

/***/ "./src/shapes/LayeredBlob.js":
/*!***********************************!*\
  !*** ./src/shapes/LayeredBlob.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates multiple concentric layers of outlined blob shapes with decreasing\n * size.\n */\nvar LayeredBlobShape = /*#__PURE__*/function (_Shape) {\n  function LayeredBlobShape() {\n    _classCallCheck(this, LayeredBlobShape);\n    return _callSuper(this, LayeredBlobShape, arguments);\n  }\n  _inherits(LayeredBlobShape, _Shape);\n  return _createClass(LayeredBlobShape, [{\n    key: \"_toRad\",\n    value: function _toRad(deg) {\n      return deg * (Math.PI / 180.0);\n    }\n  }, {\n    key: \"_divide\",\n    value: function _divide(count) {\n      // Ensure count is a positive integer\n      var safeCount = Math.max(1, Math.floor(count));\n      var deg = 360 / safeCount;\n      return Array(safeCount).fill(0).map(function (_, i) {\n        return i * deg;\n      });\n    }\n  }, {\n    key: \"_randomDoubleGenerator\",\n    value: function _randomDoubleGenerator(s) {\n      var mask = 0xffffffff;\n      var m_w = 123456789 + s & mask;\n      var m_z = 987654321 - s & mask;\n      return function () {\n        m_z = 36969 * (m_z & 65535) + (m_z >>> 16) & mask;\n        m_w = 18000 * (m_w & 65535) + (m_w >>> 16) & mask;\n        var result = (m_z << 16) + (m_w & 65535) >>> 0;\n        result /= 4294967296;\n        return result;\n      };\n    }\n  }, {\n    key: \"_magicPoint\",\n    value: function _magicPoint(value, min, max) {\n      var radius = min + value * (max - min);\n      if (radius > max) {\n        radius = radius - min;\n      } else if (radius < min) {\n        radius = radius + min;\n      }\n      return radius;\n    }\n  }, {\n    key: \"_point\",\n    value: function _point(origin, radius, degree) {\n      var skewRad = this._toRad(this.skew);\n      var angle = this._toRad(degree) + skewRad;\n      var x = origin + radius * Math.cos(angle);\n      var y = origin + radius * Math.sin(angle);\n      return [Math.round(x), Math.round(y)];\n    }\n  }, {\n    key: \"_createPoints\",\n    value: function _createPoints(size, minGrowth, edgesCount, seed) {\n      var _this = this;\n      // Ensure edgesCount is valid\n      var safeEdgesCount = Math.max(3, Math.floor(edgesCount));\n      var outerRad = Math.max(1, size / 2);\n      var innerRad = Math.max(1, minGrowth * (outerRad / 10));\n      var center = 0; // Centered at origin for SVG viewBox\n      var slices = this._divide(safeEdgesCount);\n      var seedValue = seed || Math.floor(this.random() * 99999);\n      var randVal = this._randomDoubleGenerator(seedValue);\n      return slices.map(function (degree) {\n        var radius = _this._magicPoint(randVal(), innerRad, outerRad);\n        return _this._point(center, radius, degree);\n      });\n    }\n  }, {\n    key: \"_createSvgPath\",\n    value: function _createSvgPath(points) {\n      var svgPath = '';\n      var mid = [(points[0][0] + points[1][0]) / 2, (points[0][1] + points[1][1]) / 2];\n      svgPath += \"M\".concat(mid[0], \",\").concat(mid[1]);\n      for (var i = 0; i < points.length; i++) {\n        var p1 = points[(i + 1) % points.length];\n        var p2 = points[(i + 2) % points.length];\n        var nextMid = [(p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2];\n        svgPath += \"Q\".concat(p1[0], \",\").concat(p1[1], \",\").concat(nextMid[0], \",\").concat(nextMid[1]);\n      }\n      return svgPath + 'Z';\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var paths = [];\n      var baseSize = 100;\n\n      // Ensure layers is valid\n      var safeLayers = Math.max(1, Math.min(5, Math.floor(this.layers)));\n\n      // Generate multiple layers with decreasing size\n      for (var i = 0; i < safeLayers; i++) {\n        var size = Math.max(10, baseSize * (1 - i * 0.2));\n        var points = this._createPoints(size * 2, this.growth, this.edges, i);\n        var pathString = this._createSvgPath(points);\n        paths.push(\"<path \\n                d=\\\"\".concat(pathString, \"\\\"\\n                fill=\\\"none\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            />\"));\n      }\n      return paths.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(LayeredBlobShape, \"parameters\", {\n  edges: {\n    min: 3,\n    max: 12,\n    \"default\": 5\n  },\n  layers: {\n    min: 1,\n    max: 5,\n    \"default\": 5\n  },\n  growth: {\n    min: 2,\n    max: 10,\n    \"default\": 6\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 5\n  },\n  skew: {\n    min: -90,\n    max: 90,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LayeredBlobShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/LayeredBlob.js?");

/***/ }),

/***/ "./src/shapes/LayeredBlobsMaskShape.js":
/*!*********************************************!*\
  !*** ./src/shapes/LayeredBlobsMaskShape.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a pattern of radial lines clipped between an inner circle and an\n * outer blob shape, using SVG masks.\n */\nvar LayeredBlobsMaskShape = /*#__PURE__*/function (_Shape) {\n  function LayeredBlobsMaskShape() {\n    _classCallCheck(this, LayeredBlobsMaskShape);\n    return _callSuper(this, LayeredBlobsMaskShape, arguments);\n  }\n  _inherits(LayeredBlobsMaskShape, _Shape);\n  return _createClass(LayeredBlobsMaskShape, [{\n    key: \"toRad\",\n    value: function toRad(deg) {\n      return deg * (Math.PI / 180.0);\n    }\n  }, {\n    key: \"divide\",\n    value: function divide(count) {\n      var deg = 360.0 / count;\n      return Array.from({\n        length: count\n      }, function (_, i) {\n        return i * deg;\n      });\n    }\n  }, {\n    key: \"randomDouble\",\n    value: function randomDouble(seed) {\n      var mask = 0xffffffff;\n      var m_w = 123456789 + seed & mask;\n      var m_z = 987654321 - seed & mask;\n      return function () {\n        m_z = 36969 * (m_z & 65535) + (m_z >> 16) & mask;\n        m_w = 18000 * (m_w & 65535) + (m_w >> 16) & mask;\n        var result = (m_z << 16) + (m_w & 65535) >> 0;\n        return result / 0xffffffff;\n      };\n    }\n  }, {\n    key: \"magicPoint\",\n    value: function magicPoint(value, min, max) {\n      // Base radius calculation\n      var radius = min + value * (max - min);\n      if (this.amplitude > 0) {\n        // Calculate wave effects\n        var range = max - min;\n        var safeAmplitude = Math.min(this.amplitude, 4.5); // Cap amplitude to prevent extreme values\n\n        var primaryWave = Math.sin(this.currentAngle * this.frequency) * safeAmplitude * range * 0.4;\n        var secondaryWave = Math.sin(this.currentAngle * this.frequency * 2.7) * safeAmplitude * range * 0.15;\n        var tertiaryWave = Math.sin(this.currentAngle * this.frequency * 0.5) * safeAmplitude * range * 0.1;\n\n        // Add waves to radius with safety factor\n        radius += primaryWave + secondaryWave + tertiaryWave;\n      }\n\n      // Proper bounds handling - ensure radius stays within valid range\n      if (radius > max) {\n        radius = max; // Simply cap at maximum\n      } else if (radius < min) {\n        radius = min; // Simply cap at minimum\n      }\n      return radius;\n    }\n  }, {\n    key: \"point\",\n    value: function point(centerX, centerY, radius, degree) {\n      var skewRad = this.toRad(this.skew);\n      var angle = this.toRad(degree) + skewRad;\n      var x = centerX + radius * Math.cos(angle);\n      var y = centerY + radius * Math.sin(angle);\n      return {\n        x: x,\n        y: y\n      };\n    }\n  }, {\n    key: \"createPoints\",\n    value: function createPoints(size, minGrowth, edgesCount, seed) {\n      var _this = this;\n      var outerRad = size / 2;\n      var innerRad = minGrowth * (outerRad / 10);\n      var centerX = 0;\n      var centerY = 0;\n      var slices = this.divide(edgesCount);\n      var randVal = this.randomDouble(seed || this.seed);\n      return slices.map(function (degree) {\n        _this.currentAngle = _this.toRad(degree);\n        var radius = _this.magicPoint(randVal(), innerRad, outerRad);\n        return _this.point(centerX, centerY, radius, degree);\n      });\n    }\n  }, {\n    key: \"generateBlobPath\",\n    value: function generateBlobPath() {\n      var points = this.createPoints(this.radius * 2, this.growth, this.edges, this.seed);\n      if (points.length < 3) {\n        // Ensure we have enough points for a valid shape\n        return \"M0,\".concat(-this.radius, \" A\").concat(this.radius, \",\").concat(this.radius, \" 0 1,1 0,\").concat(this.radius, \" A\").concat(this.radius, \",\").concat(this.radius, \" 0 1,1 0,\").concat(-this.radius);\n      }\n      try {\n        // Generate path with proper error handling\n        var pathCommands = [];\n\n        // Calculate first midpoint safely\n        var start = {\n          x: (points[0].x + points[1].x) / 2,\n          y: (points[0].y + points[1].y) / 2\n        };\n        pathCommands.push(\"M\".concat(start.x.toFixed(2), \",\").concat(start.y.toFixed(2)));\n        for (var i = 0; i < points.length; i++) {\n          var p1 = points[(i + 1) % points.length];\n          var p2 = points[(i + 2) % points.length];\n\n          // Ensure all points are valid\n          if (isNaN(p1.x) || isNaN(p1.y) || isNaN(p2.x) || isNaN(p2.y)) {\n            continue;\n          }\n          var mid = {\n            x: (p1.x + p2.x) / 2,\n            y: (p1.y + p2.y) / 2\n          };\n          pathCommands.push(\"Q\".concat(p1.x.toFixed(2), \",\").concat(p1.y.toFixed(2), \",\").concat(mid.x.toFixed(2), \",\").concat(mid.y.toFixed(2)));\n        }\n        pathCommands.push('Z');\n        return pathCommands.join('');\n      } catch (error) {\n        // Fallback to a circle if path generation fails\n        return \"M0,\".concat(-this.radius, \" A\").concat(this.radius, \",\").concat(this.radius, \" 0 1,1 0,\").concat(this.radius, \" A\").concat(this.radius, \",\").concat(this.radius, \" 0 1,1 0,\").concat(-this.radius);\n      }\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Create unique IDs for the SVG elements\n      var outerClipId = \"outerClip_\".concat(Math.floor(this.random() * 1000000));\n      var innerClipId = \"innerClip_\".concat(Math.floor(this.random() * 1000000));\n\n      // Generate the blob path for the outer boundary\n      var blobPathData = this.generateBlobPath();\n\n      // Define the SVG elements\n      var elements = [];\n\n      // Definitions section\n      elements.push('<defs>');\n\n      // Clip path for the blob shape (outer boundary)\n      elements.push(\"<clipPath id=\\\"\".concat(outerClipId, \"\\\">\"));\n      elements.push(\"<path d=\\\"\".concat(blobPathData, \"\\\" />\"));\n      elements.push('</clipPath>');\n\n      // Create a \"donut\" shape that clips out the inner circle\n      elements.push(\"<clipPath id=\\\"\".concat(innerClipId, \"\\\">\"));\n      elements.push(\"<path d=\\\"\".concat(blobPathData, \"\\\" />\"));\n      elements.push(\"<circle cx=\\\"0\\\" cy=\\\"0\\\" r=\\\"\".concat(this.innerRadius, \"\\\" fill=\\\"black\\\" />\"));\n      elements.push('</clipPath>');\n      elements.push('</defs>');\n\n      // Generate the lines with both clipping paths applied\n      // This results in lines visible only in the \"donut\" area between inner and outer boundaries\n      elements.push(\"<g clip-path=\\\"url(#\".concat(innerClipId, \")\\\">\"));\n\n      // Generate radial lines extending beyond the blob\n      var angleStep = 2 * Math.PI / this.lines;\n      var skewRad = this.skew * Math.PI / 180;\n      for (var i = 0; i < this.lines; i++) {\n        var angle = i * angleStep;\n        var skewedAngle = angle + skewRad;\n\n        // Extended line from origin to beyond the blob boundary\n        var x2 = Math.cos(skewedAngle) * this.radius * 2;\n        var y2 = Math.sin(skewedAngle) * this.radius * 2;\n        elements.push(\"<line \\n                x1=\\\"0\\\" \\n                y1=\\\"0\\\" \\n                x2=\\\"\".concat(x2, \"\\\" \\n                y2=\\\"\").concat(y2, \"\\\" \\n                stroke=\\\"white\\\" \\n                stroke-width=\\\"\").concat(this.thickness, \"\\\" \\n            />\"));\n      }\n      elements.push('</g>');\n      return elements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(LayeredBlobsMaskShape, \"parameters\", {\n  radius: {\n    min: 50,\n    max: 100,\n    \"default\": 120\n  },\n  innerRadius: {\n    min: 10,\n    max: 100,\n    \"default\": 40\n  },\n  lines: {\n    min: 30,\n    max: 300,\n    \"default\": 100\n  },\n  edges: {\n    min: 4,\n    max: 16,\n    \"default\": 10\n  },\n  growth: {\n    min: 3,\n    max: 6,\n    \"default\": 5\n  },\n  amplitude: {\n    min: 0,\n    max: 5,\n    \"default\": 5\n  },\n  frequency: {\n    min: 0.5,\n    max: 4,\n    \"default\": 6.0\n  },\n  thickness: {\n    min: 1,\n    max: 3,\n    \"default\": 1\n  },\n  skew: {\n    min: -90,\n    max: 90,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LayeredBlobsMaskShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/LayeredBlobsMaskShape.js?");

/***/ }),

/***/ "./src/shapes/LayeredChevron.js":
/*!**************************************!*\
  !*** ./src/shapes/LayeredChevron.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n/**\n * Generates multiple stacked chevron (V-shaped) lines with adjustable layers,\n * spacing, and pointiness.\n */\nvar LayeredChevron = /*#__PURE__*/function (_Shape) {\n  function LayeredChevron() {\n    _classCallCheck(this, LayeredChevron);\n    return _callSuper(this, LayeredChevron, arguments);\n  }\n  _inherits(LayeredChevron, _Shape);\n  return _createClass(LayeredChevron, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var lines = [];\n      var center = {\n        x: 0,\n        y: 0\n      };\n      var baseSize = 100;\n      for (var layer = 0; layer < this.layers; layer++) {\n        var currentSize = baseSize - layer * this.spacing;\n        if (currentSize <= 0) continue;\n\n        // Calculate chevron points\n        var top = {\n          x: center.x,\n          y: center.y - currentSize\n        };\n        var bottomLeft = {\n          x: center.x - currentSize,\n          y: center.y + currentSize\n        };\n        var bottomRight = {\n          x: center.x + currentSize,\n          y: center.y + currentSize\n        };\n        var leftPoint = {\n          x: center.x - currentSize * this.pointiness,\n          y: center.y\n        };\n        var rightPoint = {\n          x: center.x + currentSize * this.pointiness,\n          y: center.y\n        };\n\n        // Draw left side of chevron\n        lines.push(\"<line \\n                x1=\\\"\".concat(top.x, \"\\\" \\n                y1=\\\"\").concat(top.y, \"\\\" \\n                x2=\\\"\").concat(leftPoint.x, \"\\\" \\n                y2=\\\"\").concat(leftPoint.y, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                stroke-linecap=\\\"\").concat(this.lineCap, \"\\\"\\n            />\"));\n        lines.push(\"<line \\n                x1=\\\"\".concat(leftPoint.x, \"\\\" \\n                y1=\\\"\").concat(leftPoint.y, \"\\\" \\n                x2=\\\"\").concat(bottomLeft.x, \"\\\" \\n                y2=\\\"\").concat(bottomLeft.y, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                stroke-linecap=\\\"\").concat(this.lineCap, \"\\\"\\n            />\"));\n\n        // Draw right side of chevron\n        lines.push(\"<line \\n                x1=\\\"\".concat(top.x, \"\\\" \\n                y1=\\\"\").concat(top.y, \"\\\" \\n                x2=\\\"\").concat(rightPoint.x, \"\\\" \\n                y2=\\\"\").concat(rightPoint.y, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                stroke-linecap=\\\"\").concat(this.lineCap, \"\\\"\\n            />\"));\n        lines.push(\"<line \\n                x1=\\\"\".concat(rightPoint.x, \"\\\" \\n                y1=\\\"\").concat(rightPoint.y, \"\\\" \\n                x2=\\\"\").concat(bottomRight.x, \"\\\" \\n                y2=\\\"\").concat(bottomRight.y, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                stroke-linecap=\\\"\").concat(this.lineCap, \"\\\"\\n            />\"));\n      }\n      return lines.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(LayeredChevron, \"parameters\", {\n  layers: {\n    min: 2,\n    max: 8,\n    \"default\": 4\n  },\n  spacing: {\n    min: 10,\n    max: 50,\n    \"default\": 25\n  },\n  pointiness: {\n    min: 0.2,\n    max: 0.8,\n    \"default\": 0.5\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 3\n  },\n  lineCap: {\n    options: ['butt', 'round'],\n    \"default\": 'round'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LayeredChevron);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/LayeredChevron.js?");

/***/ }),

/***/ "./src/shapes/LayeredCross.js":
/*!************************************!*\
  !*** ./src/shapes/LayeredCross.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a layered cross shape where each inner layer is a smaller, nested\n * version of the outer rounded cross.\n */\nvar LayeredCross = /*#__PURE__*/function (_Shape) {\n  function LayeredCross() {\n    _classCallCheck(this, LayeredCross);\n    return _callSuper(this, LayeredCross, arguments);\n  }\n  _inherits(LayeredCross, _Shape);\n  return _createClass(LayeredCross, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var svgPaths = '';\n      var currentLength = this.armLength;\n      var currentWidth = this.armWidth;\n      var currentRadius = this.cornerRadius;\n      for (var i = 0; i < this.numLayers; i++) {\n        // Ensure dimensions are valid before generating path\n        // Width shrinks fastest (by 2 * spacing), check it first\n        if (currentWidth <= 0.1) break;\n        // Arm length can technically reach zero (shape becomes a square/rectangle)\n        if (currentLength < 0) currentLength = 0;\n\n        // Clamp corner radius: cannot exceed half the current arm width and must be non-negative\n        var clampedRadius = Math.max(0, Math.min(currentRadius, currentWidth / 2));\n\n        // If rounding was intended but the clamped radius becomes effectively zero, stop layering\n        // This prevents abrupt change from rounded to sharp corners deep inside\n        if (clampedRadius < 0.1 && currentRadius >= 0.1 && i > 0) {\n          break;\n        }\n        var pathData = this.generateRoundedCrossPath(currentLength, currentWidth, clampedRadius);\n        if (pathData) {\n          // Each layer is a filled white path\n          svgPaths += \"<path d=\\\"\".concat(pathData, \"\\\" fill=\\\"white\\\" />\\n\");\n        } else {\n          // If path generation failed for some reason, stop.\n          break;\n        }\n\n        // Shrink dimensions for the next inner layer\n        currentLength -= this.layerSpacing;\n        // Width reduces by spacing on both sides relative to the arm's centerline\n        currentWidth -= this.layerSpacing * 2;\n        // Radius also shrinks. Ensure it doesn't become negative conceptually.\n        currentRadius = Math.max(0, currentRadius - this.layerSpacing);\n      }\n\n      // Return the concatenated SVG path strings\n      return svgPaths;\n    }\n\n    /**\n     * Generates the SVG path data string ('d' attribute) for a rounded cross centered at (0,0).\n     * Handles cases where arm length shrinks to zero (becomes a rounded rectangle/square)\n     * and cases where corner radius is zero (sharp corners).\n     *\n     * @param {number} L - Length of arms from center (can be zero).\n     * @param {number} W - Width of arms. Must be positive.\n     * @param {number} R - Corner radius (already clamped to [0, W/2]).\n     * @returns {string} SVG path data string 'd', or empty string if dimensions are invalid (e.g., W <= 0).\n     */\n  }, {\n    key: \"generateRoundedCrossPath\",\n    value: function generateRoundedCrossPath(L, W, R) {\n      // Basic validation: Width must be positive.\n      if (W <= 0.1) return '';\n      // Ensure Length isn't negative\n      if (L < 0) L = 0;\n      var halfW = W / 2;\n\n      // --- Handle Special Cases ---\n\n      // Case 1: Corner radius is effectively zero -> Sharp corners\n      if (R < 0.1) {\n        if (L <= 0.1) {\n          // If length is also zero, draw a square centered at origin\n          return \"M \".concat(-halfW, \",\").concat(halfW, \" L \").concat(halfW, \",\").concat(halfW, \" L \").concat(halfW, \",\").concat(-halfW, \" L \").concat(-halfW, \",\").concat(-halfW, \" Z\");\n        } else {\n          // Draw a sharp-cornered cross\n          // Using Line commands for a crisp shape\n          return \"M \".concat(-halfW, \",\").concat(L, \" L \").concat(halfW, \",\").concat(L, \" L \").concat(halfW, \",\").concat(halfW, \" L \").concat(L, \",\").concat(halfW, \" L \").concat(L, \",\").concat(-halfW, \" L \").concat(halfW, \",\").concat(-halfW, \" L \").concat(halfW, \",\").concat(-L, \" L \").concat(-halfW, \",\").concat(-L, \" L \").concat(-halfW, \",\").concat(-halfW, \" L \").concat(-L, \",\").concat(-halfW, \" L \").concat(-L, \",\").concat(halfW, \" L \").concat(-halfW, \",\").concat(halfW, \" Z\");\n        }\n      }\n\n      // Case 2: Arm length is effectively zero -> Rounded Rectangle/Square\n      if (L <= 0.1) {\n        // Draw a rounded rectangle centered at 0,0 with width/height W, radius R\n        var hw = halfW; // Use hw for half-width/height (which is halfW)\n        // Radius R is already clamped to <= hw (halfW)\n        return \"M \".concat(-hw + R, \",\").concat(hw, \" L \").concat(hw - R, \",\").concat(hw, \" A \").concat(R, \",\").concat(R, \" 0 0 1 \").concat(hw, \",\").concat(hw - R, \" L \").concat(hw, \",\").concat(-hw + R, \" A \").concat(R, \",\").concat(R, \" 0 0 1 \").concat(hw - R, \",\").concat(-hw, \" L \").concat(-hw + R, \",\").concat(-hw, \" A \").concat(R, \",\").concat(R, \" 0 0 1 \").concat(-hw, \",\").concat(-hw + R, \" L \").concat(-hw, \",\").concat(hw - R, \" A \").concat(R, \",\").concat(R, \" 0 0 1 \").concat(-hw + R, \",\").concat(hw, \" Z\");\n      }\n\n      // --- Standard Case: Rounded Cross (L > 0, W > 0, R > 0) ---\n      // Calculate coordinates for the rounded cross path using Lines (L) and Arcs (A)\n      // Path follows the outer perimeter clockwise.\n      // Outer corners use sweep-flag=1 (clockwise arc).\n      // Inner corners use sweep-flag=0 (counter-clockwise arc).\n      var points = [// Start on top edge, after top-left outer corner arc\n      \"M \".concat(-halfW + R, \",\").concat(L), \"L \".concat(halfW - R, \",\").concat(L), // Top edge line\n      // Top-right outer corner (convex)\n      \"A \".concat(R, \",\").concat(R, \" 0 0 1 \").concat(halfW, \",\").concat(L - R), \"L \".concat(halfW, \",\").concat(halfW + R), // Right edge of top arm\n      // Top-right inner corner (concave)\n      \"A \".concat(R, \",\").concat(R, \" 0 0 0 \").concat(halfW + R, \",\").concat(halfW), // Sweep 0\n      \"L \".concat(L - R, \",\").concat(halfW), // Top edge of right arm\n      // Right-top outer corner (convex)\n      \"A \".concat(R, \",\").concat(R, \" 0 0 1 \").concat(L, \",\").concat(halfW - R), \"L \".concat(L, \",\").concat(-halfW + R), // Right edge line\n      // Right-bottom outer corner (convex)\n      \"A \".concat(R, \",\").concat(R, \" 0 0 1 \").concat(L - R, \",\").concat(-halfW), \"L \".concat(halfW + R, \",\").concat(-halfW), // Bottom edge of right arm\n      // Bottom-right inner corner (concave)\n      \"A \".concat(R, \",\").concat(R, \" 0 0 0 \").concat(halfW, \",\").concat(-halfW - R), // Sweep 0\n      \"L \".concat(halfW, \",\").concat(-L + R), // Right edge of bottom arm\n      // Bottom-right outer corner (convex)\n      \"A \".concat(R, \",\").concat(R, \" 0 0 1 \").concat(halfW - R, \",\").concat(-L), \"L \".concat(-halfW + R, \",\").concat(-L), // Bottom edge line\n      // Bottom-left outer corner (convex)\n      \"A \".concat(R, \",\").concat(R, \" 0 0 1 \").concat(-halfW, \",\").concat(-L + R), \"L \".concat(-halfW, \",\").concat(-halfW - R), // Left edge of bottom arm\n      // Bottom-left inner corner (concave)\n      \"A \".concat(R, \",\").concat(R, \" 0 0 0 \").concat(-halfW - R, \",\").concat(-halfW), // Sweep 0\n      \"L \".concat(-L + R, \",\").concat(-halfW), // Bottom edge of left arm\n      // Left-bottom outer corner (convex)\n      \"A \".concat(R, \",\").concat(R, \" 0 0 1 \").concat(-L, \",\").concat(-halfW + R), \"L \".concat(-L, \",\").concat(halfW - R), // Left edge line\n      // Left-top outer corner (convex)\n      \"A \".concat(R, \",\").concat(R, \" 0 0 1 \").concat(-L + R, \",\").concat(halfW), \"L \".concat(-halfW - R, \",\").concat(halfW), // Top edge of left arm\n      // Top-left inner corner (concave)\n      \"A \".concat(R, \",\").concat(R, \" 0 0 0 \").concat(-halfW, \",\").concat(halfW + R), // Sweep 0\n      \"L \".concat(-halfW, \",\").concat(L - R), // Left edge of top arm\n      // Top-left outer corner (convex - closes the path)\n      \"A \".concat(R, \",\").concat(R, \" 0 0 1 \").concat(-halfW + R, \",\").concat(L), \"Z\" // Close path command\n      ];\n\n      // Join points into a single string for the 'd' attribute\n      return points.join(' ');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(LayeredCross, \"parameters\", {\n  armLength: {\n    type: 'number',\n    min: 10,\n    // Minimum length from center\n    max: 95,\n    // Max extent from center to stay within bounds\n    step: 1,\n    \"default\": 60,\n    label: 'Arm Length'\n  },\n  armWidth: {\n    type: 'number',\n    min: 5,\n    max: 80,\n    // Should ideally be <= armLength * 2, visually enforced by user\n    step: 1,\n    \"default\": 40,\n    label: 'Arm Width'\n  },\n  cornerRadius: {\n    type: 'number',\n    min: 0,\n    max: 40,\n    // Max will be constrained by half armWidth during generation\n    step: 0.5,\n    \"default\": 10,\n    label: 'Corner Radius'\n  },\n  numLayers: {\n    type: 'number',\n    min: 1,\n    // At least one layer\n    max: 15,\n    // More layers create a denser look\n    step: 1,\n    \"default\": 5,\n    label: 'Layers'\n  },\n  layerSpacing: {\n    type: 'number',\n    min: 1,\n    max: 15,\n    // How much each layer shrinks\n    step: 0.5,\n    \"default\": 6,\n    label: 'Layer Spacing'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LayeredCross);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/LayeredCross.js?");

/***/ }),

/***/ "./src/shapes/LayeredCubeShape.js":
/*!****************************************!*\
  !*** ./src/shapes/LayeredCubeShape.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates multiple concentric 3D wireframe cubes, creating a layered or\n * nested effect with perspective.\n */\nvar LayeredCubeShape = /*#__PURE__*/function (_Shape) {\n  function LayeredCubeShape() {\n    _classCallCheck(this, LayeredCubeShape);\n    return _callSuper(this, LayeredCubeShape, arguments);\n  }\n  _inherits(LayeredCubeShape, _Shape);\n  return _createClass(LayeredCubeShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      var elements = [];\n      var maxSize = this.size;\n\n      // Convert rotation angles to radians\n      var rotX = this.rotationX * Math.PI / 180;\n      var rotY = this.rotationY * Math.PI / 180;\n      var rotZ = this.rotationZ * Math.PI / 180;\n\n      // Define the edges of a cube (pairs of vertex indices)\n      var edges = [[0, 1], [1, 2], [2, 3], [3, 0],\n      // back face\n      [4, 5], [5, 6], [6, 7], [7, 4],\n      // front face\n      [0, 4], [1, 5], [2, 6], [3, 7] // connecting edges\n      ];\n\n      // Create group for all cubes\n      elements.push(\"<g stroke=\\\"white\\\" stroke-width=\\\"\".concat(this.thickness, \"\\\" fill=\\\"none\\\" stroke-linejoin=\\\"round\\\" stroke-linecap=\\\"round\\\">\"));\n\n      // Generate layers from outside to inside\n      var _loop = function _loop() {\n        // Calculate the size for this layer\n        var size = maxSize - layer * _this.spacing * 2;\n\n        // Skip if the layer would be too small\n        if (size <= 0) return 1; // continue\n        var halfSize = size / 2;\n\n        // Define the vertices of a cube centered at origin\n        var vertices = [[-halfSize, -halfSize, -halfSize],\n        // 0: back bottom left\n        [halfSize, -halfSize, -halfSize],\n        // 1: back bottom right\n        [halfSize, halfSize, -halfSize],\n        // 2: back top right\n        [-halfSize, halfSize, -halfSize],\n        // 3: back top left\n        [-halfSize, -halfSize, halfSize],\n        // 4: front bottom left\n        [halfSize, -halfSize, halfSize],\n        // 5: front bottom right\n        [halfSize, halfSize, halfSize],\n        // 6: front top right\n        [-halfSize, halfSize, halfSize] // 7: front top left\n        ];\n\n        // Apply 3D rotations and projection to 2D\n        var projectedVertices = vertices.map(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 3),\n            x = _ref2[0],\n            y = _ref2[1],\n            z = _ref2[2];\n          // Apply rotation around X axis (pitch)\n          var x1 = x;\n          var y1 = y * Math.cos(rotX) - z * Math.sin(rotX);\n          var z1 = y * Math.sin(rotX) + z * Math.cos(rotX);\n\n          // Apply rotation around Y axis (yaw)\n          var x2 = x1 * Math.cos(rotY) + z1 * Math.sin(rotY);\n          var y2 = y1;\n          var z2 = -x1 * Math.sin(rotY) + z1 * Math.cos(rotY);\n\n          // Apply rotation around Z axis (roll)\n          var x3 = x2 * Math.cos(rotZ) - y2 * Math.sin(rotZ);\n          var y3 = x2 * Math.sin(rotZ) + y2 * Math.cos(rotZ);\n          var z3 = z2;\n          return {\n            x: Math.round(x3 * 1000) / 1000,\n            y: Math.round(y3 * 1000) / 1000,\n            z: Math.round(z3 * 1000) / 1000\n          };\n        });\n\n        // Sort edges by average z-depth for proper rendering order\n        var sortedEdges = [].concat(edges).sort(function (a, b) {\n          var avgZA = (projectedVertices[a[0]].z + projectedVertices[a[1]].z) / 2;\n          var avgZB = (projectedVertices[b[0]].z + projectedVertices[b[1]].z) / 2;\n          return avgZB - avgZA; // Draw back-to-front\n        });\n\n        // Process edges to form continuous paths\n        var remainingEdges = _toConsumableArray(sortedEdges);\n        var connectedPaths = [];\n        while (remainingEdges.length > 0) {\n          var currentPath = [remainingEdges[0]];\n          remainingEdges.splice(0, 1);\n          var foundConnection = true;\n          while (foundConnection) {\n            foundConnection = false;\n\n            // Look for an edge that connects to the last vertex in our current path\n            var lastEdge = currentPath[currentPath.length - 1];\n            var lastVertex = lastEdge[1];\n            for (var i = 0; i < remainingEdges.length; i++) {\n              // If this edge starts with our last vertex\n              if (remainingEdges[i][0] === lastVertex) {\n                currentPath.push(remainingEdges[i]);\n                remainingEdges.splice(i, 1);\n                foundConnection = true;\n                break;\n              }\n              // If this edge ends with our last vertex (need to reverse it)\n              else if (remainingEdges[i][1] === lastVertex) {\n                currentPath.push([remainingEdges[i][1], remainingEdges[i][0]]);\n                remainingEdges.splice(i, 1);\n                foundConnection = true;\n                break;\n              }\n            }\n          }\n          connectedPaths.push(currentPath);\n        }\n\n        // Draw each connected path\n        for (var _i = 0, _connectedPaths = connectedPaths; _i < _connectedPaths.length; _i++) {\n          var path = _connectedPaths[_i];\n          var pathData = path.map(function (edge, i) {\n            var start = projectedVertices[edge[0]];\n            var end = projectedVertices[edge[1]];\n            return \"\".concat(i === 0 ? 'M' : 'L').concat(start.x, \",\").concat(start.y, \" L\").concat(end.x, \",\").concat(end.y);\n          }).join(' ');\n          elements.push(\"<path d=\\\"\".concat(pathData, \"\\\" />\"));\n        }\n      };\n      for (var layer = 0; layer < this.layers; layer++) {\n        if (_loop()) continue;\n      }\n\n      // Close the group\n      elements.push(\"</g>\");\n      return elements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(LayeredCubeShape, \"parameters\", {\n  size: {\n    min: 10,\n    max: 100,\n    \"default\": 100\n  },\n  layers: {\n    min: 2,\n    max: 20,\n    \"default\": 5\n  },\n  spacing: {\n    min: 1,\n    max: 20,\n    \"default\": 10\n  },\n  thickness: {\n    min: 0.5,\n    max: 5,\n    \"default\": 3\n  },\n  rotationX: {\n    min: -60,\n    max: 60,\n    \"default\": 45\n  },\n  rotationY: {\n    min: -60,\n    max: 60,\n    \"default\": 45\n  },\n  rotationZ: {\n    min: -60,\n    max: 60,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LayeredCubeShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/LayeredCubeShape.js?");

/***/ }),

/***/ "./src/shapes/LayeredFlowShape.js":
/*!****************************************!*\
  !*** ./src/shapes/LayeredFlowShape.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates layers of closed, flowing organic shapes resembling distorted\n * rings, using Perlin noise and 3D perspective.\n */\nvar LayeredFlowShape = /*#__PURE__*/function (_Shape) {\n  function LayeredFlowShape() {\n    _classCallCheck(this, LayeredFlowShape);\n    return _callSuper(this, LayeredFlowShape, arguments);\n  }\n  _inherits(LayeredFlowShape, _Shape);\n  return _createClass(LayeredFlowShape, [{\n    key: \"getNoise\",\n    value: function getNoise(x, y) {\n      var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      try {\n        var value = this.perlin.noise(x * this.noiseScale + this.seed, y * this.noiseScale + this.seed, z * this.noiseScale + this.seed);\n        return isNaN(value) ? 0 : value;\n      } catch (e) {\n        return 0;\n      }\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var elements = [];\n      var rotationRad = this.rotation * Math.PI / 180;\n      var tiltRad = this.tilt * Math.PI / 180;\n      var height = Math.max(1, this.innerRadius * 2);\n      var sliceSpacing = height / Math.max(1, this.layers - 1);\n      for (var i = 0; i < this.layers; i++) {\n        var sliceHeight = -this.innerRadius + i * sliceSpacing;\n        var path = this.generateSlicePath(sliceHeight, rotationRad, tiltRad);\n        if (path) {\n          elements.push(\"<path \\n                    d=\\\"\".concat(path, \"\\\" \\n                    stroke=\\\"white\\\" \\n                    stroke-width=\\\"\").concat(this.thickness, \"\\\" \\n                    fill=\\\"none\\\"\\n                    stroke-linejoin=\\\"round\\\"\\n                    stroke-linecap=\\\"round\\\"\\n                />\"));\n        }\n      }\n      return elements.join('');\n    }\n  }, {\n    key: \"generateSlicePath\",\n    value: function generateSlicePath(sliceHeight, rotationY, tiltX) {\n      var points = [];\n      var steps = 100;\n      var safeInnerRadius = Math.max(0.1, this.innerRadius);\n      var heightRatio = sliceHeight / safeInnerRadius;\n      var sqrtArg = Math.max(0, 1 - heightRatio * heightRatio);\n      var maxRadius = this.radius * Math.sqrt(sqrtArg);\n      for (var i = 0; i <= steps; i++) {\n        var angle = i / steps * Math.PI * 2;\n        var cos = Math.cos(angle);\n        var sin = Math.sin(angle);\n        var r = maxRadius;\n        var noiseValue = 0;\n        noiseValue += this.getNoise(cos * this.flowFactor, sin * this.flowFactor, heightRatio) * this.noiseStrength;\n        noiseValue += this.getNoise(cos * this.flowFactor * 2.5, sin * this.flowFactor * 2.5, heightRatio * 2) * this.noiseStrength * 0.5;\n        var flowAngle = angle + this.getNoise(cos * 0.5, sin * 0.5, heightRatio * 0.5) * Math.PI * this.heightVariation;\n        var flowCos = Math.cos(flowAngle);\n        var flowSin = Math.sin(flowAngle);\n        noiseValue += this.getNoise(cos + flowCos * 0.5, sin + flowSin * 0.5, heightRatio) * this.noiseStrength * 0.7;\n        var heightFactor = 1 - Math.abs(heightRatio) * (1 - this.heightVariation);\n        r = Math.max(0.1, r * (1 + noiseValue * heightFactor));\n        var x = cos * r;\n        var y = sin * r;\n        var z = sliceHeight;\n        var rotX = x * Math.cos(rotationY) - z * Math.sin(rotationY);\n        var rotZ = x * Math.sin(rotationY) + z * Math.cos(rotationY);\n        var tiltY = y * Math.cos(tiltX) - rotZ * Math.sin(tiltX);\n        var tiltZ = y * Math.sin(tiltX) + rotZ * Math.cos(tiltX);\n        var perspective = 0.001;\n        var denom = 1 - tiltZ * perspective;\n        if (Math.abs(denom) < 0.0001) continue;\n        var projX = rotX / denom;\n        var projY = tiltY / denom;\n        if (isFinite(projX) && isFinite(projY)) {\n          points.push([projX, projY]);\n        }\n      }\n      if (points.length < 3) return '';\n      return this.createPath(points);\n    }\n  }, {\n    key: \"createPath\",\n    value: function createPath(points) {\n      var pathData = '';\n      var validStart = false;\n      for (var i = 0; i < points.length; i++) {\n        if (!isNaN(points[i][0]) && !isNaN(points[i][1])) {\n          if (!validStart) {\n            pathData = \"M\".concat(points[i][0], \",\").concat(points[i][1]);\n            validStart = true;\n          } else {\n            pathData += \" L\".concat(points[i][0], \",\").concat(points[i][1]);\n          }\n        }\n      }\n      if (!validStart) return '';\n      pathData += ' Z';\n      return pathData;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(LayeredFlowShape, \"parameters\", {\n  layers: {\n    min: 5,\n    max: 50,\n    \"default\": 32\n  },\n  radius: {\n    min: 20,\n    max: 80,\n    \"default\": 80\n  },\n  innerRadius: {\n    min: 5,\n    max: 100,\n    \"default\": 53\n  },\n  noiseScale: {\n    min: 0.05,\n    max: 1.0,\n    \"default\": 0.35\n  },\n  noiseStrength: {\n    min: 0.0,\n    max: 1.0,\n    \"default\": 0.60\n  },\n  flowFactor: {\n    min: 0.1,\n    max: 5,\n    \"default\": 3\n  },\n  thickness: {\n    min: 0.5,\n    max: 3,\n    \"default\": 1.20\n  },\n  heightVariation: {\n    min: 0.1,\n    max: 1,\n    \"default\": 0.70\n  },\n  rotation: {\n    min: 0,\n    max: 360,\n    \"default\": 360\n  },\n  tilt: {\n    min: 0,\n    max: 90,\n    \"default\": 33\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LayeredFlowShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/LayeredFlowShape.js?");

/***/ }),

/***/ "./src/shapes/LayeredMountains.js":
/*!****************************************!*\
  !*** ./src/shapes/LayeredMountains.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a pattern of layered wavy lines within a circle, resembling\n * mountain ranges or geological strata.\n */\nvar LayeredMountains = /*#__PURE__*/function (_Shape) {\n  function LayeredMountains() {\n    _classCallCheck(this, LayeredMountains);\n    return _callSuper(this, LayeredMountains, arguments);\n  }\n  _inherits(LayeredMountains, _Shape);\n  return _createClass(LayeredMountains, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var elements = [];\n      var radius = this.radius,\n        layers = this.layers,\n        amplitude = this.amplitude,\n        thickness = this.thickness,\n        curvature = this.curvature;\n\n      // Add circular border\n      elements.push(\"<circle\\n            cx=\\\"0\\\"\\n            cy=\\\"0\\\"\\n            r=\\\"\".concat(radius, \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(thickness, \"\\\"\\n            fill=\\\"none\\\"\\n        />\"));\n\n      // Create clipping path\n      var clipId = \"clip-\".concat(Math.floor(Math.random() * 10000));\n      elements.push(\"\\n            <defs>\\n                <clipPath id=\\\"\".concat(clipId, \"\\\">\\n                    <circle cx=\\\"0\\\" cy=\\\"0\\\" r=\\\"\").concat(radius, \"\\\" />\\n                </clipPath>\\n            </defs>\\n        \"));\n\n      // Container with clipping\n      elements.push(\"<g clip-path=\\\"url(#\".concat(clipId, \")\\\">\"));\n\n      // Create waves that flow across the circle\n      for (var layer = 0; layer < layers; layer++) {\n        // Layer position (vertical offset)\n        var layerOffset = -radius + radius * 2 * (layer + 0.5) / layers;\n\n        // Calculate wave parameters based on layer\n        var layerRatio = layer / (layers - 1);\n        var waveAmplitude = amplitude * (0.5 + layerRatio * 0.5);\n\n        // Create curved path that flows from left to right\n        var pathData = this.generateWavePath(radius, layerOffset, waveAmplitude, curvature, layerRatio);\n        elements.push(\"<path\\n                d=\\\"\".concat(pathData, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(thickness, \"\\\"\\n                fill=\\\"none\\\"\\n                stroke-linecap=\\\"round\\\"\\n                stroke-linejoin=\\\"round\\\"\\n            />\"));\n      }\n      elements.push(\"</g>\");\n      return elements.join('');\n    }\n  }, {\n    key: \"generateWavePath\",\n    value: function generateWavePath(radius, baseY, amplitude, curvature, layerRatio) {\n      var points = [];\n      var steps = 100;\n      var diameter = radius * 2;\n\n      // Calculate control points for smooth wave\n      // Left edge starting point (outside circle)\n      points.push([-radius * 1.5, baseY]);\n\n      // Calculate midpoints with increasing/decreasing effect\n      for (var i = 0; i <= steps; i++) {\n        var x = -radius + i / steps * diameter;\n        var xRatio = (x + radius) / diameter; // 0 to 1 across the circle\n\n        // Apply curve transformation\n        var curveEffect = Math.sin(xRatio * Math.PI) * curvature;\n\n        // Apply decreasing noise from top to bottom\n        var noiseContribution = this.getNoise(xRatio * 3, layerRatio) * amplitude * (1 - 0.7 * layerRatio);\n\n        // For lower layers, have more upward curve, for upper layers, more downward curve\n        var directionFactor = layerRatio * 2 - 1; // -1 to 1\n        var y = baseY - curveEffect * radius * 0.5 * directionFactor - noiseContribution;\n        points.push([x, y]);\n      }\n\n      // Right edge ending point (outside circle)\n      points.push([radius * 1.5, baseY]);\n\n      // Build SVG path\n      var pathData = \"M\".concat(points[0][0], \",\").concat(points[0][1]);\n\n      // Add points\n      for (var _i = 1; _i < points.length; _i++) {\n        pathData += \" L\".concat(points[_i][0], \",\").concat(points[_i][1]);\n      }\n      return pathData;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(LayeredMountains, \"parameters\", {\n  layers: {\n    min: 3,\n    max: 15,\n    \"default\": 15\n  },\n  radius: {\n    min: 50,\n    max: 200,\n    \"default\": 100\n  },\n  amplitude: {\n    min: 5,\n    max: 150,\n    \"default\": 150\n  },\n  noiseScale: {\n    min: 0.1,\n    max: 1.5,\n    \"default\": 1.5\n  },\n  seed: {\n    min: 0,\n    max: 1000,\n    \"default\": 42\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 3\n  },\n  curvature: {\n    min: 0.1,\n    max: 1,\n    \"default\": 0.8\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LayeredMountains);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/LayeredMountains.js?");

/***/ }),

/***/ "./src/shapes/LayeredPolygon.js":
/*!**************************************!*\
  !*** ./src/shapes/LayeredPolygon.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates multiple concentric layers of outlined regular polygons with\n * adjustable vertices, size, and density per layer.\n */\nvar LayeredPolygon = /*#__PURE__*/function (_Shape) {\n  function LayeredPolygon() {\n    _classCallCheck(this, LayeredPolygon);\n    return _callSuper(this, LayeredPolygon, arguments);\n  }\n  _inherits(LayeredPolygon, _Shape);\n  return _createClass(LayeredPolygon, [{\n    key: \"generatePolygonPoints\",\n    value: function generatePolygonPoints(radius, vertexCount) {\n      var rotationOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var points = [];\n      var angleStep = 2 * Math.PI / vertexCount;\n\n      // Generate points for each vertex\n      for (var i = 0; i < vertexCount; i++) {\n        var angle = i * angleStep + rotationOffset;\n        var x = radius * Math.cos(angle);\n        var y = radius * Math.sin(angle);\n        points.push([x, y]);\n      }\n      return points;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var paths = [];\n      var currentRadius = this.innerSize;\n      this.vertices = Math.round(this.vertices);\n\n      // Generate each layer\n      for (var layer = 0; layer < this.layers; layer++) {\n        // Generate multiple polygons per layer based on density\n        for (var d = 0; d < this.density; d++) {\n          var rotationOffset = d * 2 * Math.PI / (this.density * this.vertices);\n          var points = this.generatePolygonPoints(currentRadius, this.vertices, rotationOffset);\n\n          // Create path for the polygon\n          // Start with the first point\n          var pathData = \"M \".concat(points[0][0], \",\").concat(points[0][1]);\n\n          // Add lines to each subsequent point\n          for (var i = 1; i < points.length; i++) {\n            pathData += \" L \".concat(points[i][0], \",\").concat(points[i][1]);\n          }\n\n          // Close the path by connecting back to the first point\n          pathData += \" Z\";\n          paths.push(\"<path \\n                    d=\\\"\".concat(pathData, \"\\\"\\n                    fill=\\\"none\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                    stroke-linecap=\\\"square\\\"\\n                    stroke-linejoin=\\\"miter\\\"\\n                />\"));\n        }\n\n        // Increment radius for next layer\n        currentRadius += this.sizeStep;\n      }\n      return \"<g>\".concat(paths.join(''), \"</g>\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(LayeredPolygon, \"parameters\", {\n  vertices: {\n    min: 3,\n    max: 10,\n    \"default\": 6\n  },\n  layers: {\n    min: 2,\n    max: 5,\n    \"default\": 4\n  },\n  innerSize: {\n    min: 30,\n    max: 60,\n    \"default\": 13\n  },\n  sizeStep: {\n    min: 20,\n    max: 40,\n    \"default\": 20\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 6\n  },\n  density: {\n    min: 1,\n    max: 5,\n    \"default\": 1\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LayeredPolygon);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/LayeredPolygon.js?");

/***/ }),

/***/ "./src/shapes/LayeredRoundedRect.js":
/*!******************************************!*\
  !*** ./src/shapes/LayeredRoundedRect.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates nested layers of rounded rectangles, creating an extruded effect,\n * with fill or stroke options.\n */\nvar LayeredRoundedRect = /*#__PURE__*/function (_Shape) {\n  function LayeredRoundedRect() {\n    _classCallCheck(this, LayeredRoundedRect);\n    return _callSuper(this, LayeredRoundedRect, arguments);\n  }\n  _inherits(LayeredRoundedRect, _Shape);\n  return _createClass(LayeredRoundedRect, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var paths = [];\n      var styleAttribute = this.strokeInsteadOfFill ? \"fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"\".concat(this.strokeWidth, \"\\\"\") : \"fill=\\\"white\\\" stroke=\\\"none\\\"\";\n      for (var i = 0; i < this.numLayers; i++) {\n        // Calculate dimensions for the current layer\n        var width = this.outerWidth - 2 * i * this.layerGap;\n        var height = this.outerHeight - 2 * i * this.layerGap;\n\n        // Stop if shape becomes too small or inverted\n        if (width <= 0 || height <= 0) {\n          break;\n        }\n\n        // Calculate corner radius for the current layer, ensuring it's valid\n        // It shouldn't exceed half of the smallest dimension\n        // It should decrease naturally with the gap, but not become negative.\n        var maxPossibleRadius = Math.min(width / 2, height / 2);\n        // Reduce radius slightly more than the gap to maintain visual consistency on tight corners\n        var currentRadius = Math.max(0, this.cornerRadius - i * this.layerGap);\n        var radius = Math.min(currentRadius, maxPossibleRadius);\n\n        // Generate the path data for the rounded rectangle\n        var pathData = this.createRoundedRectPath(width, height, radius);\n\n        // Add the path element to the array\n        paths.push(\"<path d=\\\"\".concat(pathData, \"\\\" \").concat(styleAttribute, \" />\"));\n      }\n\n      // Combine all path strings\n      return paths.join('\\n');\n    }\n\n    /**\n     * Helper method to generate SVG path data for a rounded rectangle centered at (0,0).\n     * @param {number} w - Width of the rectangle.\n     * @param {number} h - Height of the rectangle.\n     * @param {number} r - Corner radius (will be clamped to not exceed w/2 or h/2).\n     * @returns {string} SVG path data string ('d' attribute).\n     */\n  }, {\n    key: \"createRoundedRectPath\",\n    value: function createRoundedRectPath(w, h, r) {\n      // Clamp radius to valid range\n      r = Math.max(0, Math.min(r, w / 2, h / 2));\n      var x = -w / 2;\n      var y = -h / 2;\n\n      // If radius is 0, return a simple rectangle path\n      if (r <= 0.01) {\n        // Use a small threshold for floating point comparisons\n        return \"M \".concat(x, \",\").concat(y, \" H \").concat(x + w, \" V \").concat(y + h, \" H \").concat(x, \" Z\");\n      }\n\n      // Construct path data using arcs for rounded corners\n      // Using A command: A rx ry x-axis-rotation large-arc-flag sweep-flag x y\n      // rx=ry=r, x-axis-rotation=0, large-arc-flag=0, sweep-flag=1 (for outer corners moving clockwise)\n      return \"\\n            M \".concat(x + r, \",\").concat(y, \"\\n            L \").concat(x + w - r, \",\").concat(y, \"\\n            A \").concat(r, \",\").concat(r, \" 0 0 1 \").concat(x + w, \",\").concat(y + r, \"\\n            L \").concat(x + w, \",\").concat(y + h - r, \"\\n            A \").concat(r, \",\").concat(r, \" 0 0 1 \").concat(x + w - r, \",\").concat(y + h, \"\\n            L \").concat(x + r, \",\").concat(y + h, \"\\n            A \").concat(r, \",\").concat(r, \" 0 0 1 \").concat(x, \",\").concat(y + h - r, \"\\n            L \").concat(x, \",\").concat(y + r, \"\\n            A \").concat(r, \",\").concat(r, \" 0 0 1 \").concat(x + r, \",\").concat(y, \"\\n            Z\\n        \").replace(/\\s+/g, ' ').trim(); // Clean up whitespace\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(LayeredRoundedRect, \"parameters\", {\n  outerWidth: {\n    type: 'number',\n    min: 20,\n    max: 190,\n    step: 1,\n    \"default\": 150,\n    label: 'Outer Width' // Added label for clarity\n  },\n  outerHeight: {\n    type: 'number',\n    min: 20,\n    max: 190,\n    step: 1,\n    \"default\": 100,\n    label: 'Outer Height'\n  },\n  cornerRadius: {\n    type: 'number',\n    min: 0,\n    max: 95,\n    // Max radius depends on min width/height\n    step: 1,\n    \"default\": 25,\n    label: 'Corner Radius'\n  },\n  numLayers: {\n    type: 'number',\n    min: 1,\n    max: 20,\n    step: 1,\n    \"default\": 7,\n    label: 'Number of Layers'\n  },\n  layerGap: {\n    type: 'number',\n    min: 1,\n    max: 25,\n    step: 0.5,\n    \"default\": 6,\n    label: 'Layer Gap'\n  },\n  strokeInsteadOfFill: {\n    // Changed parameter name for clarity\n    type: 'boolean',\n    \"default\": false,\n    label: 'Use Stroke Instead of Fill'\n  },\n  strokeWidth: {\n    type: 'number',\n    min: 0.1,\n    max: 5,\n    step: 0.1,\n    \"default\": 1,\n    label: 'Stroke Width (if used)'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LayeredRoundedRect);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/LayeredRoundedRect.js?");

/***/ }),

/***/ "./src/shapes/LeafVeinsShape.js":
/*!**************************************!*\
  !*** ./src/shapes/LeafVeinsShape.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a leaf shape represented by a central midrib and symmetrical,\n * curved veins branching outwards.\n */\nvar LeafVeinsShape = /*#__PURE__*/function (_Shape) {\n  function LeafVeinsShape() {\n    _classCallCheck(this, LeafVeinsShape);\n    return _callSuper(this, LeafVeinsShape, arguments);\n  }\n  _inherits(LeafVeinsShape, _Shape);\n  return _createClass(LeafVeinsShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var paths = [];\n      var scale = 1;\n      var center = {\n        x: 0,\n        y: 0\n      };\n\n      // Draw midrib\n      var startY = center.y + this.length / 2; // Inverted Y coordinates\n      var endY = center.y - this.length / 2;\n      paths.push(\"<line \\n            x1=\\\"\".concat(center.x, \"\\\" \\n            y1=\\\"\").concat(startY, \"\\\" \\n            x2=\\\"\").concat(center.x, \"\\\" \\n            y2=\\\"\").concat(endY, \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            stroke-linecap=\\\"round\\\"\\n        />\"));\n\n      // Draw veins on both sides\n      for (var i = 0; i < this.veins; i++) {\n        var progress = i / (this.veins - 1);\n        var y = startY - progress * this.length; // Inverted Y calculation\n\n        // Convert vein angle to radians (negative angle to invert direction)\n        var angleRad = -this.veinAngle * (Math.PI / 180.0);\n\n        // Calculate vein length based on leaf shape (longer in middle)\n        var veinLength = this.width * Math.sin(Math.PI * progress);\n\n        // Calculate control points for quadratic curves\n        var leftStart = {\n          x: center.x,\n          y: y\n        };\n        var leftEnd = {\n          x: center.x - veinLength * Math.cos(angleRad),\n          y: y + veinLength * Math.sin(angleRad)\n        };\n        var leftControl = {\n          x: leftStart.x - veinLength * this.curvature,\n          y: leftStart.y + veinLength * this.curvature * 0.5\n        };\n        var rightEnd = {\n          x: center.x + veinLength * Math.cos(angleRad),\n          y: y + veinLength * Math.sin(angleRad)\n        };\n        var rightControl = {\n          x: leftStart.x + veinLength * this.curvature,\n          y: leftStart.y + veinLength * this.curvature * 0.5\n        };\n\n        // Draw left vein using quadratic curve\n        paths.push(\"<path \\n                d=\\\"M \".concat(leftStart.x, \" \").concat(leftStart.y, \" Q \").concat(leftControl.x, \" \").concat(leftControl.y, \" \").concat(leftEnd.x, \" \").concat(leftEnd.y, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                stroke-linecap=\\\"round\\\"\\n                fill=\\\"none\\\"\\n            />\"));\n\n        // Draw right vein using quadratic curve\n        paths.push(\"<path \\n                d=\\\"M \".concat(leftStart.x, \" \").concat(leftStart.y, \" Q \").concat(rightControl.x, \" \").concat(rightControl.y, \" \").concat(rightEnd.x, \" \").concat(rightEnd.y, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                stroke-linecap=\\\"round\\\"\\n                fill=\\\"none\\\"\\n            />\"));\n      }\n      return paths.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(LeafVeinsShape, \"parameters\", {\n  length: {\n    min: 100,\n    max: 250,\n    \"default\": 180\n  },\n  // Overall length of the leaf\n  width: {\n    min: 50,\n    max: 150,\n    \"default\": 100\n  },\n  // Width of the leaf\n  veins: {\n    min: 4,\n    max: 12,\n    \"default\": 8\n  },\n  // Number of vein pairs\n  curvature: {\n    min: 0,\n    max: 1,\n    \"default\": 0.6\n  },\n  // How much the veins curve\n  veinAngle: {\n    min: 20,\n    max: 70,\n    \"default\": 45\n  },\n  // Angle of veins from midrib\n  thickness: {\n    min: 1,\n    max: 5,\n    \"default\": 3\n  } // Line thickness\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LeafVeinsShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/LeafVeinsShape.js?");

/***/ }),

/***/ "./src/shapes/LineGrid.js":
/*!********************************!*\
  !*** ./src/shapes/LineGrid.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a grid of short line segments, all rotated by a common angle.\n */\nvar LineGrid = /*#__PURE__*/function (_Shape) {\n  function LineGrid() {\n    _classCallCheck(this, LineGrid);\n    return _callSuper(this, LineGrid, arguments);\n  }\n  _inherits(LineGrid, _Shape);\n  return _createClass(LineGrid, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var lines = [];\n      var cellWidth = this.size / this.columns;\n      var cellHeight = this.size / this.rows;\n      var startX = -this.size / 2;\n      var startY = -this.size / 2;\n\n      // Calculate base line length from the smaller cell dimension\n      var baseLength = Math.min(cellWidth, cellHeight) * this.lengthRatio;\n      var halfLength = baseLength / 2;\n\n      // Generate grid of lines\n      for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n          var centerX = startX + j * cellWidth + cellWidth / 2;\n          var centerY = startY + i * cellHeight + cellHeight / 2;\n\n          // Create line centered at cell position with rotation\n          lines.push(\"<line \\n                    x1=\\\"-\".concat(halfLength, \"\\\" \\n                    y1=\\\"0\\\"\\n                    x2=\\\"\").concat(halfLength, \"\\\" \\n                    y2=\\\"0\\\"\\n                    transform=\\\"translate(\").concat(centerX, \" \").concat(centerY, \") rotate(\").concat(this.rotation, \")\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                    stroke-linecap=\\\"\").concat(this.lineCap, \"\\\"\\n                />\"));\n        }\n      }\n      return \"<g>\".concat(lines.join(''), \"</g>\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(LineGrid, \"parameters\", {\n  size: {\n    min: 100,\n    max: 250,\n    \"default\": 200\n  },\n  rows: {\n    min: 1,\n    max: 8,\n    \"default\": 3\n  },\n  columns: {\n    min: 1,\n    max: 8,\n    \"default\": 3\n  },\n  lengthRatio: {\n    min: 0.2,\n    max: 2,\n    \"default\": 0.8\n  },\n  rotation: {\n    min: 0,\n    max: 360,\n    \"default\": 45\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 6\n  },\n  lineCap: {\n    options: ['butt', 'round', 'square'],\n    \"default\": 'round'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LineGrid);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/LineGrid.js?");

/***/ }),

/***/ "./src/shapes/LinesBurst.js":
/*!**********************************!*\
  !*** ./src/shapes/LinesBurst.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a radial burst of lines originating near the center, with\n * randomized lengths.\n */\nvar LinesBurst = /*#__PURE__*/function (_Shape) {\n  function LinesBurst() {\n    _classCallCheck(this, LinesBurst);\n    return _callSuper(this, LinesBurst, arguments);\n  }\n  _inherits(LinesBurst, _Shape);\n  return _createClass(LinesBurst, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Reset RNG for consistent results with the same seed\n      this.resetRNG();\n      var lines = [];\n      var rotationRad = this.rotation * Math.PI / 180;\n      var angleStep = 2 * Math.PI / this.points;\n      for (var i = 0; i < this.points; i++) {\n        // Calculate angle for this line\n        var angle = i * angleStep + rotationRad;\n\n        // Calculate line length with variation\n        var variation = 1 + (this.random() * 2 - 1) * this.lengthVariation;\n        var lineLength = this.radius * variation;\n\n        // Calculate start and end coordinates\n        // Start slightly away from center to avoid the central circle effect\n        var startX = Math.cos(angle) * (this.radius * 0.05);\n        var startY = Math.sin(angle) * (this.radius * 0.05);\n        var endX = Math.cos(angle) * lineLength;\n        var endY = Math.sin(angle) * lineLength;\n\n        // Create the line element\n        lines.push(\"<line \\n                x1=\\\"\".concat(startX, \"\\\" \\n                y1=\\\"\").concat(startY, \"\\\" \\n                x2=\\\"\").concat(endX, \"\\\" \\n                y2=\\\"\").concat(endY, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                stroke-linecap=\\\"round\\\"\\n            />\"));\n      }\n      return lines.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(LinesBurst, \"parameters\", {\n  radius: {\n    min: 20,\n    max: 100,\n    \"default\": 80\n  },\n  points: {\n    min: 6,\n    max: 24,\n    \"default\": 12\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 4\n  },\n  lengthVariation: {\n    min: 0.1,\n    max: 0.9,\n    \"default\": 0.3\n  },\n  rotation: {\n    min: 0,\n    max: 360,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LinesBurst);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/LinesBurst.js?");

/***/ }),

/***/ "./src/shapes/LissajousCurve.js":
/*!**************************************!*\
  !*** ./src/shapes/LissajousCurve.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a Lissajous curve pattern using parametric equations with\n * adjustable frequencies and phase shift.\n */\nvar LissajousShape = /*#__PURE__*/function (_Shape) {\n  function LissajousShape() {\n    _classCallCheck(this, LissajousShape);\n    return _callSuper(this, LissajousShape, arguments);\n  }\n  _inherits(LissajousShape, _Shape);\n  return _createClass(LissajousShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var scale = 80;\n      var phaseRad = this.phaseShift * Math.PI / 180;\n      var segments = 128; // Increased for smoother interpolation\n      var tension = 0.3; // Controls curve tightness\n      var pathParts = [];\n\n      // Pre-calculate points for better control point estimation\n      var points = [];\n      for (var i = 0; i <= segments + 1; i++) {\n        var t = i / segments * 2 * Math.PI;\n        var x = scale * Math.sin(this.frequencyX * t + phaseRad);\n        var y = scale * Math.sin(this.frequencyY * t);\n\n        // Ensure we have valid numbers\n        points.push({\n          x: isNaN(x) ? 0 : x,\n          y: isNaN(y) ? 0 : y,\n          t: t\n        });\n      }\n\n      // Calculate smooth curve using optimized cubic Bzier curves\n      for (var _i = 0; _i < segments; _i++) {\n        var p0 = points[_i];\n        var p1 = points[_i + 1];\n\n        // Calculate derivatives for smooth tangents\n        var dx0 = scale * this.frequencyX * Math.cos(this.frequencyX * p0.t + phaseRad);\n        var dy0 = scale * this.frequencyY * Math.cos(this.frequencyY * p0.t);\n        var dx1 = scale * this.frequencyX * Math.cos(this.frequencyX * p1.t + phaseRad);\n        var dy1 = scale * this.frequencyY * Math.cos(this.frequencyY * p1.t);\n\n        // Calculate control point distances with dynamic tension\n        var dist = Math.sqrt(Math.pow(p1.x - p0.x, 2) + Math.pow(p1.y - p0.y, 2)) * tension;\n\n        // Normalize tangent vectors with safety checks\n        var len0 = Math.sqrt(dx0 * dx0 + dy0 * dy0);\n        var len1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n\n        // Calculate control points with safety checks to prevent NaN\n        var cp1x = void 0,\n          cp1y = void 0,\n          cp2x = void 0,\n          cp2y = void 0;\n        if (len0 > 0.0001) {\n          cp1x = p0.x + dx0 * dist / len0;\n          cp1y = p0.y + dy0 * dist / len0;\n        } else {\n          // Fallback if tangent length is too small\n          cp1x = p0.x;\n          cp1y = p0.y;\n        }\n        if (len1 > 0.0001) {\n          cp2x = p1.x - dx1 * dist / len1;\n          cp2y = p1.y - dy1 * dist / len1;\n        } else {\n          // Fallback if tangent length is too small\n          cp2x = p1.x;\n          cp2y = p1.y;\n        }\n\n        // Ensure all values are valid numbers\n        cp1x = isNaN(cp1x) ? p0.x : cp1x;\n        cp1y = isNaN(cp1y) ? p0.y : cp1y;\n        cp2x = isNaN(cp2x) ? p1.x : cp2x;\n        cp2y = isNaN(cp2y) ? p1.y : cp2y;\n        if (_i === 0) {\n          pathParts.push(\"M\".concat(p0.x, \",\").concat(p0.y));\n        }\n        pathParts.push(\"C\".concat(cp1x, \",\").concat(cp1y, \" \").concat(cp2x, \",\").concat(cp2y, \" \").concat(p1.x, \",\").concat(p1.y));\n      }\n\n      // Close the path smoothly\n      pathParts.push(\"Z\");\n      return \"<path \\n            d=\\\"\".concat(pathParts.join(' '), \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            stroke-linecap=\\\"round\\\"\\n            stroke-linejoin=\\\"round\\\"\\n            fill=\\\"none\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(LissajousShape, \"parameters\", {\n  thickness: {\n    min: 2,\n    max: 24,\n    \"default\": 7\n  },\n  frequencyX: {\n    min: 1,\n    max: 12,\n    \"default\": 4\n  },\n  frequencyY: {\n    min: 1,\n    max: 12,\n    \"default\": 3\n  },\n  phaseShift: {\n    min: 0,\n    max: 360,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LissajousShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/LissajousCurve.js?");

/***/ }),

/***/ "./src/shapes/LoadingSpinner.js":
/*!**************************************!*\
  !*** ./src/shapes/LoadingSpinner.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a circular loading spinner composed of multiple ellipses.\n * The ellipses decrease in size around the circle, creating a fading effect.\n */\nvar LoadingSpinner = /*#__PURE__*/function (_Shape) {\n  function LoadingSpinner() {\n    _classCallCheck(this, LoadingSpinner);\n    return _callSuper(this, LoadingSpinner, arguments);\n  }\n  _inherits(LoadingSpinner, _Shape);\n  return _createClass(LoadingSpinner, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var svgString = '';\n      var numShapes = Math.round(this.numShapes);\n      var rotationOffsetRad = this.rotationOffset * Math.PI / 180;\n      for (var i = 0; i < numShapes; i++) {\n        // Calculate scale: Linearly decrease from 1 down to minScale\n        // Element 0 is largest, element numShapes-1 is smallest\n        var scale = 1 - (1 - this.minScale) * (i / numShapes);\n\n        // Calculate angle for this ellipse\n        var angleRad = i / numShapes * 2 * Math.PI + rotationOffsetRad;\n\n        // Calculate center position of the ellipse\n        var cx = this.radius * Math.cos(angleRad);\n        var cy = this.radius * Math.sin(angleRad);\n\n        // Calculate ellipse radii based on scale\n        // rx is the radius along the original x-axis (becomes tangential after rotation)\n        // ry is the radius along the original y-axis (becomes radial after rotation)\n        var rx = this.ellipseWidth * scale / 2;\n        var ry = this.ellipseHeight * scale / 2;\n\n        // Calculate rotation angle in degrees to align the ellipse tangentially\n        // Rotate by the element's angle + 90 degrees\n        var rotateDeg = angleRad * 180 / Math.PI + 90;\n\n        // Ensure dimensions are positive\n        if (rx > 0 && ry > 0) {\n          svgString += \"<ellipse cx=\\\"\".concat(cx.toFixed(3), \"\\\" cy=\\\"\").concat(cy.toFixed(3), \"\\\" rx=\\\"\").concat(rx.toFixed(3), \"\\\" ry=\\\"\").concat(ry.toFixed(3), \"\\\" transform=\\\"rotate(\").concat(rotateDeg.toFixed(3), \" \").concat(cx.toFixed(3), \" \").concat(cy.toFixed(3), \")\\\" fill=\\\"white\\\" />\\n\");\n        }\n      }\n      return svgString;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(LoadingSpinner, \"parameters\", {\n  numShapes: {\n    type: 'number',\n    min: 3,\n    max: 30,\n    step: 1,\n    \"default\": 12,\n    label: 'Number of Shapes'\n  },\n  radius: {\n    type: 'number',\n    min: 10,\n    max: 75,\n    // Keep within bounds (radius + ellipseWidth/2 <= 100)\n    step: 1,\n    \"default\": 60,\n    label: 'Circle Radius'\n  },\n  ellipseWidth: {\n    type: 'number',\n    min: 2,\n    max: 50,\n    // Max tangential length / 2\n    step: 1,\n    \"default\": 30,\n    label: 'Max Shape Width'\n  },\n  ellipseHeight: {\n    type: 'number',\n    min: 1,\n    max: 30,\n    // Max radial length / 2\n    step: 1,\n    \"default\": 30,\n    label: 'Max Shape Height'\n  },\n  minScale: {\n    type: 'number',\n    min: 0.05,\n    max: 1.0,\n    step: 0.05,\n    \"default\": 0.1,\n    label: 'Minimum Scale'\n  },\n  rotationOffset: {\n    type: 'number',\n    min: -180,\n    max: 180,\n    step: 1,\n    \"default\": 0,\n    label: 'Rotation Offset ()'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LoadingSpinner);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/LoadingSpinner.js?");

/***/ }),

/***/ "./src/shapes/LogarithmicDots.js":
/*!***************************************!*\
  !*** ./src/shapes/LogarithmicDots.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a pattern of dots arranged in a logarithmic spiral.\n */\nvar LogarithmicDots = /*#__PURE__*/function (_Shape) {\n  function LogarithmicDots() {\n    _classCallCheck(this, LogarithmicDots);\n    return _callSuper(this, LogarithmicDots, arguments);\n  }\n  _inherits(LogarithmicDots, _Shape);\n  return _createClass(LogarithmicDots, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var dots = [];\n      var angleIncrement = 2 * Math.PI / this.density;\n      var rotationRad = this.rotation * Math.PI / 180;\n      var currentRadius = this.dotSize * 2;\n      var angle = 0;\n      var spiralCount = 0;\n      var maxRadius = 100; // Based on viewBox size\n\n      while (currentRadius < maxRadius && spiralCount < 200) {\n        for (var i = 0; i < this.density; i++) {\n          var theta = angle + i * angleIncrement + rotationRad;\n          var x = currentRadius * Math.cos(theta);\n          var y = currentRadius * Math.sin(theta);\n          dots.push(\"<circle \\n                    cx=\\\"\".concat(x, \"\\\" \\n                    cy=\\\"\").concat(y, \"\\\" \\n                    r=\\\"\").concat(this.dotSize / 2, \"\\\"\\n                    fill=\\\"white\\\"\\n                />\"));\n        }\n        currentRadius *= this.growthRate;\n        angle += angleIncrement / 2;\n        spiralCount++;\n      }\n      return dots.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(LogarithmicDots, \"parameters\", {\n  growthRate: {\n    min: 1.1,\n    max: 2.0,\n    \"default\": 1.2\n  },\n  density: {\n    min: 8,\n    max: 32,\n    \"default\": 16\n  },\n  dotSize: {\n    min: 4,\n    max: 20,\n    \"default\": 6\n  },\n  rotation: {\n    min: -180,\n    max: 180,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LogarithmicDots);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/LogarithmicDots.js?");

/***/ }),

/***/ "./src/shapes/LogoDots.js":
/*!********************************!*\
  !*** ./src/shapes/LogoDots.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a grid of circles, optionally with a vertical stem extending from\n * the top-right corner.\n */\nvar LogoDots = /*#__PURE__*/function (_Shape) {\n  function LogoDots() {\n    _classCallCheck(this, LogoDots);\n    return _callSuper(this, LogoDots, arguments);\n  }\n  _inherits(LogoDots, _Shape);\n  return _createClass(LogoDots, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Access parameters using `this` provided by the base Shape class\n      var baseWidth = this.baseWidth,\n        baseHeight = this.baseHeight,\n        radius = this.radius,\n        gap = this.gap,\n        stemHeight = this.stemHeight;\n\n      // Ensure radius is positive to prevent visual errors or calculation issues.\n      // Use a small positive minimum if radius is zero or negative.\n      var safeRadius = Math.max(0.1, radius);\n\n      // Calculate the distance between the centers of adjacent circles (diameter + gap)\n      var step = 2 * safeRadius + gap;\n      var svgElements = []; // Array to hold SVG circle element strings\n\n      // --- Centering Calculation ---\n      // We establish a calculation grid where the conceptual bottom-left circle's center is at (0,0),\n      // and the Y-axis increases upwards (standard mathematical coordinates).\n      // We then find the bounding box of all circle *centers* in this grid.\n\n      var minCalcXCenter = Infinity;\n      var maxCalcXCenter = -Infinity;\n      var minCalcYCenter = Infinity;\n      var maxCalcYCenter = -Infinity;\n      var hasCircles = false; // Flag to track if any circles will be drawn\n\n      // Calculate extents based on the base grid of circles\n      if (baseWidth > 0 && baseHeight > 0) {\n        hasCircles = true;\n        // In a grid starting at (0,0), the min center is (0,0)\n        // The max center is at column (baseWidth-1) and row (baseHeight-1)\n        minCalcXCenter = 0;\n        maxCalcXCenter = (baseWidth - 1) * step;\n        minCalcYCenter = 0;\n        maxCalcYCenter = (baseHeight - 1) * step;\n      }\n\n      // Calculate extents based on the stem circles (if any) and update overall extents\n      if (baseWidth > 0 && stemHeight > 0) {\n        hasCircles = true;\n        // X position of all stem centers is based on the rightmost column index\n        var stemBaseX = (baseWidth - 1) * step;\n        // Y position of the lowest stem center (just above the base)\n        var stemMinY = baseHeight * step;\n        // Y position of the highest stem center\n        var stemMaxY = (baseHeight - 1 + stemHeight) * step;\n\n        // Update overall min/max centers, considering stem contribution.\n        // Important: If baseHeight was 0, minCalcYCenter might still be Infinity.\n        minCalcXCenter = Math.min(minCalcXCenter === Infinity ? stemBaseX : minCalcXCenter, stemBaseX);\n        maxCalcXCenter = Math.max(maxCalcXCenter === -Infinity ? stemBaseX : maxCalcXCenter, stemBaseX);\n        minCalcYCenter = Math.min(minCalcYCenter === Infinity ? stemMinY : minCalcYCenter, stemMinY);\n        maxCalcYCenter = Math.max(maxCalcYCenter === -Infinity ? stemMaxY : maxCalcYCenter, stemMaxY);\n      }\n\n      // If no circles are defined based on parameters, return an empty string.\n      if (!hasCircles) return '';\n\n      // Calculate the full bounding box of the shape, including the radius extending beyond the centers.\n      var minX = minCalcXCenter - safeRadius;\n      var maxX = maxCalcXCenter + safeRadius;\n      var minY = minCalcYCenter - safeRadius;\n      var maxY = maxCalcYCenter + safeRadius;\n\n      // Calculate the geometric center of this bounding box.\n      // This offset will be subtracted from calculated coordinates to center the shape at (0,0) in the SVG.\n      var geometricCenterX = (minX + maxX) / 2;\n      var geometricCenterY = (minY + maxY) / 2;\n      // --- End Centering Calculation ---\n\n      // --- Generate SVG Circle Elements ---\n\n      // Generate base circles\n      if (baseWidth > 0 && baseHeight > 0) {\n        for (var i = 0; i < baseWidth; i++) {\n          // Iterate through columns (X)\n          for (var j = 0; j < baseHeight; j++) {\n            // Iterate through rows (Y)\n            // Calculate center position in the calculation grid (origin at bottom-left, Y increases upwards)\n            var calcX = i * step;\n            var calcY = j * step;\n\n            // Translate coordinates to center the shape in the SVG viewBox:\n            // Subtract the geometric center offset from the calculated position.\n            var finalCX = calcX - geometricCenterX;\n            // Calculate Y relative to the geometric center (still in math coordinates)\n            var finalCY_math = calcY - geometricCenterY;\n\n            // Add the SVG circle element string to the array.\n            // Note: We flip the final Y coordinate `(-finalCY_math)` because SVG's Y-axis increases downwards.\n            svgElements.push(\"<circle cx=\\\"\".concat(finalCX.toFixed(2), \"\\\" cy=\\\"\").concat((-finalCY_math).toFixed(2), \"\\\" r=\\\"\").concat(safeRadius, \"\\\" fill=\\\"white\\\" />\"));\n          }\n        }\n      }\n\n      // Generate stem circles\n      if (baseWidth > 0 && stemHeight > 0) {\n        var stemColumnIndex = baseWidth - 1; // Stem is always on the rightmost column of the base\n        for (var k = 0; k < stemHeight; k++) {\n          // Iterate through the height of the stem\n          // Row index in the calculation grid; starts above the base height\n          var stemRowIndex = baseHeight + k;\n\n          // Calculate center position in the calculation grid\n          var _calcX = stemColumnIndex * step;\n          var _calcY = stemRowIndex * step;\n\n          // Translate coordinates to center the shape\n          var _finalCX = _calcX - geometricCenterX;\n          var _finalCY_math = _calcY - geometricCenterY; // Y relative to geometric center (math coords)\n\n          // Add the SVG circle element string, flipping the final Y coordinate for SVG.\n          svgElements.push(\"<circle cx=\\\"\".concat(_finalCX.toFixed(2), \"\\\" cy=\\\"\").concat((-_finalCY_math).toFixed(2), \"\\\" r=\\\"\").concat(safeRadius, \"\\\" fill=\\\"white\\\" />\"));\n        }\n      }\n      // --- End Generate SVG Circle Elements ---\n\n      // Join all generated circle strings into a single SVG string, separated by newlines for readability.\n      return svgElements.join('\\n    ');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(LogoDots, \"parameters\", {\n  baseWidth: {\n    type: 'number',\n    label: 'Base Width',\n    min: 1,\n    max: 7,\n    // Max columns in the base rectangle\n    step: 1,\n    \"default\": 2,\n    description: 'Number of circles horizontally in the base rectangle.'\n  },\n  baseHeight: {\n    type: 'number',\n    label: 'Base Height',\n    min: 1,\n    max: 7,\n    // Max rows in the base rectangle\n    step: 1,\n    \"default\": 2,\n    description: 'Number of rows vertically in the base rectangle.'\n  },\n  radius: {\n    type: 'number',\n    label: 'Radius',\n    min: 1,\n    // Minimum radius of 1\n    max: 45,\n    // Adjusted max to prevent easy overflow with larger grids/gaps\n    step: 1,\n    \"default\": 25,\n    description: 'Radius of each individual circle.'\n  },\n  gap: {\n    type: 'number',\n    label: 'Gap',\n    min: -20,\n    // Allow significant overlap by using negative gap\n    max: 25,\n    // Max gap between circles\n    step: 1,\n    \"default\": 0,\n    description: 'Space between adjacent circles (negative for overlap).'\n  },\n  stemHeight: {\n    type: 'number',\n    label: 'Stem Height',\n    min: 0,\n    // Stem can have zero height (no stem)\n    max: 7,\n    // Max number of circles stacked in the stem\n    step: 1,\n    \"default\": 1,\n    description: 'Number of circles stacked vertically on the top-right corner.'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LogoDots);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/LogoDots.js?");

/***/ }),

/***/ "./src/shapes/LotusShape.js":
/*!**********************************!*\
  !*** ./src/shapes/LotusShape.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a lotus-like flower shape composed of outlined segments connecting\n * points on inner and outer circles.\n */\nvar LotusShape = /*#__PURE__*/function (_Shape) {\n  function LotusShape() {\n    _classCallCheck(this, LotusShape);\n    return _callSuper(this, LotusShape, arguments);\n  }\n  _inherits(LotusShape, _Shape);\n  return _createClass(LotusShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var paths = [];\n      var center = {\n        x: 0,\n        y: 0\n      };\n\n      // Ensure points is an integer\n      var pointsInt = Math.round(this.points);\n\n      // Convert rotation to radians\n      var rotationRad = this.rotation * Math.PI / 180;\n\n      // Calculate radii - adjusted to fit 200x200 viewBox\n      var outerRadius = 90; // slightly reduced to ensure fit with curvature\n      var innerRadius = this.innerRadius * outerRadius;\n      for (var i = 0; i < pointsInt; i++) {\n        var angle1 = i * 2 * Math.PI / pointsInt + rotationRad;\n        var angle2 = (i + 1) * 2 * Math.PI / pointsInt + rotationRad;\n        var angleMid = (angle1 + angle2) / 2;\n\n        // Outer points\n        var outer1 = {\n          x: center.x + outerRadius * Math.cos(angle1),\n          y: center.y + outerRadius * Math.sin(angle1)\n        };\n        var outer2 = {\n          x: center.x + outerRadius * Math.cos(angle2),\n          y: center.y + outerRadius * Math.sin(angle2)\n        };\n\n        // Control point for outer curve\n        var outerControl = {\n          x: center.x + outerRadius * (1 + this.curvature) * Math.cos(angleMid),\n          y: center.y + outerRadius * (1 + this.curvature) * Math.sin(angleMid)\n        };\n\n        // Inner points\n        var inner1 = {\n          x: center.x + innerRadius * Math.cos(angle1),\n          y: center.y + innerRadius * Math.sin(angle1)\n        };\n        var inner2 = {\n          x: center.x + innerRadius * Math.cos(angle2),\n          y: center.y + innerRadius * Math.sin(angle2)\n        };\n\n        // Control point for inner curve\n        var innerControl = {\n          x: center.x + innerRadius * (1 - this.curvature) * Math.cos(angleMid),\n          y: center.y + innerRadius * (1 - this.curvature) * Math.sin(angleMid)\n        };\n\n        // Draw the petal segment using a path\n        paths.push(\"<path \\n                d=\\\"M \".concat(outer1.x, \" \").concat(outer1.y, \" \\n                   Q \").concat(outerControl.x, \" \").concat(outerControl.y, \" \").concat(outer2.x, \" \").concat(outer2.y, \"\\n                   L \").concat(inner2.x, \" \").concat(inner2.y, \"\\n                   Q \").concat(innerControl.x, \" \").concat(innerControl.y, \" \").concat(inner1.x, \" \").concat(inner1.y, \"\\n                   Z\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                stroke-linejoin=\\\"round\\\"\\n                fill=\\\"none\\\"\\n            />\"));\n      }\n      return paths.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(LotusShape, \"parameters\", {\n  points: {\n    min: 3,\n    max: 10,\n    \"default\": 6\n  },\n  innerRadius: {\n    min: 0.1,\n    max: 0.9,\n    \"default\": 0.4\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 3\n  },\n  curvature: {\n    min: 0,\n    max: 0.6,\n    \"default\": 0.2\n  },\n  rotation: {\n    min: -180,\n    max: 180,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LotusShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/LotusShape.js?");

/***/ }),

/***/ "./src/shapes/MagneticDipoleField.js":
/*!*******************************************!*\
  !*** ./src/shapes/MagneticDipoleField.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates the symmetrical, looping field lines pattern of a magnetic dipole,\n * with an optional central axis line.\n */\nvar MagneticDipoleField = /*#__PURE__*/function (_Shape) {\n  function MagneticDipoleField() {\n    _classCallCheck(this, MagneticDipoleField);\n    return _callSuper(this, MagneticDipoleField, arguments);\n  }\n  _inherits(MagneticDipoleField, _Shape);\n  return _createClass(MagneticDipoleField, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var maxSize = this.maxSize;\n      var numLines = this.numLines;\n      var strokeWidth = this.strokeWidth;\n      var showAxis = this.showAxis;\n      var axisDashLength = this.axisDashLength;\n      var centralSpacingFactor = this.centralSpacingFactor;\n      var svgString = '';\n      var numSteps = 100; // Number of points per half loop for smoothness\n      var epsilon = 0.01; // Small offset to avoid division by zero or issues at poles (0 and PI)\n\n      // Determine the scale constants (L) for the field lines\n      // r = L * sin^2(phi) where phi is the angle from the dipole axis (y-axis)\n      var L_max = maxSize / 2; // Maximum extent corresponds to r=L at phi=PI/2\n      var L_min = L_max * centralSpacingFactor;\n\n      // Generate each field line loop\n      for (var i = 0; i < numLines; i++) {\n        var L = void 0;\n        if (numLines === 1) {\n          L = L_max;\n        } else {\n          // Distribute lines - can be linear, logarithmic, etc. Linear for now.\n          L = L_min + (L_max - L_min) * (i / (numLines - 1));\n          // Alternative non-linear spacing (more dense near center)\n          // const t = i / (numLines - 1);\n          // L = L_min + (L_max - L_min) * t * t; // Quadratic spacing\n        }\n        var pointsRight = [];\n        // Calculate points for the right half of the loop (phi from 0 to PI)\n        for (var k = 0; k <= numSteps; k++) {\n          var phi = epsilon + k * (Math.PI - 2 * epsilon) / numSteps;\n          var r = L * Math.sin(phi) * Math.sin(phi);\n          // Convert polar (r, phi relative to y-axis) to Cartesian (x, y)\n          var x = r * Math.sin(phi); // x = r * sin(angle_from_y)\n          var y = r * Math.cos(phi); // y = r * cos(angle_from_y)\n          pointsRight.push({\n            x: x,\n            y: y\n          });\n        }\n\n        // Build the SVG path data string for one continuous loop\n        var d = \"M \".concat(pointsRight[0].x.toFixed(3), \" \").concat(pointsRight[0].y.toFixed(3));\n        for (var _k = 1; _k < pointsRight.length; _k++) {\n          d += \" L \".concat(pointsRight[_k].x.toFixed(3), \" \").concat(pointsRight[_k].y.toFixed(3));\n        }\n        // Now draw the left side by reflecting points and drawing in reverse order (bottom to top)\n        for (var _k2 = pointsRight.length - 1; _k2 >= 0; _k2--) {\n          d += \" L \".concat((-pointsRight[_k2].x).toFixed(3), \" \").concat(pointsRight[_k2].y.toFixed(3));\n        }\n        d += ' Z'; // Close the path\n\n        svgString += \"<path d=\\\"\".concat(d, \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(strokeWidth.toFixed(2), \"\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\" />\\n\");\n      }\n\n      // Add the central axis line if requested\n      if (showAxis) {\n        var axisY = maxSize * 0.55; // Extend axis slightly beyond largest loop\n        var axisStrokeWidth = Math.max(0.5, strokeWidth / 2).toFixed(2); // Make axis slightly thinner\n        var dashArray = \"\".concat(axisDashLength, \",\").concat(axisDashLength);\n        svgString += \"<line x1=\\\"0\\\" y1=\\\"\".concat(-axisY.toFixed(3), \"\\\" x2=\\\"0\\\" y2=\\\"\").concat(axisY.toFixed(3), \"\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(axisStrokeWidth, \"\\\" stroke-dasharray=\\\"\").concat(dashArray, \"\\\" />\\n\");\n      }\n      return svgString;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(MagneticDipoleField, \"parameters\", {\n  maxSize: {\n    type: 'number',\n    min: 20,\n    max: 200,\n    // Max size of the outermost field line loop\n    step: 1,\n    \"default\": 150\n  },\n  numLines: {\n    type: 'number',\n    min: 1,\n    max: 15,\n    // Number of field lines to draw\n    step: 1,\n    \"default\": 5\n  },\n  strokeWidth: {\n    type: 'number',\n    min: 0.5,\n    max: 10,\n    step: 0.1,\n    \"default\": 1.5 // Stroke width for the field lines\n  },\n  centralSpacingFactor: {\n    type: 'number',\n    min: 0.01,\n    // Controls how close the innermost line is to the center, relative to maxSize\n    max: 0.5,\n    step: 0.01,\n    \"default\": 0.1\n  },\n  showAxis: {\n    type: 'boolean',\n    \"default\": true // Whether to draw the central dashed axis line\n  },\n  axisDashLength: {\n    type: 'number',\n    min: 1,\n    max: 10,\n    step: 1,\n    \"default\": 4 // Length of dashes and gaps for the axis line\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MagneticDipoleField);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/MagneticDipoleField.js?");

/***/ }),

/***/ "./src/shapes/MazeShape.js":
/*!*********************************!*\
  !*** ./src/shapes/MazeShape.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a square maze pattern using a Depth-First Search algorithm, drawn\n * with line segments for walls.\n */\nvar MazeShape = /*#__PURE__*/function (_Shape) {\n  function MazeShape() {\n    _classCallCheck(this, MazeShape);\n    return _callSuper(this, MazeShape, arguments);\n  }\n  _inherits(MazeShape, _Shape);\n  return _createClass(MazeShape, [{\n    key: \"generateMaze\",\n    value: function generateMaze() {\n      // Reset RNG to ensure consistent results with the same seed\n      this.resetRNG();\n\n      // Initialize grid\n      var grid = [];\n      for (var y = 0; y < this.gridSize; y++) {\n        grid[y] = [];\n        for (var x = 0; x < this.gridSize; x++) {\n          grid[y][x] = {\n            visited: false,\n            walls: {\n              top: true,\n              right: true,\n              bottom: true,\n              left: true\n            }\n          };\n        }\n      }\n\n      // Start DFS from random cell\n      var stack = [];\n      var cy = 0;\n      var cx = 0;\n      grid[cy][cx].visited = true;\n\n      // DFS to create perfect maze\n      while (true) {\n        var neighbors = [];\n\n        // Check neighbors\n        if (cy > 0 && !grid[cy - 1][cx].visited) neighbors.push({\n          y: cy - 1,\n          x: cx,\n          dir: 'top'\n        });\n        if (cx < this.gridSize - 1 && !grid[cy][cx + 1].visited) neighbors.push({\n          y: cy,\n          x: cx + 1,\n          dir: 'right'\n        });\n        if (cy < this.gridSize - 1 && !grid[cy + 1][cx].visited) neighbors.push({\n          y: cy + 1,\n          x: cx,\n          dir: 'bottom'\n        });\n        if (cx > 0 && !grid[cy][cx - 1].visited) neighbors.push({\n          y: cy,\n          x: cx - 1,\n          dir: 'left'\n        });\n        if (neighbors.length > 0) {\n          // Choose random neighbor\n          var idx = Math.floor(this.random() * neighbors.length);\n          var next = neighbors[idx];\n\n          // Remove walls between current and chosen\n          if (next.dir === 'top') {\n            grid[cy][cx].walls.top = false;\n            grid[next.y][next.x].walls.bottom = false;\n          } else if (next.dir === 'right') {\n            grid[cy][cx].walls.right = false;\n            grid[next.y][next.x].walls.left = false;\n          } else if (next.dir === 'bottom') {\n            grid[cy][cx].walls.bottom = false;\n            grid[next.y][next.x].walls.top = false;\n          } else if (next.dir === 'left') {\n            grid[cy][cx].walls.left = false;\n            grid[next.y][next.x].walls.right = false;\n          }\n\n          // Push current position to stack\n          stack.push({\n            y: cy,\n            x: cx\n          });\n\n          // Move to next cell\n          cy = next.y;\n          cx = next.x;\n          grid[cy][cx].visited = true;\n        } else if (stack.length > 0) {\n          // Backtrack\n          var pos = stack.pop();\n          cy = pos.y;\n          cx = pos.x;\n        } else {\n          // Done\n          break;\n        }\n      }\n\n      // Add entry and exit\n      grid[0][0].walls.top = false;\n      grid[this.gridSize - 1][this.gridSize - 1].walls.bottom = false;\n      return grid;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var maze = this.generateMaze();\n      var lines = [];\n      var totalSize = 200;\n      var usableSize = totalSize * 0.8; // 80% of 200\n      var margin = (totalSize - usableSize) / 2;\n      var cellSize = usableSize / this.gridSize;\n      var offset = -100 + margin;\n\n      // Draw walls\n      for (var y = 0; y < this.gridSize; y++) {\n        for (var x = 0; x < this.gridSize; x++) {\n          var cell = maze[y][x];\n          var left = offset + x * cellSize;\n          var top = offset + y * cellSize;\n          var right = left + cellSize;\n          var bottom = top + cellSize;\n          if (cell.walls.top) {\n            lines.push(\"<line x1=\\\"\".concat(left, \"\\\" y1=\\\"\").concat(top, \"\\\" x2=\\\"\").concat(right, \"\\\" y2=\\\"\").concat(top, \"\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(this.lineWidth, \"\\\" stroke-linecap=\\\"square\\\" />\"));\n          }\n          if (cell.walls.right) {\n            lines.push(\"<line x1=\\\"\".concat(right, \"\\\" y1=\\\"\").concat(top, \"\\\" x2=\\\"\").concat(right, \"\\\" y2=\\\"\").concat(bottom, \"\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(this.lineWidth, \"\\\" stroke-linecap=\\\"square\\\" />\"));\n          }\n          if (cell.walls.bottom) {\n            lines.push(\"<line x1=\\\"\".concat(left, \"\\\" y1=\\\"\").concat(bottom, \"\\\" x2=\\\"\").concat(right, \"\\\" y2=\\\"\").concat(bottom, \"\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(this.lineWidth, \"\\\" stroke-linecap=\\\"square\\\" />\"));\n          }\n          if (cell.walls.left) {\n            lines.push(\"<line x1=\\\"\".concat(left, \"\\\" y1=\\\"\").concat(top, \"\\\" x2=\\\"\").concat(left, \"\\\" y2=\\\"\").concat(bottom, \"\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(this.lineWidth, \"\\\" stroke-linecap=\\\"square\\\" />\"));\n          }\n        }\n      }\n      return lines.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(MazeShape, \"parameters\", {\n  gridSize: {\n    min: 3,\n    max: 12,\n    \"default\": 6\n  },\n  lineWidth: {\n    min: 1,\n    max: 10,\n    \"default\": 4\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MazeShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/MazeShape.js?");

/***/ }),

/***/ "./src/shapes/MeepleShape.js":
/*!***********************************!*\
  !*** ./src/shapes/MeepleShape.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a stylized human figure shape resembling a 'meeple' game piece.\n */\nvar MeepleShape = /*#__PURE__*/function (_Shape) {\n  function MeepleShape() {\n    _classCallCheck(this, MeepleShape);\n    return _callSuper(this, MeepleShape, arguments);\n  }\n  _inherits(MeepleShape, _Shape);\n  return _createClass(MeepleShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var scale = 1;\n      var centerX = 0;\n      var centerY = 0;\n\n      // Calculate scaled dimensions\n      var bodyWidth = this.bodyWidth * scale;\n      var bodyHeight = this.bodyHeight * scale;\n      var headSize = this.headSize * scale;\n      var shoulderWidth = this.shoulderWidth * scale;\n      var legSpread = this.legSpread * scale;\n\n      // Create path points\n      var points = [// Start at bottom left leg\n      \"\".concat(centerX - bodyWidth / 2 - legSpread, \",\").concat(centerY + bodyHeight / 2), // Left side up to shoulder\n      \"\".concat(centerX - shoulderWidth / 2, \",\").concat(centerY - bodyHeight / 6), // Left shoulder to neck\n      \"\".concat(centerX - headSize / 2, \",\").concat(centerY - bodyHeight / 6), // Head left side\n      \"\".concat(centerX - headSize / 2, \",\").concat(centerY - bodyHeight / 2), // Head top\n      \"\".concat(centerX + headSize / 2, \",\").concat(centerY - bodyHeight / 2), // Head right side\n      \"\".concat(centerX + headSize / 2, \",\").concat(centerY - bodyHeight / 6), // Right shoulder\n      \"\".concat(centerX + shoulderWidth / 2, \",\").concat(centerY - bodyHeight / 6), // Right side down to leg\n      \"\".concat(centerX + bodyWidth / 2 + legSpread, \",\").concat(centerY + bodyHeight / 2)];\n      return \"<path \\n            d=\\\"M \".concat(points[0], \" L \").concat(points[1], \" L \").concat(points[2], \" L \").concat(points[3], \" L \").concat(points[4], \" L \").concat(points[5], \" L \").concat(points[6], \" L \").concat(points[7], \" Z\\\"\\n            fill=\\\"white\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(MeepleShape, \"parameters\", {\n  bodyWidth: {\n    min: 40,\n    max: 200,\n    \"default\": 100\n  },\n  bodyHeight: {\n    min: 40,\n    max: 200,\n    \"default\": 120\n  },\n  headSize: {\n    min: 20,\n    max: 100,\n    \"default\": 50\n  },\n  shoulderWidth: {\n    min: 40,\n    max: 250,\n    \"default\": 160\n  },\n  legSpread: {\n    min: 0,\n    max: 60,\n    \"default\": 30\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MeepleShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/MeepleShape.js?");

/***/ }),

/***/ "./src/shapes/MeshGridShape.js":
/*!*************************************!*\
  !*** ./src/shapes/MeshGridShape.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a distorted grid (square or radial) using Perlin noise, creating an\n * organic mesh effect.\n */\nvar MeshGridShape = /*#__PURE__*/function (_Shape) {\n  function MeshGridShape() {\n    _classCallCheck(this, MeshGridShape);\n    return _callSuper(this, MeshGridShape, arguments);\n  }\n  _inherits(MeshGridShape, _Shape);\n  return _createClass(MeshGridShape, [{\n    key: \"noise\",\n    value:\n    // Enhanced noise function with better distribution\n    function noise(x, y) {\n      var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      // Use the seed but don't modify it directly\n      var seed = this.seed;\n      // More harmonious frequency components\n      var p1 = Math.sin((x + y * 0.7) * 0.13 + seed * 0.31);\n      var p2 = Math.sin((x * 1.1 - y * 0.5) * 0.23 + seed * 1.51);\n      var p3 = Math.cos((x * 0.81 + y * 0.62) * 0.19 + seed * 0.47);\n      var p4 = Math.sin((x * 0.31 + y * 1.1) * 0.18 + seed * 0.69);\n\n      // Weight components for better distribution\n      return p1 * 0.35 + p2 * 0.25 + p3 * 0.22 + p4 * 0.18;\n    }\n\n    // Smoothed noise function for high quality\n  }, {\n    key: \"smoothedNoise\",\n    value: function smoothedNoise(x, y) {\n      var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      // Skip smoothing if smoothness is at minimum\n      if (this.smoothness <= 1) return this.noise(x, y, z);\n\n      // Get surrounding noise values\n      var smoothingRadius = Math.min(this.smoothness * 0.1, 0.8);\n      var sum = 0;\n      var count = 0;\n\n      // Higher quality sampling for smoothed noise\n      var sampleCount = Math.max(3, Math.floor(this.smoothness));\n      for (var sx = -smoothingRadius; sx <= smoothingRadius; sx += smoothingRadius * 2 / (sampleCount - 1)) {\n        for (var sy = -smoothingRadius; sy <= smoothingRadius; sy += smoothingRadius * 2 / (sampleCount - 1)) {\n          sum += this.noise(x + sx, y + sy, z);\n          count++;\n        }\n      }\n      return sum / count;\n    }\n\n    // Adaptive distance attenuation\n  }, {\n    key: \"getDistanceAttenuation\",\n    value: function getDistanceAttenuation(x, y) {\n      // Use dynamic boundary based on grid parameters\n      var maxDistance = 140 + this.gridSize * 3;\n      var distance = Math.sqrt(x * x + y * y);\n\n      // More natural quadratic falloff\n      var normalizedDistance = Math.min(1, Math.pow(distance / maxDistance, 1.5));\n      if (this.fadeEdges > 0) {\n        var fadeAmount = this.fadeEdges / 100;\n        // Smoother transition curve\n        return Math.max(0, 1 - Math.pow(normalizedDistance * fadeAmount, 1.3));\n      }\n      return 1 - normalizedDistance * 0.2;\n    }\n\n    // Enhanced distortion with boundary protection and smoother transitions\n  }, {\n    key: \"distortPoint\",\n    value: function distortPoint(x, y) {\n      var attenuation = this.getDistanceAttenuation(x, y);\n\n      // Calculate bounds-aware distortion limit\n      var viewBoxBoundary = 190;\n      var distanceToEdgeX = viewBoxBoundary - Math.abs(x);\n      var distanceToEdgeY = viewBoxBoundary - Math.abs(y);\n      var distanceToBoundary = Math.min(distanceToEdgeX, distanceToEdgeY);\n\n      // Adaptive distortion strength\n      var safetyFactor = 0.6;\n      var maxAllowedDistortion = Math.max(5, distanceToBoundary * safetyFactor);\n\n      // Scale distortion based on parameter and limits\n      var effectiveDistortion = Math.min(this.distortion * attenuation, maxAllowedDistortion);\n\n      // Enhanced flow field with natural curvature\n      var baseAngle = Math.atan2(y, x);\n      var radiusRatio = Math.min(1, Math.sqrt(x * x + y * y) / 160);\n      var adaptiveFlowStrength = 0.25 + radiusRatio * 0.1;\n\n      // Calculate offset with smoothed noise for higher quality\n      var noiseX = this.smoothedNoise(x / this.noiseScale + Math.cos(baseAngle * 1.3) * adaptiveFlowStrength, y / this.noiseScale + Math.sin(baseAngle * 1.3) * adaptiveFlowStrength, 1.0) * effectiveDistortion;\n      var noiseY = this.smoothedNoise(x / this.noiseScale + Math.cos(baseAngle * 1.8) * adaptiveFlowStrength, y / this.noiseScale + Math.sin(baseAngle * 1.8) * adaptiveFlowStrength, 2.5) * effectiveDistortion;\n      return {\n        x: x + noiseX,\n        y: y + noiseY\n      };\n    }\n  }, {\n    key: \"generateRadialGrid\",\n    value: function generateRadialGrid() {\n      var lines = [];\n\n      // Calculate optimal parameters for radial grid\n      var viewBoxSize = 400;\n      var safeRadius = viewBoxSize / 2 * 0.85;\n      var maxRadius = Math.min(this.gridSize * this.cellSize, safeRadius);\n\n      // Higher segment count for smooth circles\n      var segmentMultiplier = Math.max(3, Math.min(12, Math.floor(this.gridSize * 0.75)));\n      var radialSegments = 36 + segmentMultiplier * 4;\n\n      // Adaptive circle count based on grid size\n      var targetCircleCount = Math.max(4, this.gridSize + 1);\n      var effectiveCellSize = maxRadius / targetCircleCount;\n\n      // Generate concentric circles with adaptive spacing\n      var circles = [];\n      for (var i = 1; i <= targetCircleCount; i++) {\n        // Use non-linear spacing for more interesting results\n        var ratio = i / targetCircleCount;\n        var r = maxRadius * Math.pow(ratio, 0.9);\n        var circlePoints = [];\n        for (var j = 0; j <= radialSegments; j++) {\n          var angle = j / radialSegments * Math.PI * 2;\n          var x = Math.cos(angle) * r;\n          var y = Math.sin(angle) * r;\n          var distorted = this.distortPoint(x, y);\n          circlePoints.push(distorted);\n        }\n        circles.push(circlePoints);\n      }\n\n      // Draw concentric circles with high-quality paths\n      for (var _i = 0, _circles = circles; _i < _circles.length; _i++) {\n        var _circlePoints = _circles[_i];\n        for (var _i2 = 0; _i2 < _circlePoints.length - 1; _i2++) {\n          // Skip some points for optimization when lines are very close\n          if (_i2 % Math.max(1, Math.floor(radialSegments / 120)) !== 0 && _i2 !== _circlePoints.length - 2) continue;\n          lines.push(\"<line \\n                    x1=\\\"\".concat(_circlePoints[_i2].x, \"\\\" \\n                    y1=\\\"\").concat(_circlePoints[_i2].y, \"\\\" \\n                    x2=\\\"\").concat(_circlePoints[_i2 + 1].x, \"\\\" \\n                    y2=\\\"\").concat(_circlePoints[_i2 + 1].y, \"\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(this.lineThickness, \"\\\"\\n                    stroke-linecap=\\\"round\\\"\\n                />\"));\n        }\n      }\n\n      // Draw radial lines with adaptive spacing\n      var targetRadialLineCount = Math.max(12, this.gridSize * 3);\n      var radialLineSpacing = Math.ceil(radialSegments / targetRadialLineCount);\n      for (var a = 0; a < radialSegments; a += radialLineSpacing) {\n        var radialPoints = [];\n        for (var _r = 0; _r < circles.length; _r++) {\n          radialPoints.push(circles[_r][a]);\n        }\n\n        // Draw radial lines\n        for (var _i3 = 0; _i3 < radialPoints.length - 1; _i3++) {\n          lines.push(\"<line \\n                    x1=\\\"\".concat(radialPoints[_i3].x, \"\\\" \\n                    y1=\\\"\").concat(radialPoints[_i3].y, \"\\\" \\n                    x2=\\\"\").concat(radialPoints[_i3 + 1].x, \"\\\" \\n                    y2=\\\"\").concat(radialPoints[_i3 + 1].y, \"\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(this.lineThickness, \"\\\"\\n                    stroke-linecap=\\\"round\\\"\\n                />\"));\n        }\n      }\n      return lines.join('');\n    }\n  }, {\n    key: \"generateSquareGrid\",\n    value: function generateSquareGrid() {\n      var lines = [];\n\n      // Calculate optimal grid parameters\n      var viewBoxSize = 400;\n      var safeSize = viewBoxSize * 0.84 / 2;\n\n      // Use symmetric grid by default for centering\n      var halfGridCount = this.gridSize;\n      var cellSize = Math.min(this.cellSize, safeSize / halfGridCount);\n\n      // Generate grid points with precise centering\n      var grid = [];\n      for (var i = -halfGridCount; i <= halfGridCount; i++) {\n        var row = [];\n        var y = i * cellSize;\n        for (var j = -halfGridCount; j <= halfGridCount; j++) {\n          var x = j * cellSize;\n          var distorted = this.distortPoint(x, y);\n          row.push(distorted);\n        }\n        grid.push(row);\n      }\n\n      // Draw horizontal lines with high-quality rendering\n      for (var _i4 = 0; _i4 < grid.length; _i4++) {\n        for (var _j = 0; _j < grid[_i4].length - 1; _j++) {\n          var p1 = grid[_i4][_j];\n          var p2 = grid[_i4][_j + 1];\n\n          // Calculate distance-based thickness variation\n          var centerDistance = Math.sqrt(Math.pow((p1.x + p2.x) / 2, 2) + Math.pow((p1.y + p2.y) / 2, 2));\n\n          // Smoother thickness transition\n          var adjustedThickness = this.lineThickness * (1 - Math.min(0.35, Math.pow(centerDistance / 420, 1.2)));\n          lines.push(\"<line \\n                    x1=\\\"\".concat(p1.x, \"\\\" \\n                    y1=\\\"\").concat(p1.y, \"\\\" \\n                    x2=\\\"\").concat(p2.x, \"\\\" \\n                    y2=\\\"\").concat(p2.y, \"\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(adjustedThickness, \"\\\"\\n                    stroke-linecap=\\\"round\\\"\\n                />\"));\n        }\n      }\n\n      // Draw vertical lines with same high-quality approach\n      for (var _j2 = 0; _j2 < grid[0].length; _j2++) {\n        for (var _i5 = 0; _i5 < grid.length - 1; _i5++) {\n          var _p = grid[_i5][_j2];\n          var _p2 = grid[_i5 + 1][_j2];\n          var _centerDistance = Math.sqrt(Math.pow((_p.x + _p2.x) / 2, 2) + Math.pow((_p.y + _p2.y) / 2, 2));\n          var _adjustedThickness = this.lineThickness * (1 - Math.min(0.35, Math.pow(_centerDistance / 420, 1.2)));\n          lines.push(\"<line \\n                    x1=\\\"\".concat(_p.x, \"\\\" \\n                    y1=\\\"\").concat(_p.y, \"\\\" \\n                    x2=\\\"\").concat(_p2.x, \"\\\" \\n                    y2=\\\"\").concat(_p2.y, \"\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(_adjustedThickness, \"\\\"\\n                    stroke-linecap=\\\"round\\\"\\n                />\"));\n        }\n      }\n      return lines.join('');\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Reset RNG to ensure consistent results with the same seed\n      this.resetRNG();\n      if (this.gridStyle === 'radial') {\n        return this.generateRadialGrid();\n      } else {\n        return this.generateSquareGrid();\n      }\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(MeshGridShape, \"parameters\", {\n  gridSize: {\n    min: 2,\n    max: 5,\n    \"default\": 5\n  },\n  cellSize: {\n    min: 10,\n    max: 30,\n    \"default\": 18\n  },\n  distortion: {\n    min: 25,\n    max: 100,\n    \"default\": 55\n  },\n  noiseScale: {\n    min: 5,\n    max: 12,\n    \"default\": 6\n  },\n  lineThickness: {\n    min: 1,\n    max: 4,\n    \"default\": 1.5\n  },\n  gridStyle: {\n    options: ['square', 'radial'],\n    \"default\": 'radial'\n  },\n  fadeEdges: {\n    min: 0,\n    max: 100,\n    \"default\": 60\n  },\n  // seed is now inherited from Shape class\n  smoothness: {\n    min: 1,\n    max: 10,\n    \"default\": 6\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MeshGridShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/MeshGridShape.js?");

/***/ }),

/***/ "./src/shapes/MessageBubble.js":
/*!*************************************!*\
  !*** ./src/shapes/MessageBubble.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a rounded rectangle speech bubble shape with an adjustable\n * triangular tail.\n */\nvar MessageBubble = /*#__PURE__*/function (_Shape) {\n  function MessageBubble() {\n    _classCallCheck(this, MessageBubble);\n    return _callSuper(this, MessageBubble, arguments);\n  }\n  _inherits(MessageBubble, _Shape);\n  return _createClass(MessageBubble, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var width = this.width;\n      var height = this.height;\n      var cornerRadius = Math.min(this.cornerRadius, Math.min(width, height) / 3);\n      var tailSize = this.tailSize;\n\n      // Calculate bounds\n      var halfWidth = width / 2;\n      var halfHeight = height / 2;\n\n      // Calculate tail position (0 is center, -50/50 is left/right edge)\n      var tailPosRatio = this.tailPosition / 100;\n      var tailX = tailPosRatio * (halfWidth - cornerRadius - tailSize / 2);\n\n      // Build path for bubble\n      var pathData = '';\n\n      // Top edge with corners\n      pathData += \"M \".concat(-halfWidth + cornerRadius, \" \").concat(-halfHeight);\n      pathData += \" L \".concat(halfWidth - cornerRadius, \" \").concat(-halfHeight);\n      pathData += \" Q \".concat(halfWidth, \" \").concat(-halfHeight, \" \").concat(halfWidth, \" \").concat(-halfHeight + cornerRadius);\n\n      // Right edge with corner\n      pathData += \" L \".concat(halfWidth, \" \").concat(halfHeight - cornerRadius);\n      pathData += \" Q \".concat(halfWidth, \" \").concat(halfHeight, \" \").concat(halfWidth - cornerRadius, \" \").concat(halfHeight);\n\n      // Bottom edge with tail and corners\n      if (tailSize > 0) {\n        // Bottom edge to tail start\n        pathData += \" L \".concat(tailX + tailSize / 2, \" \").concat(halfHeight);\n\n        // Tail\n        pathData += \" L \".concat(tailX, \" \").concat(halfHeight + tailSize);\n        pathData += \" L \".concat(tailX - tailSize / 2, \" \").concat(halfHeight);\n      }\n\n      // Finish bottom edge\n      pathData += \" L \".concat(-halfWidth + cornerRadius, \" \").concat(halfHeight);\n      pathData += \" Q \".concat(-halfWidth, \" \").concat(halfHeight, \" \").concat(-halfWidth, \" \").concat(halfHeight - cornerRadius);\n\n      // Left edge with corner\n      pathData += \" L \".concat(-halfWidth, \" \").concat(-halfHeight + cornerRadius);\n      pathData += \" Q \".concat(-halfWidth, \" \").concat(-halfHeight, \" \").concat(-halfWidth + cornerRadius, \" \").concat(-halfHeight);\n\n      // Close the path\n      pathData += ' Z';\n      return \"<path\\n            d=\\\"\".concat(pathData, \"\\\"\\n            fill=\\\"white\\\"\\n            stroke=\\\"none\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(MessageBubble, \"parameters\", {\n  width: {\n    min: 50,\n    max: 200,\n    \"default\": 150\n  },\n  height: {\n    min: 50,\n    max: 150,\n    \"default\": 100\n  },\n  cornerRadius: {\n    min: 0,\n    max: 50,\n    \"default\": 20\n  },\n  tailSize: {\n    min: 15,\n    max: 40,\n    \"default\": 25\n  },\n  tailPosition: {\n    min: -50,\n    max: 50,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MessageBubble);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/MessageBubble.js?");

/***/ }),

/***/ "./src/shapes/MetaBall.js":
/*!********************************!*\
  !*** ./src/shapes/MetaBall.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a single metaball-like blob shape with adjustable radius, lobes,\n * and twist.\n */\nvar MetaBall = /*#__PURE__*/function (_Shape) {\n  function MetaBall() {\n    _classCallCheck(this, MetaBall);\n    return _callSuper(this, MetaBall, arguments);\n  }\n  _inherits(MetaBall, _Shape);\n  return _createClass(MetaBall, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var maxRadius = 100;\n      var normalizedRadius = this.radius / 150.0 * maxRadius;\n      var twistRad = this.twist * Math.PI / 180;\n\n      // Generate the shape points\n      var steps = 100;\n      var points = [];\n      for (var i = 0; i <= steps; i++) {\n        var t = i / steps;\n        var angle = 2 * Math.PI * t;\n\n        // Calculate radius with lobes\n        var r = normalizedRadius * (1 + this.lobeSize * Math.cos(2 * angle + twistRad));\n        var x = r * Math.cos(angle);\n        var y = r * Math.sin(angle);\n        points.push(\"\".concat(x, \",\").concat(y));\n      }\n\n      // Create the SVG polygon\n      return \"<path \\n            d=\\\"M \".concat(points[0], \" L \").concat(points.slice(1).join(' L '), \" Z\\\"\\n            fill=\\\"white\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(MetaBall, \"parameters\", {\n  radius: {\n    min: 40,\n    max: 150,\n    \"default\": 100\n  },\n  lobeSize: {\n    min: 0.2,\n    max: 0.8,\n    \"default\": 0.5\n  },\n  twist: {\n    min: -90,\n    max: 90,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MetaBall);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/MetaBall.js?");

/***/ }),

/***/ "./src/shapes/MetaBalls.js":
/*!*********************************!*\
  !*** ./src/shapes/MetaBalls.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a shape resembling multiple merged metaballs arranged roughly in a\n * circle, using Bezier curves for smooth connections.\n */\nvar MetaBalls = /*#__PURE__*/function (_Shape) {\n  function MetaBalls() {\n    _classCallCheck(this, MetaBalls);\n    return _callSuper(this, MetaBalls, arguments);\n  }\n  _inherits(MetaBalls, _Shape);\n  return _createClass(MetaBalls, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Reset RNG before generating the shape\n      this.resetRNG();\n\n      // Generate ball positions and radiuses\n      var balls = this.generateBalls();\n\n      // Create the metaball path\n      var pathData = this.createMetaballPath(balls);\n\n      // Create the SVG elements\n      return this.createSVGElements(balls, pathData);\n    }\n\n    // No longer needed - using the inherited random() method\n    // seededRandom is replaced with a wrapper that maintains the same interface\n  }, {\n    key: \"seededRandom\",\n    value: function seededRandom(max, min) {\n      var rnd = this.random();\n      if (min === undefined && max === undefined) {\n        return rnd;\n      }\n      if (min === undefined) {\n        min = 0;\n      }\n      return min + rnd * (max - min);\n    }\n  }, {\n    key: \"generateBalls\",\n    value: function generateBalls() {\n      var balls = [];\n      var angleStep = 2 * Math.PI / this.ballCount;\n      for (var i = 0; i < this.ballCount; i++) {\n        // Add slight variation to angle for organic look, but controlled by seed\n        var angleVariation = this.seededRandom(-0.1, 0.1);\n        var angle = i * angleStep + angleVariation;\n\n        // Calculate position based on spacing parameter with subtle variation\n        var distanceFactor = this.seededRandom(0.9, 1.1);\n        var distanceVariation = this.spacing * 0.5 * distanceFactor;\n        var x = Math.cos(angle) * distanceVariation;\n        var y = Math.sin(angle) * distanceVariation;\n\n        // Calculate radius between min and max with controlled variation\n        var radiusRange = this.maxRadius - this.minRadius;\n        var radiusFactor = this.seededRandom(0.6, 0.8);\n        var radius = this.minRadius + radiusRange * radiusFactor;\n        balls.push({\n          x: x,\n          y: y,\n          r: radius,\n          c: [x, y] // Center coordinates as array for calculations\n        });\n      }\n      return balls;\n    }\n  }, {\n    key: \"createMetaballPath\",\n    value: function createMetaballPath(balls) {\n      // We need at least 3 balls to create a smooth metaball\n      if (balls.length < 2) return null;\n      var pathData = '';\n      for (var i = 0; i < balls.length; i++) {\n        // Take current ball and next two balls to create curves\n        var circles = [balls[i], balls[(i + 1) % balls.length], balls[(i + 2) % balls.length]];\n\n        // Calculate points and handles for metaball path between first and second ball\n        var pointsAndHandles = this.curvesBetweenCircles(circles[0].r, circles[1].r, circles[0].c, circles[1].c, this.handleSize, this.tension);\n\n        // If we couldn't calculate curves (e.g., circles too close), skip\n        if (!pointsAndHandles) continue;\n\n        // Calculate for the next pair, to draw arch\n        var next = this.curvesBetweenCircles(circles[1].r, circles[2].r, circles[1].c, circles[2].c, this.handleSize, this.tension);\n\n        // If we couldn't calculate next curves, skip\n        if (!next) continue;\n\n        // Set the starting point of the path ONLY if it's the first valid segment\n        if (pathData === '') {\n          pathData += \"M \".concat(pointsAndHandles.p[1][0], \",\").concat(pointsAndHandles.p[1][1], \" \");\n        }\n\n        // Draw bezier curve and arc\n        pathData += \"C \".concat(pointsAndHandles.h[1][0], \",\").concat(pointsAndHandles.h[1][1], \" \");\n        pathData += \"\".concat(pointsAndHandles.h[3][0], \",\").concat(pointsAndHandles.h[3][1], \" \");\n        pathData += \"\".concat(pointsAndHandles.p[3][0], \",\").concat(pointsAndHandles.p[3][1], \" \");\n        pathData += \"A \".concat(next.r1, \",\").concat(next.r1, \" 1 0 1 \").concat(next.p[1][0], \",\").concat(next.p[1][1], \" \");\n      }\n\n      // Close the path if we have a valid path\n      if (pathData !== '') {\n        pathData += 'Z';\n      }\n      return pathData;\n    }\n  }, {\n    key: \"createSVGElements\",\n    value: function createSVGElements(balls, pathData) {\n      var svg = '';\n\n      // Add the main metaball path if it exists\n      if (pathData && pathData !== '') {\n        svg += \"<path \\n                d=\\\"\".concat(pathData, \"\\\" \\n                fill=\\\"white\\\" \\n                stroke=\\\"none\\\" \\n            />\");\n      }\n      return svg;\n    }\n\n    // Math utility functions\n  }, {\n    key: \"dist\",\n    value: function dist(point1, point2) {\n      return Math.sqrt(Math.pow(point1[0] - point2[0], 2) + Math.pow(point1[1] - point2[1], 2));\n    }\n  }, {\n    key: \"angle\",\n    value: function angle(point1, point2) {\n      return Math.atan2(point1[1] - point2[1], point1[0] - point2[0]);\n    }\n  }, {\n    key: \"getVector\",\n    value: function getVector(center, angle, radius) {\n      return [center[0] + radius * Math.cos(angle), center[1] + radius * Math.sin(angle)];\n    }\n\n    /**\n     * Calculates curves between two circles for metaball effect\n     * Based on Metaball script by SATO Hiroyuki\n     */\n  }, {\n    key: \"curvesBetweenCircles\",\n    value: function curvesBetweenCircles(radius1, radius2, center1, center2) {\n      var handleSize = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 2.4;\n      var v = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0.5;\n      var HALF_PI = Math.PI / 2;\n      var d = this.dist(center1, center2);\n      var u1 = 0,\n        u2 = 0;\n\n      // Check if the circles are too close or far apart\n      if (radius1 === 0 || radius2 === 0 || d <= Math.abs(radius1 - radius2)) {\n        return null;\n      }\n\n      // Calculate angles when circles intersect\n      if (d < radius1 + radius2) {\n        u1 = Math.acos((radius1 * radius1 + d * d - radius2 * radius2) / (2 * radius1 * d));\n        u2 = Math.acos((radius2 * radius2 + d * d - radius1 * radius1) / (2 * radius2 * d));\n      }\n\n      // Calculate all the angles\n      var angleBetweenCenters = this.angle(center2, center1);\n      var maxSpread = Math.acos((radius1 - radius2) / d);\n      var angle1 = angleBetweenCenters + u1 + (maxSpread - u1) * v;\n      var angle2 = angleBetweenCenters - u1 - (maxSpread - u1) * v;\n      var angle3 = angleBetweenCenters + Math.PI - u2 - (Math.PI - u2 - maxSpread) * v;\n      var angle4 = angleBetweenCenters - Math.PI + u2 + (Math.PI - u2 - maxSpread) * v;\n\n      // Calculate points\n      var p1 = this.getVector(center1, angle1, radius1);\n      var p2 = this.getVector(center1, angle2, radius1);\n      var p3 = this.getVector(center2, angle3, radius2);\n      var p4 = this.getVector(center2, angle4, radius2);\n\n      // Define handle length by the distance between both ends of the curve\n      var totalRadius = radius1 + radius2;\n      var d2Base = Math.min(v * handleSize, this.dist(p1, p3) / totalRadius);\n\n      // Take into account when circles are overlapping\n      var d2 = d2Base * Math.min(1, d * 2 / (radius1 + radius2));\n      var r1 = radius1 * d2;\n      var r2 = radius2 * d2;\n\n      // Calculate handle points\n      var h1 = this.getVector(p1, angle1 - HALF_PI, r1);\n      var h2 = this.getVector(p2, angle2 + HALF_PI, r1);\n      var h3 = this.getVector(p3, angle3 + HALF_PI, r2);\n      var h4 = this.getVector(p4, angle4 - HALF_PI, r2);\n      return {\n        p: [p1, p2, p3, p4],\n        h: [h1, h2, h3, h4],\n        escaped: d > radius1,\n        r: radius2,\n        r1: radius1\n      };\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(MetaBalls, \"parameters\", {\n  ballCount: {\n    min: 3,\n    max: 12,\n    \"default\": 6\n  },\n  minRadius: {\n    min: 10,\n    max: 40,\n    \"default\": 35\n  },\n  maxRadius: {\n    min: 20,\n    max: 80,\n    \"default\": 25\n  },\n  spacing: {\n    min: 60,\n    max: 120,\n    \"default\": 100\n  },\n  handleSize: {\n    min: 0.5,\n    max: 3.5,\n    \"default\": 2.0\n  },\n  tension: {\n    min: 0.1,\n    max: 0.9,\n    \"default\": 0.3\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MetaBalls);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/MetaBalls.js?");

/***/ }),

/***/ "./src/shapes/Meteor.js":
/*!******************************!*\
  !*** ./src/shapes/Meteor.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a stylized meteor or comet head shape using masked, concentric arcs\n * and vertical lines.\n */\nvar Meteor = /*#__PURE__*/function (_Shape) {\n  function Meteor() {\n    _classCallCheck(this, Meteor);\n    return _callSuper(this, Meteor, arguments);\n  }\n  _inherits(Meteor, _Shape);\n  return _createClass(Meteor, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var elements = [];\n      var maxRadius = this.radius;\n\n      // Define a unique ID for the mask\n      var maskId = \"Meteor-mask-\".concat(Date.now());\n\n      // Create a clip path/mask to cut off the bottom of the shape\n      elements.push(\"\\n            <defs>\\n                <mask id=\\\"\".concat(maskId, \"\\\">\\n                    <rect x=\\\"-200\\\" y=\\\"-200\\\" width=\\\"400\\\" height=\\\"400\\\" fill=\\\"white\\\"/>\\n                    <circle cx=\\\"0\\\" cy=\\\"0\\\" r=\\\"\").concat(maxRadius, \"\\\" fill=\\\"black\\\"/>\\n                </mask>\\n            </defs>\\n        \"));\n\n      // Create a group for all the arcs and lines with the mask applied\n      elements.push(\"<g mask=\\\"url(#\".concat(maskId, \")\\\">\"));\n\n      // Calculate adaptive gap based on radius and lineCount\n      var adaptiveGap = maxRadius / (this.lineCount - 0.5);\n\n      // Create each concentric arc with vertical lines\n      for (var i = 0; i < this.lineCount; i++) {\n        var currentRadius = maxRadius - i * adaptiveGap;\n        if (currentRadius <= 0) continue;\n\n        // Add the semicircular arc\n        elements.push(\"\\n                <path\\n                    d=\\\"M \".concat(-currentRadius, \",0 \\n                       A \").concat(currentRadius, \" \").concat(currentRadius, \" 0 0 1 \").concat(currentRadius, \",0\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(this.strokeWidth, \"\\\"\\n                    fill=\\\"none\\\"\\n                    stroke-linecap=\\\"round\\\"\\n                />\\n            \"));\n\n        // Add left vertical line (extends beyond bottom for clean masking)\n        elements.push(\"\\n                <line\\n                    x1=\\\"\".concat(-currentRadius, \"\\\"\\n                    y1=\\\"0\\\"\\n                    x2=\\\"\").concat(-currentRadius, \"\\\"\\n                    y2=\\\"\").concat(this.bottomExtend, \"\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(this.strokeWidth, \"\\\"\\n                    stroke-linecap=\\\"round\\\"\\n                />\\n            \"));\n\n        // Add right vertical line (extends beyond bottom for clean masking)\n        elements.push(\"\\n                <line\\n                    x1=\\\"\".concat(currentRadius, \"\\\"\\n                    y1=\\\"0\\\"\\n                    x2=\\\"\").concat(currentRadius, \"\\\"\\n                    y2=\\\"\").concat(this.bottomExtend, \"\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(this.strokeWidth, \"\\\"\\n                    stroke-linecap=\\\"round\\\"\\n                />\\n            \"));\n      }\n\n      // Close the group\n      elements.push(\"</g>\");\n      return elements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(Meteor, \"parameters\", {\n  radius: {\n    min: 50,\n    max: 90,\n    \"default\": 50\n  },\n  lineCount: {\n    min: 3,\n    max: 8,\n    \"default\": 3\n  },\n  strokeWidth: {\n    min: 1,\n    max: 20,\n    \"default\": 10\n  },\n  gap: {\n    min: 10,\n    max: 40,\n    \"default\": 18\n  },\n  bottomExtend: {\n    min: 80,\n    max: 150,\n    \"default\": 70\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Meteor);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/Meteor.js?");

/***/ }),

/***/ "./src/shapes/MinimalCirclesLogo.js":
/*!******************************************!*\
  !*** ./src/shapes/MinimalCirclesLogo.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a minimal logo with a central circle and optional surrounding arc\n * segments at corners and sides.\n */\nvar MinimalCirclesLogo = /*#__PURE__*/function (_Shape) {\n  function MinimalCirclesLogo() {\n    _classCallCheck(this, MinimalCirclesLogo);\n    return _callSuper(this, MinimalCirclesLogo, arguments);\n  }\n  _inherits(MinimalCirclesLogo, _Shape);\n  return _createClass(MinimalCirclesLogo, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Access parameters using `this`\n      var cR = this.centerRadius; // Radius of the central circle\n      var sR = this.segmentRadius; // Radius of the surrounding segments\n      var G = this.gap; // Gap between central circle boundary and segment centers\n      var sw = this.strokeWidth;\n\n      // Calculate derived dimensions\n      // D is the distance from the origin (0,0) to the centers of the side segments,\n      // or the coordinates of the effective corner centers for quarter segments.\n      var D = cR + G;\n\n      // Helper function to format numbers for SVG paths\n      var f = function f(num) {\n        return num.toFixed(3);\n      };\n      var svgElements = [];\n      var strokeAttrs = \"stroke=\\\"white\\\" stroke-width=\\\"\".concat(f(sw), \"\\\" fill=\\\"none\\\"\");\n\n      // 1. Central Circle (Conditional)\n      if (this.drawCenter && cR > 0) {\n        var centerFill = this.centerFilled ? \"fill=\\\"white\\\"\" : \"fill=\\\"none\\\"\";\n        var centerStroke = this.centerFilled ? \"stroke=\\\"none\\\"\" : \"stroke=\\\"white\\\" stroke-width=\\\"\".concat(f(sw), \"\\\"\");\n        svgElements.push(\"<circle cx=\\\"0\\\" cy=\\\"0\\\" r=\\\"\".concat(f(cR), \"\\\" \").concat(centerFill, \" \").concat(centerStroke, \"/>\"));\n      }\n\n      // Check if segment radius is valid before attempting to draw segments\n      if (sR <= 0) {\n        return svgElements.join('\\n');\n      }\n\n      // --- Generate surrounding arc segments (Conditional) ---\n      // Paths are defined using the Arc command (A) for drawing the circular segments directly.\n\n      // 2. Corner Segments (Quarter Circles)\n      if (this.drawCorners) {\n        // Top-Right Quarter Circle (centered at D, D)\n        // Arc start: (D, D - sR), Arc end: (D - sR, D), Sweep: 0 (clockwise)\n        var trPath = \"M \".concat(f(D), \",\").concat(f(D - sR), \" A \").concat(f(sR), \",\").concat(f(sR), \" 0 0 0 \").concat(f(D - sR), \",\").concat(f(D));\n        svgElements.push(\"<path d=\\\"\".concat(trPath, \"\\\" \").concat(strokeAttrs, \"/>\"));\n\n        // Top-Left Quarter Circle (centered at -D, D)\n        // Arc start: (-D + sR, D), Arc end: (-D, D - sR), Sweep: 0 (clockwise)\n        var tlPath = \"M \".concat(f(-D + sR), \",\").concat(f(D), \" A \").concat(f(sR), \",\").concat(f(sR), \" 0 0 0 \").concat(f(-D), \",\").concat(f(D - sR));\n        svgElements.push(\"<path d=\\\"\".concat(tlPath, \"\\\" \").concat(strokeAttrs, \"/>\"));\n\n        // Bottom-Left Quarter Circle (centered at -D, -D)\n        // Arc start: (-D, -D + sR), Arc end: (-D + sR, -D), Sweep: 0 (clockwise)\n        var blPath = \"M \".concat(f(-D), \",\").concat(f(-D + sR), \" A \").concat(f(sR), \",\").concat(f(sR), \" 0 0 0 \").concat(f(-D + sR), \",\").concat(f(-D));\n        svgElements.push(\"<path d=\\\"\".concat(blPath, \"\\\" \").concat(strokeAttrs, \"/>\"));\n\n        // Bottom-Right Quarter Circle (centered at D, -D)\n        // Arc start: (D - sR, -D), Arc end: (D, -D + sR), Sweep: 0 (clockwise)\n        var brPath = \"M \".concat(f(D - sR), \",\").concat(f(-D), \" A \").concat(f(sR), \",\").concat(f(sR), \" 0 0 0 \").concat(f(D), \",\").concat(f(-D + sR));\n        svgElements.push(\"<path d=\\\"\".concat(brPath, \"\\\" \").concat(strokeAttrs, \"/>\"));\n      }\n\n      // 3. Side Segments (Half Circles)\n      if (this.drawSides) {\n        // Top Half Circle (centered at 0, D)\n        // Arc start: (-sR, D), Arc end: (sR, D), Sweep: 0 (clockwise - draws bottom arc)\n        var tPath = \"M \".concat(f(-sR), \",\").concat(f(D), \" A \").concat(f(sR), \",\").concat(f(sR), \" 0 0 0 \").concat(f(sR), \",\").concat(f(D));\n        svgElements.push(\"<path d=\\\"\".concat(tPath, \"\\\" \").concat(strokeAttrs, \"/>\"));\n\n        // Left Half Circle (centered at -D, 0)\n        // Arc start: (-D, sR), Arc end: (-D, -sR), Sweep: 0 (clockwise - draws right arc)\n        var lPath = \"M \".concat(f(-D), \",\").concat(f(sR), \" A \").concat(f(sR), \",\").concat(f(sR), \" 0 0 0 \").concat(f(-D), \",\").concat(f(-sR));\n        svgElements.push(\"<path d=\\\"\".concat(lPath, \"\\\" \").concat(strokeAttrs, \"/>\"));\n\n        // Bottom Half Circle (centered at 0, -D)\n        // Arc start: (sR, -D), Arc end: (-sR, -D), Sweep: 0 (clockwise - draws top arc)\n        var bPath = \"M \".concat(f(sR), \",\").concat(f(-D), \" A \").concat(f(sR), \",\").concat(f(sR), \" 0 0 0 \").concat(f(-sR), \",\").concat(f(-D));\n        svgElements.push(\"<path d=\\\"\".concat(bPath, \"\\\" \").concat(strokeAttrs, \"/>\"));\n\n        // Right Half Circle (centered at D, 0)\n        // Arc start: (D, -sR), Arc end: (D, sR), Sweep: 0 (clockwise - draws left arc)\n        var rPath = \"M \".concat(f(D), \",\").concat(f(-sR), \" A \").concat(f(sR), \",\").concat(f(sR), \" 0 0 0 \").concat(f(D), \",\").concat(f(sR));\n        svgElements.push(\"<path d=\\\"\".concat(rPath, \"\\\" \").concat(strokeAttrs, \"/>\"));\n      }\n      return svgElements.join('\\n');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(MinimalCirclesLogo, \"parameters\", {\n  centerRadius: {\n    type: 'number',\n    min: 0,\n    // Can be 0 for no center circle\n    max: 80,\n    step: 1,\n    \"default\": 25,\n    label: 'Center Radius'\n  },\n  segmentRadius: {\n    type: 'number',\n    min: 5,\n    max: 90,\n    step: 1,\n    \"default\": 30,\n    label: 'Segment Radius'\n  },\n  gap: {\n    type: 'number',\n    min: 0,\n    max: 40,\n    step: 1,\n    \"default\": 5,\n    label: 'Gap'\n  },\n  strokeWidth: {\n    type: 'number',\n    min: 0.5,\n    max: 10,\n    step: 0.1,\n    \"default\": 2,\n    label: 'Stroke Width'\n  },\n  drawCenter: {\n    type: 'boolean',\n    \"default\": true,\n    label: 'Draw Center Circle'\n  },\n  centerFilled: {\n    type: 'boolean',\n    \"default\": false,\n    // Default to outlined style\n    label: 'Fill Center Circle'\n  },\n  drawCorners: {\n    type: 'boolean',\n    \"default\": true,\n    label: 'Draw Corner Segments'\n  },\n  drawSides: {\n    type: 'boolean',\n    \"default\": true,\n    label: 'Draw Side Segments'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MinimalCirclesLogo);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/MinimalCirclesLogo.js?");

/***/ }),

/***/ "./src/shapes/MinimalClock.js":
/*!************************************!*\
  !*** ./src/shapes/MinimalClock.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a minimal outlined analog clock face with hands, markers, and\n * optional sub-dials.\n */\nvar MinimalClock = /*#__PURE__*/function (_Shape) {\n  function MinimalClock() {\n    _classCallCheck(this, MinimalClock);\n    return _callSuper(this, MinimalClock, arguments);\n  }\n  _inherits(MinimalClock, _Shape);\n  return _createClass(MinimalClock, [{\n    key: \"getPoint\",\n    value:\n    /**\n     * Helper to convert clock angle (degrees, 0=top, clockwise) and radius to SVG {x, y} point.\n     * @param {number} angle - Angle in degrees (0 is top, clockwise).\n     * @param {number} radius - Distance from the origin (0,0).\n     * @returns {{x: number, y: number}} Cartesian coordinates.\n     */\n    function getPoint(angle, radius) {\n      // Convert angle to radians, adjusting so 0 degrees is at the top (-Y axis)\n      var angleRad = (angle - 90) * Math.PI / 180;\n      return {\n        x: radius * Math.cos(angleRad),\n        y: radius * Math.sin(angleRad)\n      };\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      // Access parameters using `this`\n      var r = this.clockRadius;\n      var elements = [];\n\n      // --- Main Clock Circle ---\n      elements.push(\"<circle cx=\\\"0\\\" cy=\\\"0\\\" r=\\\"\".concat(r.toFixed(3), \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(this.mainCircleStrokeWidth, \"\\\" />\"));\n\n      // --- Main Markers (12, 3, 6, 9 o'clock) ---\n      // Draw markers inwards from the main circle radius\n      var markerLength = this.markerLength;\n      var markerWidth = this.markerWidth;\n      var markerOuterR = r; // Markers start at the main circle edge\n      var markerInnerR = Math.max(0, r - markerLength); // Ensure radius is not negative\n      for (var i = 0; i < 4; i++) {\n        var angle = i * 90;\n        var outer = this.getPoint(angle, markerOuterR);\n        var inner = this.getPoint(angle, markerInnerR);\n        elements.push(\"<line x1=\\\"\".concat(inner.x.toFixed(3), \"\\\" y1=\\\"\").concat(inner.y.toFixed(3), \"\\\" \") + \"x2=\\\"\".concat(outer.x.toFixed(3), \"\\\" y2=\\\"\").concat(outer.y.toFixed(3), \"\\\" \") + \"stroke=\\\"white\\\" stroke-width=\\\"\".concat(markerWidth, \"\\\" stroke-linecap=\\\"round\\\" />\"));\n      }\n\n      // --- Sub-Dials ---\n      if (this.showSubDials) {\n        var subR = this.subDialRadius;\n        var subTickLen = this.subDialTickLength;\n        var subTickWidth = this.subDialTickWidth;\n        var subInnerR = Math.max(0, subR - subTickLen); // Ticks draw inwards\n        var dotPlacementRadius = Math.max(1, subR * 0.25); // Radius for placing the indicator dot circle center\n        var dotIndicatorRadius = this.subDialDotRadius; // Radius of the indicator dot circle itself\n        var dotStrokeWidth = subTickWidth; // Stroke width for the indicator dot circle\n\n        // Function to generate ticks and dot for a sub-dial\n        var createSubDial = function createSubDial(centerX, centerY, numTicks) {\n          var ticksSvg = \"<g transform=\\\"translate(\".concat(centerX.toFixed(3), \", \").concat(centerY.toFixed(3), \")\\\">\");\n          // Optional: Draw sub-dial circle outline\n          // ticksSvg += `<circle cx=\"0\" cy=\"0\" r=\"${subR.toFixed(3)}\" fill=\"none\" stroke=\"white\" stroke-width=\"${subTickWidth}\" opacity=\"0.5\" />`;\n\n          if (numTicks > 0) {\n            for (var _i = 0; _i < numTicks; _i++) {\n              var _angle = _i / numTicks * 360;\n              var _outer = _this.getPoint(_angle, subR);\n              var _inner = _this.getPoint(_angle, subInnerR);\n              ticksSvg += \"<line x1=\\\"\".concat(_inner.x.toFixed(3), \"\\\" y1=\\\"\").concat(_inner.y.toFixed(3), \"\\\" \") + \"x2=\\\"\".concat(_outer.x.toFixed(3), \"\\\" y2=\\\"\").concat(_outer.y.toFixed(3), \"\\\" \") + \"stroke=\\\"white\\\" stroke-width=\\\"\".concat(subTickWidth, \"\\\" stroke-linecap=\\\"butt\\\" />\");\n            }\n          }\n          // Add outlined dot indicator\n          var dotPos = _this.getPoint(_this.subDialDotAngle, dotPlacementRadius);\n          ticksSvg += \"<circle cx=\\\"\".concat(dotPos.x.toFixed(3), \"\\\" cy=\\\"\").concat(dotPos.y.toFixed(3), \"\\\" r=\\\"\").concat(dotIndicatorRadius.toFixed(3), \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(dotStrokeWidth.toFixed(3), \"\\\" />\");\n          ticksSvg += \"</g>\";\n          return ticksSvg;\n        };\n\n        // Top sub-dial\n        elements.push(createSubDial(0, -this.subDialYOffset, this.topSubDialTicks));\n        // Bottom sub-dial\n        elements.push(createSubDial(0, this.subDialYOffset, this.bottomSubDialTicks));\n      }\n\n      // --- Hands ---\n      var hLen = Math.max(0, r * this.hourHandLength);\n      var mLen = Math.max(0, r * this.minuteHandLength);\n      var sLen = Math.max(0, r * this.secondHandLength);\n      var hWidth = this.handWidth;\n      var mWidth = Math.max(0.5, this.handWidth * 0.9); // Ensure min width\n      var sWidth = this.secondHandWidth;\n      var hourEnd = this.getPoint(this.hourAngle, hLen);\n      var minuteEnd = this.getPoint(this.minuteAngle, mLen);\n      var secondEnd = this.getPoint(this.secondAngle, sLen);\n\n      // Draw hands from thickest to thinnest so thinner hands are on top visually\n      // Hour hand\n      elements.push(\"<line x1=\\\"0\\\" y1=\\\"0\\\" x2=\\\"\".concat(hourEnd.x.toFixed(3), \"\\\" y2=\\\"\").concat(hourEnd.y.toFixed(3), \"\\\" \") + \"stroke=\\\"white\\\" stroke-width=\\\"\".concat(hWidth, \"\\\" stroke-linecap=\\\"round\\\" />\"));\n      // Minute hand\n      elements.push(\"<line x1=\\\"0\\\" y1=\\\"0\\\" x2=\\\"\".concat(minuteEnd.x.toFixed(3), \"\\\" y2=\\\"\").concat(minuteEnd.y.toFixed(3), \"\\\" \") + \"stroke=\\\"white\\\" stroke-width=\\\"\".concat(mWidth, \"\\\" stroke-linecap=\\\"round\\\" />\"));\n      // Second hand\n      elements.push(\"<line x1=\\\"0\\\" y1=\\\"0\\\" x2=\\\"\".concat(secondEnd.x.toFixed(3), \"\\\" y2=\\\"\").concat(secondEnd.y.toFixed(3), \"\\\" \") + \"stroke=\\\"white\\\" stroke-width=\\\"\".concat(sWidth, \"\\\" stroke-linecap=\\\"round\\\" />\"));\n\n      // --- Center Pivot ---\n      var pivotRadius = Math.max(1, this.handWidth * 0.8); // Relative to hand width, min radius 1\n      var pivotStrokeWidth = 1; // Fixed stroke width for the pivot outline\n      elements.push(\"<circle cx=\\\"0\\\" cy=\\\"0\\\" r=\\\"\".concat(pivotRadius.toFixed(3), \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(pivotStrokeWidth, \"\\\"/>\"));\n\n      // Combine all SVG elements\n      // Draw order: Main Circle, Markers, Labels, Sub-dials, Hour Hand, Minute Hand, Second Hand, Pivot\n      return elements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(MinimalClock, \"parameters\", {\n  clockRadius: {\n    type: 'number',\n    min: 30,\n    max: 100,\n    // Max 100 to fit comfortably in -100 to +100 box\n    step: 1,\n    \"default\": 95 // Default slightly less than 100 for markers/stroke\n  },\n  mainCircleStrokeWidth: {\n    type: 'number',\n    min: 0.5,\n    max: 10,\n    step: 0.5,\n    \"default\": 1.5 // Stroke width for the main clock circle\n  },\n  hourAngle: {\n    type: 'number',\n    min: 0,\n    max: 360,\n    step: 1,\n    \"default\": 320 // Angle in degrees (0=top, clockwise)\n  },\n  minuteAngle: {\n    type: 'number',\n    min: 0,\n    max: 360,\n    step: 1,\n    \"default\": 45 // Angle in degrees (0=top, clockwise)\n  },\n  secondAngle: {\n    type: 'number',\n    min: 0,\n    max: 360,\n    step: 1,\n    \"default\": 230 // Angle in degrees (0=top, clockwise)\n  },\n  hourHandLength: {\n    // Relative to clockRadius\n    type: 'number',\n    min: 0.1,\n    max: 0.8,\n    step: 0.05,\n    \"default\": 0.5\n  },\n  minuteHandLength: {\n    // Relative to clockRadius\n    type: 'number',\n    min: 0.2,\n    max: 0.95,\n    step: 0.05,\n    \"default\": 0.75\n  },\n  secondHandLength: {\n    // Relative to clockRadius\n    type: 'number',\n    min: 0.2,\n    max: 1.0,\n    step: 0.05,\n    \"default\": 0.85\n  },\n  handWidth: {\n    // Base width for hour/minute hands\n    type: 'number',\n    min: 0.5,\n    max: 10,\n    step: 0.5,\n    \"default\": 2.5\n  },\n  secondHandWidth: {\n    type: 'number',\n    min: 0.5,\n    max: 5,\n    step: 0.5,\n    \"default\": 1\n  },\n  markerLength: {\n    // Length of the main hour markers (drawn inwards from radius)\n    type: 'number',\n    min: 1,\n    max: 30,\n    step: 1,\n    \"default\": 8\n  },\n  markerWidth: {\n    type: 'number',\n    min: 0.5,\n    max: 8,\n    step: 0.5,\n    \"default\": 1.5\n  },\n  showSubDials: {\n    type: 'boolean',\n    \"default\": true\n  },\n  subDialYOffset: {\n    // Vertical offset for sub-dials from center\n    type: 'number',\n    min: 10,\n    max: 80,\n    // Adjusted max based on default radius\n    step: 1,\n    \"default\": 40\n  },\n  subDialRadius: {\n    type: 'number',\n    min: 5,\n    max: 40,\n    // Adjusted max based on default radius/offset\n    step: 1,\n    \"default\": 20\n  },\n  topSubDialTicks: {\n    type: 'number',\n    min: 0,\n    max: 60,\n    step: 1,\n    \"default\": 30 // Adjusted default\n  },\n  bottomSubDialTicks: {\n    type: 'number',\n    min: 0,\n    max: 60,\n    step: 1,\n    \"default\": 12 // Adjusted default\n  },\n  subDialTickLength: {\n    type: 'number',\n    min: 1,\n    max: 10,\n    step: 1,\n    \"default\": 4\n  },\n  subDialTickWidth: {\n    type: 'number',\n    min: 0.5,\n    max: 3,\n    step: 0.5,\n    \"default\": 0.75\n  },\n  subDialDotAngle: {\n    // Angle for the dot indicator\n    type: 'number',\n    min: 0,\n    max: 360,\n    step: 1,\n    \"default\": 315\n  },\n  subDialDotRadius: {\n    // Radius of the indicator dot circle itself\n    type: 'number',\n    min: 0.5,\n    max: 5,\n    step: 0.5,\n    \"default\": 1.5\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MinimalClock);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/MinimalClock.js?");

/***/ }),

/***/ "./src/shapes/MirroredClouds.js":
/*!**************************************!*\
  !*** ./src/shapes/MirroredClouds.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Creates vertically mirrored clusters of circles and scattered individual\n * circles, using Perlin noise for organic placement.\n */\nvar MirroredOrganicClouds = /*#__PURE__*/function (_Shape) {\n  function MirroredOrganicClouds() {\n    _classCallCheck(this, MirroredOrganicClouds);\n    return _callSuper(this, MirroredOrganicClouds, arguments);\n  }\n  _inherits(MirroredOrganicClouds, _Shape);\n  return _createClass(MirroredOrganicClouds, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      this.elements = []; // Store SVG elements here\n      this.placedCircles = []; // Store data of successfully placed circles {cx, cy, r}\n      var maxCoord = 100; // Viewbox half-width/height\n      this.effectiveMaxCoord = maxCoord - this.strokeWidth / 2; // Boundary considering stroke\n\n      // --- Cluster Generation ---\n      var clusterBlueprints = []; // Store parameters for each cluster before trying to place circles\n\n      // Generate blueprints for paired clusters\n      for (var i = 0; i < this.numClusterPairs; i++) {\n        var clusterParams = this._generateClusterBlueprint(maxCoord, true); // Generate params for one side\n        clusterBlueprints.push(_objectSpread(_objectSpread({}, clusterParams), {}, {\n          cx: Math.abs(clusterParams.cx)\n        })); // Right side blueprint\n        // Mirror blueprint data for the left side (same radii, offsets but mirrored cx)\n        clusterBlueprints.push(_objectSpread(_objectSpread({}, clusterParams), {}, {\n          cx: -Math.abs(clusterParams.cx)\n        }));\n      }\n\n      // Generate blueprint for the central cluster if needed\n      if (this.centralCluster) {\n        var centralClusterParams = this._generateClusterBlueprint(maxCoord, false); // Center cluster (cx=0)\n        clusterBlueprints.push(_objectSpread(_objectSpread({}, centralClusterParams), {}, {\n          cx: 0\n        }));\n      }\n\n      // Attempt to place circles for each cluster blueprint\n      clusterBlueprints.forEach(function (blueprint) {\n        _this._attemptPlaceClusterCircles(blueprint);\n      });\n\n      // --- Scattered Circle Generation ---\n      var scatteredBlueprints = []; // Store parameters for potential scattered circles\n\n      // Generate blueprints for paired scattered circles\n      for (var _i = 0; _i < this.numScatteredPairs; _i++) {\n        var scatterParams = this._generateScatteredBlueprint(maxCoord, true);\n        // Store both right and left side blueprints derived from the same noise/randomness\n        scatteredBlueprints.push(_objectSpread(_objectSpread({}, scatterParams), {}, {\n          cx: Math.abs(scatterParams.cx)\n        })); // Right side\n        scatteredBlueprints.push(_objectSpread(_objectSpread({}, scatterParams), {}, {\n          cx: -Math.abs(scatterParams.cx)\n        })); // Left side\n      }\n\n      // Generate blueprint for central scattered circle if needed\n      if (this.centralScattered) {\n        var centralScatterParams = this._generateScatteredBlueprint(maxCoord, false);\n        scatteredBlueprints.push(_objectSpread(_objectSpread({}, centralScatterParams), {}, {\n          cx: 0\n        }));\n      }\n\n      // Attempt to place scattered circles\n      scatteredBlueprints.forEach(function (blueprint) {\n        // Attempt to place this single scattered circle\n        if (_this._canPlace(blueprint.cx, blueprint.cy, blueprint.radius)) {\n          _this._placeCircle(blueprint.cx, blueprint.cy, blueprint.radius);\n        }\n      });\n\n      // Combine all generated SVG element strings\n      return this.elements.join('\\n');\n    }\n\n    /**\n     * Generates the blueprint (parameters) for a single cluster.\n     * @param {number} maxCoord - The maximum coordinate value (half viewbox size).\n     * @param {boolean} allowNonZeroX - If true, allows generating a non-zero X coordinate.\n     * @returns {object} An object containing cluster parameters (cx, cy, numCircles, radii, offsets).\n     */\n  }, {\n    key: \"_generateClusterBlueprint\",\n    value: function _generateClusterBlueprint(maxCoord, allowNonZeroX) {\n      var noiseFactor = this.noiseInfluence;\n\n      // Base position (potentially mirrored later)\n      var baseClusterX = allowNonZeroX ? (this.random() * 0.6 + 0.2) * maxCoord : 0; // Avoid exact center/edge for pairs\n      var baseClusterY = (this.random() * 2 - 1) * (maxCoord * 0.6);\n\n      // Apply noise perturbation\n      var noiseX = this.getNoise(baseClusterX, baseClusterY) * noiseFactor;\n      var noiseY = this.getNoise(baseClusterX + 5.3, baseClusterY + 8.1) * noiseFactor; // Use offset noise coords\n\n      var clusterX = baseClusterX + noiseX;\n      var clusterY = baseClusterY + noiseY;\n      var numCirclesInCluster = Math.floor(this.random() * (this.maxCirclesPerCluster - this.minCirclesPerCluster + 1)) + this.minCirclesPerCluster;\n      var radii = [];\n      var offsets = []; // Store angle and distance for each offset circle\n      var firstRadius = 0;\n      for (var j = 0; j < numCirclesInCluster; j++) {\n        var radius = this.random() * (this.maxRadius - this.minRadius) + this.minRadius;\n        radii.push(radius);\n        if (j === 0) {\n          firstRadius = radius;\n          offsets.push({\n            angle: 0,\n            distance: 0\n          }); // First circle at cluster center\n        } else {\n          // Use noise to influence angle and distance for more organic feel\n          var baseAngle = this.random() * 2 * Math.PI;\n          var angleNoise = this.getNoise(clusterX + j * 1.1, clusterY - j * 2.3) * Math.PI * 0.3; // Small angle noise\n          var angle = baseAngle + angleNoise;\n          var avgRadius = (firstRadius + radius) / 2;\n          var baseDistance = avgRadius * (0.3 + this.random() * 0.8) * this.clusterSpread;\n          var distanceNoise = this.getNoise(clusterY + j * 3.7, clusterX - j * 1.9); // Noise in [-1, 1]\n          // Allow noise to slightly increase or decrease distance, but prevent negative distance\n          var distance = Math.max(avgRadius * 0.1, baseDistance + distanceNoise * avgRadius * 0.4 * this.clusterSpread);\n          offsets.push({\n            angle: angle,\n            distance: distance\n          });\n        }\n      }\n      return {\n        cx: clusterX,\n        cy: clusterY,\n        numCircles: numCirclesInCluster,\n        radii: radii,\n        offsets: offsets\n      };\n    }\n\n    /**\n    * Attempts to place circles defined by a cluster blueprint, checking for collisions.\n    * @param {object} clusterBlueprint - Parameters generated by _generateClusterBlueprint.\n    */\n  }, {\n    key: \"_attemptPlaceClusterCircles\",\n    value: function _attemptPlaceClusterCircles(clusterBlueprint) {\n      var _this2 = this;\n      var clusterX = clusterBlueprint.cx,\n        clusterY = clusterBlueprint.cy,\n        numCircles = clusterBlueprint.numCircles,\n        radii = clusterBlueprint.radii,\n        offsets = clusterBlueprint.offsets;\n      var potentialCircles = [];\n\n      // Calculate potential positions for all circles in the cluster first\n      for (var j = 0; j < numCircles; j++) {\n        var radius = radii[j];\n        var offset = offsets[j];\n        var circleCx = clusterX + Math.cos(offset.angle) * offset.distance;\n        var circleCy = clusterY + Math.sin(offset.angle) * offset.distance;\n        potentialCircles.push({\n          cx: circleCx,\n          cy: circleCy,\n          r: radius\n        });\n      }\n\n      // Attempt to place each potential circle, checking against already placed ones\n      potentialCircles.forEach(function (pCircle) {\n        if (_this2._canPlace(pCircle.cx, pCircle.cy, pCircle.r)) {\n          _this2._placeCircle(pCircle.cx, pCircle.cy, pCircle.r);\n        }\n      });\n    }\n\n    /**\n     * Generates the blueprint (parameters) for a single scattered circle.\n     * @param {number} maxCoord - The maximum coordinate value (half viewbox size).\n     * @param {boolean} allowNonZeroX - If true, allows generating a non-zero X coordinate.\n     * @returns {object} An object containing scattered circle parameters (cx, cy, radius).\n     */\n  }, {\n    key: \"_generateScatteredBlueprint\",\n    value: function _generateScatteredBlueprint(maxCoord, allowNonZeroX) {\n      var noiseFactor = this.noiseInfluence * 1.5; // More noise influence for scattered\n\n      // Base position (potentially mirrored later)\n      var baseCx = allowNonZeroX ? (this.random() * 0.8 + 0.1) * maxCoord * (this.random() > 0.5 ? 1 : -1) // Allow sign initially\n      : 0;\n      var baseCy = (this.random() * 2 - 1) * (maxCoord * 0.8);\n\n      // Apply noise perturbation\n      var noiseX = this.getNoise(baseCx + 100.7, baseCy - 50.2) * noiseFactor;\n      var noiseY = this.getNoise(baseCx - 20.4, baseCy + 75.9) * noiseFactor;\n      var finalCx = baseCx + noiseX;\n      var finalCy = baseCy + noiseY;\n      var radius = this.random() * (this.scatterRadiusMax - this.scatterRadiusMin) + this.scatterRadiusMin;\n      return {\n        cx: finalCx,\n        cy: finalCy,\n        radius: radius\n      };\n    }\n\n    /**\n     * Checks if a new circle can be placed without overlapping existing placed circles.\n     * @param {number} cx - Center X of the new circle.\n     * @param {number} cy - Center Y of the new circle.\n     * @param {number} r - Radius of the new circle.\n     * @returns {boolean} True if placement is possible, false otherwise.\n     */\n  }, {\n    key: \"_canPlace\",\n    value: function _canPlace(cx, cy, r) {\n      // Basic boundary check (center must be roughly within bounds)\n      // More precise clamping happens in _placeCircle before SVG generation\n      if (cx + r < -100 || cx - r > 100 || cy + r < -100 || cy - r > 100) {\n        return false; // Optimization: Definitively out of bounds\n      }\n\n      // Check collision with already placed circles\n      var _iterator = _createForOfIteratorHelper(this.placedCircles),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var placed = _step.value;\n          var dx = cx - placed.cx;\n          var dy = cy - placed.cy;\n          var distSq = dx * dx + dy * dy;\n          var minDist = r + placed.r + this.collisionPadding;\n          if (distSq < minDist * minDist) {\n            return false; // Collision detected\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return true; // No collision\n    }\n\n    /**\n     * Adds a circle's SVG to elements and records its position/radius.\n     * Assumes _canPlace check has already passed.\n     * @param {number} cx - Center X coordinate.\n     * @param {number} cy - Center Y coordinate.\n     * @param {number} r - Radius.\n     */\n  }, {\n    key: \"_placeCircle\",\n    value: function _placeCircle(cx, cy, r) {\n      // Clamp coordinates to ensure the circle edge doesn't go too far out\n      var clampedCx = Math.max(-this.effectiveMaxCoord + r, Math.min(this.effectiveMaxCoord - r, cx));\n      var clampedCy = Math.max(-this.effectiveMaxCoord + r, Math.min(this.effectiveMaxCoord - r, cy));\n\n      // Ensure radius is positive\n      if (r <= 0) return;\n\n      // Generate SVG and add to elements list\n      this._createCircleAndCrossSVG(clampedCx, clampedCy, r);\n\n      // Add to the list of placed circles for future collision checks\n      this.placedCircles.push({\n        cx: clampedCx,\n        cy: clampedCy,\n        r: r\n      });\n    }\n\n    /**\n     * Helper function to generate SVG strings for a single circle and its central cross.\n     * Does NOT perform collision checks, assumes placement is valid.\n     * Adds the generated SVG strings to the `this.elements` array.\n     * @param {number} clampedCx - Final clamped Center X coordinate.\n     * @param {number} clampedCy - Final clamped Center Y coordinate.\n     * @param {number} r - Radius.\n     */\n  }, {\n    key: \"_createCircleAndCrossSVG\",\n    value: function _createCircleAndCrossSVG(clampedCx, clampedCy, r) {\n      // Create circle SVG element string\n      this.elements.push(\"<circle cx=\\\"\".concat(clampedCx.toFixed(2), \"\\\" cy=\\\"\").concat(clampedCy.toFixed(2), \"\\\" r=\\\"\").concat(r.toFixed(2), \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(this.strokeWidth, \"\\\" />\"));\n\n      // Create cross SVG (+) element string if size > 0\n      var crossHalfSize = r * this.crossSize * 0.5;\n      if (crossHalfSize > 0.1) {\n        // Avoid creating tiny paths\n        var x1 = (clampedCx - crossHalfSize).toFixed(2);\n        var x2 = (clampedCx + crossHalfSize).toFixed(2);\n        var y1 = (clampedCy - crossHalfSize).toFixed(2);\n        var y2 = (clampedCy + crossHalfSize).toFixed(2);\n        this.elements.push(\"<path d=\\\"M \".concat(x1, \",\").concat(clampedCy.toFixed(2), \" L \").concat(x2, \",\").concat(clampedCy.toFixed(2), \" M \").concat(clampedCx.toFixed(2), \",\").concat(y1, \" L \").concat(clampedCx.toFixed(2), \",\").concat(y2, \"\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(this.strokeWidth, \"\\\" fill=\\\"none\\\" stroke-linecap=\\\"round\\\" />\"));\n      }\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(MirroredOrganicClouds, \"parameters\", {\n  noiseScale: {\n    type: 'number',\n    min: 0.001,\n    max: 0.1,\n    step: 0.001,\n    \"default\": 0.03,\n    description: 'Scale/frequency of Perlin noise for placement variations.'\n  },\n  numClusterPairs: {\n    type: 'number',\n    min: 0,\n    max: 5,\n    \"default\": 1,\n    description: 'Number of mirrored cluster pairs.'\n  },\n  centralCluster: {\n    type: 'boolean',\n    \"default\": true,\n    description: 'Add a single cluster on the central Y-axis.'\n  },\n  minCirclesPerCluster: {\n    type: 'number',\n    min: 1,\n    max: 10,\n    \"default\": 2,\n    description: 'Minimum circles targeted per cluster.'\n  },\n  maxCirclesPerCluster: {\n    type: 'number',\n    min: 2,\n    max: 15,\n    \"default\": 5,\n    description: 'Maximum circles targeted per cluster.'\n  },\n  minRadius: {\n    type: 'number',\n    min: 4,\n    max: 30,\n    \"default\": 6,\n    description: 'Minimum radius for cluster circles.'\n  },\n  maxRadius: {\n    type: 'number',\n    min: 8,\n    max: 40,\n    \"default\": 18,\n    description: 'Maximum radius for cluster circles.'\n  },\n  clusterSpread: {\n    type: 'number',\n    min: 0.1,\n    max: 2.0,\n    step: 0.1,\n    \"default\": 0.7,\n    description: 'Spread factor for circles within a cluster.'\n  },\n  numScatteredPairs: {\n    type: 'number',\n    min: 0,\n    max: 10,\n    \"default\": 2,\n    description: 'Number of mirrored scattered circle pairs.'\n  },\n  centralScattered: {\n    type: 'boolean',\n    \"default\": true,\n    description: 'Add a single scattered circle on the central Y-axis.'\n  },\n  scatterRadiusMin: {\n    type: 'number',\n    min: 3,\n    max: 25,\n    \"default\": 4,\n    description: 'Minimum radius for scattered circles.'\n  },\n  scatterRadiusMax: {\n    type: 'number',\n    min: 5,\n    max: 30,\n    \"default\": 12,\n    description: 'Maximum radius for scattered circles.'\n  },\n  strokeWidth: {\n    type: 'number',\n    min: 0.5,\n    max: 5,\n    step: 0.5,\n    \"default\": 1.5,\n    description: 'Stroke width for circles and crosses.'\n  },\n  crossSize: {\n    type: 'number',\n    min: 0.0,\n    max: 0.8,\n    step: 0.05,\n    \"default\": 0.4,\n    description: 'Size of the central cross relative to radius.'\n  },\n  collisionPadding: {\n    type: 'number',\n    min: 0,\n    max: 10,\n    step: 0.5,\n    \"default\": 1.0,\n    description: 'Minimum space between circle edges.'\n  },\n  noiseInfluence: {\n    type: 'number',\n    min: 0,\n    max: 50,\n    step: 1,\n    \"default\": 15,\n    description: 'How strongly noise affects position (pixels).'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MirroredOrganicClouds);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/MirroredClouds.js?");

/***/ }),

/***/ "./src/shapes/MirroredCurveShape.js":
/*!******************************************!*\
  !*** ./src/shapes/MirroredCurveShape.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a symmetrical shape composed of two mirrored halves, each featuring\n * a curved top/bottom edge and a straight inner edge, separated by a gap.\n */\nvar MirroredCurveShape = /*#__PURE__*/function (_Shape) {\n  function MirroredCurveShape() {\n    _classCallCheck(this, MirroredCurveShape);\n    return _callSuper(this, MirroredCurveShape, arguments);\n  }\n  _inherits(MirroredCurveShape, _Shape);\n  return _createClass(MirroredCurveShape, [{\n    key: \"round\",\n    value: function round(num) {\n      return Math.round(num * 1000) / 1000;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Calculate dimensions\n      var halfSize = this.round(this.size / 2);\n      var halfHeight = this.round(this.height / 2);\n      var r = this.round(this.curveRadius);\n      var controlPoint = this.round(r * 0.5522847498307936);\n      var gapOffset = this.round(this.gap / 2);\n\n      // Define points for the right half\n      var rightPoints = {\n        start: [gapOffset, -halfHeight + r],\n        topCurve: [[gapOffset, -halfHeight + controlPoint], [gapOffset + controlPoint, -halfHeight], [gapOffset + r, -halfHeight]],\n        topEdge: [halfSize, -halfHeight],\n        rightEdge: [halfSize, halfHeight - r],\n        bottomCurve: [[halfSize, halfHeight - controlPoint], [halfSize - controlPoint, halfHeight], [halfSize - r, halfHeight]],\n        bottomEdge: [gapOffset, halfHeight]\n      };\n\n      // Create right path\n      var rightPath = [\"M \".concat(rightPoints.start[0], \" \").concat(rightPoints.start[1]), \"C \".concat(rightPoints.topCurve.map(function (p) {\n        return \"\".concat(p[0], \" \").concat(p[1]);\n      }).join(' ')), \"H \".concat(rightPoints.topEdge[0]), \"V \".concat(rightPoints.rightEdge[1]), \"C \".concat(rightPoints.bottomCurve.map(function (p) {\n        return \"\".concat(p[0], \" \").concat(p[1]);\n      }).join(' ')), \"H \".concat(rightPoints.bottomEdge[0]), \"V \".concat(rightPoints.start[1]), 'Z'].join(' ');\n\n      // Define points for the left half (mirrored)\n      var leftPoints = {\n        start: [-gapOffset, -halfHeight + r],\n        topCurve: [[-gapOffset, -halfHeight + controlPoint], [-gapOffset - controlPoint, -halfHeight], [-gapOffset - r, -halfHeight]],\n        topEdge: [-halfSize, -halfHeight],\n        leftEdge: [-halfSize, halfHeight - r],\n        bottomCurve: [[-halfSize, halfHeight - controlPoint], [-halfSize + controlPoint, halfHeight], [-halfSize + r, halfHeight]],\n        bottomEdge: [-gapOffset, halfHeight]\n      };\n\n      // Create left path\n      var leftPath = [\"M \".concat(leftPoints.start[0], \" \").concat(leftPoints.start[1]), \"C \".concat(leftPoints.topCurve.map(function (p) {\n        return \"\".concat(p[0], \" \").concat(p[1]);\n      }).join(' ')), \"H \".concat(leftPoints.topEdge[0]), \"V \".concat(leftPoints.leftEdge[1]), \"C \".concat(leftPoints.bottomCurve.map(function (p) {\n        return \"\".concat(p[0], \" \").concat(p[1]);\n      }).join(' ')), \"H \".concat(leftPoints.bottomEdge[0]), \"V \".concat(leftPoints.start[1]), 'Z'].join(' ');\n      return \"\\n            <path d=\\\"\".concat(leftPath, \"\\\" fill=\\\"white\\\" />\\n            <path d=\\\"\").concat(rightPath, \"\\\" fill=\\\"white\\\" />\\n        \");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(MirroredCurveShape, \"parameters\", {\n  size: {\n    min: 60,\n    max: 200,\n    \"default\": 120\n  },\n  height: {\n    min: 40,\n    max: 300,\n    \"default\": 120\n  },\n  curveRadius: {\n    min: 10,\n    max: 60,\n    \"default\": 40\n  },\n  gap: {\n    min: 0,\n    max: 50,\n    \"default\": 10\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MirroredCurveShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/MirroredCurveShape.js?");

/***/ }),

/***/ "./src/shapes/ModulatedGridShape.js":
/*!******************************************!*\
  !*** ./src/shapes/ModulatedGridShape.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a grid pattern where cells are filled based on modulated patterns\n * (checkerboard, columns, blocks) with symmetry options.\n */\nvar ModulatedGridShape = /*#__PURE__*/function (_Shape) {\n  function ModulatedGridShape() {\n    _classCallCheck(this, ModulatedGridShape);\n    return _callSuper(this, ModulatedGridShape, arguments);\n  }\n  _inherits(ModulatedGridShape, _Shape);\n  return _createClass(ModulatedGridShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Ensure parameters are valid\n      var horizontalUnits = Math.max(2, Math.round(this.horizontalUnits));\n      var verticalUnits = Math.max(2, Math.round(this.verticalUnits));\n      var padding = Math.max(0, this.padding);\n\n      // Calculate grid dimensions\n      var availableWidth = 200 - padding * 2;\n      var availableHeight = 200 - padding * 2;\n      var unitWidth = availableWidth / horizontalUnits;\n      var unitHeight = availableHeight / verticalUnits;\n      var totalWidth = unitWidth * horizontalUnits;\n      var totalHeight = unitHeight * verticalUnits;\n\n      // Center the pattern\n      var offsetX = -totalWidth / 2;\n      var offsetY = -totalHeight / 2;\n\n      // Create pattern grid (true = filled, false = empty)\n      var grid = Array(verticalUnits).fill().map(function () {\n        return Array(horizontalUnits).fill(false);\n      });\n\n      // Apply the selected pattern\n      this.applyPattern(grid, horizontalUnits, verticalUnits);\n\n      // Generate rectangles from the grid\n      var rectangles = [];\n      for (var row = 0; row < verticalUnits; row++) {\n        for (var col = 0; col < horizontalUnits; col++) {\n          if (grid[row][col]) {\n            var x = offsetX + col * unitWidth;\n            var y = offsetY + row * unitHeight;\n            rectangles.push(\"M\".concat(x, \",\").concat(y, \" h\").concat(unitWidth, \" v\").concat(unitHeight, \" h\").concat(-unitWidth, \" Z\"));\n          }\n        }\n      }\n      return \"<path d=\\\"\".concat(rectangles.join(' '), \"\\\" fill=\\\"white\\\" />\");\n    }\n  }, {\n    key: \"applyPattern\",\n    value: function applyPattern(grid, horizontalUnits, verticalUnits) {\n      var symmetryType = Math.round(this.symmetry);\n      var variationType = Math.round(this.variation);\n\n      // Determine pattern type based on variation parameter\n      switch (variationType) {\n        case 0:\n          // Checkerboard\n          for (var row = 0; row < verticalUnits; row++) {\n            for (var col = 0; col < horizontalUnits; col++) {\n              grid[row][col] = (row + col) % 2 === 0;\n            }\n          }\n          break;\n        case 1:\n          // Modulated columns\n          for (var _row = 0; _row < verticalUnits; _row++) {\n            for (var _col = 0; _col < horizontalUnits; _col++) {\n              // Create a pattern where only specific columns have cells on certain rows\n              grid[_row][_col] = _col % 2 === 0 && _row % 3 !== 1 || _col % 2 === 1 && _row % 3 === 1;\n            }\n          }\n          break;\n        case 2: // Simple block pattern\n        default:\n          // Pattern based on position in grid - minimal but interesting\n          for (var _row2 = 0; _row2 < verticalUnits; _row2++) {\n            for (var _col2 = 0; _col2 < horizontalUnits; _col2++) {\n              grid[_row2][_col2] = (_col2 + Math.floor(_row2 / 2)) % 2 === 0;\n            }\n          }\n          break;\n      }\n\n      // Apply symmetry if needed\n      if (symmetryType > 0) {\n        this.applySymmetry(grid, horizontalUnits, verticalUnits, symmetryType);\n      }\n    }\n  }, {\n    key: \"applySymmetry\",\n    value: function applySymmetry(grid, horizontalUnits, verticalUnits, symmetryType) {\n      // Make a copy of the original grid\n      var originalGrid = grid.map(function (row) {\n        return _toConsumableArray(row);\n      });\n      if (symmetryType === 1) {\n        // Horizontal symmetry\n        var midRow = Math.floor(verticalUnits / 2);\n        for (var row = 0; row < midRow; row++) {\n          for (var col = 0; col < horizontalUnits; col++) {\n            // Mirror the top half to bottom half\n            grid[verticalUnits - 1 - row][col] = originalGrid[row][col];\n          }\n        }\n      } else {\n        // Full symmetry (horizontal and vertical)\n        var _midRow = Math.floor(verticalUnits / 2);\n        var midCol = Math.floor(horizontalUnits / 2);\n\n        // Copy top-left quadrant to other quadrants\n        for (var _row3 = 0; _row3 < _midRow; _row3++) {\n          for (var _col3 = 0; _col3 < midCol; _col3++) {\n            // Mirror to top-right\n            grid[_row3][horizontalUnits - 1 - _col3] = originalGrid[_row3][_col3];\n\n            // Mirror to bottom-left\n            grid[verticalUnits - 1 - _row3][_col3] = originalGrid[_row3][_col3];\n\n            // Mirror to bottom-right\n            grid[verticalUnits - 1 - _row3][horizontalUnits - 1 - _col3] = originalGrid[_row3][_col3];\n          }\n        }\n      }\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(ModulatedGridShape, \"parameters\", {\n  horizontalUnits: {\n    min: 3,\n    max: 8,\n    \"default\": 4\n  },\n  verticalUnits: {\n    min: 3,\n    max: 8,\n    \"default\": 4\n  },\n  padding: {\n    min: 10,\n    max: 40,\n    \"default\": 20\n  },\n  symmetry: {\n    min: 0,\n    max: 2,\n    \"default\": 1\n  },\n  variation: {\n    min: 0,\n    max: 2,\n    \"default\": 1\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ModulatedGridShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/ModulatedGridShape.js?");

/***/ }),

/***/ "./src/shapes/MoireLines.js":
/*!**********************************!*\
  !*** ./src/shapes/MoireLines.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a Moir-like pattern using multiple layers of vertical lines with\n * varying heights and offsets.\n */\nvar MoireLines = /*#__PURE__*/function (_Shape) {\n  function MoireLines() {\n    _classCallCheck(this, MoireLines);\n    return _callSuper(this, MoireLines, arguments);\n  }\n  _inherits(MoireLines, _Shape);\n  return _createClass(MoireLines, [{\n    key: \"_lerp\",\n    value:\n    // Basic lerp function\n    function _lerp(a, b, t) {\n      return a + (b - a) * t;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var numLayers = this.numberOfLayers;\n      var numLines = this.linesPerLayer;\n      var spacing = this.lineSpacing;\n      var baseH = this.baseHeight;\n      var heightVar = this.heightVariation;\n      var layerDX = this.layerOffsetX;\n      var layerDY = this.layerOffsetY;\n      var strokeW = this.strokeWidth;\n      if (numLines <= 0 || numLayers <= 0) {\n        return ''; // Avoid division by zero or empty loops\n      }\n      var totalLayerWidth = (numLines - 1) * spacing;\n\n      // --- Bounding Box Calculation ---\n      var minX = Infinity,\n        maxX = -Infinity,\n        minY = Infinity,\n        maxY = -Infinity;\n      for (var l = 0; l < numLayers; l++) {\n        var currentLayerOffsetX = l * layerDX;\n        var currentLayerOffsetY = l * layerDY;\n\n        // Find max height for *any* line in this layer\n        var hMaxThisLayer = Math.max(baseH, baseH - heightVar);\n        var hMinThisLayer = Math.min(baseH, baseH - heightVar); // Used to calculate potential min/max y\n        var maxPossibleHeightForAnyLine = Math.max(0, hMaxThisLayer); // Ensure non-negative height\n\n        for (var i = 0; i < numLines; i++) {\n          var lineX = currentLayerOffsetX + i * spacing - totalLayerWidth / 2;\n\n          // Calculate height variation factor (0 for first line, 1 for last)\n          var heightFactor = numLines <= 1 ? 0 : i / (numLines - 1);\n          var currentHeight = this._lerp(baseH, baseH - heightVar, heightFactor);\n          var finalHeight = Math.max(0, currentHeight);\n          var y1 = currentLayerOffsetY - finalHeight / 2;\n          var y2 = y1 + finalHeight;\n\n          // Update bounds (considering stroke width isn't strictly necessary for centering, but good practice)\n          // For simplicity, we'll center based on the line coordinates themselves.\n          minX = Math.min(minX, lineX);\n          maxX = Math.max(maxX, lineX);\n          minY = Math.min(minY, y1);\n          maxY = Math.max(maxY, y2);\n        }\n        // More accurate Y bounds check considering the layer offset and max possible height\n        minY = Math.min(minY, currentLayerOffsetY - maxPossibleHeightForAnyLine / 2);\n        maxY = Math.max(maxY, currentLayerOffsetY + maxPossibleHeightForAnyLine / 2);\n      }\n\n      // If only one line, width is effectively 0, handle potential division by zero or NaN\n      if (numLines === 1) {\n        minX = Math.min(0, (numLayers - 1) * layerDX);\n        maxX = Math.max(0, (numLayers - 1) * layerDX);\n      }\n\n      // Handle cases where bounds might not have been updated (e.g., 0 lines)\n      if (minX === Infinity) minX = 0;\n      if (maxX === -Infinity) maxX = 0;\n      if (minY === Infinity) minY = 0;\n      if (maxY === -Infinity) maxY = 0;\n\n      // Calculate center of the bounding box\n      var centerX = (minX + maxX) / 2;\n      var centerY = (minY + maxY) / 2;\n\n      // --- Generate SVG with Centering Offset ---\n      var svgString = '';\n      for (var _l = 0; _l < numLayers; _l++) {\n        var _currentLayerOffsetX = _l * layerDX;\n        var _currentLayerOffsetY = _l * layerDY;\n        for (var _i = 0; _i < numLines; _i++) {\n          // Calculate line X position relative to layer center\n          var relativeX = _i * spacing - totalLayerWidth / 2;\n          // Apply layer offset and centering offset\n          var finalX = _currentLayerOffsetX + relativeX - centerX;\n\n          // Calculate height variation factor\n          var _heightFactor = numLines <= 1 ? 0 : _i / (numLines - 1);\n          var _currentHeight = this._lerp(baseH, baseH - heightVar, _heightFactor);\n          var _finalHeight = Math.max(0, _currentHeight);\n\n          // Calculate y coordinates relative to layer Y offset, then apply centering\n          var relativeY1 = -_finalHeight / 2;\n          var finalY1 = _currentLayerOffsetY + relativeY1 - centerY;\n          var finalY2 = finalY1 + _finalHeight;\n          svgString += \"<line x1=\\\"\".concat(finalX.toFixed(3), \"\\\" y1=\\\"\").concat(finalY1.toFixed(3), \"\\\" x2=\\\"\").concat(finalX.toFixed(3), \"\\\" y2=\\\"\").concat(finalY2.toFixed(3), \"\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(strokeW, \"\\\" />\\n\");\n        }\n      }\n      return svgString;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(MoireLines, \"parameters\", {\n  numberOfLayers: {\n    type: 'integer',\n    min: 1,\n    max: 8,\n    // Reduced max\n    step: 1,\n    \"default\": 4 // Default adjusted\n  },\n  linesPerLayer: {\n    type: 'integer',\n    min: 5,\n    // Increased min slightly\n    max: 60,\n    // Reduced max\n    step: 1,\n    \"default\": 30 // Default adjusted\n  },\n  lineSpacing: {\n    type: 'number',\n    min: 1,\n    max: 10,\n    // Reduced max\n    step: 0.5,\n    \"default\": 4 // Default adjusted\n  },\n  baseHeight: {\n    type: 'number',\n    min: 20,\n    // Reduced min slightly\n    max: 180,\n    // Kept max height large, but centering will handle it\n    step: 1,\n    \"default\": 100 // Default adjusted\n  },\n  heightVariation: {\n    type: 'number',\n    min: -100,\n    // Kept range large\n    max: 100,\n    // Kept range large\n    step: 1,\n    \"default\": 30 // Default adjusted\n  },\n  layerOffsetX: {\n    type: 'number',\n    min: -20,\n    // Adjusted range\n    max: 20,\n    // Adjusted range\n    step: 1,\n    \"default\": 5 // Default adjusted\n  },\n  layerOffsetY: {\n    type: 'number',\n    min: -20,\n    // Adjusted range\n    max: 20,\n    // Adjusted range\n    step: 1,\n    \"default\": -5 // Default adjusted (negative for downward shift)\n  },\n  strokeWidth: {\n    type: 'number',\n    min: 0.5,\n    max: 5,\n    // Reduced max\n    step: 0.1,\n    \"default\": 1 // Default adjusted\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MoireLines);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/MoireLines.js?");

/***/ }),

/***/ "./src/shapes/MoireWaves.js":
/*!**********************************!*\
  !*** ./src/shapes/MoireWaves.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a Moir interference pattern by overlaying multiple sine waves with\n * different frequencies and phases.\n */\nvar MoireWaves = /*#__PURE__*/function (_Shape) {\n  function MoireWaves() {\n    _classCallCheck(this, MoireWaves);\n    return _callSuper(this, MoireWaves, arguments);\n  }\n  _inherits(MoireWaves, _Shape);\n  return _createClass(MoireWaves, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var paths = [];\n      for (var i = 0; i < this.waves; i++) {\n        paths.push(this.generateWavePath(i));\n      }\n      return paths.join('');\n    }\n  }, {\n    key: \"generateWavePath\",\n    value: function generateWavePath(waveIndex) {\n      var points = [];\n      var freqMultiplier = 1 + waveIndex * 0.2;\n      for (var x = -100; x <= 100; x++) {\n        var y1 = this.amplitude * Math.sin(2 * Math.PI * this.frequency1 * x / 200 * freqMultiplier);\n        var y2 = this.amplitude * Math.sin(2 * Math.PI * this.frequency2 * x / 200 * freqMultiplier + this.phaseShift * Math.PI / 180);\n        var y = (y1 + y2) / 2;\n        points.push([x, y]);\n      }\n      var pathData = \"M \".concat(points.map(function (p) {\n        return p.join(',');\n      }).join(' L '));\n      return \"<path d=\\\"\".concat(pathData, \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"1\\\" />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(MoireWaves, \"parameters\", {\n  amplitude: {\n    type: 'number',\n    min: 5,\n    max: 50,\n    \"default\": 25\n  },\n  frequency1: {\n    type: 'number',\n    min: 1,\n    max: 10,\n    \"default\": 3\n  },\n  frequency2: {\n    type: 'number',\n    min: 1,\n    max: 10,\n    \"default\": 4\n  },\n  phaseShift: {\n    type: 'number',\n    min: 0,\n    max: 360,\n    \"default\": 45\n  },\n  waves: {\n    type: 'number',\n    min: 2,\n    max: 10,\n    \"default\": 3\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MoireWaves);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/MoireWaves.js?");

/***/ }),

/***/ "./src/shapes/MoleculeShape.js":
/*!*************************************!*\
  !*** ./src/shapes/MoleculeShape.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a stylized molecule structure with a central node and several outer\n * nodes connected by lines.\n */\nvar MoleculeShape = /*#__PURE__*/function (_Shape) {\n  function MoleculeShape() {\n    _classCallCheck(this, MoleculeShape);\n    return _callSuper(this, MoleculeShape, arguments);\n  }\n  _inherits(MoleculeShape, _Shape);\n  return _createClass(MoleculeShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      // Generate node positions\n      var nodes = [];\n      var nodeCount = Math.round(this.nodes);\n      var rotationRad = this.rotation * Math.PI / 180;\n      var center = {\n        x: 0,\n        y: 0\n      };\n      for (var i = 0; i < nodeCount; i++) {\n        var angle = i * 2 * Math.PI / nodeCount + rotationRad;\n        var x = Math.cos(angle) * this.spread;\n        var y = Math.sin(angle) * this.spread;\n        nodes.push({\n          x: x,\n          y: y\n        });\n      }\n\n      // Create SVG elements for nodes and connections\n      var elements = [];\n\n      // Add connecting lines from center to each node\n      nodes.forEach(function (node) {\n        elements.push(\"<line \\n                x1=\\\"\".concat(center.x, \"\\\" \\n                y1=\\\"\").concat(center.y, \"\\\" \\n                x2=\\\"\").concat(node.x, \"\\\" \\n                y2=\\\"\").concat(node.y, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(_this.nodeSize / 3, \"\\\"\\n                stroke-linecap=\\\"round\\\"\\n                stroke-linejoin=\\\"round\\\"\\n            />\"));\n      });\n\n      // Add connecting lines between adjacent nodes\n      for (var _i = 0; _i < nodes.length; _i++) {\n        var start = nodes[_i];\n        var end = nodes[(_i + 1) % nodes.length];\n        elements.push(\"<line \\n                x1=\\\"\".concat(start.x, \"\\\" \\n                y1=\\\"\").concat(start.y, \"\\\" \\n                x2=\\\"\").concat(end.x, \"\\\" \\n                y2=\\\"\").concat(end.y, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.nodeSize / 3, \"\\\"\\n                stroke-linecap=\\\"round\\\"\\n                stroke-linejoin=\\\"round\\\"\\n            />\"));\n      }\n\n      // Add circles for each node\n      nodes.forEach(function (node) {\n        elements.push(\"<circle \\n                cx=\\\"\".concat(node.x, \"\\\" \\n                cy=\\\"\").concat(node.y, \"\\\" \\n                r=\\\"\").concat(_this.nodeSize / 1.5, \"\\\"\\n                fill=\\\"white\\\"\\n            />\"));\n      });\n\n      // Add center node\n      elements.push(\"<circle \\n            cx=\\\"\".concat(center.x, \"\\\" \\n            cy=\\\"\").concat(center.y, \"\\\" \\n            r=\\\"\").concat(this.centerSize / 2, \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.nodeSize / 3, \"\\\"\\n            fill=\\\"none\\\"\\n        />\"));\n      return elements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(MoleculeShape, \"parameters\", {\n  nodeSize: {\n    min: 5,\n    max: 40,\n    \"default\": 15\n  },\n  nodes: {\n    min: 4,\n    max: 12,\n    \"default\": 6\n  },\n  spread: {\n    min: 20,\n    max: 120,\n    \"default\": 80\n  },\n  rotation: {\n    min: -180,\n    max: 180,\n    \"default\": 0\n  },\n  centerSize: {\n    min: 5,\n    max: 30,\n    \"default\": 10\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MoleculeShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/MoleculeShape.js?");

/***/ }),

/***/ "./src/shapes/MondrianShape.js":
/*!*************************************!*\
  !*** ./src/shapes/MondrianShape.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates an abstract pattern inspired by Mondrian, created by recursively\n * subdividing a rectangle into smaller rectangles with outlines.\n */\nvar MondrianShape = /*#__PURE__*/function (_Shape) {\n  function MondrianShape() {\n    _classCallCheck(this, MondrianShape);\n    return _callSuper(this, MondrianShape, arguments);\n  }\n  _inherits(MondrianShape, _Shape);\n  return _createClass(MondrianShape, [{\n    key: \"subdivideRect\",\n    value: function subdivideRect(rect, depth, maxDepth) {\n      if (depth >= maxDepth) return [rect];\n      var isVertical = rect.width > rect.height;\n      var spacing = this.spacing;\n      if (isVertical) {\n        var splitX = rect.x + rect.width * this.ratio;\n        var leftRect = {\n          x: rect.x,\n          y: rect.y,\n          width: splitX - rect.x - spacing / 2,\n          height: rect.height\n        };\n        var rightRect = {\n          x: splitX + spacing / 2,\n          y: rect.y,\n          width: rect.x + rect.width - splitX - spacing / 2,\n          height: rect.height\n        };\n        if (leftRect.width > rightRect.width) {\n          return [].concat(_toConsumableArray(this.subdivideRect(leftRect, depth + 1, maxDepth)), [rightRect]);\n        } else {\n          return [leftRect].concat(_toConsumableArray(this.subdivideRect(rightRect, depth + 1, maxDepth)));\n        }\n      } else {\n        var splitY = rect.y + rect.height * this.ratio;\n        var topRect = {\n          x: rect.x,\n          y: rect.y,\n          width: rect.width,\n          height: splitY - rect.y - spacing / 2\n        };\n        var bottomRect = {\n          x: rect.x,\n          y: splitY + spacing / 2,\n          width: rect.width,\n          height: rect.y + rect.height - splitY - spacing / 2\n        };\n        if (topRect.height > bottomRect.height) {\n          return [].concat(_toConsumableArray(this.subdivideRect(topRect, depth + 1, maxDepth)), [bottomRect]);\n        } else {\n          return [topRect].concat(_toConsumableArray(this.subdivideRect(bottomRect, depth + 1, maxDepth)));\n        }\n      }\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      // Calculate base rectangle size (80% of available space)\n      var size = 160; // 80% of 400 (viewBox size)\n      var baseRect = {\n        x: -size / 2,\n        y: -size / 2,\n        width: size,\n        height: size\n      };\n\n      // Generate subdivided rectangles\n      var rectangles = this.subdivideRect(baseRect, 0, this.complexity);\n\n      // Create SVG elements for each rectangle\n      var elements = rectangles.map(function (rect) {\n        return \"\\n            <rect \\n                x=\\\"\".concat(rect.x, \"\\\" \\n                y=\\\"\").concat(rect.y, \"\\\" \\n                width=\\\"\").concat(rect.width, \"\\\" \\n                height=\\\"\").concat(rect.height, \"\\\"\\n                fill=\\\"none\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(_this.thickness, \"\\\"\\n            />\");\n      });\n      return elements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(MondrianShape, \"parameters\", {\n  complexity: {\n    min: 2,\n    max: 8,\n    \"default\": 4\n  },\n  // Number of subdivisions\n  spacing: {\n    min: 0,\n    max: 25,\n    \"default\": 0\n  },\n  // Gap between rectangles\n  ratio: {\n    min: 0.1,\n    max: 0.9,\n    \"default\": 0.4\n  },\n  // Split ratio variation\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 4\n  } // Line thickness\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MondrianShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/MondrianShape.js?");

/***/ }),

/***/ "./src/shapes/MultiRadialLinesShape.js":
/*!*********************************************!*\
  !*** ./src/shapes/MultiRadialLinesShape.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a pattern of radial lines connecting concentric rings, with lines\n * alternating visibility between rings.\n */\nvar MultiRadialLinesShape = /*#__PURE__*/function (_Shape) {\n  function MultiRadialLinesShape() {\n    _classCallCheck(this, MultiRadialLinesShape);\n    return _callSuper(this, MultiRadialLinesShape, arguments);\n  }\n  _inherits(MultiRadialLinesShape, _Shape);\n  return _createClass(MultiRadialLinesShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var lines = [];\n      var angleStep = 2 * Math.PI / this.lineCount;\n\n      // Calculate all ring radii\n      var radii = [];\n      for (var ring = 0; ring < this.ringCount; ring++) {\n        radii.push(this.innerRadius + ring * this.ringSpacing);\n      }\n\n      // Generate lines for each ring\n      for (var _ring = 0; _ring < this.ringCount - 1; _ring++) {\n        var startRadius = radii[_ring];\n        var endRadius = radii[_ring + 1];\n        for (var i = 0; i < this.lineCount; i++) {\n          var baseAngle = i * angleStep;\n\n          // Show lines based on alternating pattern\n          // For even-numbered rings, show even-indexed lines\n          // For odd-numbered rings, show odd-indexed lines\n          if (i % 2 === _ring % 2) {\n            var x1 = startRadius * Math.cos(baseAngle);\n            var y1 = startRadius * Math.sin(baseAngle);\n            var x2 = endRadius * Math.cos(baseAngle);\n            var y2 = endRadius * Math.sin(baseAngle);\n            lines.push(\"<line \\n                        x1=\\\"\".concat(x1, \"\\\" \\n                        y1=\\\"\").concat(y1, \"\\\" \\n                        x2=\\\"\").concat(x2, \"\\\" \\n                        y2=\\\"\").concat(y2, \"\\\"\\n                        stroke=\\\"white\\\"\\n                        stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                        stroke-linecap=\\\"\").concat(this.lineCap, \"\\\"\\n                    />\"));\n          }\n        }\n      }\n      return lines.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(MultiRadialLinesShape, \"parameters\", {\n  innerRadius: {\n    min: 0,\n    max: 100,\n    \"default\": 25\n  },\n  ringSpacing: {\n    min: 10,\n    max: 100,\n    \"default\": 20\n  },\n  ringCount: {\n    min: 2,\n    max: 6,\n    \"default\": 4\n  },\n  lineCount: {\n    min: 3,\n    max: 48,\n    \"default\": 40\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 5\n  },\n  lineCap: {\n    options: ['butt', 'round'],\n    \"default\": 'butt'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MultiRadialLinesShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/MultiRadialLinesShape.js?");

/***/ }),

/***/ "./src/shapes/NestedCrossShape.js":
/*!****************************************!*\
  !*** ./src/shapes/NestedCrossShape.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates multiple concentric, outlined cross shapes with potentially rounded\n * corners, creating a nested effect.\n */\nvar NestedCrossShape = /*#__PURE__*/function (_Shape) {\n  function NestedCrossShape() {\n    _classCallCheck(this, NestedCrossShape);\n    return _callSuper(this, NestedCrossShape, arguments);\n  }\n  _inherits(NestedCrossShape, _Shape);\n  return _createClass(NestedCrossShape, [{\n    key: \"calculateAdaptiveParameters\",\n    value: function calculateAdaptiveParameters() {\n      var baseSize = Math.max(this.armLength + this.armWidth / 2, this.armWidth + this.armLength / 2) + this.thickness;\n      var effectiveSpacing = this.spacing + this.thickness;\n      var maxSize = baseSize + (this.count - 1) * effectiveSpacing;\n      var maxAllowedSize = this.viewBoxHalf * 0.8;\n      var scale = maxSize > maxAllowedSize ? maxAllowedSize / maxSize : 1;\n      this.adaptiveArmLength = this.armLength * scale;\n      this.adaptiveArmWidth = this.armWidth * scale;\n      this.adaptiveSpacing = this.spacing * scale;\n      this.adaptiveThickness = this.thickness * scale;\n      this.adaptiveBaseRadius = this.baseRadius * scale;\n      this.adaptiveRadiusGrowth = this.radiusGrowth * scale;\n      var maxSafeSize = this.viewBoxHalf * 0.8;\n      var maxRepetitions = Math.floor((maxSafeSize - baseSize * scale) / (effectiveSpacing * scale)) + 1;\n      this.adaptiveCount = Math.min(this.count, maxRepetitions);\n    }\n  }, {\n    key: \"calculateCornerRadius\",\n    value: function calculateCornerRadius(repetition) {\n      // Calculate the cross dimensions for this repetition\n      var size = repetition * (this.adaptiveSpacing + this.adaptiveThickness);\n      var halfWidth = this.adaptiveArmWidth / 2 + size;\n      var fullLength = this.adaptiveArmLength + size;\n\n      // Calculate the maximum safe radius that won't break the cross shape\n      var maxSafeRadius = Math.min(halfWidth, (fullLength - halfWidth) / 2);\n\n      // Use both baseRadius and radiusGrowth to calculate desired radius\n      var desiredRadius = this.adaptiveBaseRadius + repetition * this.adaptiveRadiusGrowth;\n\n      // Return the smaller of desired and safe radius\n      return Math.min(desiredRadius, maxSafeRadius);\n    }\n  }, {\n    key: \"generateCross\",\n    value: function generateCross(repetition) {\n      var size = repetition * (this.adaptiveSpacing + this.adaptiveThickness);\n      var halfWidth = this.adaptiveArmWidth / 2 + size;\n      var fullLength = this.adaptiveArmLength + size;\n\n      // Get the calculated radius for this repetition\n      var cornerRadius = this.calculateCornerRadius(repetition);\n\n      // Helper function to create arc segments\n      var createArc = function createArc(startX, startY, radiusX, radiusY, largeArc, sweep, endX, endY) {\n        return \"A \".concat(radiusX, \" \").concat(radiusY, \" 0 \").concat(largeArc, \" \").concat(sweep, \" \").concat(endX, \" \").concat(endY);\n      };\n\n      // Create the path\n      var path = [// Starting point (top-left of vertical arm)\n      \"M \".concat(-halfWidth, \" \").concat(-fullLength + cornerRadius),\n      // Top arm left corner\n      createArc(-halfWidth, -fullLength + cornerRadius, cornerRadius, cornerRadius, 0, 1, -halfWidth + cornerRadius, -fullLength), // Top arm\n      \"L \".concat(halfWidth - cornerRadius, \" \").concat(-fullLength), createArc(halfWidth - cornerRadius, -fullLength, cornerRadius, cornerRadius, 0, 1, halfWidth, -fullLength + cornerRadius), // Right arm top\n      \"L \".concat(halfWidth, \" \").concat(-halfWidth), \"L \".concat(fullLength - cornerRadius, \" \").concat(-halfWidth), createArc(fullLength - cornerRadius, -halfWidth, cornerRadius, cornerRadius, 0, 1, fullLength, -halfWidth + cornerRadius), // Right arm\n      \"L \".concat(fullLength, \" \").concat(halfWidth - cornerRadius), createArc(fullLength, halfWidth - cornerRadius, cornerRadius, cornerRadius, 0, 1, fullLength - cornerRadius, halfWidth), // Bottom arm right\n      \"L \".concat(halfWidth, \" \").concat(halfWidth), \"L \".concat(halfWidth, \" \").concat(fullLength - cornerRadius), createArc(halfWidth, fullLength - cornerRadius, cornerRadius, cornerRadius, 0, 1, halfWidth - cornerRadius, fullLength), // Bottom arm\n      \"L \".concat(-halfWidth + cornerRadius, \" \").concat(fullLength), createArc(-halfWidth + cornerRadius, fullLength, cornerRadius, cornerRadius, 0, 1, -halfWidth, fullLength - cornerRadius), // Left arm bottom\n      \"L \".concat(-halfWidth, \" \").concat(halfWidth), \"L \".concat(-fullLength + cornerRadius, \" \").concat(halfWidth), createArc(-fullLength + cornerRadius, halfWidth, cornerRadius, cornerRadius, 0, 1, -fullLength, halfWidth - cornerRadius), // Left arm\n      \"L \".concat(-fullLength, \" \").concat(-halfWidth + cornerRadius), createArc(-fullLength, -halfWidth + cornerRadius, cornerRadius, cornerRadius, 0, 1, -fullLength + cornerRadius, -halfWidth), // Close the shape\n      \"L \".concat(-halfWidth, \" \").concat(-halfWidth), 'Z'];\n      return path.join(' ');\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      this.viewBoxHalf = 200;\n      this.calculateAdaptiveParameters();\n      return Array.from({\n        length: this.adaptiveCount\n      }, function (_, i) {\n        return \"<path \\n                d=\\\"\".concat(_this.generateCross(i), \"\\\" \\n                fill=\\\"none\\\" \\n                stroke=\\\"white\\\" \\n                stroke-width=\\\"\").concat(_this.adaptiveThickness, \"\\\"\\n                stroke-linecap=\\\"round\\\"\\n                stroke-linejoin=\\\"round\\\"\\n            />\");\n      }).join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(NestedCrossShape, \"parameters\", {\n  armLength: {\n    min: 20,\n    max: 150,\n    \"default\": 80\n  },\n  armWidth: {\n    min: 0,\n    max: 100,\n    \"default\": 7\n  },\n  count: {\n    min: 1,\n    max: 24,\n    \"default\": 5\n  },\n  spacing: {\n    min: 5,\n    max: 30,\n    \"default\": 5\n  },\n  thickness: {\n    min: 0.5,\n    max: 5,\n    \"default\": 2.2\n  },\n  baseRadius: {\n    min: 0,\n    max: 50,\n    \"default\": 50\n  },\n  radiusGrowth: {\n    min: 0,\n    max: 20,\n    \"default\": 12\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (NestedCrossShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/NestedCrossShape.js?");

/***/ }),

/***/ "./src/shapes/NestedSquares.js":
/*!*************************************!*\
  !*** ./src/shapes/NestedSquares.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates nested squares rotated alternately by 45 degrees, creating a\n * layered diamond/square pattern with cutouts.\n */\nvar NestedSquaresShape = /*#__PURE__*/function (_Shape) {\n  function NestedSquaresShape() {\n    _classCallCheck(this, NestedSquaresShape);\n    return _callSuper(this, NestedSquaresShape, arguments);\n  }\n  _inherits(NestedSquaresShape, _Shape);\n  return _createClass(NestedSquaresShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Start with the outermost path\n      var pathData = '';\n      var innerScale = Math.cos(Math.PI / 4); // Scale factor for 45 rotation\n\n      for (var i = 0; i < this.count; i++) {\n        var currentSize = this.size - i * this.spacing;\n        if (currentSize <= 0) break;\n\n        // Scale alternating squares\n        if (i % 2 !== 0) {\n          currentSize *= innerScale;\n        }\n\n        // Each square rotates 45 more than the previous\n        var rotation = 45 * i;\n\n        // Add outer boundary of current shape\n        pathData += this.getSquarePath(currentSize, rotation);\n      }\n      return \"<path \\n            d=\\\"\".concat(pathData, \"\\\"\\n            fill=\\\"white\\\"\\n            fill-rule=\\\"evenodd\\\"\\n        />\");\n    }\n  }, {\n    key: \"getSquarePath\",\n    value: function getSquarePath(size, rotation) {\n      var halfSize = size / 2;\n      var angleRad = rotation * Math.PI / 180;\n      var cos = Math.cos(angleRad);\n      var sin = Math.sin(angleRad);\n\n      // Calculate corners\n      var points = [[-halfSize, -halfSize], [halfSize, -halfSize], [halfSize, halfSize], [-halfSize, halfSize]].map(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n          x = _ref2[0],\n          y = _ref2[1];\n        return [x * cos - y * sin, x * sin + y * cos];\n      });\n\n      // Create path moving clockwise for outer shapes, counter-clockwise for cutouts\n      var _points = _slicedToArray(points, 4),\n        p1 = _points[0],\n        p2 = _points[1],\n        p3 = _points[2],\n        p4 = _points[3];\n      return \" M \".concat(p1[0], \",\").concat(p1[1], \" L \").concat(p2[0], \",\").concat(p2[1], \" L \").concat(p3[0], \",\").concat(p3[1], \" L \").concat(p4[0], \",\").concat(p4[1], \" Z\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(NestedSquaresShape, \"parameters\", {\n  size: {\n    min: 100,\n    max: 200,\n    \"default\": 150\n  },\n  count: {\n    min: 1,\n    max: 6,\n    \"default\": 2\n  },\n  spacing: {\n    min: 10,\n    max: 50,\n    \"default\": 25\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (NestedSquaresShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/NestedSquares.js?");

/***/ }),

/***/ "./src/shapes/NestedTriangles.js":
/*!***************************************!*\
  !*** ./src/shapes/NestedTriangles.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a pattern of nested, outlined equilateral triangles with adjustable\n * count, spacing, and vertical offset.\n */\nvar NestedTrianglesShape = /*#__PURE__*/function (_Shape) {\n  function NestedTrianglesShape() {\n    _classCallCheck(this, NestedTrianglesShape);\n    return _callSuper(this, NestedTrianglesShape, arguments);\n  }\n  _inherits(NestedTrianglesShape, _Shape);\n  return _createClass(NestedTrianglesShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var triangles = [];\n      var heightFactor = Math.sqrt(3) / 2;\n\n      // Base size calculations\n      var outerSize = this.maxSize;\n      var height = outerSize * heightFactor;\n\n      // Calculate spacing reduction for each level\n      var reduction = this.spacing / Math.cos(Math.PI / 6);\n      for (var i = 0; i < this.count; i++) {\n        var currentSize = outerSize - i * reduction * 2;\n        if (currentSize <= 0) break;\n        var currentHeight = currentSize * heightFactor;\n        var halfWidth = currentSize / 2;\n        var halfHeight = currentHeight / 2;\n\n        // Calculate progressive offset based on triangle position\n        // First triangle (i=0) gets no offset, last triangle gets full offset\n        var progressiveOffset = i === 0 ? 0 : this.yOffset * (i / (this.count - 1));\n        var points = [\"0,\".concat(-halfHeight + progressiveOffset), // top\n        \"\".concat(halfWidth, \",\").concat(halfHeight + progressiveOffset), // bottom right\n        \"\".concat(-halfWidth, \",\").concat(halfHeight + progressiveOffset) // bottom left\n        ];\n        triangles.push(\"<polygon \\n                points=\\\"\".concat(points.join(' '), \"\\\"\\n                fill=\\\"none\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            />\"));\n      }\n      return triangles.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(NestedTrianglesShape, \"parameters\", {\n  count: {\n    min: 2,\n    max: 12,\n    \"default\": 4\n  },\n  spacing: {\n    min: 5,\n    max: 40,\n    \"default\": 25\n  },\n  maxSize: {\n    min: 100,\n    max: 300,\n    \"default\": 169\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 6\n  },\n  yOffset: {\n    min: -200,\n    max: 200,\n    \"default\": 24\n  } // Pattern shift parameter\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (NestedTrianglesShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/NestedTriangles.js?");

/***/ }),

/***/ "./src/shapes/NodedRect.js":
/*!*********************************!*\
  !*** ./src/shapes/NodedRect.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a grid of nodes connected by horizontal, vertical, and diagonal\n * lines (traces).\n */\nvar NodedRect = /*#__PURE__*/function (_Shape) {\n  function NodedRect() {\n    _classCallCheck(this, NodedRect);\n    return _callSuper(this, NodedRect, arguments);\n  }\n  _inherits(NodedRect, _Shape);\n  return _createClass(NodedRect, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var scale = 0.8;\n      var boardW = this.boardWidth * scale;\n      var boardH = this.boardHeight * scale;\n      var traceThickness = this.traceThickness * scale;\n      var nodeRadius = this.nodeRadius * scale;\n      var spacing = this.spacing * scale;\n\n      // Calculate grid dimensions\n      var cols = Math.floor(boardW / spacing);\n      var rows = Math.floor(boardH / spacing);\n      var gridWidth = cols * spacing;\n      var gridHeight = rows * spacing;\n      var offsetX = -gridWidth / 2;\n      var offsetY = -gridHeight / 2;\n\n      // Generate node positions\n      var nodePositions = [];\n      for (var row = 0; row <= rows; row++) {\n        for (var col = 0; col <= cols; col++) {\n          var x = offsetX + col * spacing;\n          var y = offsetY + row * spacing;\n          nodePositions.push({\n            x: x,\n            y: y\n          });\n        }\n      }\n      var gridCols = cols + 1;\n      var elements = [];\n\n      // Draw traces\n      for (var _row = 0; _row <= rows; _row++) {\n        for (var _col = 0; _col <= cols; _col++) {\n          var index = _row * gridCols + _col;\n          var current = nodePositions[index];\n\n          // Horizontal traces\n          if (_col < cols) {\n            var rightNeighbor = nodePositions[index + 1];\n            elements.push(\"<line\\n                       x1=\\\"\".concat(current.x, \"\\\"\\n                       y1=\\\"\").concat(current.y, \"\\\"\\n                       x2=\\\"\").concat(rightNeighbor.x, \"\\\"\\n                       y2=\\\"\").concat(rightNeighbor.y, \"\\\"\\n                       stroke=\\\"white\\\"\\n                       stroke-width=\\\"\").concat(traceThickness, \"\\\"\\n                   />\"));\n          }\n\n          // Vertical traces\n          if (_row < rows) {\n            var bottomNeighbor = nodePositions[index + gridCols];\n            elements.push(\"<line\\n                       x1=\\\"\".concat(current.x, \"\\\"\\n                       y1=\\\"\").concat(current.y, \"\\\"\\n                       x2=\\\"\").concat(bottomNeighbor.x, \"\\\"\\n                       y2=\\\"\").concat(bottomNeighbor.y, \"\\\"\\n                       stroke=\\\"white\\\"\\n                       stroke-width=\\\"\").concat(traceThickness, \"\\\"\\n                   />\"));\n          }\n\n          // Diagonal traces\n          if (_col < cols && _row < rows) {\n            var bottomRight = nodePositions[index + gridCols + 1];\n            elements.push(\"<line\\n                       x1=\\\"\".concat(current.x, \"\\\"\\n                       y1=\\\"\").concat(current.y, \"\\\"\\n                       x2=\\\"\").concat(bottomRight.x, \"\\\"\\n                       y2=\\\"\").concat(bottomRight.y, \"\\\"\\n                       stroke=\\\"white\\\"\\n                       stroke-width=\\\"\").concat(traceThickness, \"\\\"\\n                   />\"));\n          }\n          if (_col > 0 && _row < rows) {\n            var bottomLeft = nodePositions[index + gridCols - 1];\n            elements.push(\"<line\\n                       x1=\\\"\".concat(current.x, \"\\\"\\n                       y1=\\\"\").concat(current.y, \"\\\"\\n                       x2=\\\"\").concat(bottomLeft.x, \"\\\"\\n                       y2=\\\"\").concat(bottomLeft.y, \"\\\"\\n                       stroke=\\\"white\\\"\\n                       stroke-width=\\\"\").concat(traceThickness, \"\\\"\\n                   />\"));\n          }\n        }\n      }\n\n      // Draw nodes\n      for (var _i = 0, _nodePositions = nodePositions; _i < _nodePositions.length; _i++) {\n        var point = _nodePositions[_i];\n        elements.push(\"<circle\\n               cx=\\\"\".concat(point.x, \"\\\"\\n               cy=\\\"\").concat(point.y, \"\\\"\\n               r=\\\"\").concat(nodeRadius, \"\\\"\\n               fill=\\\"white\\\"\\n           />\"));\n      }\n      return elements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(NodedRect, \"parameters\", {\n  boardWidth: {\n    min: 100,\n    max: 200,\n    \"default\": 200\n  },\n  boardHeight: {\n    min: 100,\n    max: 200,\n    \"default\": 200\n  },\n  cornerRadius: {\n    min: 0,\n    max: 60,\n    \"default\": 20\n  },\n  traceThickness: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  },\n  nodeRadius: {\n    min: 2,\n    max: 10,\n    \"default\": 4\n  },\n  spacing: {\n    min: 10,\n    max: 100,\n    \"default\": 50\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (NodedRect);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/NodedRect.js?");

/***/ }),

/***/ "./src/shapes/NodesNetworkShape.js":
/*!*****************************************!*\
  !*** ./src/shapes/NodesNetworkShape.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a shape resembling a circuit board with a central chip, four corner\n * chips, and connecting lines/vias.\n */\nvar NodesNetworkShape = /*#__PURE__*/function (_Shape) {\n  function NodesNetworkShape() {\n    _classCallCheck(this, NodesNetworkShape);\n    return _callSuper(this, NodesNetworkShape, arguments);\n  }\n  _inherits(NodesNetworkShape, _Shape);\n  return _createClass(NodesNetworkShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var scale = 0.8;\n      var centerX = 0;\n      var centerY = 0;\n\n      // Scale parameters\n      var boardW = this.boardWidth * scale;\n      var boardH = this.boardHeight * scale;\n      var thickness = this.lineThickness * scale;\n      var nodeR = this.nodeRadius * scale;\n      var chipS = this.chipSize * scale;\n      var elements = [];\n\n      // Main board rectangle\n      var boardX = centerX - boardW / 2;\n      var boardY = centerY - boardH / 2;\n\n      // Central CPU chip\n      var cpuX = centerX - chipS / 2;\n      var cpuY = centerY - chipS / 2;\n      elements.push(\"<rect\\n           x=\\\"\".concat(cpuX, \"\\\"\\n           y=\\\"\").concat(cpuY, \"\\\" \\n           width=\\\"\").concat(chipS, \"\\\"\\n           height=\\\"\").concat(chipS, \"\\\"\\n           stroke=\\\"white\\\"\\n           stroke-width=\\\"\").concat(thickness, \"\\\"\\n           fill=\\\"none\\\"\\n       />\"));\n\n      // Corner chips\n      var cornerOffset = 10 * scale;\n      var cornerChips = [\n      // Top left\n      {\n        x: boardX + cornerOffset,\n        y: boardY + cornerOffset\n      },\n      // Top right  \n      {\n        x: boardX + boardW - chipS - cornerOffset,\n        y: boardY + cornerOffset\n      },\n      // Bottom left\n      {\n        x: boardX + cornerOffset,\n        y: boardY + boardH - chipS - cornerOffset\n      },\n      // Bottom right\n      {\n        x: boardX + boardW - chipS - cornerOffset,\n        y: boardY + boardH - chipS - cornerOffset\n      }];\n\n      // Add corner chips and connection lines\n      cornerChips.forEach(function (pos) {\n        // Add chip\n        elements.push(\"<rect\\n               x=\\\"\".concat(pos.x, \"\\\"\\n               y=\\\"\").concat(pos.y, \"\\\"\\n               width=\\\"\").concat(chipS, \"\\\"\\n               height=\\\"\").concat(chipS, \"\\\"\\n               stroke=\\\"white\\\" \\n               stroke-width=\\\"\").concat(thickness, \"\\\"\\n               fill=\\\"none\\\"\\n           />\"));\n\n        // Connection line from chip center to CPU center\n        var chipCenterX = pos.x + chipS / 2;\n        var chipCenterY = pos.y + chipS / 2;\n        elements.push(\"<line\\n               x1=\\\"\".concat(chipCenterX, \"\\\"\\n               y1=\\\"\").concat(chipCenterY, \"\\\"\\n               x2=\\\"\").concat(centerX, \"\\\"\\n               y2=\\\"\").concat(centerY, \"\\\"\\n               stroke=\\\"white\\\"\\n               stroke-width=\\\"\").concat(thickness, \"\\\"\\n               stroke-linecap=\\\"round\\\"\\n           />\"));\n\n        // Via circle at chip center\n        elements.push(\"<circle\\n               cx=\\\"\".concat(chipCenterX, \"\\\"\\n               cy=\\\"\").concat(chipCenterY, \"\\\"\\n               r=\\\"\").concat(nodeR, \"\\\"\\n               stroke=\\\"white\\\"\\n               stroke-width=\\\"\").concat(thickness, \"\\\"\\n               fill=\\\"none\\\"\\n           />\"));\n      });\n\n      // CPU center via\n      elements.push(\"<circle\\n           cx=\\\"\".concat(centerX, \"\\\"\\n           cy=\\\"\").concat(centerY, \"\\\"\\n           r=\\\"\").concat(nodeR, \"\\\"\\n           stroke=\\\"white\\\"\\n           stroke-width=\\\"\").concat(thickness, \"\\\"\\n           fill=\\\"none\\\"\\n       />\"));\n      return elements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(NodesNetworkShape, \"parameters\", {\n  boardWidth: {\n    min: 100,\n    max: 200,\n    \"default\": 200\n  },\n  boardHeight: {\n    min: 100,\n    max: 200,\n    \"default\": 200\n  },\n  lineThickness: {\n    min: 1,\n    max: 10,\n    \"default\": 3\n  },\n  nodeRadius: {\n    min: 2,\n    max: 10,\n    \"default\": 4\n  },\n  chipSize: {\n    min: 20,\n    max: 80,\n    \"default\": 40\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (NodesNetworkShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/NodesNetworkShape.js?");

/***/ }),

/***/ "./src/shapes/NotchForm.js":
/*!*********************************!*\
  !*** ./src/shapes/NotchForm.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a square-like shape with multiple triangular notches cut into each\n * side.\n */\nvar NotchForm = /*#__PURE__*/function (_Shape) {\n  function NotchForm() {\n    _classCallCheck(this, NotchForm);\n    return _callSuper(this, NotchForm, arguments);\n  }\n  _inherits(NotchForm, _Shape);\n  return _createClass(NotchForm, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      var halfSize = this.size / 2;\n      var sideLength = this.size - this.cornerRadius * 2;\n      var spacing = sideLength / 4; // Divide side into 4 equal parts for 3 notches\n\n      var path = '';\n\n      // Helper to add notched side\n      var addNotchedSide = function addNotchedSide(start, end) {\n        var dx = end.x - start.x;\n        var dy = end.y - start.y;\n        var length = Math.sqrt(dx * dx + dy * dy);\n        var unitX = dx / length;\n        var unitY = dy / length;\n\n        // Perpendicular vector for notch depth\n        var perpX = -unitY;\n        var perpY = unitX;\n\n        // Starting point with first spacing\n        path += \"L \".concat(start.x + spacing * unitX, \" \").concat(start.y + spacing * unitY, \" \");\n\n        // Add three notches at the spacing points\n        for (var i = 0; i < 3; i++) {\n          var notchStart = {\n            x: start.x + spacing * (i + 1) * unitX,\n            y: start.y + spacing * (i + 1) * unitY\n          };\n\n          // Add notch with width\n          path += \"L \".concat(notchStart.x - _this.notchWidth / 2 * unitX, \" \").concat(notchStart.y - _this.notchWidth / 2 * unitY, \" \");\n          path += \"L \".concat(notchStart.x + _this.notchDepth * perpX, \" \").concat(notchStart.y + _this.notchDepth * perpY, \" \");\n          path += \"L \".concat(notchStart.x + _this.notchWidth / 2 * unitX, \" \").concat(notchStart.y + _this.notchWidth / 2 * unitY, \" \");\n        }\n        path += \"L \".concat(end.x, \" \").concat(end.y, \" \");\n      };\n\n      // Start with top-left corner\n      if (this.cornerRadius > 0) {\n        path = \"M \".concat(-halfSize, \" \").concat(-halfSize + this.cornerRadius, \" \");\n        path += \"A \".concat(this.cornerRadius, \" \").concat(this.cornerRadius, \" 0 0 0 \").concat(-halfSize + this.cornerRadius, \" \").concat(-halfSize, \" \");\n      } else {\n        path = \"M \".concat(-halfSize + this.cornerRadius, \" \").concat(-halfSize, \" \");\n      }\n\n      // Define corner points\n      var topLeft = {\n        x: -halfSize + this.cornerRadius,\n        y: -halfSize\n      };\n      var topRight = {\n        x: halfSize - this.cornerRadius,\n        y: -halfSize\n      };\n      var bottomRight = {\n        x: halfSize - this.cornerRadius,\n        y: halfSize\n      };\n      var bottomLeft = {\n        x: -halfSize + this.cornerRadius,\n        y: halfSize\n      };\n\n      // Add four sides with notches\n      addNotchedSide(topLeft, topRight);\n      if (this.cornerRadius > 0) {\n        path += \"A \".concat(this.cornerRadius, \" \").concat(this.cornerRadius, \" 0 0 0 \").concat(halfSize, \" \").concat(-halfSize + this.cornerRadius, \" \");\n      }\n      addNotchedSide({\n        x: halfSize,\n        y: -halfSize + this.cornerRadius\n      }, {\n        x: halfSize,\n        y: halfSize - this.cornerRadius\n      });\n      if (this.cornerRadius > 0) {\n        path += \"A \".concat(this.cornerRadius, \" \").concat(this.cornerRadius, \" 0 0 0 \").concat(halfSize - this.cornerRadius, \" \").concat(halfSize, \" \");\n      }\n      addNotchedSide(bottomRight, bottomLeft);\n      if (this.cornerRadius > 0) {\n        path += \"A \".concat(this.cornerRadius, \" \").concat(this.cornerRadius, \" 0 0 0 \").concat(-halfSize, \" \").concat(halfSize - this.cornerRadius, \" \");\n      }\n      addNotchedSide({\n        x: -halfSize,\n        y: halfSize - this.cornerRadius\n      }, {\n        x: -halfSize,\n        y: -halfSize + this.cornerRadius\n      });\n\n      // Close path with final corner arc\n      if (this.cornerRadius > 0) {\n        path += \"A \".concat(this.cornerRadius, \" \").concat(this.cornerRadius, \" 0 0 0 \").concat(-halfSize, \" \").concat(-halfSize + this.cornerRadius, \" \");\n      }\n      path += 'Z';\n      return \"\\n            <path\\n                d=\\\"\".concat(path, \"\\\"\\n                fill=\\\"white\\\"\\n            />\\n        \");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(NotchForm, \"parameters\", {\n  size: {\n    min: 50,\n    max: 200,\n    \"default\": 150\n  },\n  notchDepth: {\n    min: 5,\n    max: 40,\n    \"default\": 20\n  },\n  notchWidth: {\n    min: 10,\n    max: 60,\n    \"default\": 30\n  },\n  cornerRadius: {\n    min: 0,\n    max: 40,\n    \"default\": 15\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (NotchForm);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/NotchForm.js?");

/***/ }),

/***/ "./src/shapes/OctagonalFrame.js":
/*!**************************************!*\
  !*** ./src/shapes/OctagonalFrame.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates an octagonal frame shape by cutting out a smaller, concentric\n * octagon from a larger one.\n */\nvar OctagonalFrameShape = /*#__PURE__*/function (_Shape) {\n  function OctagonalFrameShape() {\n    _classCallCheck(this, OctagonalFrameShape);\n    return _callSuper(this, OctagonalFrameShape, arguments);\n  }\n  _inherits(OctagonalFrameShape, _Shape);\n  return _createClass(OctagonalFrameShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var outerSize = 150;\n      var halfOuter = outerSize / 2;\n\n      // Calculate inner dimensions\n      var innerSize = outerSize * this.innerRatio;\n      var halfInner = innerSize / 2;\n\n      // Calculate corner cuts (ensuring they don't exceed half the size)\n      var outerCut = Math.min(this.cornerSize, outerSize / 2);\n      var innerCut = outerCut * (innerSize / outerSize); // Scale cut for inner shape\n\n      // Create outer octagonal path\n      var outerPath = this.createOctagonPath(-halfOuter, -halfOuter, outerSize, outerSize, outerCut);\n\n      // Create centered inner octagonal path (in reverse direction for cutout)\n      var innerPath = this.createOctagonPath(-halfInner, -halfInner, innerSize, innerSize, innerCut, true // reverse direction for cutout\n      );\n      return \"<path \\n            d=\\\"\".concat(outerPath, \" \").concat(innerPath, \"\\\"\\n            fill=\\\"white\\\"\\n            fill-rule=\\\"evenodd\\\"\\n        />\");\n    }\n  }, {\n    key: \"createOctagonPath\",\n    value: function createOctagonPath(x, y, width, height, cutSize) {\n      var reverse = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n      var points = [[x + cutSize, y],\n      // Top edge start\n      [x + width - cutSize, y],\n      // Top edge end\n      [x + width, y + cutSize],\n      // Right top\n      [x + width, y + height - cutSize],\n      // Right bottom\n      [x + width - cutSize, y + height],\n      // Bottom edge end\n      [x + cutSize, y + height],\n      // Bottom edge start\n      [x, y + height - cutSize],\n      // Left bottom\n      [x, y + cutSize] // Left top\n      ];\n      if (reverse) {\n        points.reverse();\n      }\n      var commands = points.map(function (point, i) {\n        return i === 0 ? \"M \".concat(point[0], \" \").concat(point[1]) : \"L \".concat(point[0], \" \").concat(point[1]);\n      });\n      return commands.join(' ') + ' Z';\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(OctagonalFrameShape, \"parameters\", {\n  innerRatio: {\n    min: 0.3,\n    max: 0.9,\n    \"default\": 0.65\n  },\n  cornerSize: {\n    min: 5,\n    max: 100,\n    \"default\": 35\n  } // Size of the 45 corner cuts\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (OctagonalFrameShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/OctagonalFrame.js?");

/***/ }),

/***/ "./src/shapes/OmniPlanGrid.js":
/*!************************************!*\
  !*** ./src/shapes/OmniPlanGrid.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates an abstract geometric grid inspired by the Omniplan logo, featuring\n * center, middle, and outer squares connected by lines.\n */\nvar OmniPlanGrid = /*#__PURE__*/function (_Shape) {\n  function OmniPlanGrid() {\n    _classCallCheck(this, OmniPlanGrid);\n    return _callSuper(this, OmniPlanGrid, arguments);\n  }\n  _inherits(OmniPlanGrid, _Shape);\n  return _createClass(OmniPlanGrid, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Access parameters using `this`\n      var c = this.centerSize / 2; // Half center size\n      var mSize = this.middleSize; // Full size along the arm\n      var mWidth = this.middleWidth / 2; // Half width of the arm\n      var o = this.outerSize / 2; // Half outer size\n      var g = this.gap;\n      var ox = this.outerOffset; // Center offset X for outer squares\n      var oy = this.outerOffset; // Center offset Y for outer squares (using same for symmetry)\n      var os = o; // Half-size of outer square for corner calculations\n\n      var d = \"\"; // Path data string\n\n      // 1. Central Square\n      d += \"M \".concat(-c, \",\").concat(-c, \" H \").concat(c, \" V \").concat(c, \" H \").concat(-c, \" Z \");\n\n      // 2. Middle Arms (U-shapes extending from the center square)\n      // Top Arm\n      var myTop = -(c + g); // Y-coordinate of the edge connected to the gap\n      var myBottom = -(c + g + mSize); // Y-coordinate of the outer edge\n      d += \"M \".concat(-mWidth, \",\").concat(myTop, \" V \").concat(myBottom, \" H \").concat(mWidth, \" V \").concat(myTop, \" \");\n\n      // Bottom Arm\n      var byTop = c + g; // Y-coordinate of the edge connected to the gap\n      var byBottom = c + g + mSize; // Y-coordinate of the outer edge\n      d += \"M \".concat(-mWidth, \",\").concat(byTop, \" V \").concat(byBottom, \" H \").concat(mWidth, \" V \").concat(byTop, \" \");\n\n      // Left Arm\n      var lxRight = -(c + g); // X-coordinate of the edge connected to the gap\n      var lxLeft = -(c + g + mSize); // X-coordinate of the outer edge\n      d += \"M \".concat(lxRight, \",\").concat(-mWidth, \" H \").concat(lxLeft, \" V \").concat(mWidth, \" H \").concat(lxRight, \" \");\n\n      // Right Arm\n      var rxLeft = c + g; // X-coordinate of the edge connected to the gap\n      var rxRight = c + g + mSize; // X-coordinate of the outer edge\n      d += \"M \".concat(rxLeft, \",\").concat(-mWidth, \" H \").concat(rxRight, \" V \").concat(mWidth, \" H \").concat(rxLeft, \" \");\n\n      // 3. Outer Squares\n      // Top-Left Outer Square (Center: -ox, -oy)\n      d += \"M \".concat(-ox - os, \",\").concat(-oy - os, \" H \").concat(-ox + os, \" V \").concat(-oy + os, \" H \").concat(-ox - os, \" Z \");\n      // Top-Right Outer Square (Center: ox, -oy)\n      d += \"M \".concat(ox - os, \",\").concat(-oy - os, \" H \").concat(ox + os, \" V \").concat(-oy + os, \" H \").concat(ox - os, \" Z \");\n      // Bottom-Right Outer Square (Center: ox, oy)\n      d += \"M \".concat(ox - os, \",\").concat(oy - os, \" H \").concat(ox + os, \" V \").concat(oy + os, \" H \").concat(ox - os, \" Z \");\n      // Bottom-Left Outer Square (Center: -ox, oy)\n      d += \"M \".concat(-ox - os, \",\").concat(oy - os, \" H \").concat(-ox + os, \" V \").concat(oy + os, \" H \").concat(-ox - os, \" Z \");\n\n      // 4. Diagonal Lines (if enabled)\n      if (this.showDiagonals) {\n        // Connect inner corner of outer square to corresponding corner of the central square.\n        // Inner corner of Top-Left outer square: (-ox+os, -oy+os) -> Center Top-Left: (-c, -c)\n        d += \"M \".concat(-ox + os, \",\").concat(-oy + os, \" L \").concat(-c, \",\").concat(-c, \" \");\n        // Inner corner of Top-Right outer square: (ox-os, -oy+os) -> Center Top-Right: (c, -c)\n        d += \"M \".concat(ox - os, \",\").concat(-oy + os, \" L \").concat(c, \",\").concat(-c, \" \");\n        // Inner corner of Bottom-Right outer square: (ox-os, oy-os) -> Center Bottom-Right: (c, c)\n        d += \"M \".concat(ox - os, \",\").concat(oy - os, \" L \").concat(c, \",\").concat(c, \" \");\n        // Inner corner of Bottom-Left outer square: (-ox+os, oy-os) -> Center Bottom-Left: (-c, c)\n        d += \"M \".concat(-ox + os, \",\").concat(oy - os, \" L \").concat(-c, \",\").concat(c, \" \");\n      }\n\n      // Ensure path data is trimmed before returning\n      var finalPathData = d.trim();\n\n      // Return the SVG path element\n      return \"<path d=\\\"\".concat(finalPathData, \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(this.strokeWidth, \"\\\" stroke-linecap=\\\"square\\\" stroke-linejoin=\\\"miter\\\" />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(OmniPlanGrid, \"parameters\", {\n  centerSize: {\n    type: 'number',\n    min: 5,\n    max: 80,\n    step: 1,\n    \"default\": 30,\n    label: 'Center Square Size'\n  },\n  middleSize: {\n    type: 'number',\n    min: 5,\n    max: 60,\n    step: 1,\n    \"default\": 20,\n    label: 'Middle Element Size' // Size along the extending direction\n  },\n  middleWidth: {\n    type: 'number',\n    min: 5,\n    max: 60,\n    step: 1,\n    \"default\": 20,\n    label: 'Middle Element Width' // Width perpendicular to the extending direction\n  },\n  outerSize: {\n    type: 'number',\n    min: 10,\n    max: 100,\n    step: 1,\n    \"default\": 40,\n    label: 'Outer Square Size'\n  },\n  gap: {\n    type: 'number',\n    min: 0,\n    max: 30,\n    step: 0.5,\n    \"default\": 5,\n    label: 'Gap Between Elements'\n  },\n  outerOffset: {\n    type: 'number',\n    min: 20,\n    max: 95,\n    step: 1,\n    \"default\": 65,\n    // Default calculated for visual coherence: 30/2 + 5 + 20 + 5 + 40/2 = 15+5+20+5+20 = 65\n    label: 'Outer Square Offset' // Distance from center to center of outer squares\n  },\n  strokeWidth: {\n    type: 'number',\n    min: 0.5,\n    max: 10,\n    step: 0.1,\n    \"default\": 2,\n    label: 'Stroke Width'\n  },\n  showDiagonals: {\n    type: 'boolean',\n    \"default\": true,\n    label: 'Show Diagonals'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (OmniPlanGrid);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/OmniPlanGrid.js?");

/***/ }),

/***/ "./src/shapes/OpenCompact.js":
/*!***********************************!*\
  !*** ./src/shapes/OpenCompact.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a shape resembling an open compact or clamshell, composed of two\n * vertically separated hollow ellipses.\n */\nvar OpenCompact = /*#__PURE__*/function (_Shape) {\n  function OpenCompact() {\n    _classCallCheck(this, OpenCompact);\n    return _callSuper(this, OpenCompact, arguments);\n  }\n  _inherits(OpenCompact, _Shape);\n  return _createClass(OpenCompact, [{\n    key: \"_clamp\",\n    value: /** Helper to clamp values */\n    function _clamp(val, min, max) {\n      return Math.max(min, Math.min(max, val));\n    }\n  }, {\n    key: \"_createEllipsePath\",\n    value: function _createEllipsePath(cx, cy, rx, ry, clockwise) {\n      if (rx <= 0 || ry <= 0) return ''; // Avoid degenerate ellipses\n\n      var sweepFlag = clockwise ? 1 : 0;\n      // Ensure radii are positive\n      rx = Math.abs(rx);\n      ry = Math.abs(ry);\n\n      // Using two 180-degree arcs to form the ellipse\n      var path = \"M \".concat(cx - rx, \",\").concat(cy, \" \") + // Start at left-middle\n      \"A \".concat(rx.toFixed(2), \",\").concat(ry.toFixed(2), \" 0 0,\").concat(sweepFlag, \" \").concat(cx + rx, \",\").concat(cy, \" \") + // Top/Bottom arc to right-middle\n      \"A \".concat(rx.toFixed(2), \",\").concat(ry.toFixed(2), \" 0 0,\").concat(sweepFlag, \" \").concat(cx - rx, \",\").concat(cy, \" \") + // Bottom/Top arc back to left-middle\n      \"Z\";\n      return path;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var rx = this.shellWidth / 2;\n      var ry = this.shellHeight / 2;\n\n      // Clamp perspective shift to prevent inner ellipse going outside outer\n      var maxPerspective = ry * (1 - this.rimRatio) - 1; // Leave 1px margin\n      var actualPerspective = this._clamp(this.perspective, 0, Math.max(0, maxPerspective));\n      var innerRx = rx * this.rimRatio;\n      var innerRy = ry * this.rimRatio;\n\n      // Calculate centers ensuring space for height and separation\n      // Total height needed approx = shellHeight * 2 + separation\n      var topOuterCy = this._clamp(0 - this.separation / 2 - ry, -98 + ry, 98 - ry - this.separation / 2);\n      var bottomOuterCy = this._clamp(topOuterCy + this.shellHeight + this.separation, -98 + ry + this.separation / 2, 98 - ry);\n\n      // Apply perspective shift to inner ellipses\n      var topInnerCy = topOuterCy + actualPerspective;\n      var bottomInnerCy = bottomOuterCy - actualPerspective;\n\n      // --- Generate Path Data ---\n      // Top Shell: Outer (clockwise), Inner (counter-clockwise)\n      var outerPathTop = this._createEllipsePath(0, topOuterCy, rx, ry, true);\n      var innerPathTop = this._createEllipsePath(0, topInnerCy, innerRx, innerRy, false);\n\n      // Bottom Shell: Outer (clockwise), Inner (counter-clockwise)\n      var outerPathBottom = this._createEllipsePath(0, bottomOuterCy, rx, ry, true);\n      var innerPathBottom = this._createEllipsePath(0, bottomInnerCy, innerRx, innerRy, false);\n\n      // Combine paths. fill-rule=\"evenodd\" ensures the inner paths create holes.\n      var combinedPath = \"\".concat(outerPathTop, \" \").concat(innerPathTop, \" \").concat(outerPathBottom, \" \").concat(innerPathBottom);\n      return \"<path d=\\\"\".concat(combinedPath, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" fill-rule=\\\"evenodd\\\" />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(OpenCompact, \"parameters\", {\n  shellWidth: {\n    type: 'number',\n    min: 50,\n    max: 195,\n    // Stay within -100 to 100 range\n    step: 1,\n    \"default\": 180,\n    label: 'Width'\n  },\n  shellHeight: {\n    type: 'number',\n    min: 20,\n    max: 90,\n    // Ensure separation can fit\n    step: 1,\n    \"default\": 60,\n    label: 'Shell Height'\n  },\n  separation: {\n    type: 'number',\n    min: 2,\n    max: 50,\n    // Vertical gap\n    step: 1,\n    \"default\": 10,\n    label: 'Separation'\n  },\n  rimRatio: {\n    type: 'number',\n    min: 0.4,\n    max: 0.95,\n    // Inner radius / Outer radius\n    step: 0.01,\n    \"default\": 0.75,\n    label: 'Rim Thickness' // Inverse relationship visually\n  },\n  perspective: {\n    type: 'number',\n    min: 0,\n    max: 25,\n    // How much the inner hole shifts vertically\n    step: 1,\n    \"default\": 8,\n    label: 'Perspective Shift'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (OpenCompact);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/OpenCompact.js?");

/***/ }),

/***/ "./src/shapes/OrbitingFigure.js":
/*!**************************************!*\
  !*** ./src/shapes/OrbitingFigure.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Represents a stylized figure with a tilted elliptical body, an orbiting ring\n * created by overlapping paths, and a circular head.\n */\nvar OrbitingFigure = /*#__PURE__*/function (_Shape) {\n  function OrbitingFigure() {\n    _classCallCheck(this, OrbitingFigure);\n    return _callSuper(this, OrbitingFigure, arguments);\n  }\n  _inherits(OrbitingFigure, _Shape);\n  return _createClass(OrbitingFigure, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Access parameters using `this`\n      var rx = this.bodyRx;\n      var ry = this.bodyRy;\n      var angle = this.bodyAngle;\n      var ringWidth = this.ringWidth;\n      var headR = this.headRadius;\n      var headY = this.headYOffset;\n\n      // Calculate outer ellipse radii for the ring\n      // Add ringWidth to both radii to define the outer boundary\n      var rx_outer = rx + ringWidth;\n      var ry_outer = ry + ringWidth;\n\n      // Convert angle to radians for trigonometric functions\n      var angleRad = angle * Math.PI / 180;\n      var cosA = Math.cos(angleRad);\n      var sinA = Math.sin(angleRad);\n\n      // Calculate the coordinates of the sharp tips of the ring\n      // These lie on the major axis (relative to rx) of the outer ellipse\n      var tipX = rx_outer * cosA;\n      var tipY = rx_outer * sinA;\n      var LT = {\n        x: -tipX,\n        y: -tipY\n      }; // Left Tip\n      var RT = {\n        x: tipX,\n        y: tipY\n      }; // Right Tip\n\n      // Function to format numbers for SVG paths\n      var f = function f(num) {\n        return num.toFixed(3);\n      };\n\n      // Path 1: Back part of the ring (Top Outer Arc, Bottom Inner Arc)\n      // M -> Move to Left Tip (LT)\n      // A -> Draw Outer Arc (top) from LT to RT\n      // A -> Draw Inner Arc (bottom) from RT back to LT\n      // Z -> Close path\n      var path1_d = \"\\n            M \".concat(f(LT.x), \",\").concat(f(LT.y), \"\\n            A \").concat(f(rx_outer), \",\").concat(f(ry_outer), \",\").concat(f(angle), \",0,1,\").concat(f(RT.x), \",\").concat(f(RT.y), \"\\n            A \").concat(f(rx), \",\").concat(f(ry), \",\").concat(f(angle), \",0,0,\").concat(f(LT.x), \",\").concat(f(LT.y), \"\\n            Z\\n        \");\n\n      // Path 2: Front part of the ring (Top Inner Arc, Bottom Outer Arc)\n      // M -> Move to Left Tip (LT)\n      // A -> Draw Inner Arc (top) from LT to RT\n      // A -> Draw Outer Arc (bottom) from RT back to LT\n      // Z -> Close path\n      var path2_d = \"\\n            M \".concat(f(LT.x), \",\").concat(f(LT.y), \"\\n            A \").concat(f(rx), \",\").concat(f(ry), \",\").concat(f(angle), \",0,1,\").concat(f(RT.x), \",\").concat(f(RT.y), \"\\n            A \").concat(f(rx_outer), \",\").concat(f(ry_outer), \",\").concat(f(angle), \",0,0,\").concat(f(LT.x), \",\").concat(f(LT.y), \"\\n            Z\\n        \");\n\n      // Assemble the SVG elements in the correct draw order for occlusion\n      var svgElements = [// 1. Back Ring Path\n      \"<path d=\\\"\".concat(path1_d, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\"/>\"), // 2. Central Body Ellipse\n      \"<ellipse cx=\\\"0\\\" cy=\\\"0\\\" rx=\\\"\".concat(f(rx), \"\\\" ry=\\\"\").concat(f(ry), \"\\\" transform=\\\"rotate(\").concat(f(angle), \" 0 0)\\\" fill=\\\"white\\\" stroke=\\\"none\\\"/>\"), // 3. Front Ring Path\n      \"<path d=\\\"\".concat(path2_d, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\"/>\"), // 4. Head Circle\n      \"<circle cx=\\\"0\\\" cy=\\\"\".concat(f(headY), \"\\\" r=\\\"\").concat(f(headR), \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\"/>\")];\n      return svgElements.join('\\n');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(OrbitingFigure, \"parameters\", {\n  bodyRx: {\n    type: 'number',\n    min: 10,\n    max: 90,\n    step: 1,\n    \"default\": 50,\n    label: 'Body Width Radius'\n  },\n  bodyRy: {\n    type: 'number',\n    min: 10,\n    max: 90,\n    step: 1,\n    \"default\": 30,\n    label: 'Body Height Radius'\n  },\n  bodyAngle: {\n    type: 'number',\n    min: -60,\n    max: 60,\n    step: 1,\n    \"default\": -25,\n    label: 'Body Tilt Angle'\n  },\n  ringWidth: {\n    type: 'number',\n    min: 3,\n    max: 50,\n    step: 1,\n    \"default\": 20,\n    label: 'Ring Width'\n  },\n  headRadius: {\n    type: 'number',\n    min: 5,\n    max: 35,\n    step: 1,\n    \"default\": 15,\n    label: 'Head Radius'\n  },\n  headYOffset: {\n    type: 'number',\n    min: -95,\n    max: -20,\n    step: 1,\n    \"default\": -70,\n    label: 'Head Vertical Position'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (OrbitingFigure);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/OrbitingFigure.js?");

/***/ }),

/***/ "./src/shapes/OrganicDiffusion.js":
/*!****************************************!*\
  !*** ./src/shapes/OrganicDiffusion.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates organic, blobby shapes resembling diffusion patterns using gradient\n * noise and Marching Squares contour tracing.\n */\nvar OrganicDiffusion = /*#__PURE__*/function (_Shape) {\n  function OrganicDiffusion() {\n    var _this;\n    _classCallCheck(this, OrganicDiffusion);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _callSuper(this, OrganicDiffusion, [].concat(args));\n    // --- Noise Generation ---\n    _defineProperty(_this, \"p\", []);\n    // Permutation table (populated by _initializeNoise)\n    _defineProperty(_this, \"gradients\", []);\n    // --- Marching Squares ---\n    // Defines the line segments crossing a square for each of the 16 possible states.\n    // Coordinates are relative to the square's top-left corner (0,0) to bottom-right (1,1).\n    // y=0 is top, y=1 is bottom. Midpoints: 0.5.\n    // Bit order: D(TR)-C(TL)-B(BR)-A(BL) -> 8-4-2-1\n    _defineProperty(_this, \"marchingSquaresEdges\", [/* 0*/[], /* 1*/[{\n      x1: 0,\n      y1: 0.5,\n      x2: 0.5,\n      y2: 1\n    }],\n    // A only (BottomLeft) -> Left edge to Bottom edge\n    /* 2*/\n    [{\n      x1: 0.5,\n      y1: 1,\n      x2: 1,\n      y2: 0.5\n    }],\n    // B only (BottomRight) -> Bottom edge to Right edge\n    /* 3*/\n    [{\n      x1: 0,\n      y1: 0.5,\n      x2: 1,\n      y2: 0.5\n    }],\n    // A & B -> Left edge to Right edge\n    /* 4*/\n    [{\n      x1: 0,\n      y1: 0.5,\n      x2: 0.5,\n      y2: 0\n    }],\n    // C only (TopLeft) -> Left edge to Top edge\n    /* 5*/\n    [{\n      x1: 0.5,\n      y1: 1,\n      x2: 0.5,\n      y2: 0\n    }],\n    // A & C -> Bottom edge to Top edge\n    /* 6*/\n    [{\n      x1: 0.5,\n      y1: 1,\n      x2: 1,\n      y2: 0.5\n    }, {\n      x1: 0,\n      y1: 0.5,\n      x2: 0.5,\n      y2: 0\n    }],\n    // B & C (Ambiguous 1) -> Bottom-to-Right, Left-to-Top\n    /* 7*/\n    [{\n      x1: 0.5,\n      y1: 0,\n      x2: 1,\n      y2: 0.5\n    }],\n    // A, B, C -> Top edge to Right edge\n    /* 8*/\n    [{\n      x1: 1,\n      y1: 0.5,\n      x2: 0.5,\n      y2: 0\n    }],\n    // D only (TopRight) -> Right edge to Top edge\n    /* 9*/\n    [{\n      x1: 0,\n      y1: 0.5,\n      x2: 0.5,\n      y2: 1\n    }, {\n      x1: 1,\n      y1: 0.5,\n      x2: 0.5,\n      y2: 0\n    }],\n    // A & D (Ambiguous 2) -> Left-to-Bottom, Right-to-Top\n    /*10*/\n    [{\n      x1: 0.5,\n      y1: 1,\n      x2: 0.5,\n      y2: 0\n    }],\n    // B & D -> Bottom edge to Top edge\n    /*11*/\n    [{\n      x1: 0,\n      y1: 0.5,\n      x2: 0.5,\n      y2: 0\n    }],\n    // A, B, D -> Left edge to Top edge\n    /*12*/\n    [{\n      x1: 0,\n      y1: 0.5,\n      x2: 1,\n      y2: 0.5\n    }],\n    // C & D -> Left edge to Right edge\n    /*13*/\n    [{\n      x1: 0.5,\n      y1: 1,\n      x2: 1,\n      y2: 0.5\n    }],\n    // A, C, D -> Bottom edge to Right edge\n    /*14*/\n    [{\n      x1: 0,\n      y1: 0.5,\n      x2: 0.5,\n      y2: 1\n    }],\n    // B, C, D -> Left edge to Bottom edge\n    /*15*/\n    []]);\n    return _this;\n  }\n  _inherits(OrganicDiffusion, _Shape);\n  return _createClass(OrganicDiffusion, [{\n    key: \"_initializeNoise\",\n    value:\n    // Gradient vectors (populated by _initializeNoise)\n\n    /** Initializes the permutation table and gradient vectors for noise generation using the seeded RNG. */\n    function _initializeNoise() {\n      this.gradients = [\n      // Simple 2D gradients\n      [1, 0], [-1, 0], [0, 1], [0, -1], [1, 1], [-1, 1], [1, -1], [-1, -1]];\n      this.p = Array.from({\n        length: 256\n      }, function (_, i) {\n        return i;\n      });\n      // Fisher-Yates shuffle using the inherited seeded random number generator\n      for (var i = this.p.length - 1; i > 0; i--) {\n        var j = Math.floor(this.random() * (i + 1));\n        var _ref = [this.p[j], this.p[i]];\n        this.p[i] = _ref[0];\n        this.p[j] = _ref[1];\n      }\n      this.p = this.p.concat(this.p); // Double the array to avoid modulo wrap issues\n    }\n\n    /** Gets a pseudo-random gradient vector for given integer grid coordinates. */\n  }, {\n    key: \"_getGradient\",\n    value: function _getGradient(x, y) {\n      // Use bitwise AND for faster modulo 256\n      var xi = Math.floor(x) & 255;\n      var yi = Math.floor(y) & 255;\n      var hash = this.p[this.p[xi] + yi & 255];\n      return this.gradients[hash % this.gradients.length];\n    }\n\n    /** Computes the dot product between a gradient vector and a distance vector. */\n  }, {\n    key: \"_dotProduct\",\n    value: function _dotProduct(grad, dx, dy) {\n      return grad[0] * dx + grad[1] * dy;\n    }\n\n    /** Smoothing function (quintic curve: 6t^5 - 15t^4 + 10t^3) for interpolation. */\n  }, {\n    key: \"_fade\",\n    value: function _fade(t) {\n      return t * t * t * (t * (t * 6 - 15) + 10);\n    }\n\n    /** Generates a 2D gradient noise value for the given coordinates. */\n  }, {\n    key: \"_noise\",\n    value: function _noise(x, y) {\n      // Find grid cell coordinates (integer part)\n      var xi = Math.floor(x);\n      var yi = Math.floor(y);\n\n      // Find relative coordinates within the cell (fractional part)\n      var xf = x - xi;\n      var yf = y - yi;\n\n      // Get gradients for the 4 corners of the cell\n      var grad00 = this._getGradient(xi, yi); // Top-Left\n      var grad10 = this._getGradient(xi + 1, yi); // Top-Right\n      var grad01 = this._getGradient(xi, yi + 1); // Bottom-Left\n      var grad11 = this._getGradient(xi + 1, yi + 1); // Bottom-Right\n\n      // Compute dot products between gradient and distance vectors\n      var dot00 = this._dotProduct(grad00, xf, yf);\n      var dot10 = this._dotProduct(grad10, xf - 1, yf);\n      var dot01 = this._dotProduct(grad01, xf, yf - 1);\n      var dot11 = this._dotProduct(grad11, xf - 1, yf - 1);\n\n      // Interpolate using the fade curve\n      var u = this._fade(xf);\n      var v = this._fade(yf);\n      var lerp1 = dot00 + u * (dot10 - dot00); // Interpolate top edge\n      var lerp2 = dot01 + u * (dot11 - dot01); // Interpolate bottom edge\n      var result = lerp1 + v * (lerp2 - lerp1); // Interpolate between edges\n\n      // Normalize noise output roughly to [0, 1] range\n      // For [-1,1] grads, theoretical max is sqrt(N)/2, approx 0.7 for 2D\n      // For [1,1] grads, max is closer to 1.0. Let's use a safe normalization.\n      return (result + 1.0) / 2.0; // Map roughly [-1, 1] to [0, 1]\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape(params) {\n      // Ensure noise state is initialized for the current seed\n      this._initializeNoise();\n      var noiseZoom = this.noiseScale > 0 ? 100.0 / this.noiseScale : 10.0; // Higher scale -> smaller features\n      var threshold = this.threshold;\n      var resolution = Math.max(2, Math.floor(this.resolution)); // Grid cells per axis\n      var viewBoxMin = -100;\n      var viewBoxMax = 100;\n      var viewBoxSize = viewBoxMax - viewBoxMin; // 200\n      var step = viewBoxSize / resolution; // Size of one grid cell\n\n      // Generate noise grid values\n      var noiseGrid = [];\n      for (var i = 0; i <= resolution; i++) {\n        // Need N+1 points for N cells\n        noiseGrid[i] = [];\n        var y = viewBoxMin + i * step;\n        for (var j = 0; j <= resolution; j++) {\n          var x = viewBoxMin + j * step;\n          // Sample noise - scale coordinates for desired feature size\n          noiseGrid[i][j] = this._noise(x / noiseZoom, y / noiseZoom);\n        }\n      }\n\n      // --- Generate Path Segments using Marching Squares ---\n      var segments = [];\n      for (var _i = 0; _i < resolution; _i++) {\n        // Iterate through cells\n        for (var _j = 0; _j < resolution; _j++) {\n          // Calculate world coordinates of the square's top-left corner\n          var xBase = viewBoxMin + _j * step;\n          var yBase = viewBoxMin + _i * step;\n\n          // Get noise values at corners (TL, TR, BL, BR) relative to this cell\n          var valC = noiseGrid[_i][_j]; // TL (TopLeft)\n          var valD = noiseGrid[_i][_j + 1]; // TR (TopRight)\n          var valA = noiseGrid[_i + 1][_j]; // BL (BottomLeft)\n          var valB = noiseGrid[_i + 1][_j + 1]; // BR (BottomRight)\n\n          // Determine Marching Squares case index (Bit order: D-C-B-A -> 8-4-2-1)\n          var caseIndex = 0;\n          if (valA >= threshold) caseIndex |= 1;\n          if (valB >= threshold) caseIndex |= 2;\n          if (valC >= threshold) caseIndex |= 4;\n          if (valD >= threshold) caseIndex |= 8;\n\n          // Get edge definitions for this case\n          var edges = this.marchingSquaresEdges[caseIndex];\n\n          // Add segments in world coordinates\n          var _iterator = _createForOfIteratorHelper(edges),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var edge = _step.value;\n              var p1x = xBase + edge.x1 * step;\n              var p1y = yBase + edge.y1 * step; // Note: y increases downwards in grid index, upwards in SVG coords\n              var p2x = xBase + edge.x2 * step;\n              var p2y = yBase + edge.y2 * step;\n              segments.push({\n                x1: p1x,\n                y1: p1y,\n                x2: p2x,\n                y2: p2y,\n                used: false\n              });\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }\n      }\n\n      // --- Link Segments into Paths ---\n      var fullPathData = '';\n      var tolerance = step * 0.1; // Tolerance for matching endpoints\n      var f = function f(num) {\n        return num.toFixed(3);\n      }; // Formatting helper\n\n      for (var _i2 = 0; _i2 < segments.length; _i2++) {\n        if (segments[_i2].used) continue;\n\n        // Start a new path chain\n        segments[_i2].used = true;\n        var currentPathPoints = [{\n          x: segments[_i2].x1,\n          y: segments[_i2].y1\n        }, {\n          x: segments[_i2].x2,\n          y: segments[_i2].y2\n        }];\n        var currentHead = currentPathPoints[0];\n        var currentTail = currentPathPoints[1];\n        var closedLoop = false;\n        var changed = true;\n        while (changed) {\n          // Keep searching until no more segments can be added to either end\n          changed = false;\n\n          // Try extending the tail\n          for (var _j2 = 0; _j2 < segments.length; _j2++) {\n            if (segments[_j2].used) continue;\n            var segJ = segments[_j2];\n            var matchFound = false;\n            var nextPoint = null;\n            if (Math.abs(segJ.x1 - currentTail.x) < tolerance && Math.abs(segJ.y1 - currentTail.y) < tolerance) {\n              nextPoint = {\n                x: segJ.x2,\n                y: segJ.y2\n              }; // Extend with segJ forward\n              matchFound = true;\n            } else if (Math.abs(segJ.x2 - currentTail.x) < tolerance && Math.abs(segJ.y2 - currentTail.y) < tolerance) {\n              nextPoint = {\n                x: segJ.x1,\n                y: segJ.y1\n              }; // Extend with segJ reversed\n              matchFound = true;\n            }\n            if (matchFound) {\n              segments[_j2].used = true;\n              // Check if this segment closes the loop\n              if (Math.abs(nextPoint.x - currentHead.x) < tolerance && Math.abs(nextPoint.y - currentHead.y) < tolerance) {\n                closedLoop = true;\n              } else {\n                currentPathPoints.push(nextPoint);\n                currentTail = nextPoint;\n              }\n              changed = true;\n              break; // Found segment to extend tail\n            }\n          }\n          if (changed || closedLoop) continue; // Restart search or stop if closed\n\n          // Try extending the head (prepending)\n          for (var _j3 = 0; _j3 < segments.length; _j3++) {\n            if (segments[_j3].used) continue;\n            var _segJ = segments[_j3];\n            var _matchFound = false;\n            var _nextPoint = null;\n            if (Math.abs(_segJ.x2 - currentHead.x) < tolerance && Math.abs(_segJ.y2 - currentHead.y) < tolerance) {\n              _nextPoint = {\n                x: _segJ.x1,\n                y: _segJ.y1\n              }; // Prepend with segJ forward\n              _matchFound = true;\n            } else if (Math.abs(_segJ.x1 - currentHead.x) < tolerance && Math.abs(_segJ.y1 - currentHead.y) < tolerance) {\n              _nextPoint = {\n                x: _segJ.x2,\n                y: _segJ.y2\n              }; // Prepend with segJ reversed\n              _matchFound = true;\n            }\n            if (_matchFound) {\n              segments[_j3].used = true;\n              // Check if this segment closes the loop (shouldn't happen here if tail didn't close)\n              // Prepend and update head\n              currentPathPoints.unshift(_nextPoint);\n              currentHead = _nextPoint;\n              changed = true;\n              break; // Found segment to extend head\n            }\n          }\n          // If closedLoop is true,changed might be false, but we should exit anyway.\n          if (closedLoop) changed = false;\n        } // End while(changed)\n\n        // Add the constructed path (point sequence) to the SVG data\n        if (currentPathPoints.length > 1) {\n          var pathString = \"M \".concat(f(currentPathPoints[0].x), \",\").concat(f(currentPathPoints[0].y));\n          for (var k = 1; k < currentPathPoints.length; k++) {\n            // Could add smoothing here (e.g., Bezier curves) instead of L\n            pathString += \" L \".concat(f(currentPathPoints[k].x), \",\").concat(f(currentPathPoints[k].y));\n          }\n          if (closedLoop) {\n            pathString += ' Z'; // Close the path explicitly if loop detected\n          }\n          fullPathData += pathString + ' ';\n        }\n      }\n\n      // Use fill-rule=\"evenodd\" to handle potentially overlapping or nested paths correctly for filling.\n      // It ensures areas enclosed by an odd number of path windings are filled.\n      return \"<path d=\\\"\".concat(fullPathData.trim(), \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" fill-rule=\\\"evenodd\\\"/>\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(OrganicDiffusion, \"parameters\", {\n  noiseScale: {\n    type: 'number',\n    min: 5,\n    max: 100,\n    step: 1,\n    \"default\": 35,\n    label: 'Feature Scale'\n  },\n  threshold: {\n    type: 'number',\n    min: 0.05,\n    max: 0.95,\n    step: 0.01,\n    \"default\": 0.55,\n    label: 'Coverage Threshold'\n  },\n  resolution: {\n    type: 'number',\n    min: 10,\n    max: 100,\n    step: 1,\n    \"default\": 50,\n    label: 'Detail Resolution'\n  }\n  // Seed parameter is inherited from Shape base class\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (OrganicDiffusion);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/OrganicDiffusion.js?");

/***/ }),

/***/ "./src/shapes/OrganicForm.js":
/*!***********************************!*\
  !*** ./src/shapes/OrganicForm.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n// --- Helper functions for Vector Math ---\n\n// Calculate squared distance between two points {x, y}\nfunction distSq(p1, p2) {\n  var dx = p1.x - p2.x;\n  var dy = p1.y - p2.y;\n  return dx * dx + dy * dy;\n}\n\n// Calculate distance between two points {x, y}\nfunction dist(p1, p2) {\n  return Math.sqrt(distSq(p1, p2));\n}\n\n// Subtract point p2 from p1 (returns vector p2->p1)\nfunction sub(p1, p2) {\n  return {\n    x: p1.x - p2.x,\n    y: p1.y - p2.y\n  };\n}\n\n// Add two points/vectors\nfunction add(p1, p2) {\n  return {\n    x: p1.x + p2.x,\n    y: p1.y + p2.y\n  };\n}\n\n// Scale a point/vector by a factor\nfunction scale(p, factor) {\n  return {\n    x: p.x * factor,\n    y: p.y * factor\n  };\n}\n\n// Normalize a vector to unit length\nfunction normalize(p) {\n  var len = Math.sqrt(p.x * p.x + p.y * p.y);\n  if (len === 0) return {\n    x: 0,\n    y: 0\n  }; // Avoid division by zero\n  return {\n    x: p.x / len,\n    y: p.y / len\n  };\n}\n// --- End Helper Functions ---\n\n/**\n * Creates abstract, smoothly curved organic shapes using Bezier curves, with\n * options for symmetry and irregularity.\n */\nvar OrganicForm = /*#__PURE__*/function (_Shape) {\n  function OrganicForm() {\n    _classCallCheck(this, OrganicForm);\n    return _callSuper(this, OrganicForm, arguments);\n  }\n  _inherits(OrganicForm, _Shape);\n  return _createClass(OrganicForm, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var points = [];\n      // Ensure numPoints is an integer and at least 3 for a valid shape.\n      var num = Math.max(3, Math.floor(this.numPoints));\n\n      // --- 1. Generate Anchor Points ---\n      // Determine the positions of the main vertices of the shape outline based on parameters.\n      if (this.verticalSymmetry) {\n        // Generate points for the right half and reflect across the Y-axis for the left.\n        var isOdd = num % 2 !== 0;\n        // Calculate number of points needed for the right half, including axis points.\n        // Examples: num=5 (odd) -> ceil(2.5)=3 points; num=6 (even) -> 6/2+1=4 points.\n        var numHalf = isOdd ? Math.ceil(num / 2) : num / 2 + 1;\n        // Calculate angle step between points in the half-circle (from -PI/2 to PI/2).\n        var angleStepHalf = Math.PI / Math.max(1, numHalf - 1); // Avoid division by zero\n\n        var rightPoints = [];\n        for (var i = 0; i < numHalf; i++) {\n          // Calculate the base angle for this point, spanning from bottom (-PI/2) to top (PI/2).\n          var baseAngle = void 0;\n          if (numHalf === 1) baseAngle = 0; // Single point case (won't happen due to num>=3)\n          else if (i === 0) baseAngle = -Math.PI / 2; // Bottom point on Y-axis\n          else if (i === numHalf - 1) baseAngle = Math.PI / 2; // Top point on Y-axis\n          else baseAngle = -Math.PI / 2 + i * angleStepHalf; // Intermediate points\n\n          // Add random variation to the angle, reducing it near the axis for smoother symmetry.\n          var maxAngleDev = angleStepHalf * this.angleVariation * 0.5; // Max deviation allowed\n          var currentAngleVariation = maxAngleDev;\n          if (i === 0 || i === numHalf - 1) {\n            currentAngleVariation *= 0.05; // Significantly less variation for axis points\n          }\n          var angle = baseAngle + (this.random() - 0.5) * 2 * currentAngleVariation;\n\n          // Calculate radius with random variation based on 'complexity'.\n          var radiusVariation = this.radius * (1 + (this.random() - 0.5) * 2 * this.complexity);\n          // Clamp radius to prevent extremely small/large shapes and stay within viewBox.\n          var currentRadius = this._clamp(radiusVariation, this.radius * 0.2, 98);\n\n          // Convert polar coordinates (angle, radius) to Cartesian (x, y).\n          var x = currentRadius * Math.cos(angle);\n          var y = currentRadius * Math.sin(angle);\n\n          // Force the first (bottom) and last (top) points exactly onto the Y-axis for clean symmetry.\n          if (i === 0 || i === numHalf - 1) {\n            x = 0;\n          }\n          rightPoints.push({\n            x: x,\n            y: y\n          });\n        }\n\n        // Build the full points array starting with the right side points.\n        points.push.apply(points, rightPoints);\n\n        // Add reflections of the right-side points (excluding the axis points already added)\n        // to create the left side, iterating backwards to maintain order.\n        var reflectionStartIndex = 1; // Always skip reflecting the first point (bottom axis)\n        var reflectionEndIndex = numHalf - 1; // Don't reflect the last point (top axis)\n        for (var _i = reflectionEndIndex - 1; _i >= reflectionStartIndex; _i--) {\n          // Only add reflection if the point is not extremely close to the axis already.\n          if (Math.abs(rightPoints[_i].x) > 0.01) {\n            points.push({\n              x: -rightPoints[_i].x,\n              y: rightPoints[_i].y\n            });\n          }\n          // Note: This might result in `num-1` points for odd `num`, which works fine with path closure.\n        }\n      } else {\n        // No symmetry: generate points spread around the full circle (0 to 2*PI).\n        var angleStepBase = 2 * Math.PI / num;\n        for (var _i2 = 0; _i2 < num; _i2++) {\n          var _baseAngle = _i2 * angleStepBase;\n          // Add random angle variation.\n          var _angle = _baseAngle + (this.random() - 0.5) * 2 * angleStepBase * this.angleVariation;\n\n          // Calculate radius with random variation.\n          var _radiusVariation = this.radius * (1 + (this.random() - 0.5) * 2 * this.complexity);\n          var _currentRadius = this._clamp(_radiusVariation, this.radius * 0.2, 98);\n          var _x = _currentRadius * Math.cos(_angle);\n          var _y = _currentRadius * Math.sin(_angle);\n          points.push({\n            x: _x,\n            y: _y\n          });\n        }\n      }\n\n      // --- 2. Calculate Bezier Control Points ---\n      // Determine control points needed for smooth cubic Bezier curves between the anchor points.\n      var controlPoints = [];\n      var n = points.length; // Actual number of anchor points generated\n\n      // Handle potential edge cases with insufficient points (defensive coding).\n      if (n < 2) return \"<circle cx=\\\"0\\\" cy=\\\"0\\\" r=\\\"\".concat(this.radius * 0.1, \"\\\" fill=\\\"white\\\"/>\"); // Draw small circle if < 2 pts\n      if (n === 2) return \"<line x1=\\\"\".concat(points[0].x.toFixed(2), \"\\\" y1=\\\"\").concat(points[0].y.toFixed(2), \"\\\" x2=\\\"\").concat(points[1].x.toFixed(2), \"\\\" y2=\\\"\").concat(points[1].y.toFixed(2), \"\\\" stroke=\\\"white\\\" stroke-width=\\\"2\\\"/>\"); // Draw line if 2 pts\n\n      // Calculate control points for each anchor point.\n      for (var _i3 = 0; _i3 < n; _i3++) {\n        // Get current, previous, and next points, handling wrap-around for the closed shape.\n        var pPrev = points[(_i3 - 1 + n) % n];\n        var pCurr = points[_i3];\n        var pNext = points[(_i3 + 1) % n];\n\n        // Estimate the tangent direction at pCurr based on its neighbors.\n        var tangentVec = sub(pNext, pPrev); // Vector from pPrev to pNext\n        var tangent = normalize(tangentVec); // Unit vector along the tangent direction\n\n        // Calculate distances to neighboring anchor points.\n        var distNext = dist(pCurr, pNext);\n        var distPrev = dist(pCurr, pPrev);\n\n        // Determine the length of the control point handles (distance from anchor point).\n        // This length is proportional to the distance to neighbors and scaled by 'smoothness'.\n        // The 0.35 factor is a tuning parameter affecting how \"tight\" the curve follows the tangent.\n        var scaleFactor = this.smoothness * 0.35;\n\n        // Calculate the first control point (cp1) - outgoing from pCurr towards pNext.\n        // Position is pCurr offset along the tangent direction.\n        var cp1 = add(pCurr, scale(tangent, distNext * scaleFactor));\n        // Calculate the second control point (cp2) - incoming to pCurr from pPrev.\n        // Position is pCurr offset along the negative tangent direction.\n        var cp2 = sub(pCurr, scale(tangent, distPrev * scaleFactor));\n\n        // Store both control points associated with the anchor point pCurr.\n        // cp1 will be used for the curve segment leaving pCurr.\n        // cp2 will be used for the curve segment arriving at pCurr.\n        controlPoints.push({\n          cp1: cp1,\n          cp2: cp2\n        });\n      }\n\n      // --- 3. Build SVG Path Data string ('d' attribute) ---\n      // Construct the path using cubic Bezier curves ('C' command).\n      var pathData = \"M \".concat(points[0].x.toFixed(2), \" \").concat(points[0].y.toFixed(2)); // Move to the first anchor point.\n\n      // Iterate through anchor points to create curve segments.\n      for (var _i4 = 0; _i4 < n; _i4++) {\n        var nextIdx = (_i4 + 1) % n; // Index of the next anchor point (wraps around).\n        var _pNext = points[nextIdx]; // The anchor point the curve segment goes to.\n\n        // Control points for the curve from points[i] to points[nextIdx]:\n        // cp1: Outgoing control point from points[i] (calculated in the i-th iteration).\n        // cp2: Incoming control point to points[nextIdx] (calculated in the nextIdx-th iteration).\n        var _cp = controlPoints[_i4].cp1;\n        var _cp2 = controlPoints[nextIdx].cp2;\n\n        // Append the cubic Bezier curve segment command to the path data.\n        // Format: C cp1x,cp1y cp2x,cp2y pNextx,pNexty\n        pathData += \" C \".concat(_cp.x.toFixed(2), \",\").concat(_cp.y.toFixed(2), \" \").concat(_cp2.x.toFixed(2), \",\").concat(_cp2.y.toFixed(2), \" \").concat(_pNext.x.toFixed(2), \",\").concat(_pNext.y.toFixed(2));\n      }\n      pathData += ' Z'; // Close the path to form a closed shape.\n\n      // Return the final SVG path element as a string.\n      return \"<path d=\\\"\".concat(pathData, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\");\n    }\n\n    /**\n     * Helper method to clamp a value within a specified range [min, max].\n     * Used internally for parameters like radius.\n     */\n  }, {\n    key: \"_clamp\",\n    value: function _clamp(value, min, max) {\n      return Math.max(min, Math.min(value, max));\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(OrganicForm, \"parameters\", {\n  numPoints: {\n    type: 'number',\n    min: 12,\n    max: 32,\n    step: 1,\n    \"default\": 12,\n    label: 'Vertices' // Base complexity: more points allow more lobes/features\n  },\n  radius: {\n    type: 'number',\n    min: 30,\n    max: 95,\n    step: 1,\n    \"default\": 80,\n    label: 'Average Radius' // Controls the overall size\n  },\n  smoothness: {\n    type: 'number',\n    min: 0.1,\n    max: 1.0,\n    step: 0.05,\n    \"default\": 0.8,\n    label: 'Smoothness' // Controls curvature: higher values give rounder forms\n  },\n  complexity: {\n    type: 'number',\n    min: 0.2,\n    max: 0.9,\n    step: 0.05,\n    \"default\": 0.6,\n    label: 'Radial Variation' // Randomness in distance from center (0=circle base)\n  },\n  angleVariation: {\n    type: 'number',\n    min: 0.0,\n    max: 0.7,\n    step: 0.05,\n    \"default\": 0.5,\n    label: 'Angular Variation' // Randomness in angle between points (0=equal spacing)\n  },\n  verticalSymmetry: {\n    type: 'boolean',\n    \"default\": true,\n    label: 'Vertical Symmetry' // Enforce symmetry across the Y-axis\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (OrganicForm);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/OrganicForm.js?");

/***/ }),

/***/ "./src/shapes/OrganicKnot.js":
/*!***********************************!*\
  !*** ./src/shapes/OrganicKnot.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates an abstract knot shape using two overlapping figure-eight paths\n * defined by Bezier curves, with adjustable bulge and thickness.\n */\nvar OrganicKnot = /*#__PURE__*/function (_Shape) {\n  function OrganicKnot() {\n    _classCallCheck(this, OrganicKnot);\n    return _callSuper(this, OrganicKnot, arguments);\n  }\n  _inherits(OrganicKnot, _Shape);\n  return _createClass(OrganicKnot, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var Rx = this.radiusX;\n      var Ry = this.radiusY;\n      var centerFactor = this.centerGapFactor;\n      var bulgeX = this.outerBulgeX;\n      var bulgeY = this.outerBulgeY;\n      var innerK = this.innerTightness;\n      var strokeWidth = this.strokeWidth;\n\n      // Calculate inner control point distance factor based on average radius and tightness/gap parameters\n      // This aims to keep the central crossing visually consistent relative to the overall size\n      var avgR = (Rx + Ry) / 2;\n      var d_inner = avgR * centerFactor * innerK;\n\n      // Calculate outer control point distances based on respective radii and bulge factors\n      // These control the shape of the outer loops independently\n      var dx_outer = Rx * bulgeX * 0.55; // 0.55 is an empirical scaling factor\n      var dy_outer = Ry * bulgeY * 0.55; // Using the same factor for consistency\n\n      // Helper function to format numbers for SVG path data\n      var fmt = function fmt(num) {\n        return parseFloat(num.toFixed(3));\n      };\n\n      // --- Shape generation logic starts here ---\n\n      // Path 1: Vertical Figure-Eight (Top/Bottom Loops using Ry)\n      // Control points near center use d_inner, control points near outer peaks use dy_outer and Ry\n      var path1_d = \"\\n            M 0,0\\n            C \".concat(fmt(d_inner), \",\").concat(fmt(d_inner), \" \").concat(fmt(-dy_outer), \",\").concat(fmt(Ry), \" 0,\").concat(fmt(Ry), \"\\n            C \").concat(fmt(dy_outer), \",\").concat(fmt(Ry), \" \").concat(fmt(-d_inner), \",\").concat(fmt(d_inner), \" 0,0\\n            C \").concat(fmt(-d_inner), \",\").concat(fmt(-d_inner), \" \").concat(fmt(dy_outer), \",\").concat(fmt(-Ry), \" 0,\").concat(fmt(-Ry), \"\\n            C \").concat(fmt(-dy_outer), \",\").concat(fmt(-Ry), \" \").concat(fmt(d_inner), \",\").concat(fmt(-d_inner), \" 0,0 Z\\n        \").trim();\n\n      // Path 2: Horizontal Figure-Eight (Left/Right Loops using Rx)\n      // Control points near center use d_inner, control points near outer peaks use dx_outer and Rx\n      var path2_d = \"\\n            M 0,0\\n            C \".concat(fmt(d_inner), \",\").concat(fmt(-d_inner), \" \").concat(fmt(Rx), \",\").concat(fmt(dx_outer), \" \").concat(fmt(Rx), \",0\\n            C \").concat(fmt(Rx), \",\").concat(fmt(-dx_outer), \" \").concat(fmt(-d_inner), \",\").concat(fmt(-d_inner), \" 0,0\\n            C \").concat(fmt(-d_inner), \",\").concat(fmt(d_inner), \" \").concat(fmt(-Rx), \",\").concat(fmt(-dx_outer), \" \").concat(fmt(-Rx), \",0\\n            C \").concat(fmt(-Rx), \",\").concat(fmt(dx_outer), \" \").concat(fmt(d_inner), \",\").concat(fmt(d_inner), \" 0,0 Z\\n        \").trim();\n\n      // Generate the SVG path elements with specified stroke width and rounded ends/joins\n      var svgPath1 = \"<path d=\\\"\".concat(path1_d, \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(strokeWidth, \"\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\"/>\");\n      var svgPath2 = \"<path d=\\\"\".concat(path2_d, \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(strokeWidth, \"\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\"/>\");\n\n      // Combine the two paths. Path 2 is drawn on top for the over/under weaving effect.\n      return \"\\n            \".concat(svgPath1, \"\\n            \").concat(svgPath2, \"\\n        \");\n      // --- Shape generation logic ends here ---\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(OrganicKnot, \"parameters\", {\n  radiusX: {\n    type: 'number',\n    min: 20,\n    max: 98,\n    // Keep within viewBox limits\n    step: 1,\n    \"default\": 80,\n    label: 'Horizontal Size' // Controls the extent of the left/right loops\n  },\n  radiusY: {\n    type: 'number',\n    min: 20,\n    max: 98,\n    // Keep within viewBox limits\n    step: 1,\n    \"default\": 60,\n    label: 'Vertical Size' // Controls the extent of the top/bottom loops\n  },\n  centerGapFactor: {\n    // Controls the size of the central opening\n    type: 'number',\n    min: 0.05,\n    // Very tight center\n    max: 0.7,\n    // Very open center\n    step: 0.05,\n    \"default\": 0.25,\n    label: 'Center Gap Factor' // Influences inner control points relative to radii\n  },\n  outerBulgeX: {\n    // Controls the bulge/pointiness of the horizontal outer loops\n    type: 'number',\n    min: 0.2,\n    // Less bulge, more pointy\n    max: 1.8,\n    // More bulge, very rounded loops\n    step: 0.05,\n    \"default\": 0.7,\n    label: 'Horizontal Bulge'\n  },\n  outerBulgeY: {\n    // Controls the bulge/pointiness of the vertical outer loops\n    type: 'number',\n    min: 0.2,\n    // Less bulge, more pointy\n    max: 1.8,\n    // More bulge, very rounded loops\n    step: 0.05,\n    \"default\": 0.9,\n    label: 'Vertical Bulge'\n  },\n  innerTightness: {\n    // Controls how sharply the curves bend near the center (applies to both)\n    type: 'number',\n    min: 0.2,\n    // Looser curve near center\n    max: 2.0,\n    // Tighter curve near center\n    step: 0.05,\n    \"default\": 1.0,\n    label: 'Inner Curve Tightness'\n  },\n  strokeWidth: {\n    type: 'number',\n    min: 2,\n    // Minimum thickness\n    max: 35,\n    // Allow for significantly thicker \"weight\"\n    step: 0.5,\n    \"default\": 12,\n    // Increased default weight\n    label: 'Stroke Width'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (OrganicKnot);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/OrganicKnot.js?");

/***/ }),

/***/ "./src/shapes/OrganicNodes.js":
/*!************************************!*\
  !*** ./src/shapes/OrganicNodes.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates an organic structure with a central hub and arms radiating to\n * circular nodes, featuring variable arm thickness.\n */\nvar OrganicNodes = /*#__PURE__*/function (_Shape) {\n  function OrganicNodes() {\n    _classCallCheck(this, OrganicNodes);\n    return _callSuper(this, OrganicNodes, arguments);\n  }\n  _inherits(OrganicNodes, _Shape);\n  return _createClass(OrganicNodes, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var numNodes = Math.round(this.numNodes);\n      var nodeRadius = this.nodeRadius;\n      var armLength = this.armLength;\n      var armThicknessStart = this.armThicknessStart;\n      var armThicknessEnd = this.armThicknessEnd;\n      var centerRadius = this.centerRadius;\n\n      // Prevent arms from becoming inverted if thickness > radius\n      var safeCenterRadius = Math.max(centerRadius, armThicknessStart / 2 + 1);\n      var safeNodeRadius = Math.max(nodeRadius, armThicknessEnd / 2 + 1);\n      var svgElements = '';\n\n      // Calculate the maximum extent to potentially scale down if needed\n      var maxExtent = armLength + safeNodeRadius;\n      var scaleFactor = maxExtent > 98 ? 98 / maxExtent : 1; // Use 98 for slight margin\n\n      var scaledNodeRadius = safeNodeRadius * scaleFactor;\n      var scaledArmLength = armLength * scaleFactor;\n      var scaledArmThicknessStart = armThicknessStart * scaleFactor;\n      var scaledArmThicknessEnd = armThicknessEnd * scaleFactor;\n      var scaledCenterRadius = safeCenterRadius * scaleFactor;\n\n      // Draw the central hub circle first (arms and nodes will overlap)\n      if (scaledCenterRadius > 0) {\n        svgElements += \"<circle cx=\\\"0\\\" cy=\\\"0\\\" r=\\\"\".concat(scaledCenterRadius.toFixed(2), \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\\n\");\n      }\n\n      // Calculate angular offsets based on thickness for smooth connection points\n      // Use Math.max to avoid asin(>1) issues if thickness exceeds diameter\n      var angleOffsetStart = Math.asin(Math.min(1, scaledArmThicknessStart / (2 * scaledCenterRadius)));\n      var angleOffsetEnd = Math.asin(Math.min(1, scaledArmThicknessEnd / (2 * scaledNodeRadius)));\n      for (var i = 0; i < numNodes; i++) {\n        var angle = i / numNodes * 2 * Math.PI; // Angle for this node/arm\n\n        // Node center coordinates\n        var nx = scaledArmLength * Math.cos(angle);\n        var ny = scaledArmLength * Math.sin(angle);\n\n        // Arm path points calculation\n        // Points on the central circle edge\n        var p1c_x = scaledCenterRadius * Math.cos(angle - angleOffsetStart);\n        var p1c_y = scaledCenterRadius * Math.sin(angle - angleOffsetStart);\n        var p2c_x = scaledCenterRadius * Math.cos(angle + angleOffsetStart);\n        var p2c_y = scaledCenterRadius * Math.sin(angle + angleOffsetStart);\n\n        // Points on the node circle edge (approximated)\n        // Use node center offset by thickness perpendicular to arm direction\n        // More accurate would involve tangents, but this is simpler for visual effect.\n        // These points define the base of the arm connection at the node.\n        var p1n_x = nx - scaledArmThicknessEnd / 2 * Math.sin(angle);\n        var p1n_y = ny + scaledArmThicknessEnd / 2 * Math.cos(angle);\n        var p2n_x = nx + scaledArmThicknessEnd / 2 * Math.sin(angle);\n        var p2n_y = ny - scaledArmThicknessEnd / 2 * Math.cos(angle);\n\n        // Draw the arm as a filled polygon (quadrilateral)\n        // Using L commands for straight connections. Could use Q for curves later.\n        var armPathData = \"\\n                 M \".concat(p1c_x.toFixed(2), \",\").concat(p1c_y.toFixed(2), \"\\n                 L \").concat(p1n_x.toFixed(2), \",\").concat(p1n_y.toFixed(2), \"\\n                 L \").concat(p2n_x.toFixed(2), \",\").concat(p2n_y.toFixed(2), \"\\n                 L \").concat(p2c_x.toFixed(2), \",\").concat(p2c_y.toFixed(2), \"\\n                 Z\\n             \");\n        svgElements += \"<path d=\\\"\".concat(armPathData.replace(/\\s+/g, ' ').trim(), \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\\n\");\n\n        // Draw the outer node circle (drawn last to overlap arm ends)\n        svgElements += \"<circle cx=\\\"\".concat(nx.toFixed(2), \"\\\" cy=\\\"\").concat(ny.toFixed(2), \"\\\" r=\\\"\").concat(scaledNodeRadius.toFixed(2), \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\\n\");\n      }\n      return svgElements;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(OrganicNodes, \"parameters\", {\n  numNodes: {\n    type: 'number',\n    min: 3,\n    max: 12,\n    step: 1,\n    \"default\": 7,\n    description: \"Number of outer nodes/spheres\"\n  },\n  nodeRadius: {\n    type: 'number',\n    min: 5,\n    max: 40,\n    step: 1,\n    \"default\": 25,\n    description: \"Radius of the outer nodes\"\n  },\n  armLength: {\n    type: 'number',\n    min: 20,\n    max: 90,\n    step: 1,\n    \"default\": 65,\n    description: \"Distance from center to node centers\"\n  },\n  armThicknessStart: {\n    type: 'number',\n    min: 2,\n    max: 30,\n    step: 1,\n    \"default\": 12,\n    description: \"Thickness of arm at the central hub\"\n  },\n  armThicknessEnd: {\n    type: 'number',\n    min: 2,\n    max: 30,\n    step: 1,\n    \"default\": 10,\n    description: \"Thickness of arm near the outer node\"\n  },\n  centerRadius: {\n    type: 'number',\n    min: 0,\n    max: 40,\n    step: 1,\n    \"default\": 15,\n    description: \"Radius of the central hub connection area\"\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (OrganicNodes);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/OrganicNodes.js?");

/***/ }),

/***/ "./src/shapes/OrganicSculpture.js":
/*!****************************************!*\
  !*** ./src/shapes/OrganicSculpture.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates abstract, stacked organic shapes resembling minimalist sculptures,\n * with rounded edges and optional cutouts.\n */\nvar OrganicSculpture = /*#__PURE__*/function (_Shape) {\n  function OrganicSculpture() {\n    _classCallCheck(this, OrganicSculpture);\n    return _callSuper(this, OrganicSculpture, arguments);\n  }\n  _inherits(OrganicSculpture, _Shape);\n  return _createClass(OrganicSculpture, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var svgPaths = '';\n      var totalHeight = 0;\n      var segmentData = [];\n      var heightVariationFactor = 0.4; // +/- 20% variation\n      var widthVariationFactor = 0.4; // +/- 20% variation\n\n      // 1. Calculate dimensions and positions for each segment based on parameters and randomness\n      for (var i = 0; i < this.numSegments; i++) {\n        // Apply random variation to segment height and width\n        var h = this.avgHeight * (1 - heightVariationFactor / 2 + this.random() * heightVariationFactor);\n        var w = this.avgWidth * (1 - widthVariationFactor / 2 + this.random() * widthVariationFactor);\n        // Apply random horizontal offset (wiggle)\n        var xOffset = (this.random() - 0.5) * 2 * this.alignmentWiggle;\n        segmentData.push({\n          height: h,\n          width: w,\n          xOffset: xOffset\n        });\n        totalHeight += h;\n        if (i < this.numSegments - 1) {\n          totalHeight += this.gap; // Add gap between segments\n        }\n      }\n\n      // Calculate starting Y position to center the entire stack vertically\n      var currentY = -totalHeight / 2;\n\n      // 2. Generate paths for each segment\n      for (var _i = 0; _i < this.numSegments; _i++) {\n        var seg = segmentData[_i];\n        // Create the main organic path for the segment\n        var segPathData = this.createSegmentPath(seg.xOffset,\n        // Centered horizontally with wiggle\n        currentY,\n        // Current vertical position\n        seg.width, seg.height, this.cornerRadius);\n        var finalPathData = segPathData;\n\n        // Determine if this segment should have a hole based on probability\n        if (this.random() < this.holeProbability) {\n          // Create the path for the hole (counter-clockwise for fill-rule)\n          var holePathData = this.createHolePath(seg.xOffset,\n          // Center hole within segment's x-offset\n          currentY,\n          // Base y of the segment\n          seg.width, seg.height, this.holeSizeRatio, this.cornerRadius * 0.8 // Hole slightly less round than outer shape\n          );\n          // Append hole path to segment path for compound path rendering\n          finalPathData += \" \" + holePathData;\n        }\n\n        // Add the complete path for this segment to the SVG string\n        // Use fill-rule=\"evenodd\" to handle the holes correctly\n        svgPaths += \"<path d=\\\"\".concat(finalPathData, \"\\\" fill=\\\"white\\\" fill-rule=\\\"evenodd\\\" stroke=\\\"none\\\" />\\n\");\n\n        // Update Y position for the next segment, including the gap\n        currentY += seg.height + this.gap;\n      }\n      return svgPaths.trim(); // Return the combined SVG paths\n    }\n\n    /**\n     * Creates an organic, rounded rectangle path for a segment using wavy edges.\n     * Uses quadratic Bezier curves for corners and edges to simulate waviness.\n     * @param {number} cx - Center X coordinate for the segment (considering wiggle).\n     * @param {number} cy - Top Y coordinate for the segment.\n     * @param {number} width - Width of the segment.\n     * @param {number} height - Height of the segment.\n     * @param {number} radius - Base corner radius.\n     * @param {number} waviness - Amplitude of edge distortion.\n     * @returns {string} SVG path data string.\n     */\n  }, {\n    key: \"createSegmentPath\",\n    value: function createSegmentPath(cx, cy, width, height, radius) {\n      var _this = this;\n      var waviness = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n      var w2 = width / 2;\n      var h2 = height / 2;\n      // Ensure radius isn't larger than half the width/height\n      radius = Math.min(radius, w2, h2);\n\n      // Define base corner points\n      var topLeft = {\n        x: cx - w2,\n        y: cy\n      };\n      var topRight = {\n        x: cx + w2,\n        y: cy\n      };\n      var bottomRight = {\n        x: cx + w2,\n        y: cy + height\n      };\n      var bottomLeft = {\n        x: cx - w2,\n        y: cy + height\n      };\n\n      // Helper function to apply random perturbation based on waviness\n      var perturb = function perturb(val) {\n        var range = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : waviness;\n        return val + (_this.random() - 0.5) * 2 * range;\n      };\n\n      // Construct the path using lines and quadratic Bezier curves for corners,\n      // and quadratic curves for edges to introduce waviness. Points are perturbed.\n      // Path moves clockwise.\n      var pathWavy = \"\\n            M \".concat(perturb(topLeft.x + radius), \",\").concat(perturb(topLeft.y), \"\\n            Q \").concat(perturb(cx), \",\").concat(perturb(topLeft.y - waviness * 0.8), \" \").concat(perturb(topRight.x - radius), \",\").concat(perturb(topRight.y), \"\\n            Q \").concat(perturb(topRight.x), \",\").concat(perturb(topRight.y), \" \").concat(perturb(topRight.x), \",\").concat(perturb(topRight.y + radius), \"\\n            Q \").concat(perturb(topRight.x + waviness * 0.8), \",\").concat(perturb(cy + h2), \" \").concat(perturb(bottomRight.x), \",\").concat(perturb(bottomRight.y - radius), \"\\n            Q \").concat(perturb(bottomRight.x), \",\").concat(perturb(bottomRight.y), \" \").concat(perturb(bottomRight.x - radius), \",\").concat(perturb(bottomRight.y), \"\\n            Q \").concat(perturb(cx), \",\").concat(perturb(bottomRight.y + waviness * 0.8), \" \").concat(perturb(bottomLeft.x + radius), \",\").concat(perturb(bottomLeft.y), \"\\n            Q \").concat(perturb(bottomLeft.x), \",\").concat(perturb(bottomLeft.y), \" \").concat(perturb(bottomLeft.x), \",\").concat(perturb(bottomLeft.y - radius), \"\\n            Q \").concat(perturb(bottomLeft.x - waviness * 0.8), \",\").concat(perturb(cy + h2), \" \").concat(perturb(topLeft.x), \",\").concat(perturb(topLeft.y + radius), \"\\n            Q \").concat(perturb(topLeft.x), \",\").concat(perturb(topLeft.y), \" \").concat(perturb(topLeft.x + radius), \",\").concat(perturb(topLeft.y), \"\\n            Z\\n        \");\n\n      // Clean up extra whitespace and return\n      return pathWavy.replace(/\\s+/g, ' ').trim();\n    }\n\n    /**\n    * Creates a counter-clockwise rounded rectangle path for a hole within a segment.\n     * @param {number} segX - Center X coordinate of the parent segment.\n     * @param {number} segY - Top Y coordinate of the parent segment.\n     * @param {number} segWidth - Width of the parent segment.\n     * @param {number} segHeight - Height of the parent segment.\n     * @param {number} sizeRatio - Size of the hole relative to the segment dimensions.\n     * @param {number} radius - Corner radius for the hole.\n     * @returns {string} SVG path data string (counter-clockwise).\n    */\n  }, {\n    key: \"createHolePath\",\n    value: function createHolePath(segX, segY, segWidth, segHeight, sizeRatio, radius) {\n      // Calculate hole dimensions based on ratio\n      var holeWidth = segWidth * sizeRatio;\n      var holeHeight = segHeight * sizeRatio;\n      // Ensure hole radius is valid\n      var holeRadius = Math.max(0, Math.min(radius, holeWidth / 2, holeHeight / 2));\n      var w2 = holeWidth / 2;\n      var h2 = holeHeight / 2;\n\n      // Calculate the center of the hole (same center as the segment)\n      var holeCx = segX;\n      var holeCy = segY + segHeight / 2;\n\n      // Define corner points for the hole's bounding box\n      var topLeft = {\n        x: holeCx - w2,\n        y: holeCy - h2\n      };\n      var topRight = {\n        x: holeCx + w2,\n        y: holeCy - h2\n      };\n      var bottomRight = {\n        x: holeCx + w2,\n        y: holeCy + h2\n      };\n      var bottomLeft = {\n        x: holeCx - w2,\n        y: holeCy + h2\n      };\n\n      // Build counter-clockwise path using lines and quadratic Bezier corners.\n      // This direction is necessary for correct rendering with fill-rule=\"evenodd\".\n      var path = \"\\n            M \".concat(topLeft.x + holeRadius, \",\").concat(topLeft.y, \"\\n            Q \").concat(topLeft.x, \",\").concat(topLeft.y, \" \").concat(topLeft.x, \",\").concat(topLeft.y + holeRadius, \"\\n            L \").concat(bottomLeft.x, \",\").concat(bottomLeft.y - holeRadius, \"\\n            Q \").concat(bottomLeft.x, \",\").concat(bottomLeft.y, \" \").concat(bottomLeft.x + holeRadius, \",\").concat(bottomLeft.y, \"\\n            L \").concat(bottomRight.x - holeRadius, \",\").concat(bottomRight.y, \"\\n            Q \").concat(bottomRight.x, \",\").concat(bottomRight.y, \" \").concat(bottomRight.x, \",\").concat(bottomRight.y - holeRadius, \"\\n            L \").concat(topRight.x, \",\").concat(topRight.y + holeRadius, \"\\n            Q \").concat(topRight.x, \",\").concat(topRight.y, \" \").concat(topRight.x - holeRadius, \",\").concat(topRight.y, \"\\n            Z\\n        \");\n\n      // Clean up extra whitespace and return\n      return path.replace(/\\s+/g, ' ').trim();\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(OrganicSculpture, \"parameters\", {\n  numSegments: {\n    type: 'number',\n    min: 1,\n    max: 5,\n    step: 1,\n    \"default\": 3,\n    label: 'Segments'\n  },\n  avgHeight: {\n    type: 'number',\n    min: 20,\n    max: 60,\n    // Reduced max to help fit viewBox\n    step: 1,\n    \"default\": 45,\n    label: 'Avg Height'\n  },\n  avgWidth: {\n    type: 'number',\n    min: 30,\n    max: 120,\n    step: 1,\n    \"default\": 70,\n    label: 'Avg Width'\n  },\n  cornerRadius: {\n    // Controls general roundness/blobbiness\n    type: 'number',\n    min: 5,\n    max: 40,\n    step: 1,\n    \"default\": 20,\n    label: 'Roundness'\n  },\n  gap: {\n    type: 'number',\n    min: -10,\n    // Allow overlap\n    max: 20,\n    // Reduced max gap\n    step: 1,\n    \"default\": 8,\n    label: 'Gap'\n  },\n  holeProbability: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    step: 0.1,\n    \"default\": 0.6,\n    label: 'Hole %'\n  },\n  holeSizeRatio: {\n    // Relative to segment size\n    type: 'number',\n    min: 0.1,\n    max: 0.7,\n    step: 0.05,\n    \"default\": 0.45,\n    label: 'Hole Size'\n  },\n  alignmentWiggle: {\n    // Max horizontal offset deviation\n    type: 'number',\n    min: 0,\n    max: 30,\n    step: 1,\n    \"default\": 10,\n    label: 'Alignment Wiggle'\n  },\n  seed: {\n    // Inherited from Shape, but good to list explicitly if crucial\n    type: 'number',\n    min: 1,\n    max: 10000,\n    \"default\": 42,\n    label: 'Seed'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (OrganicSculpture);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/OrganicSculpture.js?");

/***/ }),

/***/ "./src/shapes/OrganicSymbol.js":
/*!*************************************!*\
  !*** ./src/shapes/OrganicSymbol.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates an organic shape based on a rounded rectangle with multiple rounded\n * 'finger' cutouts extending inwards from the sides.\n */\nvar OrganicSymbol = /*#__PURE__*/function (_Shape) {\n  function OrganicSymbol() {\n    _classCallCheck(this, OrganicSymbol);\n    return _callSuper(this, OrganicSymbol, arguments);\n  }\n  _inherits(OrganicSymbol, _Shape);\n  return _createClass(OrganicSymbol, [{\n    key: \"_clamp\",\n    value: /** Helper to clamp values */\n    function _clamp(val, min, max) {\n      return Math.max(min, Math.min(max, val));\n    }\n\n    /** Helper for random variation */\n  }, {\n    key: \"_vary\",\n    value: function _vary(value, factor) {\n      // Use a slightly skewed distribution for variation? No, keep it simple.\n      return value * (1 + (this.random() - 0.5) * 2 * factor);\n    }\n\n    /**\n     * Generates the SVG path for a rounded rectangle (clockwise).\n     * @param {number} w - Width.\n     * @param {number} h - Height.\n     * @param {number} r - Corner radius.\n     * @returns {string} SVG path data string.\n     */\n  }, {\n    key: \"_createOuterPath\",\n    value: function _createOuterPath(w, h, r) {\n      var hw = w / 2;\n      var hh = h / 2;\n      r = this._clamp(r, 0, Math.min(hw, hh)); // Ensure radius fits\n\n      var path = \"M \".concat(hw - r, \",\").concat(-hh, \" \") + // Top edge start\n      \"A \".concat(r, \",\").concat(r, \" 0 0 1 \").concat(hw, \",\").concat(-hh + r, \" \") + // Top-right corner\n      \"L \".concat(hw, \",\").concat(hh - r, \" \") + // Right edge\n      \"A \".concat(r, \",\").concat(r, \" 0 0 1 \").concat(hw - r, \",\").concat(hh, \" \") + // Bottom-right corner\n      \"L \".concat(-hw + r, \",\").concat(hh, \" \") + // Bottom edge\n      \"A \".concat(r, \",\").concat(r, \" 0 0 1 \").concat(-hw, \",\").concat(hh - r, \" \") + // Bottom-left corner\n      \"L \".concat(-hw, \",\").concat(-hh + r, \" \") + // Left edge\n      \"A \".concat(r, \",\").concat(r, \" 0 0 1 \").concat(-hw + r, \",\").concat(-hh, \" \") + // Top-left corner\n      \"Z\"; // Close (top edge)\n      return path;\n    }\n\n    /**\n     * Generates the SVG path for a single finger cutout (counter-clockwise).\n     * @param {string} side - 'top', 'left', or 'bottom'.\n     * @param {number} centerPos - Center position of the finger along the edge.\n     * @param {number} width - Width of the finger base.\n     * @param {number} length - Length of the finger cutout.\n     * @param {number} baseWidth - Width of the main shape.\n     * @param {number} baseHeight - Height of the main shape.\n     * @returns {string} SVG path data string for the finger cutout.\n     */\n  }, {\n    key: \"_createFingerPath\",\n    value: function _createFingerPath(side, centerPos, width, length, baseWidth, baseHeight) {\n      var hw = baseWidth / 2;\n      var hh = baseHeight / 2;\n      var radius = width / 2; // Finger tip radius\n\n      var x1, y1, x2, y2, tx1, ty1, tx2, ty2, sweepFlag;\n      if (side === 'top') {\n        x1 = centerPos - width / 2;\n        y1 = -hh;\n        x2 = centerPos + width / 2;\n        y2 = -hh;\n        tx1 = x1;\n        ty1 = y1 + length - radius;\n        tx2 = x2;\n        ty2 = y1 + length - radius;\n        sweepFlag = 0; // Visually CCW arc\n      } else if (side === 'bottom') {\n        x1 = centerPos + width / 2; // Start right for CCW path\n        y1 = hh;\n        x2 = centerPos - width / 2; // End left\n        y2 = hh;\n        tx1 = x1;\n        ty1 = y1 - length + radius;\n        tx2 = x2;\n        ty2 = y1 - length + radius;\n        sweepFlag = 0; // Visually CCW arc\n      } else {\n        // side === 'left'\n        x1 = -hw;\n        y1 = centerPos + width / 2; // Start bottom for CCW path\n        x2 = -hw;\n        y2 = centerPos - width / 2; // End top\n        tx1 = x1 + length - radius;\n        ty1 = y1;\n        tx2 = x1 + length - radius;\n        ty2 = y2;\n        sweepFlag = 0; // Visually CCW arc\n      }\n\n      // Ensure tip coordinates are valid\n      tx1 = this._clamp(tx1, -hw, hw);\n      tx2 = this._clamp(tx2, -hw, hw);\n      ty1 = this._clamp(ty1, -hh, hh);\n      ty2 = this._clamp(ty2, -hh, hh);\n\n      // Build counter-clockwise path for the cutout hole\n      var path = \"M \".concat(x1.toFixed(2), \",\").concat(y1.toFixed(2), \" \") + // Start point on edge\n      \"L \".concat(tx1.toFixed(2), \",\").concat(ty1.toFixed(2), \" \") + // Line to start of arc\n      \"A \".concat(radius.toFixed(2), \",\").concat(radius.toFixed(2), \" 0 1 \").concat(sweepFlag, \" \").concat(tx2.toFixed(2), \",\").concat(ty2.toFixed(2), \" \") + // Arc around the tip (use 1 for sweep flag for CCW path winding)\n      \"L \".concat(x2.toFixed(2), \",\").concat(y2.toFixed(2), \" \") + // Line back to edge\n      \"Z\";\n      return path;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      var w = this.width;\n      var h = this.height;\n      var r = this.cornerRadius;\n      var hw = w / 2;\n      var hh = h / 2;\n      var minFingerWidth = 3;\n\n      // 1. Create the outer rounded rectangle path\n      var combinedPath = this._createOuterPath(w, h, r);\n\n      // 2. Define finger groups\n      var fingerSides = [{\n        side: 'top',\n        num: this.numFingersTop,\n        edgeStart: -hw + r,\n        edgeEnd: hw - r\n      }, {\n        side: 'left',\n        num: this.numFingersLeft,\n        edgeStart: -hh + r,\n        edgeEnd: hh - r\n      }, {\n        side: 'bottom',\n        num: this.numFingersBottom,\n        edgeStart: -hw + r,\n        edgeEnd: hw - r\n      }];\n\n      // 3. Generate finger paths ensuring no overlap\n      fingerSides.forEach(function (_ref) {\n        var side = _ref.side,\n          num = _ref.num,\n          edgeStart = _ref.edgeStart,\n          edgeEnd = _ref.edgeEnd;\n        if (num <= 0) return;\n        var availableEdgeLength = edgeEnd - edgeStart;\n        if (availableEdgeLength <= 0) return;\n\n        // Pre-calculate varied widths and lengths\n        var actualFingerWidths = [];\n        var actualFingerLengths = [];\n        var totalActualFingerWidth = 0;\n        for (var i = 0; i < num; i++) {\n          var width = _this._clamp(_this._vary(_this.fingerWidth, _this.irregularity), minFingerWidth, availableEdgeLength * 0.4); // Limit width to avoid dominating edge\n          actualFingerWidths.push(width);\n          totalActualFingerWidth += width;\n          var length = _this._clamp(_this._vary(_this.fingerLength, _this.irregularity), 5, Math.min(w, h) * 0.7);\n          actualFingerLengths.push(length);\n        }\n\n        // Calculate minimum gaps\n        var minGap = _this.fingerWidth * _this.minGapFactor;\n        var totalMinGapWidth = (num + 1) * minGap;\n\n        // Calculate space available for variable gaps\n        var totalVariableGapSpace = availableEdgeLength - totalActualFingerWidth - totalMinGapWidth;\n\n        // If not enough space, attempt to shrink fingers proportionally? Or just place with min gap?\n        // For simplicity, if totalVariableGapSpace is negative, we'll just use the minGap and let fingers potentially get squashed or clamped later.\n        if (totalVariableGapSpace < 0) {\n          // console.warn(`Not enough space for fingers on side ${side}. Reducing gaps.`);\n          totalVariableGapSpace = 0; // Force only minimum gaps\n        }\n\n        // Distribute variable gap space randomly\n        var gapWeights = [];\n        var totalWeight = 0;\n        for (var _i = 0; _i < num + 1; _i++) {\n          var weight = _this.random();\n          gapWeights.push(weight);\n          totalWeight += weight;\n        }\n        // Normalize weights\n        var gapSizes = gapWeights.map(function (w) {\n          return minGap + totalVariableGapSpace * (w / totalWeight);\n        });\n\n        // Place fingers sequentially\n        var currentPos = edgeStart;\n        for (var _i2 = 0; _i2 < num; _i2++) {\n          currentPos += gapSizes[_i2]; // Add gap before the finger\n          var fingerWidth = actualFingerWidths[_i2];\n          var fingerLength = actualFingerLengths[_i2];\n          var fingerCenter = currentPos + fingerWidth / 2;\n\n          // Check if finger placement exceeds edge boundary (sanity check)\n          if (currentPos + fingerWidth > edgeEnd + 0.01) {\n            // Add epsilon for float errors\n            // console.warn(`Finger ${i+1} on side ${side} exceeds boundary. Skipping remaining fingers.`);\n            break; // Stop placing fingers if they overflow\n          }\n          combinedPath += \" \" + _this._createFingerPath(side, fingerCenter, fingerWidth, fingerLength, w, h);\n          currentPos += fingerWidth; // Advance position past the finger\n        }\n      });\n\n      // 4. Return combined path with evenodd fill rule\n      return \"<path d=\\\"\".concat(combinedPath, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" fill-rule=\\\"evenodd\\\" />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(OrganicSymbol, \"parameters\", {\n  width: {\n    type: 'number',\n    min: 100,\n    max: 190,\n    step: 2,\n    \"default\": 150,\n    label: 'Width'\n  },\n  height: {\n    type: 'number',\n    min: 100,\n    max: 190,\n    step: 2,\n    \"default\": 150,\n    label: 'Height'\n  },\n  cornerRadius: {\n    type: 'number',\n    min: 5,\n    max: 50,\n    step: 1,\n    \"default\": 25,\n    label: 'Corner Roundness'\n  },\n  numFingersLeft: {\n    type: 'number',\n    min: 0,\n    max: 8,\n    step: 1,\n    \"default\": 3,\n    label: 'Left Fingers'\n  },\n  numFingersTop: {\n    type: 'number',\n    min: 0,\n    max: 8,\n    step: 1,\n    \"default\": 3,\n    label: 'Top Fingers'\n  },\n  numFingersBottom: {\n    type: 'number',\n    min: 0,\n    max: 8,\n    step: 1,\n    \"default\": 3,\n    label: 'Bottom Fingers'\n  },\n  fingerLength: {\n    type: 'number',\n    min: 10,\n    max: 80,\n    step: 1,\n    \"default\": 40,\n    label: 'Finger Length'\n  },\n  fingerWidth: {\n    type: 'number',\n    min: 5,\n    max: 40,\n    // Max width should be reasonable relative to spacing\n    step: 1,\n    \"default\": 15,\n    label: 'Finger Width'\n  },\n  minGapFactor: {\n    type: 'number',\n    min: 0.0,\n    max: 1.0,\n    step: 0.05,\n    \"default\": 0.1,\n    // Min gap as factor of finger width\n    label: 'Min Gap Factor'\n  },\n  irregularity: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    step: 0.05,\n    \"default\": 0.5,\n    label: 'Irregularity' // Controls randomness in spacing, length, width\n  },\n  seed: {\n    type: 'number',\n    min: 1,\n    max: 10000,\n    \"default\": 123\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (OrganicSymbol);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/OrganicSymbol.js?");

/***/ }),

/***/ "./src/shapes/OverlappingSquares.js":
/*!******************************************!*\
  !*** ./src/shapes/OverlappingSquares.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates an icon of two overlapping rounded squares, one filled and one\n * outlined, often used for copy/paste actions.\n */\nvar OverlappingSquares = /*#__PURE__*/function (_Shape) {\n  function OverlappingSquares() {\n    _classCallCheck(this, OverlappingSquares);\n    return _callSuper(this, OverlappingSquares, arguments);\n  }\n  _inherits(OverlappingSquares, _Shape);\n  return _createClass(OverlappingSquares, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var size = this.size;\n      // Ensure corner radius isn't larger than half the size\n      var cornerRadius = Math.min(this.cornerRadius, size / 2);\n      var offsetX = this.offsetX;\n      var offsetY = this.offsetY;\n      var strokeWidth = this.strokeWidth;\n\n      // Calculate positions to keep the overall shape relatively centered\n      // Position of the back (outlined) square's top-left corner\n      var backX = -size / 2 - offsetX / 2;\n      var backY = -size / 2 - offsetY / 2;\n\n      // Position of the front (filled) square's top-left corner\n      var frontX = -size / 2 + offsetX / 2;\n      var frontY = -size / 2 + offsetY / 2;\n\n      // Use rx and ry for rounded corners\n      var rx = cornerRadius;\n      var ry = cornerRadius;\n\n      // Create the SVG for the back (outlined) square\n      var backSquare = \"<rect x=\\\"\".concat(backX.toFixed(3), \"\\\" y=\\\"\").concat(backY.toFixed(3), \"\\\" width=\\\"\").concat(size, \"\\\" height=\\\"\").concat(size, \"\\\" rx=\\\"\").concat(rx, \"\\\" ry=\\\"\").concat(ry, \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(strokeWidth, \"\\\" />\");\n\n      // Create the SVG for the front (filled) square\n      var frontSquare = \"<rect x=\\\"\".concat(frontX.toFixed(3), \"\\\" y=\\\"\").concat(frontY.toFixed(3), \"\\\" width=\\\"\").concat(size, \"\\\" height=\\\"\").concat(size, \"\\\" rx=\\\"\").concat(rx, \"\\\" ry=\\\"\").concat(ry, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\");\n\n      // Return the combined SVG string, drawing the back square first\n      return backSquare + frontSquare;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(OverlappingSquares, \"parameters\", {\n  size: {\n    type: 'number',\n    min: 20,\n    max: 150,\n    // Max size to keep within bounds with offset\n    step: 1,\n    \"default\": 80\n  },\n  cornerRadius: {\n    type: 'number',\n    min: 0,\n    max: 75,\n    // Max radius depends on size, ensure it's less than size/2\n    step: 1,\n    \"default\": 15\n  },\n  offsetX: {\n    type: 'number',\n    min: -50,\n    // Horizontal offset between squares\n    max: 50,\n    step: 1,\n    \"default\": 20 // Default offset to the right\n  },\n  offsetY: {\n    type: 'number',\n    min: -50,\n    // Vertical offset between squares\n    max: 50,\n    step: 1,\n    \"default\": 20 // Default offset downwards\n  },\n  strokeWidth: {\n    type: 'number',\n    min: 1,\n    max: 15,\n    step: 1,\n    \"default\": 4 // Stroke width for the outlined square\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (OverlappingSquares);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/OverlappingSquares.js?");

/***/ }),

/***/ "./src/shapes/ParallelStripesCircle.js":
/*!*********************************************!*\
  !*** ./src/shapes/ParallelStripesCircle.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a pattern of parallel horizontal stripes clipped within a circular\n * boundary.\n */\nvar ParallelStripesCircle = /*#__PURE__*/function (_Shape) {\n  function ParallelStripesCircle() {\n    _classCallCheck(this, ParallelStripesCircle);\n    return _callSuper(this, ParallelStripesCircle, arguments);\n  }\n  _inherits(ParallelStripesCircle, _Shape);\n  return _createClass(ParallelStripesCircle, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Calculate dimensions\n      var diameter = this.radius * 2;\n\n      // Calculate total height of stripes and gaps\n      var totalStripeHeight = this.lineCount * this.thickness;\n      var totalSpacing = (this.lineCount - 1) * this.spacing;\n      var totalHeight = totalStripeHeight + totalSpacing;\n\n      // Calculate starting Y position based on alignment\n      var startY;\n      switch (this.alignment) {\n        case 'top':\n          startY = -this.radius;\n          break;\n        case 'bottom':\n          startY = -this.radius + (diameter - totalHeight);\n          break;\n        default:\n          // center\n          startY = -totalHeight / 2;\n          break;\n      }\n\n      // Create unique mask ID\n      var maskId = \"stripesMask_\".concat(Math.random().toString(36).substr(2, 9));\n\n      // Generate stripes with uniform spacing\n      var stripes = [];\n      var currentY = startY;\n      for (var i = 0; i < this.lineCount; i++) {\n        stripes.push(\"<rect \\n                x=\\\"\".concat(-this.radius - 1, \"\\\" \\n                y=\\\"\").concat(currentY, \"\\\" \\n                width=\\\"\").concat((this.radius + 1) * 2, \"\\\" \\n                height=\\\"\").concat(this.thickness, \"\\\" \\n                fill=\\\"black\\\" \\n            />\"));\n        currentY += this.thickness + this.spacing;\n      }\n      return \"\\n            <defs>\\n                <clipPath id=\\\"\".concat(maskId, \"\\\">\\n                    <circle cx=\\\"0\\\" cy=\\\"0\\\" r=\\\"\").concat(this.radius, \"\\\"/>\\n                </clipPath>\\n            </defs>\\n            <g clip-path=\\\"url(#\").concat(maskId, \")\\\">\\n                <circle cx=\\\"0\\\" cy=\\\"0\\\" r=\\\"\").concat(this.radius, \"\\\" fill=\\\"white\\\" />\\n                \").concat(stripes.join('\\n'), \"\\n            </g>\\n        \");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(ParallelStripesCircle, \"parameters\", {\n  lineCount: {\n    min: 3,\n    max: 20,\n    \"default\": 8\n  },\n  thickness: {\n    min: 1,\n    max: 20,\n    \"default\": 9\n  },\n  radius: {\n    min: 50,\n    max: 100,\n    \"default\": 90\n  },\n  spacing: {\n    min: 1,\n    max: 50,\n    \"default\": 20\n  },\n  alignment: {\n    options: ['center', 'top', 'bottom'],\n    \"default\": 'center'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ParallelStripesCircle);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/ParallelStripesCircle.js?");

/***/ }),

/***/ "./src/shapes/ParametricKnot.js":
/*!**************************************!*\
  !*** ./src/shapes/ParametricKnot.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates continuous line shapes resembling knots or scribbles using\n * parametric equations based on superimposed circular motions.\n */\nvar ParametricKnot = /*#__PURE__*/function (_Shape) {\n  function ParametricKnot() {\n    _classCallCheck(this, ParametricKnot);\n    return _callSuper(this, ParametricKnot, arguments);\n  }\n  _inherits(ParametricKnot, _Shape);\n  return _createClass(ParametricKnot, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var points = [];\n      // Calculate the maximum value for the parameter t and the step increment\n      var tMax = this.numCycles * 2 * Math.PI;\n      var dt = tMax / this.numPoints;\n      var maxX = 0,\n        maxY = 0; // Track maximum absolute coordinates for dynamic scaling\n\n      // Generate points based on the parametric equation\n      for (var i = 0; i <= this.numPoints; i++) {\n        var t = i * dt;\n\n        // Calculate angles for the primary and secondary circular motions\n        var angle1 = this.primaryFreq * t;\n        var angle2 = this.secondaryFreq * t + this.phaseShift;\n\n        // Calculate x and y coordinates by summing the two components\n        // x(t) = R1*cos(f1*t) + R2*cos(f2*t + phase)\n        // y(t) = R1*sin(f1*t) + R2*sin(f2*t + phase)\n        var x = this.primaryRadius * Math.cos(angle1) + this.secondaryRadius * Math.cos(angle2);\n        var y = this.primaryRadius * Math.sin(angle1) + this.secondaryRadius * Math.sin(angle2);\n        points.push({\n          x: x,\n          y: y\n        });\n\n        // Update maximum absolute coordinates found so far\n        maxX = Math.max(maxX, Math.abs(x));\n        maxY = Math.max(maxY, Math.abs(y));\n      }\n\n      // Determine the maximum dimension reached by the shape (max of |x| or |y|)\n      var maxDim = Math.max(maxX, maxY);\n\n      // Calculate scaling factor to fit the shape within the [-99, 99] range, leaving a small margin\n      // If the shape is already within bounds, scale remains 1.0\n      var scale = 1.0;\n      if (maxDim > 99) {\n        scale = 99 / maxDim;\n      }\n\n      // Apply scaling to all points and format them as strings \"x,y\" for the polyline attribute\n      var pointStrings = points.map(function (p) {\n        var scaledX = (p.x * scale).toFixed(2);\n        var scaledY = (p.y * scale).toFixed(2);\n        return \"\".concat(scaledX, \",\").concat(scaledY);\n      });\n\n      // Return the SVG polyline element string with calculated points and styling\n      // fill=\"none\" and stroke=\"white\" are used as per requirements for open line shapes\n      return \"<polyline points=\\\"\".concat(pointStrings.join(' '), \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(this.strokeWidth, \"\\\" />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(ParametricKnot, \"parameters\", {\n  primaryFreq: {\n    type: 'number',\n    min: 0.1,\n    max: 15,\n    step: 0.1,\n    \"default\": 3\n  },\n  // Frequency of the main underlying pattern (e.g., number of lobes)\n  secondaryFreq: {\n    type: 'number',\n    min: 0.1,\n    max: 30,\n    step: 0.1,\n    \"default\": 8\n  },\n  // Frequency of the secondary modulation (adds loops/wobbles)\n  primaryRadius: {\n    type: 'number',\n    min: 10,\n    max: 70,\n    // Max radius for the main component\n    step: 1,\n    \"default\": 50\n  },\n  secondaryRadius: {\n    type: 'number',\n    min: 0,\n    max: 45,\n    // Max radius for the secondary component (Combined max radius affects scaling)\n    step: 1,\n    \"default\": 25\n  },\n  phaseShift: {\n    type: 'number',\n    min: 0,\n    max: Math.PI * 2,\n    // Controls the phase alignment between the two frequency components\n    step: 0.05,\n    \"default\": 1.57 // Default: PI / 2\n  },\n  numCycles: {\n    type: 'number',\n    min: 1,\n    max: 20,\n    // Determines the length of the curve (parameter t ranges from 0 to numCycles * 2 * PI)\n    step: 1,\n    \"default\": 1\n  },\n  numPoints: {\n    type: 'number',\n    min: 100,\n    max: 1000,\n    // Number of points calculated to define the curve's smoothness\n    step: 10,\n    \"default\": 400\n  },\n  strokeWidth: {\n    type: 'number',\n    min: 0.5,\n    max: 5,\n    // Thickness of the line\n    step: 0.1,\n    \"default\": 1\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ParametricKnot);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/ParametricKnot.js?");

/***/ }),

/***/ "./src/shapes/PedestalShape.js":
/*!*************************************!*\
  !*** ./src/shapes/PedestalShape.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a pedestal shape composed of a wider base rectangle topped by a\n * narrower column rectangle, with optional rounding.\n */\nvar PedestalShape = /*#__PURE__*/function (_Shape) {\n  function PedestalShape() {\n    _classCallCheck(this, PedestalShape);\n    return _callSuper(this, PedestalShape, arguments);\n  }\n  _inherits(PedestalShape, _Shape);\n  return _createClass(PedestalShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Calculate center and scale based on viewBox\n      var center = {\n        x: 0,\n        y: 0\n      };\n      var scale = 0.8;\n\n      // Scale parameters\n      var baseWidth = this.baseWidth * scale;\n      var columnWidth = this.columnWidth * scale;\n      var columnHeight = this.columnHeight * scale;\n      var baseHeight = this.baseHeight * scale;\n      var requestedCornerRadius = this.cornerRadius * scale;\n\n      // Calculate positions\n      var baseLeft = center.x - baseWidth / 2;\n      var baseRight = center.x + baseWidth / 2;\n      var columnLeft = center.x - columnWidth / 2;\n      var columnRight = center.x + columnWidth / 2;\n      var baseBottom = center.y + (columnHeight + baseHeight) / 2;\n      var baseTop = baseBottom - baseHeight;\n      var columnTop = baseTop - columnHeight;\n\n      // Calculate safe corner radius values (can't exceed half of width or height)\n      var baseCornerRadius = Math.min(requestedCornerRadius, baseWidth / 2, baseHeight / 2);\n      var columnCornerRadius = Math.min(requestedCornerRadius, columnWidth / 2, columnHeight / 2);\n\n      // Prepare the path for both shapes\n      var basePath, columnPath;\n      if (baseCornerRadius > 0) {\n        // Rounded base rectangle\n        basePath = \"\\n                M \".concat(baseLeft + baseCornerRadius, \" \").concat(baseTop, \"\\n                h \").concat(baseWidth - 2 * baseCornerRadius, \"\\n                a \").concat(baseCornerRadius, \" \").concat(baseCornerRadius, \" 0 0 1 \").concat(baseCornerRadius, \" \").concat(baseCornerRadius, \"\\n                v \").concat(baseHeight - 2 * baseCornerRadius, \"\\n                a \").concat(baseCornerRadius, \" \").concat(baseCornerRadius, \" 0 0 1 -\").concat(baseCornerRadius, \" \").concat(baseCornerRadius, \"\\n                h -\").concat(baseWidth - 2 * baseCornerRadius, \"\\n                a \").concat(baseCornerRadius, \" \").concat(baseCornerRadius, \" 0 0 1 -\").concat(baseCornerRadius, \" -\").concat(baseCornerRadius, \"\\n                v -\").concat(baseHeight - 2 * baseCornerRadius, \"\\n                a \").concat(baseCornerRadius, \" \").concat(baseCornerRadius, \" 0 0 1 \").concat(baseCornerRadius, \" -\").concat(baseCornerRadius, \"\\n                Z\\n            \");\n      } else {\n        // Non-rounded base rectangle\n        basePath = \"\\n                M \".concat(baseLeft, \" \").concat(baseTop, \"\\n                h \").concat(baseWidth, \"\\n                v \").concat(baseHeight, \"\\n                h -\").concat(baseWidth, \"\\n                v -\").concat(baseHeight, \"\\n                Z\\n            \");\n      }\n      if (columnCornerRadius > 0) {\n        // Rounded column rectangle\n        columnPath = \"\\n                M \".concat(columnLeft + columnCornerRadius, \" \").concat(columnTop, \"\\n                h \").concat(columnWidth - 2 * columnCornerRadius, \"\\n                a \").concat(columnCornerRadius, \" \").concat(columnCornerRadius, \" 0 0 1 \").concat(columnCornerRadius, \" \").concat(columnCornerRadius, \"\\n                v \").concat(columnHeight - 2 * columnCornerRadius, \"\\n                a \").concat(columnCornerRadius, \" \").concat(columnCornerRadius, \" 0 0 1 -\").concat(columnCornerRadius, \" \").concat(columnCornerRadius, \"\\n                h -\").concat(columnWidth - 2 * columnCornerRadius, \"\\n                a \").concat(columnCornerRadius, \" \").concat(columnCornerRadius, \" 0 0 1 -\").concat(columnCornerRadius, \" -\").concat(columnCornerRadius, \"\\n                v -\").concat(columnHeight - 2 * columnCornerRadius, \"\\n                a \").concat(columnCornerRadius, \" \").concat(columnCornerRadius, \" 0 0 1 \").concat(columnCornerRadius, \" -\").concat(columnCornerRadius, \"\\n                Z\\n            \");\n      } else {\n        // Non-rounded column rectangle\n        columnPath = \"\\n                M \".concat(columnLeft, \" \").concat(columnTop, \"\\n                h \").concat(columnWidth, \"\\n                v \").concat(columnHeight, \"\\n                h -\").concat(columnWidth, \"\\n                v -\").concat(columnHeight, \"\\n                Z\\n            \");\n      }\n\n      // Combine both paths into a single path element\n      return \"<path d=\\\"\".concat(basePath.trim(), \" \").concat(columnPath.trim(), \"\\\" fill=\\\"white\\\"/>\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(PedestalShape, \"parameters\", {\n  baseWidth: {\n    min: 100,\n    max: 200,\n    \"default\": 200\n  },\n  columnWidth: {\n    min: 20,\n    max: 150,\n    \"default\": 80\n  },\n  columnHeight: {\n    min: 50,\n    max: 150,\n    \"default\": 120\n  },\n  baseHeight: {\n    min: 20,\n    max: 100,\n    \"default\": 60\n  },\n  cornerRadius: {\n    min: 0,\n    max: 40,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PedestalShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/PedestalShape.js?");

/***/ }),

/***/ "./src/shapes/PencilBurst.js":
/*!***********************************!*\
  !*** ./src/shapes/PencilBurst.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a radial burst of pencil-like shapes pointing inwards, with\n * alternating lengths.\n */\nvar PencilBurst = /*#__PURE__*/function (_Shape) {\n  function PencilBurst() {\n    _classCallCheck(this, PencilBurst);\n    return _callSuper(this, PencilBurst, arguments);\n  }\n  _inherits(PencilBurst, _Shape);\n  return _createClass(PencilBurst, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      var pencils = [];\n      var angleStep = 2 * Math.PI / this.numPencils;\n      var halfWidth = this.pencilWidth / 2;\n      var _loop = function _loop() {\n        var angle = i * angleStep; // Angle for rotation\n\n        // Determine the outer radius for this pencil (alternating)\n        var currentOuterRadius = i % 2 === 0 ? _this.outerRadius1 : _this.outerRadius2;\n\n        // Ensure outer radius is always greater than inner radius + minimum length\n        var minLength = 10; // Minimum length for a pencil to be visible\n        var safeOuterRadius = Math.max(currentOuterRadius, _this.innerRadius + minLength);\n        var totalLength = safeOuterRadius - _this.innerRadius;\n\n        // Check for problematic radius settings (should be caught by Math.max, but good practice)\n        if (totalLength < minLength / 2) {\n          // Use a small threshold instead of <= 0\n          console.warn(\"PencilBurst: Calculated totalLength for pencil \".concat(i, \" is too small. Check radii.\"));\n          return 1; // continue\n          // Skip this pencil if radii are too close or inverted\n        }\n        var tipLength = totalLength * _this.tipRatio;\n        // Clamp tipLength to be at least a tiny positive value if totalLength is very small\n        var safeTipLength = Math.max(0.1, tipLength);\n        var bodyStartRadius = _this.innerRadius + safeTipLength; // Distance from center to base of the triangular tip\n\n        // Define points for a single pencil shape pointing straight up (along negative Y axis)\n        // Ensure bodyStartRadius doesn't exceed safeOuterRadius\n        var safeBodyStartRadius = Math.min(bodyStartRadius, safeOuterRadius - 0.1); // Ensure tip base is inside the outer radius\n\n        var p1 = {\n          x: 0,\n          y: -_this.innerRadius\n        }; // Tip point\n        var p2 = {\n          x: -halfWidth,\n          y: -safeBodyStartRadius\n        }; // Left base of tip\n        var p3 = {\n          x: -halfWidth,\n          y: -safeOuterRadius\n        }; // Left end of body\n        var p4 = {\n          x: halfWidth,\n          y: -safeOuterRadius\n        }; // Right end of body\n        var p5 = {\n          x: halfWidth,\n          y: -safeBodyStartRadius\n        }; // Right base of tip\n\n        // Rotate each point around the origin (0,0) by the calculated angle\n        var rotatedPoints = [p1, p2, p3, p4, p5].map(function (p) {\n          return _this.rotatePoint(p.x, p.y, angle);\n        });\n\n        // Format points for SVG polygon string\n        var pointsString = rotatedPoints.map(function (p) {\n          return \"\".concat(p.x.toFixed(2), \",\").concat(p.y.toFixed(2));\n        }).join(' ');\n\n        // Create the SVG polygon element string\n        // Polygons are closed shapes, use fill=\"white\" as per instructions.\n        pencils.push(\"<polygon points=\\\"\".concat(pointsString, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\"));\n      };\n      for (var i = 0; i < this.numPencils; i++) {\n        if (_loop()) continue;\n      }\n\n      // Combine pencil polygons into the final SVG string\n      return pencils.join('\\n            ');\n    }\n\n    /**\n     * Helper function to rotate a point (x, y) around the origin (0, 0) by a given angle in radians.\n     * @param {number} x - The x-coordinate of the point.\n     * @param {number} y - The y-coordinate of the point.\n     * @param {number} angle - The angle of rotation in radians.\n     * @returns {{x: number, y: number}} The coordinates of the rotated point.\n     */\n  }, {\n    key: \"rotatePoint\",\n    value: function rotatePoint(x, y, angle) {\n      var cosA = Math.cos(angle);\n      var sinA = Math.sin(angle);\n      // Standard 2D rotation formula\n      var xPrime = x * cosA - y * sinA;\n      var yPrime = x * sinA + y * cosA;\n      return {\n        x: xPrime,\n        y: yPrime\n      };\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(PencilBurst, \"parameters\", {\n  numPencils: {\n    type: 'number',\n    min: 4,\n    // Min 4 to show alternating pattern clearly\n    max: 36,\n    step: 1,\n    \"default\": 12,\n    label: 'Number of Pencils'\n  },\n  innerRadius: {\n    type: 'number',\n    min: 5,\n    max: 60,\n    step: 1,\n    \"default\": 25,\n    label: 'Inner Radius (Tip Position)'\n  },\n  outerRadius1: {\n    // Length for even-indexed pencils\n    type: 'number',\n    min: 30,\n    max: 98,\n    step: 1,\n    \"default\": 80,\n    label: 'Outer Radius 1'\n  },\n  outerRadius2: {\n    // Length for odd-indexed pencils\n    type: 'number',\n    min: 30,\n    max: 98,\n    step: 1,\n    \"default\": 60,\n    label: 'Outer Radius 2'\n  },\n  pencilWidth: {\n    type: 'number',\n    min: 2,\n    max: 40,\n    step: 1,\n    \"default\": 12,\n    label: 'Pencil Width'\n  },\n  tipRatio: {\n    // Proportion of the length dedicated to the tip\n    type: 'number',\n    min: 0.1,\n    max: 0.9,\n    step: 0.05,\n    \"default\": 0.4,\n    label: 'Tip Length Ratio'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PencilBurst);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/PencilBurst.js?");

/***/ }),

/***/ "./src/shapes/PerspectiveBars.js":
/*!***************************************!*\
  !*** ./src/shapes/PerspectiveBars.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a stack of horizontal bars with a simulated perspective effect,\n * making one vertical edge appear smaller and closer together than the other.\n*/\nvar PerspectiveBars = /*#__PURE__*/function (_Shape) {\n  function PerspectiveBars() {\n    _classCallCheck(this, PerspectiveBars);\n    return _callSuper(this, PerspectiveBars, arguments);\n  }\n  _inherits(PerspectiveBars, _Shape);\n  return _createClass(PerspectiveBars, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var numBars = Math.max(1, this.numBars); // Ensure at least one bar\n      var barHeight = this.barHeight;\n      var barWidth = this.barWidth;\n      // perspectiveFactor determines how much smaller the left side is compared to the right\n      // perspectiveScale = 1.0 - perspectiveFactor. Scale=1 means no perspective, Scale=0 means full convergence.\n      var perspectiveScale = 1.0 - this.perspectiveFactor;\n      var verticalSpacing = this.verticalSpacing;\n      var cornerRadius = this.cornerRadius;\n      var paths = [];\n      var x_right = barWidth / 2;\n      var x_left = -barWidth / 2;\n\n      // --- Calculate geometry based on parameters ---\n\n      // Calculate heights and spacing at the right (front) and left (back) edges\n      var heightRight = barHeight;\n      var spacingRight = verticalSpacing;\n      var heightLeft = barHeight * perspectiveScale;\n      var spacingLeft = verticalSpacing * perspectiveScale;\n\n      // Calculate total height span at the right edge to center vertically\n      var totalHeightRight = numBars * heightRight + Math.max(0, numBars - 1) * spacingRight;\n      // Calculate the Y coordinate of the top edge of the *first* bar at the right\n      var yTopRight_0 = -totalHeightRight / 2;\n\n      // Calculate total height span at the left edge\n      var totalHeightLeft = numBars * heightLeft + Math.max(0, numBars - 1) * spacingLeft;\n      // Calculate the Y coordinate of the top edge of the *first* bar at the left\n      var yTopLeft_0 = -totalHeightLeft / 2;\n\n      // --- Generate path for each bar ---\n      for (var i = 0; i < numBars; i++) {\n        // Calculate Y coordinates for the current bar at the right edge\n        var yTopRight_i = yTopRight_0 + i * (heightRight + spacingRight);\n        var yBottomRight_i = yTopRight_i + heightRight;\n\n        // Calculate Y coordinates for the current bar at the left edge\n        var yTopLeft_i = yTopLeft_0 + i * (heightLeft + spacingLeft);\n        var yBottomLeft_i = yTopLeft_i + heightLeft;\n\n        // Clamp corner radius based on the dimensions of this specific bar\n        // Use Math.max(0.01, ...) to prevent issues with zero radius in arc commands if cornerRadius > 0\n        var currentHeightLeft = Math.abs(yBottomLeft_i - yTopLeft_i);\n        var currentHeightRight = Math.abs(yBottomRight_i - yTopRight_i);\n\n        // Calculate maximum possible radius based on geometry\n        var maxRadiusLeft = Math.min(barWidth / 2, currentHeightLeft / 2);\n        var maxRadiusRight = Math.min(barWidth / 2, currentHeightRight / 2);\n\n        // Effective radii, scaled by perspective, and clamped\n        var r_eff_left = cornerRadius * perspectiveScale;\n        var r_eff_right = cornerRadius;\n\n        // Clamp radii to maximum possible values\n        r_eff_left = Math.max(0, Math.min(r_eff_left, maxRadiusLeft));\n        r_eff_right = Math.max(0, Math.min(r_eff_right, maxRadiusRight));\n\n        // Helper to format numbers for SVG path data\n        var format = function format(num) {\n          return parseFloat(num.toFixed(3));\n        };\n        var pathData = void 0;\n\n        // Use sharp corners if effective radius is negligible\n        if (r_eff_left < 0.01 && r_eff_right < 0.01) {\n          pathData = \"\\n                    M \".concat(format(x_left), \", \").concat(format(yTopLeft_i), \"\\n                    L \").concat(format(x_right), \", \").concat(format(yTopRight_i), \"\\n                    L \").concat(format(x_right), \", \").concat(format(yBottomRight_i), \"\\n                    L \").concat(format(x_left), \", \").concat(format(yBottomLeft_i), \"\\n                    Z\");\n        } else {\n          // Build the path string with arcs for rounded corners\n          // This uses circular arcs (A command), which is an approximation for true perspective rounding,\n          // but provides the desired visual effect.\n          pathData = \"\\n                    M \".concat(format(x_left + r_eff_left), \", \").concat(format(yTopLeft_i), \"\\n                    L \").concat(format(x_right - r_eff_right), \", \").concat(format(yTopRight_i), \"\\n                    A \").concat(format(r_eff_right), \",\").concat(format(r_eff_right), \" 0 0 1 \").concat(format(x_right), \", \").concat(format(yTopRight_i + r_eff_right), \"\\n                    L \").concat(format(x_right), \", \").concat(format(yBottomRight_i - r_eff_right), \"\\n                    A \").concat(format(r_eff_right), \",\").concat(format(r_eff_right), \" 0 0 1 \").concat(format(x_right - r_eff_right), \", \").concat(format(yBottomRight_i), \"\\n                    L \").concat(format(x_left + r_eff_left), \", \").concat(format(yBottomLeft_i), \"\\n                    A \").concat(format(r_eff_left), \",\").concat(format(r_eff_left), \" 0 0 1 \").concat(format(x_left), \", \").concat(format(yBottomLeft_i - r_eff_left), \"\\n                    L \").concat(format(x_left), \", \").concat(format(yTopLeft_i + r_eff_left), \"\\n                    A \").concat(format(r_eff_left), \",\").concat(format(r_eff_left), \" 0 0 1 \").concat(format(x_left + r_eff_left), \", \").concat(format(yTopLeft_i), \"\\n                    Z\");\n        }\n        paths.push(\"<path d=\\\"\".concat(pathData.replace(/\\s+/g, ' ').trim(), \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\"));\n      }\n      return paths.join('\\n');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(PerspectiveBars, \"parameters\", {\n  numBars: {\n    type: 'number',\n    label: 'Number of Bars',\n    min: 1,\n    max: 10,\n    step: 1,\n    \"default\": 4\n  },\n  barHeight: {\n    type: 'number',\n    label: 'Front Bar Height',\n    min: 5,\n    max: 50,\n    step: 1,\n    \"default\": 25\n  },\n  barWidth: {\n    type: 'number',\n    label: 'Bar Width',\n    min: 20,\n    max: 180,\n    // Keep within viewBox horizontal bounds roughly\n    step: 1,\n    \"default\": 120\n  },\n  perspectiveFactor: {\n    type: 'number',\n    label: 'Perspective',\n    // Higher means left side smaller\n    min: 0.05,\n    // Avoid 0 (left side vanishes)\n    max: 0.95,\n    // Avoid 1 (no perspective)\n    step: 0.05,\n    \"default\": 0.6\n  },\n  verticalSpacing: {\n    type: 'number',\n    label: 'Front Vertical Spacing',\n    min: 0,\n    max: 40,\n    step: 1,\n    \"default\": 10\n  },\n  cornerRadius: {\n    type: 'number',\n    label: 'Corner Radius',\n    min: 0,\n    max: 20,\n    // Max radius limited by bar height/width later\n    step: 1,\n    \"default\": 5\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PerspectiveBars);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/PerspectiveBars.js?");

/***/ }),

/***/ "./src/shapes/PerspectiveCubeShape.js":
/*!********************************************!*\
  !*** ./src/shapes/PerspectiveCubeShape.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape.js */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a 3D wireframe representation of a cube with simple perspective\n * projection.\n */\nvar PerspectiveCubeShape = /*#__PURE__*/function (_Shape) {\n  function PerspectiveCubeShape() {\n    _classCallCheck(this, PerspectiveCubeShape);\n    return _callSuper(this, PerspectiveCubeShape, arguments);\n  }\n  _inherits(PerspectiveCubeShape, _Shape);\n  return _createClass(PerspectiveCubeShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var size = this.size;\n      var perspective = this.perspective;\n      var rotation = this.rotation * Math.PI / 180;\n      var stroke = this.lineThickness;\n\n      // Calculate front face points\n      var frontX = size * Math.cos(rotation);\n      var frontY = size * Math.sin(rotation);\n\n      // Front face corners\n      var frontTL = [-frontX, -frontY];\n      var frontTR = [frontX, -frontY];\n      var frontBL = [-frontX, frontY];\n      var frontBR = [frontX, frontY];\n\n      // Back face is scaled by perspective and offset\n      var backX = frontX * perspective;\n      var backY = frontY * perspective;\n      var backOffset = size * (1 - perspective) * 0.8;\n\n      // Back face corners\n      var backTL = [-backX - backOffset, -backY - backOffset];\n      var backTR = [backX - backOffset, -backY - backOffset];\n      var backBL = [-backX - backOffset, backY - backOffset];\n      var backBR = [backX - backOffset, backY - backOffset];\n\n      // Create the SVG path elements\n      var elements = [// Front face\n      \"<polygon points=\\\"\".concat(frontTL[0], \",\").concat(frontTL[1], \" \").concat(frontTR[0], \",\").concat(frontTR[1], \" \").concat(frontBR[0], \",\").concat(frontBR[1], \" \").concat(frontBL[0], \",\").concat(frontBL[1], \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(stroke, \"\\\"/>\"), // Back face\n      \"<polygon points=\\\"\".concat(backTL[0], \",\").concat(backTL[1], \" \").concat(backTR[0], \",\").concat(backTR[1], \" \").concat(backBR[0], \",\").concat(backBR[1], \" \").concat(backBL[0], \",\").concat(backBL[1], \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(stroke, \"\\\"/>\"), // Connecting lines\n      \"<line x1=\\\"\".concat(frontTL[0], \"\\\" y1=\\\"\").concat(frontTL[1], \"\\\" x2=\\\"\").concat(backTL[0], \"\\\" y2=\\\"\").concat(backTL[1], \"\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(stroke, \"\\\"/>\"), \"<line x1=\\\"\".concat(frontTR[0], \"\\\" y1=\\\"\").concat(frontTR[1], \"\\\" x2=\\\"\").concat(backTR[0], \"\\\" y2=\\\"\").concat(backTR[1], \"\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(stroke, \"\\\"/>\"), \"<line x1=\\\"\".concat(frontBL[0], \"\\\" y1=\\\"\").concat(frontBL[1], \"\\\" x2=\\\"\").concat(backBL[0], \"\\\" y2=\\\"\").concat(backBL[1], \"\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(stroke, \"\\\"/>\"), \"<line x1=\\\"\".concat(frontBR[0], \"\\\" y1=\\\"\").concat(frontBR[1], \"\\\" x2=\\\"\").concat(backBR[0], \"\\\" y2=\\\"\").concat(backBR[1], \"\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(stroke, \"\\\"/>\")];\n      return elements.join('');\n    }\n  }]);\n}(_Shape_js__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(PerspectiveCubeShape, \"parameters\", {\n  size: {\n    min: 20,\n    max: 100,\n    \"default\": 60\n  },\n  perspective: {\n    min: 0.1,\n    max: 1.0,\n    \"default\": 0.6\n  },\n  rotation: {\n    min: 0,\n    max: 360,\n    \"default\": 30\n  },\n  lineThickness: {\n    min: 1,\n    max: 5,\n    \"default\": 2\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PerspectiveCubeShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/PerspectiveCubeShape.js?");

/***/ }),

/***/ "./src/shapes/PerspectiveGrid.js":
/*!***************************************!*\
  !*** ./src/shapes/PerspectiveGrid.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a retro wireframe perspective grid within a rounded rectangle frame.\n * Creates a tunnel effect converging towards the center.\n */\nvar PerspectiveGrid = /*#__PURE__*/function (_Shape) {\n  function PerspectiveGrid() {\n    _classCallCheck(this, PerspectiveGrid);\n    return _callSuper(this, PerspectiveGrid, arguments);\n  }\n  _inherits(PerspectiveGrid, _Shape);\n  return _createClass(PerspectiveGrid, [{\n    key: \"lerp\",\n    value:\n    // Linear interpolation helper\n    function lerp(a, b, t) {\n      return a + (b - a) * t;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var w = this.width;\n      var h = this.height;\n      var cr = Math.min(this.cornerRadius, w / 2, h / 2); // Clamp corner radius\n      var vDiv = this.verticalDivisions;\n      var hDiv = this.horizontalDivisions;\n      var pFactor = this.perspectiveFactor;\n      var sw = this.strokeWidth;\n      var w_near = w / 2;\n      var h_near = h / 2;\n      var w_far = w_near * pFactor;\n      var h_far = h_near * pFactor;\n      var pathData = '';\n\n      // 1. Frame (Rounded Rectangle)\n      // Move to top-left corner start\n      pathData += \"M \".concat((-w_near + cr).toFixed(3), \",\").concat((-h_near).toFixed(3), \" \");\n      // Line to top-right corner start\n      pathData += \"L \".concat((w_near - cr).toFixed(3), \",\").concat((-h_near).toFixed(3), \" \");\n      // Arc to top-right vertical line start\n      pathData += \"A \".concat(cr.toFixed(3), \",\").concat(cr.toFixed(3), \" 0 0 1 \").concat(w_near.toFixed(3), \",\").concat((-h_near + cr).toFixed(3), \" \");\n      // Line to bottom-right corner start\n      pathData += \"L \".concat(w_near.toFixed(3), \",\").concat((h_near - cr).toFixed(3), \" \");\n      // Arc to bottom-right horizontal line start\n      pathData += \"A \".concat(cr.toFixed(3), \",\").concat(cr.toFixed(3), \" 0 0 1 \").concat((w_near - cr).toFixed(3), \",\").concat(h_near.toFixed(3), \" \");\n      // Line to bottom-left corner start\n      pathData += \"L \".concat((-w_near + cr).toFixed(3), \",\").concat(h_near.toFixed(3), \" \");\n      // Arc to bottom-left vertical line start\n      pathData += \"A \".concat(cr.toFixed(3), \",\").concat(cr.toFixed(3), \" 0 0 1 \").concat((-w_near).toFixed(3), \",\").concat((h_near - cr).toFixed(3), \" \");\n      // Line to top-left corner start arc\n      pathData += \"L \".concat((-w_near).toFixed(3), \",\").concat((-h_near + cr).toFixed(3), \" \");\n      // Arc back to starting point M\n      pathData += \"A \".concat(cr.toFixed(3), \",\").concat(cr.toFixed(3), \" 0 0 1 \").concat((-w_near + cr).toFixed(3), \",\").concat((-h_near).toFixed(3), \" \");\n      // Don't close path 'Z' here if adding more lines to the same path element\n\n      // 2. Vertical Perspective Lines\n      for (var i = 0; i <= vDiv; i++) {\n        var x_ratio = i / vDiv * 2 - 1; // Map i from 0..vDiv to -1..1\n\n        var xn_t = (x_ratio * w_near).toFixed(3);\n        var yn_t = (-h_near).toFixed(3);\n        var xf_t = (x_ratio * w_far).toFixed(3);\n        var yf_t = (-h_far).toFixed(3);\n        var xn_b = xn_t; // Same x as top\n        var yn_b = h_near.toFixed(3);\n        var xf_b = xf_t; // Same x as top far\n        var yf_b = h_far.toFixed(3);\n\n        // Draw top converging line segment\n        pathData += \" M \".concat(xn_t, \",\").concat(yn_t, \" L \").concat(xf_t, \",\").concat(yf_t, \" \");\n        // Draw bottom converging line segment\n        pathData += \" M \".concat(xn_b, \",\").concat(yn_b, \" L \").concat(xf_b, \",\").concat(yf_b, \" \");\n      }\n\n      // 3. Horizontal Perspective Lines\n      for (var j = 0; j <= hDiv; j++) {\n        var t = j / hDiv; // Interpolation factor 0..1\n\n        var hj = this.lerp(h_near, h_far, t);\n        var wj = this.lerp(w_near, w_far, t);\n        var x1 = (-wj).toFixed(3);\n        var x2 = wj.toFixed(3);\n        var y_top = (-hj).toFixed(3);\n        var y_bottom = hj.toFixed(3);\n\n        // Draw top horizontal line segment\n        pathData += \" M \".concat(x1, \",\").concat(y_top, \" L \").concat(x2, \",\").concat(y_top, \" \");\n        // Draw bottom horizontal line segment\n        pathData += \" M \".concat(x1, \",\").concat(y_bottom, \" L \").concat(x2, \",\").concat(y_bottom, \" \");\n      }\n      return \"<path d=\\\"\".concat(pathData, \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(sw, \"\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\" />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(PerspectiveGrid, \"parameters\", {\n  width: {\n    type: 'number',\n    min: 20,\n    max: 190,\n    step: 1,\n    \"default\": 160\n  },\n  height: {\n    type: 'number',\n    min: 20,\n    max: 190,\n    step: 1,\n    \"default\": 100\n  },\n  cornerRadius: {\n    type: 'number',\n    min: 0,\n    max: 50,\n    // Max half of default height\n    step: 1,\n    \"default\": 10\n  },\n  verticalDivisions: {\n    type: 'number',\n    min: 2,\n    max: 20,\n    step: 2,\n    // Keep it even for symmetry\n    \"default\": 8 // Number of segments along top/bottom edges\n  },\n  horizontalDivisions: {\n    type: 'number',\n    min: 1,\n    max: 20,\n    step: 1,\n    \"default\": 6 // Number of segments along the depth\n  },\n  perspectiveFactor: {\n    type: 'number',\n    min: 0.01,\n    max: 0.99,\n    step: 0.01,\n    \"default\": 0.1 // Ratio of far plane size to near plane size\n  },\n  strokeWidth: {\n    type: 'number',\n    min: 0.5,\n    max: 5,\n    step: 0.5,\n    \"default\": 1\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PerspectiveGrid);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/PerspectiveGrid.js?");

/***/ }),

/***/ "./src/shapes/PerspectiveGridShape.js":
/*!********************************************!*\
  !*** ./src/shapes/PerspectiveGridShape.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a 3D grid of outlined boxes or triangles with adjustable\n * perspective and rotation.\n */\nvar PerspectiveGridShape = /*#__PURE__*/function (_Shape) {\n  function PerspectiveGridShape() {\n    _classCallCheck(this, PerspectiveGridShape);\n    return _callSuper(this, PerspectiveGridShape, arguments);\n  }\n  _inherits(PerspectiveGridShape, _Shape);\n  return _createClass(PerspectiveGridShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var elements = [];\n\n      // Size parameters\n      var width = this.size;\n      var height = this.size;\n      var depth = this.depth;\n\n      // Convert rotation angles to radians\n      var rotX = this.rotationX * Math.PI / 180;\n      var rotY = this.rotationY * Math.PI / 180;\n\n      // Center offset for positioning\n      var halfWidth = width / 2;\n      var halfHeight = height / 2;\n\n      // Calculate actual cell dimensions\n      var cellWidth = (width - (this.columns + 1) * this.spacing) / this.columns;\n      var cellHeight = (height - (this.rows + 1) * this.spacing) / this.rows;\n\n      // Create all cells with 3D coordinates\n      var shapes = [];\n\n      // Create grid cells - proper 3D boxes\n      for (var row = 0; row < this.rows; row++) {\n        for (var col = 0; col < this.columns; col++) {\n          // Calculate position in grid (normalized from -1 to 1)\n          var normalizedCol = col / (this.columns - 1) * 2 - 1;\n          var normalizedRow = row / (this.rows - 1) * 2 - 1;\n\n          // Calculate top-left corner position\n          var x = -halfWidth + this.spacing + col * (cellWidth + this.spacing);\n          var y = -halfHeight + this.spacing + row * (cellHeight + this.spacing);\n\n          // Calculate z-depth based on distance from center\n          // This creates a curved surface effect for better perspective\n          var distanceFromCenter = Math.sqrt(normalizedCol * normalizedCol + normalizedRow * normalizedRow);\n          var cellDepth = depth * Math.min(distanceFromCenter, 1);\n\n          // Create a proper 3D cell with front face and back face\n          var cell = {\n            type: 'box',\n            // Front face (z=0)\n            frontFace: [{\n              x: x,\n              y: y,\n              z: 0\n            },\n            // Top-left front\n            {\n              x: x + cellWidth,\n              y: y,\n              z: 0\n            },\n            // Top-right front\n            {\n              x: x + cellWidth,\n              y: y + cellHeight,\n              z: 0\n            },\n            // Bottom-right front\n            {\n              x: x,\n              y: y + cellHeight,\n              z: 0\n            } // Bottom-left front\n            ],\n            // Back face (z=cellDepth)\n            backFace: [{\n              x: x,\n              y: y,\n              z: cellDepth\n            },\n            // Top-left back\n            {\n              x: x + cellWidth,\n              y: y,\n              z: cellDepth\n            },\n            // Top-right back\n            {\n              x: x + cellWidth,\n              y: y + cellHeight,\n              z: cellDepth\n            },\n            // Bottom-right back\n            {\n              x: x,\n              y: y + cellHeight,\n              z: cellDepth\n            } // Bottom-left back\n            ],\n            avgZ: cellDepth / 2 // for sorting\n          };\n          shapes.push(cell);\n        }\n      }\n\n      // Project points to 2D with improved perspective\n      var projectPoint = function projectPoint(point) {\n        // Make a copy of the point to avoid modifying the original\n        var p = _objectSpread({}, point);\n\n        // Calculate the center of the grid's bounding box\n        var centerX = 0; // We're already centering at origin\n        var centerY = 0;\n        var centerZ = depth / 2; // Center point between front and back\n\n        // Apply rotation around X axis (pitch) centered at the grid's center\n        var y1 = (p.y - centerY) * Math.cos(rotX) - (p.z - centerZ) * Math.sin(rotX) + centerY;\n        var z1 = (p.y - centerY) * Math.sin(rotX) + (p.z - centerZ) * Math.cos(rotX) + centerZ;\n\n        // Apply rotation around Y axis (yaw) centered at the grid's center\n        var x2 = (p.x - centerX) * Math.cos(rotY) + (z1 - centerZ) * Math.sin(rotY) + centerX;\n        var z2 = -(p.x - centerX) * Math.sin(rotY) + (z1 - centerZ) * Math.cos(rotY) + centerZ;\n\n        // Apply perspective projection with adjustable factor\n        var perspectiveFactor = 600; // Adjust for desired perspective strength\n        var scale = perspectiveFactor / (perspectiveFactor + z2);\n        return {\n          x: x2 * scale,\n          y: y1 * scale,\n          z: z2\n        };\n      };\n\n      // Sort shapes back to front for proper rendering\n      shapes.sort(function (a, b) {\n        // Calculate actual z after rotation\n        var aZ = a.avgZ * Math.cos(rotX) * Math.cos(rotY);\n        var bZ = b.avgZ * Math.cos(rotX) * Math.cos(rotY);\n        return bZ - aZ;\n      });\n\n      // Draw all shapes\n      for (var _i = 0, _shapes = shapes; _i < _shapes.length; _i++) {\n        var shape = _shapes[_i];\n        if (shape.type === 'box') {\n          // Project all points of the box\n          var frontFaceProjected = shape.frontFace.map(projectPoint);\n          var backFaceProjected = shape.backFace.map(projectPoint);\n\n          // Draw front face\n          elements.push(\"<path d=\\\"\\n          M\".concat(frontFaceProjected[0].x, \",\").concat(frontFaceProjected[0].y, \"\\n          L\").concat(frontFaceProjected[1].x, \",\").concat(frontFaceProjected[1].y, \"\\n          L\").concat(frontFaceProjected[2].x, \",\").concat(frontFaceProjected[2].y, \"\\n          L\").concat(frontFaceProjected[3].x, \",\").concat(frontFaceProjected[3].y, \"\\n          Z\\n        \\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(this.thickness, \"\\\" fill=\\\"none\\\" />\"));\n\n          // Draw back face\n          elements.push(\"<path d=\\\"\\n          M\".concat(backFaceProjected[0].x, \",\").concat(backFaceProjected[0].y, \"\\n          L\").concat(backFaceProjected[1].x, \",\").concat(backFaceProjected[1].y, \"\\n          L\").concat(backFaceProjected[2].x, \",\").concat(backFaceProjected[2].y, \"\\n          L\").concat(backFaceProjected[3].x, \",\").concat(backFaceProjected[3].y, \"\\n          Z\\n        \\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(this.thickness, \"\\\" fill=\\\"none\\\" />\"));\n\n          // Draw connecting edges (between front and back faces)\n          for (var i = 0; i < 4; i++) {\n            elements.push(\"<path d=\\\"\\n            M\".concat(frontFaceProjected[i].x, \",\").concat(frontFaceProjected[i].y, \"\\n            L\").concat(backFaceProjected[i].x, \",\").concat(backFaceProjected[i].y, \"\\n          \\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(this.thickness, \"\\\" fill=\\\"none\\\" />\"));\n          }\n        } else if (shape.type === 'triangle') {\n          // Project triangle points\n          var projectedPoints = shape.points.map(projectPoint);\n\n          // Draw triangle\n          elements.push(\"<path d=\\\"\\n          M\".concat(projectedPoints[0].x, \",\").concat(projectedPoints[0].y, \"\\n          L\").concat(projectedPoints[1].x, \",\").concat(projectedPoints[1].y, \"\\n          L\").concat(projectedPoints[2].x, \",\").concat(projectedPoints[2].y, \"\\n          Z\\n        \\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(this.thickness, \"\\\" fill=\\\"none\\\" />\"));\n        }\n      }\n      return elements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(PerspectiveGridShape, \"parameters\", {\n  size: {\n    min: 50,\n    max: 150,\n    \"default\": 150\n  },\n  rows: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  },\n  columns: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  },\n  spacing: {\n    min: 0,\n    max: 30,\n    \"default\": 0\n  },\n  depth: {\n    min: 0,\n    max: 100,\n    \"default\": 100\n  },\n  rotationX: {\n    min: -180,\n    max: 180,\n    \"default\": 0\n  },\n  rotationY: {\n    min: -180,\n    max: 180,\n    \"default\": 0\n  },\n  thickness: {\n    min: 1,\n    max: 5,\n    \"default\": 2\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PerspectiveGridShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/PerspectiveGridShape.js?");

/***/ }),

/***/ "./src/shapes/PieSegments.js":
/*!***********************************!*\
  !*** ./src/shapes/PieSegments.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a circle divided into equal segments by lines radiating from the\n * center, like a pie chart outline.\n */\nvar PieSegmentsShape = /*#__PURE__*/function (_Shape) {\n  function PieSegmentsShape() {\n    _classCallCheck(this, PieSegmentsShape);\n    return _callSuper(this, PieSegmentsShape, arguments);\n  }\n  _inherits(PieSegmentsShape, _Shape);\n  return _createClass(PieSegmentsShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var elements = [];\n      var angleStep = 2 * Math.PI / this.segments;\n      var rotationRad = this.rotation * Math.PI / 180;\n\n      // Add the outer circle\n      elements.push(\"<circle \\n            cx=\\\"0\\\" \\n            cy=\\\"0\\\" \\n            r=\\\"\".concat(this.radius, \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            fill=\\\"none\\\"\\n        />\"));\n\n      // Add the segments\n      for (var i = 0; i < this.segments; i++) {\n        var angle = i * angleStep + rotationRad;\n        var x = this.radius * Math.cos(angle);\n        var y = this.radius * Math.sin(angle);\n        elements.push(\"<line \\n                x1=\\\"0\\\" \\n                y1=\\\"0\\\" \\n                x2=\\\"\".concat(x, \"\\\" \\n                y2=\\\"\").concat(y, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                stroke-linecap=\\\"butt\\\"\\n            />\"));\n      }\n      return elements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(PieSegmentsShape, \"parameters\", {\n  segments: {\n    min: 3,\n    max: 32,\n    \"default\": 8\n  },\n  radius: {\n    min: 20,\n    max: 150,\n    \"default\": 100\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  },\n  rotation: {\n    min: -180,\n    max: 180,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PieSegmentsShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/PieSegments.js?");

/***/ }),

/***/ "./src/shapes/PinwheelShape.js":
/*!*************************************!*\
  !*** ./src/shapes/PinwheelShape.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a four-armed pinwheel shape with adjustable arm length, width, and\n * center gap.\n */\nvar PinwheelShape = /*#__PURE__*/function (_Shape) {\n  function PinwheelShape() {\n    _classCallCheck(this, PinwheelShape);\n    return _callSuper(this, PinwheelShape, arguments);\n  }\n  _inherits(PinwheelShape, _Shape);\n  return _createClass(PinwheelShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Calculate center and scale based on viewBox\n      var center = {\n        x: 0,\n        y: 0\n      };\n      var scale = 0.8;\n\n      // Scale parameters\n      var armLength = this.armLength * scale;\n      var centerGap = this.centerGap * scale;\n      var armWidth = this.armWidth * scale;\n      var rotation = 0;\n\n      // Array to store path data for each arm\n      var arms = [];\n\n      // Create four arms of the pinwheel\n      for (var i = 0; i < 4; i++) {\n        var angle = rotation + i * Math.PI / 2;\n\n        // Calculate corner points for each arm\n        var p1 = {\n          x: center.x + centerGap * Math.cos(angle),\n          y: center.y + centerGap * Math.sin(angle)\n        };\n        var p2 = {\n          x: p1.x + armLength * Math.cos(angle),\n          y: p1.y + armLength * Math.sin(angle)\n        };\n        var p3 = {\n          x: p2.x + armWidth * Math.cos(angle + Math.PI / 2),\n          y: p2.y + armWidth * Math.sin(angle + Math.PI / 2)\n        };\n        var p4 = {\n          x: p1.x + armWidth * Math.cos(angle + Math.PI / 2),\n          y: p1.y + armWidth * Math.sin(angle + Math.PI / 2)\n        };\n\n        // Create path data for this arm\n        arms.push(\"M \".concat(p1.x, \" \").concat(p1.y, \" L \").concat(p2.x, \" \").concat(p2.y, \" L \").concat(p3.x, \" \").concat(p3.y, \" L \").concat(p4.x, \" \").concat(p4.y, \" Z\"));\n      }\n      return \"<path d=\\\"\".concat(arms.join(' '), \"\\\" fill=\\\"white\\\"/>\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(PinwheelShape, \"parameters\", {\n  armLength: {\n    min: 50,\n    max: 100,\n    \"default\": 120\n  },\n  centerGap: {\n    min: 0,\n    max: 60,\n    \"default\": 0\n  },\n  armWidth: {\n    min: 20,\n    max: 100,\n    \"default\": 60\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PinwheelShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/PinwheelShape.js?");

/***/ }),

/***/ "./src/shapes/PixelPattern.js":
/*!************************************!*\
  !*** ./src/shapes/PixelPattern.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a pixelated pattern within a grid, using symmetry and noise-based\n * fill probability.\n */\nvar PixelPattern = /*#__PURE__*/function (_Shape) {\n  function PixelPattern() {\n    _classCallCheck(this, PixelPattern);\n    return _callSuper(this, PixelPattern, arguments);\n  }\n  _inherits(PixelPattern, _Shape);\n  return _createClass(PixelPattern, [{\n    key: \"createSeededRandom\",\n    value: function createSeededRandom(seed) {\n      return function () {\n        seed = (seed * 9301 + 49297) % 233280;\n        return seed / 233280;\n      };\n    }\n  }, {\n    key: \"createGrid\",\n    value: function createGrid() {\n      var grid = [];\n      for (var y = 0; y < this.gridSize; y++) {\n        var row = [];\n        for (var x = 0; x < this.gridSize; x++) {\n          row.push(0);\n        }\n        grid.push(row);\n      }\n      return grid;\n    }\n  }, {\n    key: \"getPositionProbability\",\n    value: function getPositionProbability(x, y) {\n      var center = this.gridSize / 2;\n      var distFromCenter = Math.sqrt(Math.pow(x - center, 2) + Math.pow(y - center, 2));\n      var maxDist = Math.sqrt(2) * center;\n      var normalizedDist = distFromCenter / maxDist;\n      switch (this.patternType) {\n        case 'center-heavy':\n          return this.fillProbability * (1 - normalizedDist);\n        case 'edge-heavy':\n          return this.fillProbability * normalizedDist;\n        case 'uniform':\n          return this.fillProbability;\n        case 'random':\n        default:\n          return this.fillProbability;\n      }\n    }\n  }, {\n    key: \"applySymmetry\",\n    value: function applySymmetry(x, y, value) {\n      var center = Math.floor(this.gridSize / 2);\n      this.grid[y][x] = value;\n      if (this.symmetry === 'radial4') {\n        this.grid[y][this.gridSize - 1 - x] = value;\n        this.grid[this.gridSize - 1 - y][x] = value;\n        this.grid[this.gridSize - 1 - y][this.gridSize - 1 - x] = value;\n        var xFromCenter = x - center;\n        var yFromCenter = y - center;\n        var x90 = center - yFromCenter;\n        var y90 = center + xFromCenter;\n        if (x90 >= 0 && x90 < this.gridSize && y90 >= 0 && y90 < this.gridSize) {\n          this.grid[y90][x90] = value;\n          this.grid[y90][this.gridSize - 1 - x90] = value;\n          this.grid[this.gridSize - 1 - y90][x90] = value;\n          this.grid[this.gridSize - 1 - y90][this.gridSize - 1 - x90] = value;\n        }\n      } else {\n        this.grid[y][this.gridSize - 1 - x] = value;\n        this.grid[this.gridSize - 1 - y][x] = value;\n        this.grid[this.gridSize - 1 - y][this.gridSize - 1 - x] = value;\n        var xc = x - center;\n        var yc = y - center;\n        var positions = [[center + xc, center + yc], [center + yc, center - xc], [center - xc, center - yc], [center - yc, center + xc], [center + yc, center + xc], [center - yc, center - xc], [center + xc, center - yc], [center - xc, center + yc]];\n        for (var _i = 0, _positions = positions; _i < _positions.length; _i++) {\n          var _positions$_i = _slicedToArray(_positions[_i], 2),\n            px = _positions$_i[0],\n            py = _positions$_i[1];\n          if (px >= 0 && px < this.gridSize && py >= 0 && py < this.gridSize) {\n            this.grid[py][px] = value;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"generatePattern\",\n    value: function generatePattern() {\n      var _this = this;\n      var center = Math.floor(this.gridSize / 2);\n      var fillRegion = function fillRegion(x, y) {\n        if (_this.symmetry === 'radial8') {\n          return x >= center && y <= center && x - center >= center - y;\n        } else {\n          return x >= center && y <= center;\n        }\n      };\n      for (var y = 0; y < this.gridSize; y++) {\n        for (var x = 0; x < this.gridSize; x++) {\n          if (fillRegion(x, y)) {\n            var probability = this.getPositionProbability(x, y);\n            if (this.rng() < probability) {\n              this.applySymmetry(x, y, 1);\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      this.gridSize = this.gridSize % 2 === 0 ? this.gridSize + 1 : this.gridSize;\n      this.rng = this.createSeededRandom(this.randomSeed);\n      this.grid = this.createGrid();\n      this.generatePattern();\n      var maxGridSpace = 400 * 0.8;\n      var calculatedPixelSize = maxGridSpace / this.gridSize;\n      var pixelSize = Math.min(this.pixelSize, calculatedPixelSize);\n      var totalGridSize = this.gridSize * pixelSize;\n      var offset = totalGridSize / 2;\n      var pathData = '';\n      for (var y = 0; y < this.gridSize; y++) {\n        for (var x = 0; x < this.gridSize; x++) {\n          if (this.grid[y][x] === 1) {\n            var posX = x * pixelSize - offset;\n            var posY = y * pixelSize - offset;\n            pathData += \"M\".concat(posX, \",\").concat(posY, \" h\").concat(pixelSize, \" v\").concat(pixelSize, \" h-\").concat(pixelSize, \" Z \");\n          }\n        }\n      }\n      return \"<path d=\\\"\".concat(pathData.trim(), \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\"/>\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(PixelPattern, \"parameters\", {\n  gridSize: {\n    min: 8,\n    max: 16,\n    \"default\": 12\n  },\n  pixelSize: {\n    min: 5,\n    max: 10,\n    \"default\": 15\n  },\n  fillProbability: {\n    min: 0.3,\n    max: 0.9,\n    \"default\": 0.7\n  },\n  symmetry: {\n    options: ['radial4', 'radial8'],\n    \"default\": 'radial8'\n  },\n  patternType: {\n    options: ['center-heavy', 'edge-heavy', 'uniform', 'random'],\n    \"default\": 'random'\n  },\n  randomSeed: {\n    min: 1,\n    max: 1000,\n    \"default\": 42\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PixelPattern);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/PixelPattern.js?");

/***/ }),

/***/ "./src/shapes/PixelatedSmileyFace.js":
/*!*******************************************!*\
  !*** ./src/shapes/PixelatedSmileyFace.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a pixelated smiley face where the grid size is controlled\n * by complexity. Features like eyes and mouth are drawn using single solid pixel blocks.\n */\nvar PixelatedSmileyFace = /*#__PURE__*/function (_Shape) {\n  function PixelatedSmileyFace() {\n    _classCallCheck(this, PixelatedSmileyFace);\n    return _callSuper(this, PixelatedSmileyFace, arguments);\n  }\n  _inherits(PixelatedSmileyFace, _Shape);\n  return _createClass(PixelatedSmileyFace, [{\n    key: \"plot\",\n    value:\n    // Helper to plot a pixel, ensuring it's within grid bounds\n    function plot(row, col, grid) {\n      var gridSize = grid.length;\n      // Use Math.floor for consistent grid indexing from potentially float inputs\n      var r = Math.floor(row);\n      var c = Math.floor(col);\n      if (r >= 0 && r < gridSize && c >= 0 && c < gridSize) {\n        grid[r][c] = true;\n      }\n    }\n\n    // Bresenham's line algorithm adapted for grid plotting\n    // Takes potentially float coordinates and floors them\n  }, {\n    key: \"drawLine\",\n    value: function drawLine(r0, c0, r1, c1, grid) {\n      var R0 = Math.floor(r0);\n      var C0 = Math.floor(c0);\n      var R1 = Math.floor(r1);\n      var C1 = Math.floor(c1);\n      var dr = Math.abs(R1 - R0);\n      var dc = -Math.abs(C1 - C0);\n      var sr = R0 < R1 ? 1 : -1;\n      var sc = C0 < C1 ? 1 : -1;\n      var err = dr + dc;\n      var cr = R0;\n      var cc = C0;\n      var safety = 0; // Prevent infinite loops\n\n      while (safety < grid.length * 4) {\n        // Increased safety limit based on grid size\n        this.plot(cr, cc, grid); // Use plot which handles bounds checking\n        if (cr === R1 && cc === C1) break;\n        var e2 = 2 * err;\n        if (e2 >= dc) {\n          if (cr === R1) break;\n          err += dc;\n          cr += sr;\n        }\n        if (e2 <= dr) {\n          if (cc === C1) break;\n          err += dr;\n          cc += sc;\n        }\n        safety++;\n      }\n      if (safety >= grid.length * 4) {\n        console.warn(\"Bresenham safety break triggered\");\n      }\n    }\n\n    // Bresenham's Circle Algorithm (Midpoint variant) for plotting pixel circle\n    // Requires integer center and radius\n  }, {\n    key: \"drawCircle\",\n    value: function drawCircle(centerXInt, centerYInt, radiusInt, grid) {\n      var x = radiusInt;\n      var y = 0;\n      var err = 1 - x; // Start error calculation adjusted for integer math\n\n      while (x >= y) {\n        // Plot points for all 8 octants\n        this.plot(centerYInt + y, centerXInt + x, grid);\n        this.plot(centerYInt + x, centerXInt + y, grid);\n        this.plot(centerYInt + x, centerXInt - y, grid);\n        this.plot(centerYInt + y, centerXInt - x, grid);\n        this.plot(centerYInt - y, centerXInt - x, grid);\n        this.plot(centerYInt - x, centerXInt - y, grid);\n        this.plot(centerYInt - x, centerXInt + y, grid);\n        this.plot(centerYInt - y, centerXInt + x, grid);\n        y++;\n        if (err <= 0) {\n          err += 2 * y + 1;\n        } else {\n          // >= 0\n          x--;\n          err += 2 * (y - x) + 1;\n        }\n      }\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var gridSize = Math.max(6, Math.floor(this.complexity)); // Ensure grid size is integer\n      var pixelSize = 200 / gridSize;\n      var grid = Array(gridSize).fill(0).map(function () {\n        return Array(gridSize).fill(false);\n      });\n\n      // Calculate center and radius using floating point for precision\n      var gridCenterFloat = (gridSize - 1) / 2.0; // Center coordinate (e.g., 10 -> 4.5)\n      var faceRadiusFloat = gridSize / 2.0 * 0.95;\n\n      // --- 1. Draw Face Outline (Optional) ---\n      if (this.faceOutline) {\n        // Round center and floor radius for the integer-based circle algorithm\n        var centerXInt = Math.round(gridCenterFloat);\n        var centerYInt = Math.round(gridCenterFloat);\n        var radiusInt = Math.max(1, Math.floor(faceRadiusFloat)); // Ensure radius is at least 1\n        this.drawCircle(centerXInt, centerYInt, radiusInt, grid);\n      }\n\n      // --- 2. Draw Eyes ---\n      // Calculate eye positions using float coordinates first\n      var eyeCenterYFloat = gridCenterFloat + faceRadiusFloat * (this.eyeY / 100);\n      var eyeCenterXOffsetFloat = faceRadiusFloat * (this.eyeSpacing / 100);\n      var leftEyeBaseXFloat = gridCenterFloat - eyeCenterXOffsetFloat;\n      var rightEyeBaseXFloat = gridCenterFloat + eyeCenterXOffsetFloat;\n\n      // Determine integer dimensions for eyes\n      var eyeHeightActual = Math.max(1, Math.floor(this.eyeHeight));\n      var eyeWidthActual = Math.max(1, Math.floor(this.eyeWidth));\n\n      // Calculate integer start row/col for the top-left corner of the eye block\n      // Use Math.round for the center point before calculating offset start points\n      var eyeStartRow = Math.round(eyeCenterYFloat - (eyeHeightActual - 1) / 2);\n      var leftEyeStartCol = Math.round(leftEyeBaseXFloat - (eyeWidthActual - 1) / 2);\n      var rightEyeStartCol = Math.round(rightEyeBaseXFloat - (eyeWidthActual - 1) / 2);\n\n      // Draw left eye block using plot (which floors coordinates)\n      for (var rOffset = 0; rOffset < eyeHeightActual; rOffset++) {\n        for (var cOffset = 0; cOffset < eyeWidthActual; cOffset++) {\n          this.plot(eyeStartRow + rOffset, leftEyeStartCol + cOffset, grid);\n        }\n      }\n\n      // Draw right eye block\n      for (var _rOffset = 0; _rOffset < eyeHeightActual; _rOffset++) {\n        for (var _cOffset = 0; _cOffset < eyeWidthActual; _cOffset++) {\n          this.plot(eyeStartRow + _rOffset, rightEyeStartCol + _cOffset, grid);\n        }\n      }\n\n      // --- 3. Draw Mouth ---\n      var t = (this.emotion + 100) / 200; // Normalize emotion 0-1\n      var mouthWidthFloat = faceRadiusFloat * (0.2 + 0.6 * t);\n      var mouthCenterYFloat = gridCenterFloat + faceRadiusFloat * (0.45 - 0.2 * t);\n      var mouthCurvatureFloat = this.emotion / 100 * (faceRadiusFloat * 0.30); // Adjusted curvature\n\n      var mouthPoints = [];\n      var numMouthSegments = Math.max(5, Math.floor(gridSize / 4));\n      for (var i = 0; i <= numMouthSegments; i++) {\n        var segmentT = -1 + 2 * i / numMouthSegments; // Range from -1 to 1\n        var colRelative = mouthWidthFloat / 2 * segmentT;\n        // Parabolic curve using float coordinates\n        var rowOffset = mouthCurvatureFloat * (1 - segmentT * segmentT);\n        var colFloat = gridCenterFloat + colRelative;\n        var rowFloat = mouthCenterYFloat + rowOffset;\n        mouthPoints.push({\n          row: rowFloat,\n          col: colFloat\n        });\n      }\n\n      // Draw lines between mouth points (drawLine handles flooring)\n      for (var _i = 0; _i < mouthPoints.length - 1; _i++) {\n        var p1 = mouthPoints[_i];\n        var p2 = mouthPoints[_i + 1];\n        this.drawLine(p1.row, p1.col, p2.row, p2.col, grid);\n      }\n      // Explicitly plot the start/end points in case they are missed or single-point mouth\n      if (mouthPoints.length > 0) {\n        this.plot(mouthPoints[0].row, mouthPoints[0].col, grid);\n        this.plot(mouthPoints[mouthPoints.length - 1].row, mouthPoints[mouthPoints.length - 1].col, grid);\n      }\n\n      // --- 4. Generate SVG Rects from Grid ---\n      var svgElements = '';\n      // Removed overlap calculation as it might cause issues.\n      // Precise positioning relies on coordinates and pixelSize.\n      for (var r = 0; r < gridSize; r++) {\n        for (var c = 0; c < gridSize; c++) {\n          if (grid[r][c]) {\n            // Calculate top-left corner for the pixel\n            var x = -100 + c * pixelSize;\n            var y = -100 + r * pixelSize;\n            // Use pixelSize directly. Add a tiny epsilon to width/height to fight potential anti-aliasing gaps.\n            var epsilon = 0.1;\n            svgElements += \"<rect x=\\\"\".concat(x, \"\\\" y=\\\"\").concat(y, \"\\\" width=\\\"\").concat(pixelSize + epsilon, \"\\\" height=\\\"\").concat(pixelSize + epsilon, \"\\\" fill=\\\"white\\\" />\\n\");\n          }\n        }\n      }\n\n      // If no pixels were drawn, add a fallback small indicator square\n      if (svgElements === '') {\n        console.warn(\"PixelatedSmileyFace: No pixels generated for current parameters.\");\n        var fallbackSize = 10;\n        svgElements = \"<rect x=\\\"\".concat(-fallbackSize / 2, \"\\\" y=\\\"\").concat(-fallbackSize / 2, \"\\\" width=\\\"\").concat(fallbackSize, \"\\\" height=\\\"\").concat(fallbackSize, \"\\\" fill=\\\"red\\\" />\"); // Red error indicator\n      }\n\n      // Wrap in a group for consistency\n      return \"<g>\".concat(svgElements, \"</g>\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(PixelatedSmileyFace, \"parameters\", {\n  complexity: {\n    type: 'number',\n    min: 16,\n    // Minimum grid size for recognizable features\n    max: 32,\n    step: 2,\n    \"default\": 24\n  },\n  emotion: {\n    // -100 = sad, 0 = neutral, 100 = happy\n    type: 'number',\n    min: -100,\n    max: 100,\n    step: 20,\n    \"default\": 100\n  },\n  eyeWidth: {\n    // In grid units (pixels)\n    type: 'number',\n    min: 1,\n    max: 8,\n    step: 1,\n    \"default\": 1\n  },\n  eyeHeight: {\n    // In grid units (pixels)\n    type: 'number',\n    min: 1,\n    max: 8,\n    step: 1,\n    \"default\": 4\n  },\n  eyeSpacing: {\n    // Percentage of face radius\n    type: 'number',\n    min: 10,\n    max: 80,\n    step: 5,\n    \"default\": 30\n  },\n  eyeY: {\n    // Percentage of face radius from center (- up, + down)\n    type: 'number',\n    min: -50,\n    max: 50,\n    step: 5,\n    \"default\": -20\n  },\n  faceOutline: {\n    type: 'boolean',\n    \"default\": true\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PixelatedSmileyFace);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/PixelatedSmileyFace.js?");

/***/ }),

/***/ "./src/shapes/Plant.js":
/*!*****************************!*\
  !*** ./src/shapes/Plant.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a stylized plant shape composed of vertically stacked pairs of\n * outward-curving corner segments.\n */\nvar PlantShape = /*#__PURE__*/function (_Shape) {\n  function PlantShape() {\n    _classCallCheck(this, PlantShape);\n    return _callSuper(this, PlantShape, arguments);\n  }\n  _inherits(PlantShape, _Shape);\n  return _createClass(PlantShape, [{\n    key: \"generateCornerPair\",\n    value: function generateCornerPair(yOffset, isLast) {\n      var verticalExtend = isLast ? 0 : this.spacing;\n\n      // Generate right side segment\n      var rightSegment = \"<path \\n            d=\\\"M 0,\".concat(yOffset + this.cornerRadius, \" \\n               A \").concat(this.cornerRadius, \" \").concat(this.cornerRadius, \" 0 0 1 \").concat(this.cornerRadius, \",\").concat(yOffset, \" \\n               L \").concat(this.length, \",\").concat(yOffset, \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            fill=\\\"none\\\"\\n        />\");\n\n      // Generate left side segment\n      var leftSegment = \"<path \\n            d=\\\"M 0,\".concat(yOffset + this.cornerRadius, \" \\n               A \").concat(this.cornerRadius, \" \").concat(this.cornerRadius, \" 0 0 0 -\").concat(this.cornerRadius, \",\").concat(yOffset, \" \\n               L -\").concat(this.length, \",\").concat(yOffset, \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            fill=\\\"none\\\"\\n        />\");\n\n      // Generate vertical segment that connects to the next pair\n      var verticalSegment = isLast ? '' : \"<path \\n            d=\\\"M 0,\".concat(yOffset + this.cornerRadius, \" \\n               L 0,\").concat(yOffset + this.cornerRadius + verticalExtend, \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            fill=\\\"none\\\"\\n        />\");\n      return leftSegment + rightSegment + verticalSegment;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var segments = [];\n      var totalHeight = (this.segmentCount - 1) * this.spacing;\n\n      // Generate pairs of segments from bottom to top\n      for (var i = 0; i < this.segmentCount; i++) {\n        var yOffset = -totalHeight + i * this.spacing;\n        var isLast = i === this.segmentCount - 1;\n        segments.push(this.generateCornerPair(yOffset, isLast));\n      }\n      return \"<g transform=\\\"translate(0, \".concat(totalHeight / 2, \")\\\">\").concat(segments.join(''), \"</g>\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(PlantShape, \"parameters\", {\n  cornerRadius: {\n    min: 5,\n    max: 30,\n    \"default\": 30\n  },\n  length: {\n    min: 20,\n    max: 100,\n    \"default\": 90\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 10\n  },\n  segmentCount: {\n    min: 1,\n    max: 6,\n    \"default\": 6\n  },\n  spacing: {\n    min: 5,\n    max: 50,\n    \"default\": 28\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PlantShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/Plant.js?");

/***/ }),

/***/ "./src/shapes/PlugShape.js":
/*!*********************************!*\
  !*** ./src/shapes/PlugShape.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a simplified electrical plug shape with a rectangular base and two\n * prongs.\n */\nvar PlugShape = /*#__PURE__*/function (_Shape) {\n  function PlugShape() {\n    _classCallCheck(this, PlugShape);\n    return _callSuper(this, PlugShape, arguments);\n  }\n  _inherits(PlugShape, _Shape);\n  return _createClass(PlugShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Scale factor to fit within viewBox\n      var scale = 1.5;\n\n      // Calculate dimensions\n      var baseWidth = this.baseWidth * scale;\n      var baseHeight = this.baseHeight * scale;\n      var prongLength = this.prongLength * scale;\n      var prongSpacing = this.prongSpacing * scale;\n      var prongWidth = this.prongWidth * scale;\n      var cornerRadius = this.cornerRadius * scale;\n\n      // Center horizontally, shift up slightly for prongs\n      var baseX = -baseWidth / 2;\n      var baseY = -baseHeight / 2 - prongLength / 3;\n\n      // Prong coordinates\n      var leftProngX = -prongSpacing / 2 - prongWidth;\n      var rightProngX = prongSpacing / 2;\n      var prongY = baseY + baseHeight;\n      return \"\\n            <g fill=\\\"white\\\">\\n                <path \\n                    d=\\\"\\n                        M \".concat(baseX + cornerRadius, \" \").concat(baseY, \"\\n                        h \").concat(baseWidth - 2 * cornerRadius, \"\\n                        q \").concat(cornerRadius, \" 0 \").concat(cornerRadius, \" \").concat(cornerRadius, \"\\n                        v \").concat(baseHeight - 2 * cornerRadius, \"\\n                        q 0 \").concat(cornerRadius, \" -\").concat(cornerRadius, \" \").concat(cornerRadius, \"\\n                        h -\").concat(baseWidth - 2 * cornerRadius, \"\\n                        q -\").concat(cornerRadius, \" 0 -\").concat(cornerRadius, \" -\").concat(cornerRadius, \"\\n                        v -\").concat(baseHeight - 2 * cornerRadius, \"\\n                        q 0 -\").concat(cornerRadius, \" \").concat(cornerRadius, \" -\").concat(cornerRadius, \"\\n                        Z\\n                    \\\"\\n                />\\n                <rect\\n                    x=\\\"\").concat(leftProngX, \"\\\"\\n                    y=\\\"\").concat(prongY, \"\\\"\\n                    width=\\\"\").concat(prongWidth, \"\\\"\\n                    rx=\\\"\").concat(cornerRadius, \"\\\"\\n                    ry=\\\"\").concat(cornerRadius, \"\\\"\\n                    height=\\\"\").concat(prongLength, \"\\\"\\n                />\\n                <rect\\n                    x=\\\"\").concat(rightProngX, \"\\\"\\n                    y=\\\"\").concat(prongY, \"\\\"\\n                    width=\\\"\").concat(prongWidth, \"\\\"\\n                    rx=\\\"\").concat(cornerRadius, \"\\\"\\n                    ry=\\\"\").concat(cornerRadius, \"\\\"\\n                    height=\\\"\").concat(prongLength, \"\\\"\\n                />\\n            </g>\\n        \");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(PlugShape, \"parameters\", {\n  baseWidth: {\n    min: 40,\n    max: 120,\n    \"default\": 80\n  },\n  baseHeight: {\n    min: 30,\n    max: 100,\n    \"default\": 60\n  },\n  prongLength: {\n    min: 20,\n    max: 100,\n    \"default\": 60\n  },\n  prongSpacing: {\n    min: 10,\n    max: 50,\n    \"default\": 25\n  },\n  prongWidth: {\n    min: 4,\n    max: 20,\n    \"default\": 8\n  },\n  cornerRadius: {\n    min: 0,\n    max: 20,\n    \"default\": 5\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PlugShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/PlugShape.js?");

/***/ }),

/***/ "./src/shapes/PolarLineBurst.js":
/*!**************************************!*\
  !*** ./src/shapes/PolarLineBurst.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a radial burst pattern where lines are distributed within four\n * quadrants, with controls for spread, length, and skew.\n */\nvar PolarLineBurst = /*#__PURE__*/function (_Shape) {\n  function PolarLineBurst() {\n    _classCallCheck(this, PolarLineBurst);\n    return _callSuper(this, PolarLineBurst, arguments);\n  }\n  _inherits(PolarLineBurst, _Shape);\n  return _createClass(PolarLineBurst, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var lines = [];\n      var baseRotation = this.rotation * Math.PI / 180;\n      var skewRad = this.skew * Math.PI / 180;\n      var quadrantGapRad = this.quadrantGap * Math.PI / 180;\n      var quadrantArcRad = this.quadrantArc * Math.PI / 180;\n\n      // Generate 4 quadrants\n      for (var quadrant = 0; quadrant < 4; quadrant++) {\n        var quadrantRotation = baseRotation + quadrant * (Math.PI / 2 + quadrantGapRad);\n\n        // Generate lines for each quadrant\n        for (var i = 0; i < this.lineCount; i++) {\n          // Calculate base progress (0 to 1)\n          var progress = i / (this.lineCount - 1);\n\n          // Apply spread power for spacing distribution\n          progress = Math.pow(progress, this.spreadPower);\n\n          // Calculate alternating effects if enabled\n          var isAlternate = i % 2 === 1;\n          var lengthMult = 1;\n          var angleOffset = 0;\n          if (this.alternateLines === 'length' && isAlternate) {\n            lengthMult = 0.7;\n          } else if (this.alternateLines === 'spacing' && isAlternate) {\n            angleOffset = quadrantArcRad * 0.1;\n          }\n\n          // Calculate angle within quadrant\n          var angle = quadrantArcRad * progress + angleOffset;\n\n          // Calculate line length with power-based scaling\n          var lengthProgress = Math.pow(progress, this.lengthPower);\n          var lineLength = this.startRadius + (this.size - this.startRadius) * lengthProgress * lengthMult;\n\n          // Apply rotations and skew\n          var totalAngle = quadrantRotation + angle + skewRad * progress;\n          var x = Math.cos(totalAngle) * lineLength;\n          var y = Math.sin(totalAngle) * lineLength;\n          lines.push(\"<line \\n                    x1=\\\"\".concat(Math.cos(totalAngle) * this.startRadius, \"\\\" \\n                    y1=\\\"\").concat(Math.sin(totalAngle) * this.startRadius, \"\\\"\\n                    x2=\\\"\").concat(x, \"\\\"\\n                    y2=\\\"\").concat(y, \"\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                    stroke-linecap=\\\"\").concat(this.lineCap, \"\\\"\\n                />\"));\n        }\n      }\n      return lines.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(PolarLineBurst, \"parameters\", {\n  // Core parameters\n  size: {\n    min: 50,\n    max: 200,\n    \"default\": 100\n  },\n  lineCount: {\n    min: 4,\n    max: 50,\n    \"default\": 10\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 3\n  },\n  lineCap: {\n    options: ['butt', 'round'],\n    \"default\": 'round'\n  },\n  rotation: {\n    min: 0,\n    max: 360,\n    \"default\": 59\n  },\n  // Distribution controls\n  spreadPower: {\n    min: 0.1,\n    max: 4,\n    \"default\": 1\n  },\n  // Controls line spacing distribution\n  lengthPower: {\n    min: 0.1,\n    max: 4,\n    \"default\": 1\n  },\n  // Controls length progression\n\n  // Geometry controls\n  quadrantArc: {\n    min: 1,\n    max: 120,\n    \"default\": 90\n  },\n  // Angle span within each quadrant\n  startRadius: {\n    min: 0,\n    max: 100,\n    \"default\": 25\n  },\n  // Starting radius for lines\n  quadrantGap: {\n    min: 0,\n    max: 90,\n    \"default\": 0\n  },\n  // Gap between quadrants in degrees\n  skew: {\n    min: -45,\n    max: 45,\n    \"default\": 0\n  },\n  // Skew angle for asymmetric shapes\n\n  // Style variations\n  alternateLines: {\n    options: ['none', 'length', 'spacing'],\n    \"default\": 'none'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PolarLineBurst);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/PolarLineBurst.js?");

/***/ }),

/***/ "./src/shapes/PolygonalBang.js":
/*!*************************************!*\
  !*** ./src/shapes/PolygonalBang.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a jagged, starburst-like polygon with alternating sharp peaks and\n * valleys based on inner and outer radii.\n */\nvar PolygonalBang = /*#__PURE__*/function (_Shape) {\n  function PolygonalBang() {\n    _classCallCheck(this, PolygonalBang);\n    return _callSuper(this, PolygonalBang, arguments);\n  }\n  _inherits(PolygonalBang, _Shape);\n  return _createClass(PolygonalBang, [{\n    key: \"generatePoints\",\n    value: function generatePoints() {\n      // Reset RNG to ensure consistent results with the same seed\n      this.resetRNG();\n      this.points = Math.round(this.points);\n      var points = [];\n      var angleStep = 2 * Math.PI / this.points;\n\n      // Generate alternating inner and outer points\n      for (var i = 0; i < this.points; i++) {\n        // Add randomness to angle\n        var angleVariation = angleStep * this.positionChaos * (this.random() - 0.5);\n        var angle = i * angleStep + angleVariation;\n\n        // Create an inner point (valley)\n        var innerRadiusVariation = 1 + this.irregularity * (this.random() - 0.5);\n        var innerPointRadius = this.radius * this.innerRadius * innerRadiusVariation;\n        var innerPoint = {\n          x: innerPointRadius * Math.cos(angle),\n          y: innerPointRadius * Math.sin(angle)\n        };\n\n        // Create an outer point (spike)\n        // Halfway between current angle and next angle\n        var midAngle = angle + angleStep / 2 + angleStep * this.irregularity * (this.random() - 0.5) * 0.5;\n\n        // Spike height varies\n        var spikeHeightVariation = 1 + this.irregularity * (this.random() - 0.5) * 2;\n        var outerPointRadius = this.radius * (1 + this.spikeHeight * spikeHeightVariation);\n        var outerPoint = {\n          x: outerPointRadius * Math.cos(midAngle),\n          y: outerPointRadius * Math.sin(midAngle)\n        };\n\n        // Add points in alternating order\n        points.push(innerPoint);\n        points.push(outerPoint);\n      }\n      return points;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var points = this.generatePoints();\n      var pathData = '';\n\n      // Create path data\n      points.forEach(function (point, i) {\n        if (i === 0) {\n          pathData += \"M \".concat(point.x, \" \").concat(point.y);\n        } else {\n          pathData += \" L \".concat(point.x, \" \").concat(point.y);\n        }\n      });\n\n      // Close the path\n      pathData += ' Z';\n      return \"<path\\n            d=\\\"\".concat(pathData, \"\\\"\\n            fill=\\\"white\\\"\\n            stroke=\\\"none\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(PolygonalBang, \"parameters\", {\n  radius: {\n    min: 40,\n    max: 60,\n    \"default\": 60\n  },\n  points: {\n    min: 8,\n    max: 16,\n    \"default\": 12\n  },\n  spikeHeight: {\n    min: 0.2,\n    max: 0.5,\n    \"default\": 0.35\n  },\n  // Shorter spikes relative to base radius\n  innerRadius: {\n    min: 0.6,\n    max: 0.9,\n    \"default\": 0.75\n  },\n  // Large inner circle\n  irregularity: {\n    min: 0.1,\n    max: 0.8,\n    \"default\": 0.4\n  },\n  // Irregularity of the points\n  positionChaos: {\n    min: 0.1,\n    max: 0.4,\n    \"default\": 0.2\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PolygonalBang);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/PolygonalBang.js?");

/***/ }),

/***/ "./src/shapes/PolygonalShieldWireframe.js":
/*!************************************************!*\
  !*** ./src/shapes/PolygonalShieldWireframe.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a shield shape with polygonal edges and inner wireframe lines\n * connecting outer and inner vertices.\n */\nvar PolygonalShieldWireframe = /*#__PURE__*/function (_Shape) {\n  function PolygonalShieldWireframe() {\n    _classCallCheck(this, PolygonalShieldWireframe);\n    return _callSuper(this, PolygonalShieldWireframe, arguments);\n  }\n  _inherits(PolygonalShieldWireframe, _Shape);\n  return _createClass(PolygonalShieldWireframe, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Extract parameter values using `this`\n      var H = this.baseHeight;\n      var W = this.baseWidth;\n      var halfH = H / 2;\n      var halfW = W / 2;\n      var halfW_top = W * this.topWidthFactor / 2;\n      var Y_shoulder = -halfH + H * this.shoulderHeightFactor; // Y coord from center\n      var Y_lrc = halfH - H * this.bottomPointHeightFactor; // Y coord from center\n      var X_lrc = halfW * this.bottomCornerWidthFactor;\n      var inset = this.insetDepth;\n      var sw = this.strokeWidth;\n\n      // Define outer vertices\n      var outerVertices = [{\n        x: 0,\n        y: halfH\n      },\n      // 0: Bottom Point (BP)\n      {\n        x: X_lrc,\n        y: Y_lrc\n      },\n      // 1: Lower Right Corner (LRC)\n      {\n        x: halfW,\n        y: Y_shoulder\n      },\n      // 2: Shoulder Right Point (SRP)\n      {\n        x: halfW_top,\n        y: -halfH\n      },\n      // 3: Top Right Corner (TRC)\n      {\n        x: -halfW_top,\n        y: -halfH\n      },\n      // 4: Top Left Corner (TLC)\n      {\n        x: -halfW,\n        y: Y_shoulder\n      },\n      // 5: Shoulder Left Point (SLP)\n      {\n        x: -X_lrc,\n        y: Y_lrc\n      } // 6: Lower Left Corner (LLC)\n      ];\n\n      // Calculate scale factor for inner vertices\n      // Use distance from center to furthest point as reference\n      var maxRadius = Math.max(Math.sqrt(Math.pow(halfW, 2) + Math.pow(Y_shoulder, 2)), Math.sqrt(Math.pow(X_lrc, 2) + Math.pow(Y_lrc, 2)), Math.sqrt(Math.pow(halfW_top, 2) + Math.pow(halfH, 2)), halfH // Bottom point\n      );\n      var scale = 1;\n      if (maxRadius > 0 && inset > 0) {\n        scale = Math.max(0, (maxRadius - inset) / maxRadius);\n      }\n      // Clamp scale to prevent inversion\n      scale = Math.min(1, scale);\n\n      // Define inner vertices by scaling outer vertices towards the center (0,0)\n      var innerVertices = outerVertices.map(function (v) {\n        return {\n          x: v.x * scale,\n          y: v.y * scale\n        };\n      });\n\n      // Build the SVG path data string\n      var d = '';\n\n      // Function to format a point for SVG path\n      var formatPoint = function formatPoint(p) {\n        return \"\".concat(p.x.toFixed(2), \",\").concat(p.y.toFixed(2));\n      };\n\n      // 1. Draw Outer Shield Polygon\n      d += \"M \".concat(formatPoint(outerVertices[0]), \" \");\n      for (var i = 1; i < outerVertices.length; i++) {\n        d += \"L \".concat(formatPoint(outerVertices[i]), \" \");\n      }\n      d += 'Z '; // Close the outer path\n\n      // 2. Draw Inner Shield Polygon (if inset is large enough)\n      if (inset > 0.1 && scale < 0.999) {\n        // Only draw if visually distinct\n        d += \"M \".concat(formatPoint(innerVertices[0]), \" \");\n        for (var _i = 1; _i < innerVertices.length; _i++) {\n          d += \"L \".concat(formatPoint(innerVertices[_i]), \" \");\n        }\n        d += 'Z '; // Close the inner path\n      }\n\n      // 3. Draw Connecting Lines (Wireframe edges)\n      if (inset > 0.1 && scale < 0.999) {\n        for (var _i2 = 0; _i2 < outerVertices.length; _i2++) {\n          d += \"M \".concat(formatPoint(outerVertices[_i2]), \" L \").concat(formatPoint(innerVertices[_i2]), \" \");\n        }\n      }\n\n      // Return the final SVG path element string with wireframe styling\n      return \"<path d=\\\"\".concat(d.trim(), \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(sw, \"\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\" />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(PolygonalShieldWireframe, \"parameters\", {\n  baseWidth: {\n    type: 'number',\n    min: 50,\n    max: 195,\n    \"default\": 160,\n    step: 1,\n    label: 'Base Width'\n  },\n  baseHeight: {\n    type: 'number',\n    min: 50,\n    max: 195,\n    \"default\": 180,\n    step: 1,\n    label: 'Base Height'\n  },\n  topWidthFactor: {\n    type: 'number',\n    min: 0.1,\n    max: 1.2,\n    \"default\": 0.7,\n    step: 0.05,\n    label: 'Top Width Factor'\n  },\n  shoulderHeightFactor: {\n    type: 'number',\n    min: 0.05,\n    max: 0.9,\n    \"default\": 0.3,\n    step: 0.05,\n    label: 'Shoulder Height (from top)'\n  },\n  // Fraction from top where width is max\n  bottomPointHeightFactor: {\n    type: 'number',\n    min: 0.05,\n    max: 0.7,\n    \"default\": 0.2,\n    step: 0.05,\n    label: 'Lower Corner Height (from bottom)'\n  },\n  // Fraction from bottom defining Y of lower corners\n  bottomCornerWidthFactor: {\n    type: 'number',\n    min: 0.1,\n    max: 1.0,\n    \"default\": 0.7,\n    step: 0.05,\n    label: 'Lower Corner Width Factor'\n  },\n  // Multiplier for baseWidth/2 to get X of lower corners\n  insetDepth: {\n    type: 'number',\n    min: 0,\n    max: 50,\n    \"default\": 20,\n    step: 1,\n    label: 'Inset Depth'\n  },\n  // Controls the distance between outer and inner outlines\n  strokeWidth: {\n    type: 'number',\n    min: 0.5,\n    max: 10,\n    \"default\": 2,\n    step: 0.5,\n    label: 'Stroke Width'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PolygonalShieldWireframe);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/PolygonalShieldWireframe.js?");

/***/ }),

/***/ "./src/shapes/PrismaShape.js":
/*!***********************************!*\
  !*** ./src/shapes/PrismaShape.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a 3D shape resembling a prism or crystal, combining a cube base\n * with a pyramid top using perspective.\n */\nvar PrismaShape = /*#__PURE__*/function (_Shape) {\n  function PrismaShape() {\n    _classCallCheck(this, PrismaShape);\n    return _callSuper(this, PrismaShape, arguments);\n  }\n  _inherits(PrismaShape, _Shape);\n  return _createClass(PrismaShape, [{\n    key: \"rotatePoint\",\n    value: function rotatePoint(point, center, rotation) {\n      var radians = rotation * Math.PI / 180;\n      var dx = point.x - center.x;\n      var dy = point.y - center.y;\n      var rotatedX = dx * Math.cos(radians) - dy * Math.sin(radians);\n      var rotatedY = dx * Math.sin(radians) + dy * Math.cos(radians);\n      return {\n        x: center.x + rotatedX,\n        y: center.y + rotatedY\n      };\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Center point for the shape\n      var center = {\n        x: 0,\n        y: 0\n      };\n\n      // Calculate scaled dimensions\n      var size = this.cubeSize;\n      var pyramidHeight = this.pyramidHeight;\n      var perspective = this.perspective;\n      var frontOffset = size * perspective;\n\n      // Calculate base points for the cube\n      var frontLeft = {\n        x: center.x - size / 2,\n        y: center.y + size / 2\n      };\n      var frontRight = {\n        x: center.x + size / 2,\n        y: center.y + size / 2\n      };\n      var backLeft = {\n        x: frontLeft.x - frontOffset,\n        y: frontLeft.y - frontOffset\n      };\n      var backRight = {\n        x: frontRight.x - frontOffset,\n        y: frontRight.y - frontOffset\n      };\n\n      // Rotate all points\n      var rotatedFrontLeft = this.rotatePoint(frontLeft, center, this.rotation);\n      var rotatedFrontRight = this.rotatePoint(frontRight, center, this.rotation);\n      var rotatedBackLeft = this.rotatePoint(backLeft, center, this.rotation);\n      var rotatedBackRight = this.rotatePoint(backRight, center, this.rotation);\n\n      // Calculate pyramid apex\n      var pyramidApex = this.rotatePoint({\n        x: center.x - frontOffset / 2,\n        y: center.y - pyramidHeight\n      }, center, this.rotation);\n\n      // Generate SVG path commands\n      var paths = [];\n\n      // Cube base (front face)\n      paths.push(\"<path d=\\\"\\n            M \".concat(rotatedFrontLeft.x, \" \").concat(rotatedFrontLeft.y, \"\\n            L \").concat(rotatedFrontRight.x, \" \").concat(rotatedFrontRight.y, \"\\n            L \").concat(rotatedBackRight.x, \" \").concat(rotatedBackRight.y, \"\\n            L \").concat(rotatedBackLeft.x, \" \").concat(rotatedBackLeft.y, \"\\n            Z\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            stroke-linecap=\\\"round\\\"\\n            stroke-linejoin=\\\"round\\\"\\n            fill=\\\"none\\\"\\n        />\"));\n\n      // Pyramid faces\n      paths.push(\"<path d=\\\"\\n            M \".concat(rotatedFrontLeft.x, \" \").concat(rotatedFrontLeft.y, \"\\n            L \").concat(pyramidApex.x, \" \").concat(pyramidApex.y, \"\\n            L \").concat(rotatedFrontRight.x, \" \").concat(rotatedFrontRight.y, \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            stroke-linecap=\\\"round\\\"\\n            stroke-linejoin=\\\"round\\\"\\n            fill=\\\"none\\\"\\n        />\"));\n      paths.push(\"<path d=\\\"\\n            M \".concat(rotatedBackLeft.x, \" \").concat(rotatedBackLeft.y, \"\\n            L \").concat(pyramidApex.x, \" \").concat(pyramidApex.y, \"\\n            L \").concat(rotatedBackRight.x, \" \").concat(rotatedBackRight.y, \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            stroke-linecap=\\\"round\\\"\\n            stroke-linejoin=\\\"round\\\"\\n            fill=\\\"none\\\"\\n        />\"));\n      return paths.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(PrismaShape, \"parameters\", {\n  cubeSize: {\n    min: 50,\n    max: 200,\n    \"default\": 120\n  },\n  pyramidHeight: {\n    min: 20,\n    max: 150,\n    \"default\": 80\n  },\n  perspective: {\n    min: 0.1,\n    max: 0.5,\n    \"default\": 0.3\n  },\n  thickness: {\n    min: 1,\n    max: 5,\n    \"default\": 2\n  },\n  rotation: {\n    min: -45,\n    max: 45,\n    \"default\": 15\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PrismaShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/PrismaShape.js?");

/***/ }),

/***/ "./src/shapes/PuzzlePieceShape.js":
/*!****************************************!*\
  !*** ./src/shapes/PuzzlePieceShape.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a simplified puzzle piece shape using a rectangle and masked\n * circular notches.\n */\nvar PuzzlePieceShape = /*#__PURE__*/function (_Shape) {\n  function PuzzlePieceShape() {\n    _classCallCheck(this, PuzzlePieceShape);\n    return _callSuper(this, PuzzlePieceShape, arguments);\n  }\n  _inherits(PuzzlePieceShape, _Shape);\n  return _createClass(PuzzlePieceShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var x = -this.width / 2;\n      var y = -this.height / 2;\n\n      // Calculate notch centers\n      var leftNotchX = x;\n      var leftNotchY = this.notchOffset;\n      var rightNotchX = x + this.width;\n      var rightNotchY = -this.notchOffset;\n\n      // Define the mask that will cut out the notches\n      return \"\\n            <defs>\\n                <mask id=\\\"pieceMask\\\">\\n                    <!-- White rectangle creates the base shape -->\\n                    <rect \\n                        x=\\\"\".concat(x, \"\\\" \\n                        y=\\\"\").concat(y, \"\\\" \\n                        width=\\\"\").concat(this.width, \"\\\" \\n                        height=\\\"\").concat(this.height, \"\\\" \\n                        fill=\\\"white\\\"\\n                    />\\n                    <!-- Black circles create the notch cutouts -->\\n                    <circle \\n                        cx=\\\"\").concat(leftNotchX, \"\\\" \\n                        cy=\\\"\").concat(leftNotchY, \"\\\" \\n                        r=\\\"\").concat(this.notchRadius, \"\\\"\\n                        fill=\\\"black\\\"\\n                    />\\n                    <circle \\n                        cx=\\\"\").concat(rightNotchX, \"\\\" \\n                        cy=\\\"\").concat(rightNotchY, \"\\\" \\n                        r=\\\"\").concat(this.notchRadius, \"\\\"\\n                        fill=\\\"black\\\"\\n                    />\\n                </mask>\\n            </defs>\\n            \\n            <!-- Main piece with mask applied -->\\n            <rect \\n                x=\\\"\").concat(x, \"\\\" \\n                y=\\\"\").concat(y, \"\\\" \\n                width=\\\"\").concat(this.width, \"\\\" \\n                height=\\\"\").concat(this.height, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                stroke-linecap=\\\"\").concat(this.cap, \"\\\"\\n                fill=\\\"white\\\"\\n                mask=\\\"url(#pieceMask)\\\"\\n            />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(PuzzlePieceShape, \"parameters\", {\n  width: {\n    min: 50,\n    max: 200,\n    \"default\": 120\n  },\n  height: {\n    min: 50,\n    max: 200,\n    \"default\": 160\n  },\n  notchRadius: {\n    min: 10,\n    max: 50,\n    \"default\": 30\n  },\n  notchOffset: {\n    min: 0,\n    max: 50,\n    \"default\": 20\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  },\n  cap: {\n    options: ['butt', 'round'],\n    \"default\": 'round'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PuzzlePieceShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/PuzzlePieceShape.js?");

/***/ }),

/***/ "./src/shapes/QuadSquaresShape.js":
/*!****************************************!*\
  !*** ./src/shapes/QuadSquaresShape.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a shape composed of four outlined, rounded squares arranged around\n * a central point.\n */\nvar QuadSquaresShape = /*#__PURE__*/function (_Shape) {\n  function QuadSquaresShape() {\n    _classCallCheck(this, QuadSquaresShape);\n    return _callSuper(this, QuadSquaresShape, arguments);\n  }\n  _inherits(QuadSquaresShape, _Shape);\n  return _createClass(QuadSquaresShape, [{\n    key: \"createRoundedRect\",\n    value: function createRoundedRect(x, y, width, height, radius) {\n      var commands = [// Start at top left after the corner radius\n      \"M \".concat(x + radius, \" \").concat(y), // Top line to right corner\n      \"H \".concat(x + width - radius), // Top right corner\n      \"A \".concat(radius, \" \").concat(radius, \" 0 0 1 \").concat(x + width, \" \").concat(y + radius), // Right line\n      \"V \".concat(y + height - radius), // Bottom right corner\n      \"A \".concat(radius, \" \").concat(radius, \" 0 0 1 \").concat(x + width - radius, \" \").concat(y + height), // Bottom line\n      \"H \".concat(x + radius), // Bottom left corner\n      \"A \".concat(radius, \" \").concat(radius, \" 0 0 1 \").concat(x, \" \").concat(y + height - radius), // Left line\n      \"V \".concat(y + radius), // Top left corner\n      \"A \".concat(radius, \" \").concat(radius, \" 0 0 1 \").concat(x + radius, \" \").concat(y), 'Z'];\n      return commands.join(' ');\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      // Apply scale factor to match viewBox\n      var scale = 0.8; // Adjust scale to fit -200,200 coordinate space\n      var size = this.size * scale;\n      var spacing = this.spacing * scale;\n      var cornerRadius = this.cornerRadius * scale;\n\n      // Center coordinates\n      var centerX = 0;\n      var centerY = 0;\n\n      // Define the positions for the four squares\n      var positions = [[0, -1],\n      // top\n      [1, 0],\n      // right\n      [0, 1],\n      // bottom\n      [-1, 0] // left\n      ];\n\n      // Create all squares\n      var squares = positions.map(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n          x = _ref2[0],\n          y = _ref2[1];\n        var squareX = centerX + x * spacing - size / 2;\n        var squareY = centerY + y * spacing - size / 2;\n        return _this.createRoundedRect(squareX, squareY, size, size, cornerRadius);\n      });\n      return squares.map(function (square) {\n        return \"\\n            <path \\n                d=\\\"\".concat(square, \"\\\"\\n                fill=\\\"none\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"2\\\"\\n            />\\n        \");\n      }).join('\\n');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(QuadSquaresShape, \"parameters\", {\n  size: {\n    min: 50,\n    max: 200,\n    \"default\": 100\n  },\n  spacing: {\n    min: 0,\n    max: 100,\n    \"default\": 30\n  },\n  cornerRadius: {\n    min: 0,\n    max: 50,\n    \"default\": 20\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (QuadSquaresShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/QuadSquaresShape.js?");

/***/ }),

/***/ "./src/shapes/QuantumWavesShape.js":
/*!*****************************************!*\
  !*** ./src/shapes/QuantumWavesShape.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a pattern resembling quantum waves or dripping paint, composed of\n * vertical streams of dots modulated by sine waves and noise.\n */\nvar QuantumWavesShape = /*#__PURE__*/function (_Shape) {\n  function QuantumWavesShape() {\n    _classCallCheck(this, QuantumWavesShape);\n    return _callSuper(this, QuantumWavesShape, arguments);\n  }\n  _inherits(QuantumWavesShape, _Shape);\n  return _createClass(QuantumWavesShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var streamCount = this.streamCount,\n        streamLength = this.streamLength,\n        dropSpacing = this.dropSpacing,\n        waveAmplitude = this.waveAmplitude,\n        waveFrequency = this.waveFrequency,\n        phaseOffset = this.phaseOffset,\n        noiseScale = this.noiseScale,\n        noiseStrength = this.noiseStrength,\n        dropSize = this.dropSize;\n      var elements = [];\n      var totalWidth = streamCount * dropSpacing;\n      var startX = -totalWidth / 2 + dropSpacing / 2;\n\n      // Calculate how many drops in each stream\n      var dropsPerStream = Math.floor(streamLength / dropSpacing) + 2;\n\n      // Create streams\n      for (var streamIndex = 0; streamIndex < streamCount; streamIndex++) {\n        var baseX = startX + streamIndex * dropSpacing;\n        var streamPhase = phaseOffset * Math.PI / 180 * streamIndex / streamCount;\n\n        // Create drops\n        for (var dropIndex = 0; dropIndex < dropsPerStream; dropIndex++) {\n          // Position along the stream (0-1)\n          var progress = dropIndex / dropsPerStream;\n\n          // Base y position\n          var y = -streamLength / 2 + progress * streamLength;\n\n          // Calculate sine wave offset\n          var sineOffset = waveAmplitude * Math.sin(2 * Math.PI * progress * waveFrequency + streamPhase);\n\n          // Calculate flow region intensity (middle has more flow)\n          var distFromMiddle = Math.abs(progress - 0.5);\n          var flowIntensity = void 0;\n          if (distFromMiddle < 0.2) {\n            // Full flow in middle\n            flowIntensity = 1.0;\n          } else if (distFromMiddle < 0.35) {\n            // Transition zone\n            flowIntensity = 1.0 - (distFromMiddle - 0.2) * 5;\n          } else {\n            // Minimal flow at ends\n            flowIntensity = 0.1;\n          }\n\n          // Add subtle noise to make it more organic\n          var noiseValue = this.getNoise(streamIndex * 0.2, progress * 2);\n\n          // Calculate noise influence (stronger in middle)\n          var noiseOffset = noiseValue * noiseStrength * 0.05 * flowIntensity;\n\n          // Final x position (sine wave + subtle noise)\n          var x = baseX + sineOffset + noiseOffset;\n\n          // Calculate dot size variation\n          var sizeFactor = 1.0;\n\n          // Size variation stronger in high-flow areas\n          if (flowIntensity > 0.5) {\n            var sizeNoise = this.getNoise(streamIndex * 0.3 + 100, progress * 3 + 200);\n\n            // Make dots larger at max wave amplitude\n            var wavePosition = Math.abs(Math.sin(2 * Math.PI * progress * waveFrequency + streamPhase));\n\n            // Combine wave position and noise for size variation\n            var fixedVariation = 0.3; // Built-in variation amount\n            sizeFactor = 1.0 + (wavePosition * 0.7 + sizeNoise * 0.3) * fixedVariation * 2;\n          }\n\n          // Final size with a minimum to prevent negative values\n          var finalSize = Math.max(0.5, dropSize * sizeFactor);\n\n          // Add dot\n          elements.push(\"<circle \\n                    cx=\\\"\".concat(x, \"\\\" \\n                    cy=\\\"\").concat(y, \"\\\" \\n                    r=\\\"\").concat(finalSize / 2, \"\\\" \\n                    fill=\\\"white\\\"\\n                />\"));\n        }\n      }\n      return elements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(QuantumWavesShape, \"parameters\", {\n  streamCount: {\n    min: 4,\n    max: 32,\n    \"default\": 12\n  },\n  streamLength: {\n    min: 50,\n    max: 200,\n    \"default\": 150\n  },\n  dropSpacing: {\n    min: 5,\n    max: 25,\n    \"default\": 11\n  },\n  waveAmplitude: {\n    min: 0,\n    max: 50,\n    \"default\": 30\n  },\n  waveFrequency: {\n    min: 0.1,\n    max: 4,\n    \"default\": 0.5\n  },\n  dropSize: {\n    min: 1,\n    max: 8,\n    \"default\": 5\n  },\n  phaseOffset: {\n    min: -180,\n    max: 180,\n    \"default\": -180\n  },\n  noiseScale: {\n    min: 0.01,\n    max: 0.5,\n    \"default\": 0.31\n  },\n  noiseStrength: {\n    min: 0,\n    max: 100,\n    \"default\": 100\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (QuantumWavesShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/QuantumWavesShape.js?");

/***/ }),

/***/ "./src/shapes/RadialBars.js":
/*!**********************************!*\
  !*** ./src/shapes/RadialBars.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a radial pattern of bar segments (annulus sectors) with randomized\n * lengths.\n */\nvar RadialBars = /*#__PURE__*/function (_Shape) {\n  function RadialBars() {\n    _classCallCheck(this, RadialBars);\n    return _callSuper(this, RadialBars, arguments);\n  }\n  _inherits(RadialBars, _Shape);\n  return _createClass(RadialBars, [{\n    key: \"generateShape\",\n    value:\n    /**\n     * Generates the SVG elements for the RadialBars shape.\n     * Accesses parameters via `this.parameterName`.\n     * @param {object} params - An object containing the parameter values for this shape instance (available as this.parameterName).\n     * @returns {string} SVG string containing <path> elements forming the radial bars.\n     */\n    function generateShape(params) {\n      // Ensure outerRadiusMax is always greater than innerRadius to allow for bar length\n      var outerRadiusMax = Math.max(this.outerRadiusMax, this.innerRadius + 1);\n      var innerRadius = this.innerRadius;\n      // Ensure there's at least one bar to avoid division by zero\n      var numBars = Math.max(1, this.numBars);\n\n      // Calculate angular step, bar width, and gap width in radians\n      var angleStep = 2 * Math.PI / numBars;\n      var barAngle = angleStep * this.barWidthRatio;\n      var gapAngle = angleStep * (1 - this.barWidthRatio);\n\n      // Calculate maximum and minimum possible lengths for the bars\n      var maxPossibleLength = outerRadiusMax - innerRadius;\n      // Ensure minimum length is not negative if ratio is 0\n      var minActualLength = Math.max(0, maxPossibleLength * this.minBarLengthRatio);\n      var paths = ''; // Accumulator for SVG path strings\n\n      for (var i = 0; i < numBars; i++) {\n        // Calculate start and end angles for the current bar, centering it in its allocated slot\n        var currentStartAngle = i * angleStep + gapAngle / 2;\n        var currentEndAngle = currentStartAngle + barAngle;\n\n        // Determine the actual length and outer radius for this specific bar using seeded randomness\n        var randomFactor = this.random(); // Value between 0 and 1 from seeded RNG\n        var actualLength = minActualLength + randomFactor * (maxPossibleLength - minActualLength);\n        var currentOuterRadius = innerRadius + actualLength;\n\n        // Skip drawing if the bar angle is negligible (prevents rendering issues)\n        if (barAngle < 0.001) continue;\n\n        // Calculate the four corner points of the wedge using trigonometry\n        // Points are calculated in a counter-clockwise order: inner-start, outer-start, outer-end, inner-end\n        var p1x = innerRadius * Math.cos(currentStartAngle);\n        var p1y = innerRadius * Math.sin(currentStartAngle);\n        var p2x = currentOuterRadius * Math.cos(currentStartAngle);\n        var p2y = currentOuterRadius * Math.sin(currentStartAngle);\n        var p3x = currentOuterRadius * Math.cos(currentEndAngle);\n        var p3y = currentOuterRadius * Math.sin(currentEndAngle);\n        var p4x = innerRadius * Math.cos(currentEndAngle);\n        var p4y = innerRadius * Math.sin(currentEndAngle);\n\n        // Construct the SVG path data string for the wedge (a segment of an annulus)\n        // M = Move to start point (inner radius, start angle)\n        // L = Line to outer radius, start angle\n        // A = Arc along outer radius (rx, ry, x-axis-rotation, large-arc-flag=0, sweep-flag=1 for CCW)\n        // L = Line to inner radius, end angle\n        // A = Arc along inner radius back to start (rx, ry, x-axis-rotation, large-arc-flag=0, sweep-flag=0 for CW)\n        // Z = Close path\n        // Using toFixed(3) for cleaner SVG output and floating point precision control\n        var pathData = \"\\n                M \".concat(p1x.toFixed(3), \" \").concat(p1y.toFixed(3), \"\\n                L \").concat(p2x.toFixed(3), \" \").concat(p2y.toFixed(3), \"\\n                A \").concat(currentOuterRadius.toFixed(3), \" \").concat(currentOuterRadius.toFixed(3), \" 0 0 1 \").concat(p3x.toFixed(3), \" \").concat(p3y.toFixed(3), \"\\n                L \").concat(p4x.toFixed(3), \" \").concat(p4y.toFixed(3), \"\\n                A \").concat(innerRadius.toFixed(3), \" \").concat(innerRadius.toFixed(3), \" 0 0 0 \").concat(p1x.toFixed(3), \" \").concat(p1y.toFixed(3), \"\\n                Z\\n            \");\n\n        // Add the generated path to the accumulator string\n        paths += \"<path d=\\\"\".concat(pathData, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\\n\");\n      }\n\n      // Return the combined SVG string containing all the path elements\n      return paths;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(RadialBars, \"parameters\", {\n  numBars: {\n    type: 'number',\n    min: 5,\n    max: 150,\n    // Increased max for potentially finer detail\n    step: 1,\n    \"default\": 60,\n    label: 'Number of Bars'\n  },\n  innerRadius: {\n    type: 'number',\n    min: 0.1,\n    // Use a small minimum instead of 0 to avoid degenerate arcs\n    max: 80,\n    // Ensure max inner radius is less than max outer radius\n    step: 0.1,\n    \"default\": 10,\n    label: 'Inner Radius'\n  },\n  outerRadiusMax: {\n    type: 'number',\n    min: 10,\n    // Ensure min outer radius is reasonable\n    max: 100,\n    // Keep within the -100 to +100 boundary\n    step: 1,\n    \"default\": 95,\n    label: 'Max Outer Radius'\n  },\n  minBarLengthRatio: {\n    type: 'number',\n    min: 0.0,\n    max: 1.0,\n    step: 0.05,\n    \"default\": 0.2,\n    label: 'Min Length Ratio' // Ratio of max possible length (outerRadiusMax - innerRadius)\n  },\n  barWidthRatio: {\n    type: 'number',\n    min: 0.1,\n    // Minimum width to ensure visibility\n    max: 1.0,\n    // 1.0 means no gap between bars\n    step: 0.05,\n    \"default\": 0.8,\n    label: 'Bar Width Ratio' // Proportion of angular space each bar occupies\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RadialBars);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/RadialBars.js?");

/***/ }),

/***/ "./src/shapes/RadialBurst.js":
/*!***********************************!*\
  !*** ./src/shapes/RadialBurst.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a radial burst of capsule-shaped beams radiating from an optional\n * central circle.\n */\nvar RadialBurst = /*#__PURE__*/function (_Shape) {\n  function RadialBurst() {\n    _classCallCheck(this, RadialBurst);\n    return _callSuper(this, RadialBurst, arguments);\n  }\n  _inherits(RadialBurst, _Shape);\n  return _createClass(RadialBurst, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var svgElements = '';\n\n      // Add the central circle if radius > 0\n      if (this.centerRadius > 0) {\n        svgElements += \"<circle cx=\\\"0\\\" cy=\\\"0\\\" r=\\\"\".concat(this.centerRadius, \"\\\" fill=\\\"white\\\" />\");\n      }\n      var numBeams = Math.round(this.numBeams); // Ensure integer value\n      if (numBeams <= 0 || this.beamLength <= 0 || this.beamWidth <= 0) {\n        return svgElements; // Return only circle if beams are invalid\n      }\n      var angleIncrement = 2 * Math.PI / numBeams;\n      var halfWidth = this.beamWidth / 2;\n      var innerDist = this.centerRadius + this.innerGap; // Distance from center to inner end of beam body\n      var outerDist = innerDist + this.beamLength; // Distance from center to outer end of beam body\n\n      // Check if beams have any length to draw\n      if (innerDist < outerDist && halfWidth > 0) {\n        for (var i = 0; i < numBeams; i++) {\n          var angle = angleIncrement * i;\n          var cosAngle = Math.cos(angle);\n          var sinAngle = Math.sin(angle);\n\n          // Calculate centers of the inner and outer semicircles of the capsule\n          var innerX = innerDist * cosAngle;\n          var innerY = innerDist * sinAngle;\n          var outerX = outerDist * cosAngle;\n          var outerY = outerDist * sinAngle;\n\n          // Calculate the four points defining the straight sides of the capsule\n          // Offset perpendicular to the beam direction\n          var offsetX = halfWidth * sinAngle;\n          var offsetY = halfWidth * cosAngle;\n          var p1x = innerX + offsetX;\n          var p1y = innerY - offsetY;\n          var p2x = outerX + offsetX;\n          var p2y = outerY - offsetY;\n          var p3x = outerX - offsetX;\n          var p3y = outerY + offsetY;\n          var p4x = innerX - offsetX;\n          var p4y = innerY + offsetY;\n\n          // Construct the path data for the capsule shape\n          // M p1 L p2 A hw,hw 0 0 1 p3 L p4 A hw,hw 0 0 1 p1 Z\n          var pathData = \"\\n                    M \".concat(p1x.toFixed(3), \" \").concat(p1y.toFixed(3), \"\\n                    L \").concat(p2x.toFixed(3), \" \").concat(p2y.toFixed(3), \"\\n                    A \").concat(halfWidth.toFixed(3), \" \").concat(halfWidth.toFixed(3), \" 0 0 1 \").concat(p3x.toFixed(3), \" \").concat(p3y.toFixed(3), \"\\n                    L \").concat(p4x.toFixed(3), \" \").concat(p4y.toFixed(3), \"\\n                    A \").concat(halfWidth.toFixed(3), \" \").concat(halfWidth.toFixed(3), \" 0 0 1 \").concat(p1x.toFixed(3), \" \").concat(p1y.toFixed(3), \"\\n                    Z\\n                \");\n          svgElements += \"<path d=\\\"\".concat(pathData, \"\\\" fill=\\\"white\\\" />\");\n        }\n      }\n      return svgElements;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(RadialBurst, \"parameters\", {\n  numBeams: {\n    type: 'number',\n    min: 3,\n    max: 30,\n    step: 1,\n    \"default\": 16,\n    label: 'Number of Beams' // Optional label for UI\n  },\n  beamLength: {\n    type: 'number',\n    min: 10,\n    max: 75,\n    // Adjusted to keep within bounds\n    step: 1,\n    \"default\": 55,\n    label: 'Beam Length'\n  },\n  beamWidth: {\n    type: 'number',\n    min: 2,\n    max: 25,\n    step: 1,\n    \"default\": 10,\n    label: 'Beam Width'\n  },\n  centerRadius: {\n    type: 'number',\n    min: 0,\n    max: 20,\n    step: 1,\n    \"default\": 6,\n    label: 'Center Circle Radius'\n  },\n  innerGap: {\n    type: 'number',\n    min: 0,\n    max: 25,\n    // Adjusted to keep within bounds\n    step: 1,\n    \"default\": 5,\n    label: 'Gap from Center'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RadialBurst);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/RadialBurst.js?");

/***/ }),

/***/ "./src/shapes/RadialGridShape.js":
/*!***************************************!*\
  !*** ./src/shapes/RadialGridShape.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a grid of circles where radius varies based on distance from a\n * pattern center, with optional grid rounding.\n */\nvar RadialGridShape = /*#__PURE__*/function (_Shape) {\n  function RadialGridShape() {\n    _classCallCheck(this, RadialGridShape);\n    return _callSuper(this, RadialGridShape, arguments);\n  }\n  _inherits(RadialGridShape, _Shape);\n  return _createClass(RadialGridShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var circles = [];\n      var gridOffset = (this.gridSize - 1) / 2;\n      var patternCenter = {\n        x: this.patternOffsetX,\n        y: this.patternOffsetY\n      };\n      for (var row = 0; row < this.gridSize; row++) {\n        for (var col = 0; col < this.gridSize; col++) {\n          // Calculate grid position (always centered)\n          var baseX = (col - gridOffset) * this.spacing;\n          var baseY = (row - gridOffset) * this.spacing;\n\n          // Calculate distance from grid center for circle interpolation\n          var distanceFromGridCenter = Math.sqrt(Math.pow(baseX, 2) + Math.pow(baseY, 2));\n          var maxGridDistance = gridOffset * this.spacing;\n\n          // Skip circles outside the rounded grid boundary\n          if (distanceFromGridCenter > maxGridDistance * (1 + this.gridRound)) {\n            continue;\n          }\n\n          // Interpolate position towards circular grid (staying centered)\n          var angle = Math.atan2(baseY, baseX);\n          var interpolationFactor = this.gridRound * Math.min(1, distanceFromGridCenter / maxGridDistance);\n          var x = baseX * (1 - interpolationFactor) + Math.cos(angle) * distanceFromGridCenter * interpolationFactor;\n          var y = baseY * (1 - interpolationFactor) + Math.sin(angle) * distanceFromGridCenter * interpolationFactor;\n\n          // Calculate distance from pattern center for radius scaling\n          var distanceFromPattern = Math.sqrt(Math.pow(x - patternCenter.x, 2) + Math.pow(y - patternCenter.y, 2));\n\n          // Calculate radius based on distance from pattern center\n          var maxDistance = Math.sqrt(2) * (gridOffset * this.spacing);\n          var radiusRatio = Math.max(0, 1 - distanceFromPattern / maxDistance);\n          var radius = this.minRadius + (this.maxRadius - this.minRadius) * Math.pow(radiusRatio, this.radiusFalloff);\n          circles.push(\"<circle \\n                    cx=\\\"\".concat(x, \"\\\" \\n                    cy=\\\"\").concat(y, \"\\\" \\n                    r=\\\"\").concat(radius, \"\\\"\\n                    fill=\\\"white\\\"\\n                />\"));\n        }\n      }\n      return circles.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(RadialGridShape, \"parameters\", {\n  gridSize: {\n    min: 3,\n    max: 6,\n    \"default\": 6\n  },\n  maxRadius: {\n    min: 5,\n    max: 30,\n    \"default\": 15\n  },\n  minRadius: {\n    min: 1,\n    max: 15,\n    \"default\": 2\n  },\n  spacing: {\n    min: 20,\n    max: 60,\n    \"default\": 33\n  },\n  gridRound: {\n    min: 0,\n    max: 1,\n    \"default\": 0.3\n  },\n  patternOffsetX: {\n    min: -50,\n    max: 50,\n    \"default\": 0\n  },\n  patternOffsetY: {\n    min: -50,\n    max: 50,\n    \"default\": 0\n  },\n  radiusFalloff: {\n    min: 0.5,\n    max: 2.5,\n    \"default\": 1.5\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RadialGridShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/RadialGridShape.js?");

/***/ }),

/***/ "./src/shapes/RadialLines.js":
/*!***********************************!*\
  !*** ./src/shapes/RadialLines.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates lines radiating from an inner radius to an outer radius, with\n * optional skew.\n */\nvar RadialLinesShape = /*#__PURE__*/function (_Shape) {\n  function RadialLinesShape() {\n    _classCallCheck(this, RadialLinesShape);\n    return _callSuper(this, RadialLinesShape, arguments);\n  }\n  _inherits(RadialLinesShape, _Shape);\n  return _createClass(RadialLinesShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var lines = [];\n      var angleStep = 2 * Math.PI / this.lineCount;\n      var skewRad = this.skew * Math.PI / 180;\n      for (var i = 0; i < this.lineCount; i++) {\n        var baseAngle = i * angleStep;\n\n        // Calculate start point\n        var x1 = this.innerRadius * Math.cos(baseAngle);\n        var y1 = this.innerRadius * Math.sin(baseAngle);\n\n        // Calculate end point with skew\n        var skewedAngle = baseAngle + skewRad;\n        var x2 = this.outerRadius * Math.cos(skewedAngle);\n        var y2 = this.outerRadius * Math.sin(skewedAngle);\n        lines.push(\"<line \\n                x1=\\\"\".concat(x1, \"\\\" \\n                y1=\\\"\").concat(y1, \"\\\" \\n                x2=\\\"\").concat(x2, \"\\\" \\n                y2=\\\"\").concat(y2, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                stroke-linecap=\\\"\").concat(this.lineCap, \"\\\"\\n            />\"));\n      }\n      return lines.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(RadialLinesShape, \"parameters\", {\n  innerRadius: {\n    min: 0,\n    max: 100,\n    \"default\": 39\n  },\n  outerRadius: {\n    min: 50,\n    max: 150,\n    \"default\": 77\n  },\n  lineCount: {\n    min: 3,\n    max: 24,\n    \"default\": 12\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 4\n  },\n  lineCap: {\n    options: ['butt', 'round'],\n    \"default\": 'butt'\n  },\n  skew: {\n    min: -90,\n    max: 90,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RadialLinesShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/RadialLines.js?");

/***/ }),

/***/ "./src/shapes/RadialTriangles.js":
/*!***************************************!*\
  !*** ./src/shapes/RadialTriangles.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a radial pattern of triangles pointing outwards from an inner\n * radius, with adjustable width, sharpness, and skew.\n */\nvar RadialTriangles = /*#__PURE__*/function (_Shape) {\n  function RadialTriangles() {\n    _classCallCheck(this, RadialTriangles);\n    return _callSuper(this, RadialTriangles, arguments);\n  }\n  _inherits(RadialTriangles, _Shape);\n  return _createClass(RadialTriangles, [{\n    key: \"generateTriangle\",\n    value: function generateTriangle(angle) {\n      // Convert skew to radians and apply\n      var skewRad = this.skew * Math.PI / 180;\n      var baseAngle = angle + skewRad;\n\n      // Calculate inner point\n      var innerX = this.innerRadius * Math.cos(angle);\n      var innerY = this.innerRadius * Math.sin(angle);\n\n      // Calculate width angle based on sharpness factor\n      var widthAngle = this.width / this.outerRadius * (this.sharpness / 100);\n\n      // Calculate outer points with width spread\n      var leftX = this.outerRadius * Math.cos(baseAngle - widthAngle);\n      var leftY = this.outerRadius * Math.sin(baseAngle - widthAngle);\n      var rightX = this.outerRadius * Math.cos(baseAngle + widthAngle);\n      var rightY = this.outerRadius * Math.sin(baseAngle + widthAngle);\n\n      // Generate path data\n      return \"M \".concat(innerX, \",\").concat(innerY, \" \\n                L \").concat(leftX, \",\").concat(leftY, \" \\n                L \").concat(rightX, \",\").concat(rightY, \" Z\");\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var triangles = [];\n      var angleStep = 2 * Math.PI / this.count;\n\n      // Generate triangles in radial pattern\n      for (var i = 0; i < this.count; i++) {\n        var angle = i * angleStep;\n        triangles.push(\"<path \\n                d=\\\"\".concat(this.generateTriangle(angle), \"\\\"\\n                fill=\\\"\").concat(this.mode === 'fill' ? 'white' : 'none', \"\\\"\\n                stroke=\\\"\").concat(this.mode === 'stroke' ? 'white' : 'none', \"\\\"\\n                stroke-width=\\\"\").concat(this.mode === 'stroke' ? this.thickness : 0, \"\\\"\\n                stroke-linejoin=\\\"miter\\\"\\n            />\"));\n      }\n      return \"<g>\".concat(triangles.join(''), \"</g>\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(RadialTriangles, \"parameters\", {\n  innerRadius: {\n    min: 0,\n    max: 100,\n    \"default\": 39\n  },\n  outerRadius: {\n    min: 50,\n    max: 150,\n    \"default\": 77\n  },\n  count: {\n    min: 3,\n    max: 16,\n    \"default\": 8\n  },\n  width: {\n    min: 10,\n    max: 60,\n    \"default\": 30\n  },\n  sharpness: {\n    min: 10,\n    max: 90,\n    \"default\": 50\n  },\n  skew: {\n    min: -90,\n    max: 90,\n    \"default\": 0\n  },\n  mode: {\n    options: ['fill', 'stroke'],\n    \"default\": 'fill'\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RadialTriangles);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/RadialTriangles.js?");

/***/ }),

/***/ "./src/shapes/RainbowArcs.js":
/*!***********************************!*\
  !*** ./src/shapes/RainbowArcs.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a stack of concentric arcs with adjustable count, spacing,\n * thickness, angle span, and orientation.\n */\nvar RainbowArcs = /*#__PURE__*/function (_Shape) {\n  function RainbowArcs() {\n    _classCallCheck(this, RainbowArcs);\n    return _callSuper(this, RainbowArcs, arguments);\n  }\n  _inherits(RainbowArcs, _Shape);\n  return _createClass(RainbowArcs, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var elements = [];\n      var radians = function radians(angle) {\n        return angle * Math.PI / 180;\n      };\n\n      // Calculate rotation based on direction - only right angles or 45 angles\n      var rotation = 0;\n      switch (this.direction) {\n        case 'right':\n          rotation = 0;\n          break;\n        case 'down-right':\n          rotation = 45;\n          break;\n        case 'down':\n          rotation = 90;\n          break;\n        case 'down-left':\n          rotation = 135;\n          break;\n        case 'left':\n          rotation = 180;\n          break;\n        case 'up-left':\n          rotation = 225;\n          break;\n        case 'up':\n          rotation = 270;\n          break;\n        case 'up-right':\n          rotation = 315;\n          break;\n      }\n\n      // Keep outer radius fixed\n      var outerRadius = this.radius;\n\n      // Calculate inner radius (smallest arc)\n      var minRadius = Math.max(10, outerRadius * 0.2); // Ensure minimum size for smallest arc\n\n      // Calculate spacing between arcs\n      var availableSpace = outerRadius - minRadius;\n      var calculatedSpacing = this.arcCount > 1 ? availableSpace / (this.arcCount - 1) : 0;\n      var finalSpacing = Math.min(this.spacing, calculatedSpacing);\n\n      // Create container group with rotation\n      elements.push(\"<g transform=\\\"rotate(\".concat(rotation, \")\\\">\"));\n      var startAngleRad = radians(this.startAngle);\n      var endAngleRad = radians(this.endAngle);\n      var sweepFlag = endAngleRad > startAngleRad ? 1 : 0;\n      var largeArcFlag = Math.abs(this.endAngle - this.startAngle) > 180 ? 1 : 0;\n\n      // Draw arcs from outer to inner\n      for (var i = 0; i < this.arcCount; i++) {\n        // Calculate radius for current arc - evenly distribute from outer to inner\n        var currentRadius = void 0;\n        if (this.arcCount > 1) {\n          currentRadius = outerRadius - i * finalSpacing;\n        } else {\n          currentRadius = outerRadius;\n        }\n\n        // Ensure we don't go below minimum radius\n        if (currentRadius < minRadius) break;\n\n        // Use consistent thickness for all arcs\n        var arcThickness = this.thickness;\n\n        // Calculate start and end points\n        var startX = Math.cos(startAngleRad) * currentRadius;\n        var startY = Math.sin(startAngleRad) * currentRadius;\n        var endX = Math.cos(endAngleRad) * currentRadius;\n        var endY = Math.sin(endAngleRad) * currentRadius;\n\n        // Create path for this arc\n        var path = \"<path \\n                d=\\\"M \".concat(startX, \" \").concat(startY, \" A \").concat(currentRadius, \" \").concat(currentRadius, \" 0 \").concat(largeArcFlag, \" \").concat(sweepFlag, \" \").concat(endX, \" \").concat(endY, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(arcThickness, \"\\\"\\n                fill=\\\"none\\\"\\n                stroke-linecap=\\\"\").concat(this.cornerRadius > 0 ? 'round' : 'butt', \"\\\"\\n            />\");\n        elements.push(path);\n      }\n      elements.push('</g>');\n      return elements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(RainbowArcs, \"parameters\", {\n  radius: {\n    min: 50,\n    max: 100,\n    \"default\": 90\n  },\n  arcCount: {\n    min: 2,\n    max: 12,\n    \"default\": 5\n  },\n  spacing: {\n    min: 5,\n    max: 50,\n    \"default\": 15\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 8\n  },\n  startAngle: {\n    min: -180,\n    max: 180,\n    \"default\": -135\n  },\n  endAngle: {\n    min: -180,\n    max: 180,\n    \"default\": 135\n  },\n  cornerRadius: {\n    min: 0,\n    max: 1,\n    \"default\": 0\n  },\n  direction: {\n    options: ['right', 'down-right', 'down', 'down-left', 'left', 'up-left', 'up', 'up-right'],\n    \"default\": 'up'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RainbowArcs);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/RainbowArcs.js?");

/***/ }),

/***/ "./src/shapes/RectangleGrid.js":
/*!*************************************!*\
  !*** ./src/shapes/RectangleGrid.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a simple grid of rectangular cells with fill or stroke options.\n */\nvar RectangleGrid = /*#__PURE__*/function (_Shape) {\n  function RectangleGrid() {\n    _classCallCheck(this, RectangleGrid);\n    return _callSuper(this, RectangleGrid, arguments);\n  }\n  _inherits(RectangleGrid, _Shape);\n  return _createClass(RectangleGrid, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var cells = [];\n\n      // Calculate cell dimensions accounting for spacing\n      var cellWidth = (this.width - this.spacing * (this.columns - 1)) / this.columns;\n      var cellHeight = (this.height - this.spacing * (this.rows - 1)) / this.rows;\n\n      // Calculate starting position to center the grid\n      var startX = -this.width / 2;\n      var startY = -this.height / 2;\n\n      // Generate grid of rectangles\n      for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n          // Calculate position including spacing\n          var x = startX + j * (cellWidth + this.spacing);\n          var y = startY + i * (cellHeight + this.spacing);\n          cells.push(\"<rect \\n                    x=\\\"\".concat(x, \"\\\"\\n                    y=\\\"\").concat(y, \"\\\"\\n                    width=\\\"\").concat(cellWidth, \"\\\"\\n                    height=\\\"\").concat(cellHeight, \"\\\"\\n                    fill=\\\"\").concat(this.mode === 'fill' ? 'white' : 'none', \"\\\"\\n                    stroke=\\\"\").concat(this.mode === 'stroke' ? 'white' : 'none', \"\\\"\\n                    stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                />\"));\n        }\n      }\n      return cells.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(RectangleGrid, \"parameters\", {\n  width: {\n    min: 100,\n    max: 200,\n    \"default\": 150\n  },\n  height: {\n    min: 100,\n    max: 200,\n    \"default\": 150\n  },\n  rows: {\n    min: 1,\n    max: 8,\n    \"default\": 5\n  },\n  columns: {\n    min: 1,\n    max: 8,\n    \"default\": 5\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  },\n  spacing: {\n    min: 0,\n    max: 20,\n    \"default\": 0\n  },\n  mode: {\n    options: ['stroke', 'fill'],\n    \"default\": 'stroke'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RectangleGrid);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/RectangleGrid.js?");

/***/ }),

/***/ "./src/shapes/RecursiveCrescent.js":
/*!*****************************************!*\
  !*** ./src/shapes/RecursiveCrescent.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates multiple nested crescent shapes with decreasing size and\n * potentially rotated offsets.\n */\nvar RecursiveCrescent = /*#__PURE__*/function (_Shape) {\n  function RecursiveCrescent() {\n    _classCallCheck(this, RecursiveCrescent);\n    return _callSuper(this, RecursiveCrescent, arguments);\n  }\n  _inherits(RecursiveCrescent, _Shape);\n  return _createClass(RecursiveCrescent, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Calculate valid ring count based on parameters\n      var maxRings = Math.min(this.rings, Math.floor(this.radius / this.spacing));\n\n      // If no valid rings, return an empty SVG\n      if (maxRings <= 0) {\n        return '<g></g>';\n      }\n      var crescents = [];\n      var baseAngle = this.rotation * Math.PI / 180;\n\n      // Create a unique mask ID for this instance\n      var maskId = \"crescent-mask-\".concat(Math.random().toString(36).substr(2, 9));\n\n      // Start with mask definition\n      crescents.push(\"\\n            <defs>\\n                <mask id=\\\"\".concat(maskId, \"\\\">\\n                    <rect x=\\\"-200\\\" y=\\\"-200\\\" width=\\\"400\\\" height=\\\"400\\\" fill=\\\"black\\\"/>\\n        \"));\n\n      // Generate each recursive ring\n      for (var i = 0; i < maxRings; i++) {\n        // Calculate current ring properties with safety checks\n        var scale = Math.pow(0.85, i);\n        var currentRadius = Math.max(5, this.radius - i * this.spacing);\n        var safeThickness = Math.min(currentRadius * 0.8, this.thickness * scale);\n\n        // Calculate offset with smooth progression\n        var offsetAngle = baseAngle + i * Math.PI / 16;\n        var safeOffsetDistance = Math.min(this.offset / 100 * currentRadius, currentRadius * 0.6 // Limit offset to prevent excessive overlap\n        );\n        var offsetX = safeOffsetDistance * Math.cos(offsetAngle);\n        var offsetY = safeOffsetDistance * Math.sin(offsetAngle);\n\n        // The inner radius must be positive and less than the outer radius\n        var innerRadius = Math.max(1, currentRadius - safeThickness);\n\n        // Draw the crescent\n        crescents.push(\"\\n                <circle \\n                    cx=\\\"0\\\" \\n                    cy=\\\"0\\\" \\n                    r=\\\"\".concat(currentRadius, \"\\\"\\n                    fill=\\\"white\\\"\\n                />\\n                <circle \\n                    cx=\\\"\").concat(offsetX, \"\\\" \\n                    cy=\\\"\").concat(offsetY, \"\\\" \\n                    r=\\\"\").concat(innerRadius, \"\\\"\\n                    fill=\\\"black\\\"\\n                />\\n            \"));\n      }\n\n      // Close mask definition\n      crescents.push(\"\\n                </mask>\\n            </defs>\\n        \");\n\n      // Add the final masked shape\n      crescents.push(\"\\n            <rect \\n                x=\\\"-200\\\" \\n                y=\\\"-200\\\" \\n                width=\\\"400\\\" \\n                height=\\\"400\\\"\\n                fill=\\\"white\\\"\\n                mask=\\\"url(#\".concat(maskId, \")\\\"\\n            />\\n        \"));\n      return crescents.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(RecursiveCrescent, \"parameters\", {\n  radius: {\n    min: 20,\n    max: 150,\n    \"default\": 80\n  },\n  rings: {\n    min: 1,\n    max: 8,\n    \"default\": 4\n  },\n  thickness: {\n    min: 1,\n    max: 50,\n    \"default\": 15\n  },\n  spacing: {\n    min: 5,\n    max: 50,\n    \"default\": 20\n  },\n  rotation: {\n    min: -360,\n    max: 360,\n    \"default\": -90\n  },\n  offset: {\n    min: 0,\n    max: 100,\n    \"default\": 30\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RecursiveCrescent);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/RecursiveCrescent.js?");

/***/ }),

/***/ "./src/shapes/RecursiveSqrdCircles.js":
/*!********************************************!*\
  !*** ./src/shapes/RecursiveSqrdCircles.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a recursive pattern alternating between squares and circle cutouts\n * using SVG masks.\n */\nvar RecursiveSqrdCircles = /*#__PURE__*/function (_Shape) {\n  function RecursiveSqrdCircles() {\n    _classCallCheck(this, RecursiveSqrdCircles);\n    return _callSuper(this, RecursiveSqrdCircles, arguments);\n  }\n  _inherits(RecursiveSqrdCircles, _Shape);\n  return _createClass(RecursiveSqrdCircles, [{\n    key: \"generateMaskId\",\n    value: function generateMaskId(iteration) {\n      return \"square-circle-mask-\".concat(iteration, \"-\").concat(Math.random().toString(36).substr(2, 9));\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      var shapes = [];\n      var defs = ['<defs>'];\n\n      // Function to create one iteration\n      var _createIteration = function createIteration(size, rotation, iteration) {\n        if (iteration >= _this.iterations) return '';\n\n        // Generate unique mask ID for this iteration\n        var maskId = _this.generateMaskId(iteration);\n\n        // Create mask definition for this iteration\n        defs.push(\"\\n                <mask id=\\\"\".concat(maskId, \"\\\">\\n                    <rect x=\\\"\").concat(-size / 2, \"\\\" y=\\\"\").concat(-size / 2, \"\\\" width=\\\"\").concat(size, \"\\\" height=\\\"\").concat(size, \"\\\" fill=\\\"white\\\"/>\\n                    <circle cx=\\\"0\\\" cy=\\\"0\\\" r=\\\"\").concat(size / 2, \"\\\" fill=\\\"black\\\"/>\\n                </mask>\\n            \"));\n\n        // Calculate next iteration size\n        var nextSize = size * _this.scale;\n\n        // Create current square with mask\n        var square = \"\\n                <rect \\n                    x=\\\"\".concat(-size / 2, \"\\\" \\n                    y=\\\"\").concat(-size / 2, \"\\\" \\n                    width=\\\"\").concat(size, \"\\\" \\n                    height=\\\"\").concat(size, \"\\\"\\n                    transform=\\\"rotate(\").concat(rotation, \")\\\"\\n                    fill=\\\"white\\\"\\n                    mask=\\\"url(#\").concat(maskId, \")\\\"\\n                />\\n            \");\n\n        // Recursively create next iteration\n        return square + _createIteration(nextSize, rotation + _this.rotation, iteration + 1);\n      };\n\n      // Close defs\n      defs.push('</defs>');\n\n      // Generate the complete pattern\n      var pattern = _createIteration(this.size, 0, 0);\n      return defs.join('') + pattern;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(RecursiveSqrdCircles, \"parameters\", {\n  size: {\n    min: 50,\n    max: 200,\n    \"default\": 150\n  },\n  iterations: {\n    min: 1,\n    max: 6,\n    \"default\": 4\n  },\n  scale: {\n    min: 0.2,\n    max: 0.8,\n    \"default\": 0.6\n  },\n  rotation: {\n    min: -90,\n    max: 90,\n    \"default\": 90\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RecursiveSqrdCircles);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/RecursiveSqrdCircles.js?");

/***/ }),

/***/ "./src/shapes/RhombusPattern.js":
/*!**************************************!*\
  !*** ./src/shapes/RhombusPattern.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a grid pattern of outlined rhombuses (diamonds), each optionally\n * containing a smaller inner rhombus and connecting lines.\n */\nvar RhombusPattern = /*#__PURE__*/function (_Shape) {\n  function RhombusPattern() {\n    _classCallCheck(this, RhombusPattern);\n    return _callSuper(this, RhombusPattern, arguments);\n  }\n  _inherits(RhombusPattern, _Shape);\n  return _createClass(RhombusPattern, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var shapes = [];\n      var gridCount = Math.floor(this.gridSize);\n      var totalSize = (this.diamondSize + this.spacing) * gridCount;\n      var startX = -totalSize / 2 + (this.diamondSize + this.spacing) / 2;\n      var startY = -totalSize / 2 + (this.diamondSize + this.spacing) / 2;\n      for (var row = 0; row < gridCount; row++) {\n        for (var col = 0; col < gridCount; col++) {\n          var x = startX + col * (this.diamondSize + this.spacing);\n          var y = startY + row * (this.diamondSize + this.spacing);\n\n          // Outer diamond points\n          var outerPoints = [[x, y - this.diamondSize / 2], [x + this.diamondSize / 2, y], [x, y + this.diamondSize / 2], [x - this.diamondSize / 2, y]];\n\n          // Draw outer diamond\n          shapes.push(\"<path \\n                    d=\\\"M \".concat(outerPoints[0][0], \" \").concat(outerPoints[0][1], \" \\n                       L \").concat(outerPoints[1][0], \" \").concat(outerPoints[1][1], \" \\n                       L \").concat(outerPoints[2][0], \" \").concat(outerPoints[2][1], \" \\n                       L \").concat(outerPoints[3][0], \" \").concat(outerPoints[3][1], \" Z\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                    stroke-linecap=\\\"\").concat(this.lineCap, \"\\\"\\n                    fill=\\\"none\\\"\\n                />\"));\n\n          // Only draw inner diamond and connecting lines if innerRatio > 0.1\n          if (this.innerRatio > 0.1) {\n            var innerSize = this.diamondSize * this.innerRatio;\n            var innerPoints = [[x, y - innerSize / 2], [x + innerSize / 2, y], [x, y + innerSize / 2], [x - innerSize / 2, y]];\n\n            // Draw inner diamond\n            shapes.push(\"<path \\n                        d=\\\"M \".concat(innerPoints[0][0], \" \").concat(innerPoints[0][1], \" \\n                           L \").concat(innerPoints[1][0], \" \").concat(innerPoints[1][1], \" \\n                           L \").concat(innerPoints[2][0], \" \").concat(innerPoints[2][1], \" \\n                           L \").concat(innerPoints[3][0], \" \").concat(innerPoints[3][1], \" Z\\\"\\n                        stroke=\\\"white\\\"\\n                        stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                        stroke-linecap=\\\"\").concat(this.lineCap, \"\\\"\\n                        fill=\\\"none\\\"\\n                    />\"));\n\n            // Draw connecting lines\n            for (var i = 0; i < 4; i++) {\n              shapes.push(\"<line \\n                            x1=\\\"\".concat(outerPoints[i][0], \"\\\" \\n                            y1=\\\"\").concat(outerPoints[i][1], \"\\\" \\n                            x2=\\\"\").concat(innerPoints[i][0], \"\\\" \\n                            y2=\\\"\").concat(innerPoints[i][1], \"\\\"\\n                            stroke=\\\"white\\\"\\n                            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                            stroke-linecap=\\\"\").concat(this.lineCap, \"\\\"\\n                        />\"));\n            }\n          }\n        }\n      }\n      return shapes.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(RhombusPattern, \"parameters\", {\n  gridSize: {\n    min: 2,\n    max: 4,\n    \"default\": 2\n  },\n  diamondSize: {\n    min: 20,\n    max: 80,\n    \"default\": 60\n  },\n  thickness: {\n    min: 1,\n    max: 8,\n    \"default\": 2\n  },\n  spacing: {\n    min: 1,\n    max: 50,\n    \"default\": 1\n  },\n  innerRatio: {\n    min: 0.1,\n    max: 0.9,\n    \"default\": 0.6\n  },\n  lineCap: {\n    options: ['butt', 'round'],\n    \"default\": 'round'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RhombusPattern);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/RhombusPattern.js?");

/***/ }),

/***/ "./src/shapes/RhythmicWaves.js":
/*!*************************************!*\
  !*** ./src/shapes/RhythmicWaves.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a pattern of vertical, curved 'roots' or waves extending upwards\n * from a common base line.\n */\nvar RhythmicWaves = /*#__PURE__*/function (_Shape) {\n  function RhythmicWaves() {\n    _classCallCheck(this, RhythmicWaves);\n    return _callSuper(this, RhythmicWaves, arguments);\n  }\n  _inherits(RhythmicWaves, _Shape);\n  return _createClass(RhythmicWaves, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var lines = [];\n      var baseWidth = 400 * this.rootSpread; // Increased from 240 to fill viewBox\n      var center = {\n        x: 0,\n        y: 0\n      };\n      var groundLevel = center.y + this.archHeight / 2;\n      var archTop = center.y - this.archHeight / 2;\n      for (var i = 0; i < this.rootCount; i++) {\n        var progress = i / (this.rootCount - 1);\n        var phase = this.rootPhase * Math.PI / 180 * Math.sin(progress * Math.PI);\n        var startX = center.x - baseWidth / 2 + baseWidth * progress;\n        var startPoint = {\n          x: startX,\n          y: groundLevel\n        };\n        var endPoint = {\n          x: startX,\n          y: archTop\n        };\n        var control1 = {\n          x: startX + 100 * this.rootCurve * Math.cos(phase),\n          // Increased from 50\n          y: groundLevel - this.archHeight * 0.4 // Adjusted from 1/3\n        };\n        var control2 = {\n          x: startX - 60 * this.rootCurve * Math.cos(phase),\n          // Increased from 30\n          y: archTop + this.archHeight * 0.4 // Adjusted from 1/3\n        };\n        lines.push(\"<path \\n                d=\\\"M \".concat(startPoint.x, \" \").concat(startPoint.y, \" \\n                   C \").concat(control1.x, \" \").concat(control1.y, \" \\n                     \").concat(control2.x, \" \").concat(control2.y, \" \\n                     \").concat(endPoint.x, \" \").concat(endPoint.y, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.rootThickness, \"\\\"\\n                stroke-linecap=\\\"round\\\"\\n                fill=\\\"none\\\"\\n            />\"));\n      }\n      return lines.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(RhythmicWaves, \"parameters\", {\n  archHeight: {\n    min: 50,\n    max: 200,\n    \"default\": 180\n  },\n  rootCount: {\n    min: 3,\n    max: 12,\n    \"default\": 6\n  },\n  rootThickness: {\n    min: 2,\n    max: 15,\n    \"default\": 8\n  },\n  rootCurve: {\n    min: 0.1,\n    max: 1.0,\n    \"default\": 0.6\n  },\n  rootSpread: {\n    min: 0.2,\n    max: 0.8,\n    \"default\": 0.3\n  },\n  rootPhase: {\n    min: -90,\n    max: 90,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RhythmicWaves);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/RhythmicWaves.js?");

/***/ }),

/***/ "./src/shapes/RibbonShape.js":
/*!***********************************!*\
  !*** ./src/shapes/RibbonShape.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a continuous, flowing ribbon shape using parametric equations based\n * on sine waves.\n */\nvar RibbonShape = /*#__PURE__*/function (_Shape) {\n  function RibbonShape() {\n    _classCallCheck(this, RibbonShape);\n    return _callSuper(this, RibbonShape, arguments);\n  }\n  _inherits(RibbonShape, _Shape);\n  return _createClass(RibbonShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var points = [];\n      var steps = 100;\n      for (var i = 0; i <= steps; i++) {\n        var t = i / steps * Math.PI * 2;\n        var x = Math.sin(t * this.cycles) * this.width;\n        var y = Math.cos(t) * this.width * this.squeeze;\n        points.push(\"\".concat(x, \",\").concat(y));\n      }\n      return \"<path \\n            d=\\\"M \".concat(points.join(' L '), \"\\\"\\n            fill=\\\"none\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            stroke-linecap=\\\"\").concat(this.lineCap, \"\\\"\\n            stroke-linejoin=\\\"round\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(RibbonShape, \"parameters\", {\n  cycles: {\n    min: 2,\n    max: 4,\n    \"default\": 2\n  },\n  width: {\n    min: 20,\n    max: 100,\n    \"default\": 80\n  },\n  thickness: {\n    min: 2,\n    max: 20,\n    \"default\": 12\n  },\n  squeeze: {\n    min: 0.2,\n    max: 1,\n    \"default\": 0.6\n  },\n  lineCap: {\n    options: ['butt', 'round'],\n    \"default\": 'round'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RibbonShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/RibbonShape.js?");

/***/ }),

/***/ "./src/shapes/RoundedCross.js":
/*!************************************!*\
  !*** ./src/shapes/RoundedCross.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a cross shape composed of five equal squares, with rounded corners\n * applied to the outer perimeter.\n */\nvar RoundedCross = /*#__PURE__*/function (_Shape) {\n  function RoundedCross() {\n    _classCallCheck(this, RoundedCross);\n    return _callSuper(this, RoundedCross, arguments);\n  }\n  _inherits(RoundedCross, _Shape);\n  return _createClass(RoundedCross, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var blockSize = this.blockSize;\n      var h = blockSize / 2; // Half the block size (also half the arm width)\n      // Ensure corner radius is not larger than half the block size\n      var r = Math.min(this.cornerRadius, h);\n\n      // No explicit scaling needed if max blockSize keeps 3*h within bounds\n      // Keep coordinates directly if 3*h <= 100\n      // const maxCoord = 3 * h;\n      // const scale = maxCoord > 0 ? 98 / maxCoord : 1; // Use 98 for margin\n      // const H = h * scale;\n      // const R = r * scale;\n\n      // Use direct coordinates since max 3*h = 99 fits within -100 to 100\n      var H = h;\n      var R = r;\n\n      // Handle the case where corner radius is zero (sharp corners)\n      if (R <= 0.01) {\n        var _pathData = \"\\n                M \".concat(H, \" \").concat(3 * H, \" L \").concat(-H, \" \").concat(3 * H, \"\\n                L \").concat(-H, \" \").concat(H, \" L \").concat(-3 * H, \" \").concat(H, \"\\n                L \").concat(-3 * H, \" \").concat(-H, \" L \").concat(-H, \" \").concat(-H, \"\\n                L \").concat(-H, \" \").concat(-3 * H, \" L \").concat(H, \" \").concat(-3 * H, \"\\n                L \").concat(H, \" \").concat(-H, \" L \").concat(3 * H, \" \").concat(-H, \"\\n                L \").concat(3 * H, \" \").concat(H, \" L \").concat(H, \" \").concat(H, \"\\n                Z\");\n        return \"<path d=\\\"\".concat(_pathData, \"\\\" fill=\\\"white\\\" />\");\n      }\n\n      // Construct the path string with arcs\n      var pathData = \"\\n            M \".concat(H, \" \").concat(3 * H - R, \"\\n            A \").concat(R, \" \").concat(R, \" 0 0 1 \").concat(H - R, \" \").concat(3 * H, \"\\n            L \").concat(-H + R, \" \").concat(3 * H, \"\\n            A \").concat(R, \" \").concat(R, \" 0 0 1 \").concat(-H, \" \").concat(3 * H - R, \"\\n            L \").concat(-H, \" \").concat(H + R, \"\\n            A \").concat(R, \" \").concat(R, \" 0 0 1 \").concat(-H - R, \" \").concat(H, \"\\n            L \").concat(-3 * H + R, \" \").concat(H, \"\\n            A \").concat(R, \" \").concat(R, \" 0 0 1 \").concat(-3 * H, \" \").concat(H - R, \"\\n            L \").concat(-3 * H, \" \").concat(-H + R, \"\\n            A \").concat(R, \" \").concat(R, \" 0 0 1 \").concat(-3 * H + R, \" \").concat(-H, \"\\n            L \").concat(-H - R, \" \").concat(-H, \"\\n            A \").concat(R, \" \").concat(R, \" 0 0 1 \").concat(-H, \" \").concat(-H - R, \"\\n            L \").concat(-H, \" \").concat(-3 * H + R, \"\\n            A \").concat(R, \" \").concat(R, \" 0 0 1 \").concat(-H + R, \" \").concat(-3 * H, \"\\n            L \").concat(H - R, \" \").concat(-3 * H, \"\\n            A \").concat(R, \" \").concat(R, \" 0 0 1 \").concat(H, \" \").concat(-3 * H + R, \"\\n            L \").concat(H, \" \").concat(-H - R, \"\\n            A \").concat(R, \" \").concat(R, \" 0 0 1 \").concat(H + R, \" \").concat(-H, \"\\n            L \").concat(3 * H - R, \" \").concat(-H, \"\\n            A \").concat(R, \" \").concat(R, \" 0 0 1 \").concat(3 * H, \" \").concat(-H + R, \"\\n            L \").concat(3 * H, \" \").concat(H - R, \"\\n            A \").concat(R, \" \").concat(R, \" 0 0 1 \").concat(3 * H - R, \" \").concat(H, \"\\n            L \").concat(H + R, \" \").concat(H, \"\\n            A \").concat(R, \" \").concat(R, \" 0 0 1 \").concat(H, \" \").concat(H + R, \"\\n            Z\\n        \");\n      return \"<path d=\\\"\".concat(pathData.replace(/\\s+/g, ' '), \"\\\" fill=\\\"white\\\" />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(RoundedCross, \"parameters\", {\n  blockSize: {\n    type: 'number',\n    min: 10,\n    max: 66,\n    // Max extent 3*h = 99\n    step: 1,\n    \"default\": 40\n  },\n  cornerRadius: {\n    type: 'number',\n    min: 0,\n    max: 33,\n    // Max extent blockSize / 2\n    step: 0.5,\n    \"default\": 10\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RoundedCross);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/RoundedCross.js?");

/***/ }),

/***/ "./src/shapes/RoundedInnerStarShape.js":
/*!*********************************************!*\
  !*** ./src/shapes/RoundedInnerStarShape.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a star shape where the inner corners (valleys) are rounded using\n * Bezier curves.\n */\nvar RoundedInnerStarShape = /*#__PURE__*/function (_Shape) {\n  function RoundedInnerStarShape() {\n    _classCallCheck(this, RoundedInnerStarShape);\n    return _callSuper(this, RoundedInnerStarShape, arguments);\n  }\n  _inherits(RoundedInnerStarShape, _Shape);\n  return _createClass(RoundedInnerStarShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var pathParts = [];\n      // Ensure points is an integer using Math.round\n      var pointsInt = Math.round(this.points);\n      var rotationInRadians = this.rotation * Math.PI / 180;\n      var angleStep = 2 * Math.PI / pointsInt;\n\n      // Calculate control point distance based on curve strength\n      // Add adaptive scaling based on point count to prevent self-intersection\n      var pointScale = Math.min(1, 5 / pointsInt);\n      var controlDist = this.curveStrength / 100 * (this.size - this.innerRadius) * 0.5 * pointScale;\n      for (var i = 0; i < pointsInt; i++) {\n        var angle = i * angleStep + rotationInRadians;\n        var nextAngle = (i + 1) % pointsInt * angleStep + rotationInRadians;\n\n        // Outer point\n        var outerX = Math.cos(angle) * this.size;\n        var outerY = Math.sin(angle) * this.size;\n\n        // Inner point\n        var midAngle = angle + angleStep / 2;\n        var innerX = Math.cos(midAngle) * this.innerRadius;\n        var innerY = Math.sin(midAngle) * this.innerRadius;\n\n        // Next outer point\n        var nextOuterX = Math.cos(nextAngle) * this.size;\n        var nextOuterY = Math.sin(nextAngle) * this.size;\n\n        // Control points for the curves - use perpendicular angles for smooth transitions\n        var controlAngle1 = angle + Math.PI / 2;\n        var controlAngle2 = nextAngle - Math.PI / 2;\n\n        // Control point calculation - similar to original but with better stability\n        // First control point (after outer point)\n        var control1X = outerX + Math.cos(controlAngle1) * controlDist;\n        var control1Y = outerY + Math.sin(controlAngle1) * controlDist;\n\n        // Second control point (before inner point)\n        var control2X = innerX - Math.cos(controlAngle1) * controlDist;\n        var control2Y = innerY - Math.sin(controlAngle1) * controlDist;\n\n        // Third control point (after inner point)\n        var control3X = innerX - Math.cos(controlAngle2) * controlDist;\n        var control3Y = innerY - Math.sin(controlAngle2) * controlDist;\n\n        // Fourth control point (before next outer point)\n        var control4X = nextOuterX + Math.cos(controlAngle2) * controlDist;\n        var control4Y = nextOuterY + Math.sin(controlAngle2) * controlDist;\n        if (i === 0) {\n          pathParts.push(\"M \".concat(outerX, \",\").concat(outerY));\n        }\n\n        // Add the two cubic bezier curves for this segment\n        pathParts.push(\"C \".concat(control1X, \",\").concat(control1Y, \" \").concat(control2X, \",\").concat(control2Y, \" \").concat(innerX, \",\").concat(innerY));\n        pathParts.push(\"C \".concat(control3X, \",\").concat(control3Y, \" \").concat(control4X, \",\").concat(control4Y, \" \").concat(nextOuterX, \",\").concat(nextOuterY));\n      }\n      pathParts.push('Z');\n      return \"<path \\n            d=\\\"\".concat(pathParts.join(' '), \"\\\"\\n            fill=\\\"white\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"1\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(RoundedInnerStarShape, \"parameters\", {\n  size: {\n    min: 50,\n    max: 100,\n    \"default\": 100\n  },\n  points: {\n    min: 3,\n    max: 12,\n    \"default\": 4\n  },\n  innerRadius: {\n    min: 10,\n    max: 100,\n    \"default\": 40\n  },\n  curveStrength: {\n    min: 0,\n    max: 100,\n    \"default\": 70\n  },\n  rotation: {\n    min: -180,\n    max: 180,\n    \"default\": 45\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RoundedInnerStarShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/RoundedInnerStarShape.js?");

/***/ }),

/***/ "./src/shapes/RoundedPolygon.js":
/*!**************************************!*\
  !*** ./src/shapes/RoundedPolygon.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a regular polygon with rounded corners, adjustable sides, and\n * corner radius.\n */\nvar RoundedPolygon = /*#__PURE__*/function (_Shape) {\n  function RoundedPolygon() {\n    _classCallCheck(this, RoundedPolygon);\n    return _callSuper(this, RoundedPolygon, arguments);\n  }\n  _inherits(RoundedPolygon, _Shape);\n  return _createClass(RoundedPolygon, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      this.sides = Math.round(this.sides);\n      this.size = 100;\n      // Generate base polygon points\n      var points = [];\n      var angleStep = 2 * Math.PI / this.sides;\n      for (var i = 0; i < this.sides; i++) {\n        var angle = i * angleStep - Math.PI / 2; // Start from top\n        var x = this.size * Math.cos(angle);\n        var y = this.size * Math.sin(angle);\n        points.push([x, y]);\n      }\n\n      // Calculate maximum possible corner radius based on polygon geometry\n      var sideLength = Math.sqrt(Math.pow(points[1][0] - points[0][0], 2) + Math.pow(points[1][1] - points[0][1], 2));\n      var maxRadius = sideLength * Math.sin(Math.PI / this.sides) * 0.5;\n      var cornerRadius = this.cornerRadius / 100 * maxRadius;\n\n      // Generate path with rounded corners using quadratic bezier curves\n      var path = '';\n      for (var _i = 0; _i < points.length; _i++) {\n        var curr = points[_i];\n        var next = points[(_i + 1) % points.length];\n        var nextNext = points[(_i + 2) % points.length];\n\n        // Calculate vectors\n        var v1 = {\n          x: next[0] - curr[0],\n          y: next[1] - curr[1]\n        };\n        var v2 = {\n          x: nextNext[0] - next[0],\n          y: nextNext[1] - next[1]\n        };\n\n        // Normalize vectors\n        var len1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);\n        var len2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);\n        var n1 = {\n          x: v1.x / len1,\n          y: v1.y / len1\n        };\n        var n2 = {\n          x: v2.x / len2,\n          y: v2.y / len2\n        };\n\n        // Calculate control points\n        var cp1 = {\n          x: next[0] - n1.x * cornerRadius,\n          y: next[1] - n1.y * cornerRadius\n        };\n        var cp2 = {\n          x: next[0] + n2.x * cornerRadius,\n          y: next[1] + n2.y * cornerRadius\n        };\n\n        // Start path\n        if (_i === 0) {\n          path += \"M \".concat(curr[0], \",\").concat(curr[1]);\n        }\n\n        // Add line to first control point\n        path += \" L \".concat(cp1.x, \",\").concat(cp1.y);\n\n        // Add quadratic bezier curve for the corner\n        path += \" Q \".concat(next[0], \",\").concat(next[1], \" \").concat(cp2.x, \",\").concat(cp2.y);\n      }\n      path += 'Z';\n      return \"<path d=\\\"\".concat(path, \"\\\" fill=\\\"white\\\"/>\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(RoundedPolygon, \"parameters\", {\n  sides: {\n    min: 3,\n    max: 12,\n    \"default\": 5\n  },\n  cornerRadius: {\n    min: 0,\n    max: 100,\n    \"default\": 20\n  } // as percentage of max possible radius\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RoundedPolygon);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/RoundedPolygon.js?");

/***/ }),

/***/ "./src/shapes/RoundedRect.js":
/*!***********************************!*\
  !*** ./src/shapes/RoundedRect.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a hollow rounded rectangle (frame) by cutting out a smaller,\n * concentric rounded rectangle.\n */\nvar RoundedRectShape = /*#__PURE__*/function (_Shape) {\n  function RoundedRectShape() {\n    _classCallCheck(this, RoundedRectShape);\n    return _callSuper(this, RoundedRectShape, arguments);\n  }\n  _inherits(RoundedRectShape, _Shape);\n  return _createClass(RoundedRectShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var outerSize = 150;\n      var halfOuter = outerSize / 2;\n\n      // Calculate inner dimensions\n      var innerSize = outerSize * this.innerRatio;\n      var halfInner = innerSize / 2;\n\n      // Calculate corner radii using fixed ratio of 2\n      var outerRadius = Math.min(this.cornerRadius, outerSize / 4);\n      var innerRadius = outerRadius / 2; // Fixed ratio of 2\n\n      // Create outer rounded rectangle path\n      var outerPath = this.createRoundedRectPath(-halfOuter, -halfOuter, outerSize, outerSize, outerRadius);\n\n      // Create centered inner rounded rectangle path\n      var innerPath = this.createRoundedRectPath(-halfInner, -halfInner, innerSize, innerSize, innerRadius);\n      return \"<path d=\\\"\".concat(outerPath, \" \").concat(innerPath, \"\\\"\\n                  fill=\\\"white\\\"\\n                  fill-rule=\\\"evenodd\\\"/>\");\n    }\n  }, {\n    key: \"createRoundedRectPath\",\n    value: function createRoundedRectPath(x, y, width, height, radius) {\n      // Ensure radius doesn't exceed half of width or height\n      var r = Math.min(radius, width / 2, height / 2);\n      var commands = [\"M \".concat(x + r, \" \").concat(y), \"h \".concat(width - 2 * r), \"a \".concat(r, \" \").concat(r, \" 0 0 1 \").concat(r, \" \").concat(r), \"v \".concat(height - 2 * r), \"a \".concat(r, \" \").concat(r, \" 0 0 1 -\").concat(r, \" \").concat(r), \"h -\".concat(width - 2 * r), \"a \".concat(r, \" \").concat(r, \" 0 0 1 -\").concat(r, \" -\").concat(r), \"v -\".concat(height - 2 * r), \"a \".concat(r, \" \").concat(r, \" 0 0 1 \").concat(r, \" -\").concat(r), 'Z'];\n      return commands.join(' ');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(RoundedRectShape, \"parameters\", {\n  innerRatio: {\n    min: 0.7,\n    max: 0.9,\n    \"default\": 0.65\n  },\n  cornerRadius: {\n    min: 5,\n    max: 100,\n    \"default\": 35\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RoundedRectShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/RoundedRect.js?");

/***/ }),

/***/ "./src/shapes/RoundedRectangles.js":
/*!*****************************************!*\
  !*** ./src/shapes/RoundedRectangles.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a grid of rounded rectangles with adjustable rows, columns,\n * spacing, and corner radius percentage.\n */\nvar RoundedRectangleGrid = /*#__PURE__*/function (_Shape) {\n  function RoundedRectangleGrid() {\n    _classCallCheck(this, RoundedRectangleGrid);\n    return _callSuper(this, RoundedRectangleGrid, arguments);\n  }\n  _inherits(RoundedRectangleGrid, _Shape);\n  return _createClass(RoundedRectangleGrid, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var cells = [];\n\n      // Calculate cell dimensions accounting for spacing\n      var cellWidth = (this.width - this.spacing * (this.columns - 1)) / this.columns;\n      var cellHeight = (this.height - this.spacing * (this.rows - 1)) / this.rows;\n\n      // Calculate starting position to center the grid\n      var startX = -this.width / 2;\n      var startY = -this.height / 2;\n\n      // Generate grid of rounded rectangles\n      for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n          // Calculate position including spacing\n          var x = startX + j * (cellWidth + this.spacing);\n          var y = startY + i * (cellHeight + this.spacing);\n\n          // Calculate corner radius as percentage of minimum cell dimension\n          var maxRadius = Math.min(cellWidth, cellHeight) / 2;\n          var appliedRadius = this.cornerRadius / 100 * maxRadius;\n          cells.push(\"<rect \\n                    x=\\\"\".concat(x, \"\\\"\\n                    y=\\\"\").concat(y, \"\\\"\\n                    width=\\\"\").concat(cellWidth, \"\\\"\\n                    height=\\\"\").concat(cellHeight, \"\\\"\\n                    rx=\\\"\").concat(appliedRadius, \"\\\"\\n                    ry=\\\"\").concat(appliedRadius, \"\\\"\\n                    fill=\\\"\").concat(this.mode === 'fill' ? 'white' : 'none', \"\\\"\\n                    stroke=\\\"\").concat(this.mode === 'stroke' ? 'white' : 'none', \"\\\"\\n                    stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                />\"));\n        }\n      }\n      return cells.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(RoundedRectangleGrid, \"parameters\", {\n  width: {\n    min: 100,\n    max: 250,\n    \"default\": 200\n  },\n  height: {\n    min: 100,\n    max: 250,\n    \"default\": 200\n  },\n  rows: {\n    min: 1,\n    max: 8,\n    \"default\": 3\n  },\n  columns: {\n    min: 1,\n    max: 8,\n    \"default\": 3\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  },\n  spacing: {\n    min: 0,\n    max: 20,\n    \"default\": 10\n  },\n  cornerRadius: {\n    min: 0,\n    max: 100,\n    \"default\": 50\n  },\n  mode: {\n    options: ['stroke', 'fill'],\n    \"default\": 'fill'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RoundedRectangleGrid);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/RoundedRectangles.js?");

/***/ }),

/***/ "./src/shapes/RoundedShell.js":
/*!************************************!*\
  !*** ./src/shapes/RoundedShell.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates an organic, blobby outer shape with irregular edges and a rounded\n * rectangular cutout in the center.\n */\nvar RoundedShell = /*#__PURE__*/function (_Shape) {\n  function RoundedShell() {\n    _classCallCheck(this, RoundedShell);\n    return _callSuper(this, RoundedShell, arguments);\n  }\n  _inherits(RoundedShell, _Shape);\n  return _createClass(RoundedShell, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // --- Helper function ---\n      var clamp = function clamp(val, min, max) {\n        return Math.max(min, Math.min(max, val));\n      };\n\n      // --- Generate Outer Shape Vertices ---\n      var vertices = [];\n      var angleStep = 2 * Math.PI / this.complexity;\n      for (var i = 0; i < this.complexity; i++) {\n        // Base angle + random offset for irregularity in placement\n        var angleOffset = this.irregularity * angleStep * (this.random() - 0.5);\n        var angle = i * angleStep + angleOffset;\n\n        // Base radius + random offset for irregularity in distance\n        var randomFactor = 1 + this.irregularity * (this.random() * 2 - 1);\n        // Clamp radius variation to prevent overly small or large segments\n        var radius = clamp(this.baseRadius * randomFactor, this.baseRadius * (1 - this.irregularity * 1.5), this.baseRadius * (1 + this.irregularity * 1.5));\n        var x = radius * Math.cos(angle);\n        var y = radius * Math.sin(angle);\n\n        // Clamp individual coordinates to stay within viewbox boundaries\n        x = clamp(x, -98, 98);\n        y = clamp(y, -98, 98);\n        vertices.push({\n          x: x,\n          y: y\n        });\n      }\n\n      // --- Generate Outer Path Data (Smooth Closed Curve using Quadratic Beziers) ---\n      var outerPathData = '';\n      if (vertices.length >= 2) {\n        // Start at the midpoint of the line connecting the last and first vertex\n        var startX = (vertices[0].x + vertices[vertices.length - 1].x) / 2;\n        var startY = (vertices[0].y + vertices[vertices.length - 1].y) / 2;\n        outerPathData = \"M \".concat(startX.toFixed(2), \",\").concat(startY.toFixed(2), \" \");\n\n        // Add quadratic Bezier curves connecting midpoints of segments, using vertices as control points\n        for (var _i = 0; _i < vertices.length; _i++) {\n          var next_i = (_i + 1) % vertices.length;\n          var midX = (vertices[_i].x + vertices[next_i].x) / 2;\n          var midY = (vertices[_i].y + vertices[next_i].y) / 2;\n          // Q command: control point (vertex), end point (midpoint)\n          outerPathData += \"Q \".concat(vertices[_i].x.toFixed(2), \",\").concat(vertices[_i].y.toFixed(2), \" \").concat(midX.toFixed(2), \",\").concat(midY.toFixed(2), \" \");\n        }\n        outerPathData += 'Z'; // Close the path\n      } else {\n        // Fallback for insufficient vertices\n        outerPathData = 'M 0,0 Z';\n      }\n\n      // --- Generate Inner Path Data (Counter-Clockwise Rounded Rectangle) ---\n      var w = this.holeWidth;\n      var h = this.holeHeight;\n\n      // Dynamically clamp corner radius to fit the rectangle dimensions\n      var maxR = Math.min(w / 2, h / 2);\n      var r = clamp(this.cornerRadius, 2, maxR); // Ensure radius is at least 2 and not too big\n\n      // Calculate top-left corner coordinates based on center offset\n      var rectX = -w / 2;\n      var rectY = this.holeYOffset - h / 2;\n\n      // Clamp position to prevent the hole from going significantly outside the [-100, 100] box\n      rectX = clamp(rectX, -98, 98 - w); // Ensure left edge isn't < -98 and right edge isn't > 98\n      rectY = clamp(rectY, -98, 98 - h); // Ensure top edge isn't < -98 and bottom edge isn't > 98\n\n      // Build the path string using Move (M), Line (L), and Arc (A) commands\n      // Format: A rx,ry x-axis-rotation large-arc-flag,sweep-flag x,y\n      // sweep-flag 0 = counter-clockwise angle direction\n      var innerPathData = \"M \".concat(rectX + r, \",\").concat(rectY, \" \"); // Move to top side, right of corner\n\n      // Top-left arc\n      innerPathData += \"A \".concat(r, \",\").concat(r, \" 0 0 0 \").concat(rectX, \",\").concat(rectY + r, \" \");\n      // Left side\n      innerPathData += \"L \".concat(rectX, \",\").concat(rectY + h - r, \" \");\n      // Bottom-left arc\n      innerPathData += \"A \".concat(r, \",\").concat(r, \" 0 0 0 \").concat(rectX + r, \",\").concat(rectY + h, \" \");\n      // Bottom side\n      innerPathData += \"L \".concat(rectX + w - r, \",\").concat(rectY + h, \" \");\n      // Bottom-right arc\n      innerPathData += \"A \".concat(r, \",\").concat(r, \" 0 0 0 \").concat(rectX + w, \",\").concat(rectY + h - r, \" \");\n      // Right side\n      innerPathData += \"L \".concat(rectX + w, \",\").concat(rectY + r, \" \");\n      // Top-right arc\n      innerPathData += \"A \".concat(r, \",\").concat(r, \" 0 0 0 \").concat(rectX + w - r, \",\").concat(rectY, \" \");\n      // Top side (closing line)\n      innerPathData += \"L \".concat(rectX + r, \",\").concat(rectY, \" \");\n      innerPathData += 'Z'; // Close the path\n\n      // --- Combine Paths ---\n      // The outer path is clockwise, inner is counter-clockwise.\n      // Standard fill-rule (nonzero) will treat the inner path as a hole.\n      var combinedPath = outerPathData + ' ' + innerPathData;\n      return \"<path d=\\\"\".concat(combinedPath, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(RoundedShell, \"parameters\", {\n  complexity: {\n    type: 'number',\n    min: 3,\n    max: 12,\n    step: 1,\n    \"default\": 5,\n    label: 'Outer Complexity'\n  },\n  irregularity: {\n    type: 'number',\n    min: 0,\n    max: 0.8,\n    step: 0.05,\n    \"default\": 0.3,\n    label: 'Outer Irregularity'\n  },\n  baseRadius: {\n    type: 'number',\n    min: 50,\n    max: 95,\n    step: 1,\n    \"default\": 75,\n    label: 'Outer Size'\n  },\n  holeWidth: {\n    type: 'number',\n    min: 20,\n    max: 140,\n    // Allow wider holes\n    step: 1,\n    \"default\": 70,\n    label: 'Hole Width'\n  },\n  holeHeight: {\n    type: 'number',\n    min: 10,\n    max: 100,\n    // Allow taller holes\n    step: 1,\n    \"default\": 40,\n    label: 'Hole Height'\n  },\n  holeYOffset: {\n    type: 'number',\n    min: -50,\n    // Allow moving up slightly\n    max: 60,\n    // Allow moving down further\n    step: 1,\n    \"default\": 30,\n    label: 'Hole Vertical Offset'\n  },\n  cornerRadius: {\n    type: 'number',\n    min: 2,\n    max: 50,\n    // Max radius, will be capped dynamically\n    step: 1,\n    \"default\": 15,\n    label: 'Hole Corner Radius'\n  },\n  seed: {\n    // Keep seed parameter from base class\n    type: 'number',\n    min: 1,\n    max: 10000,\n    \"default\": 42\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RoundedShell);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/RoundedShell.js?");

/***/ }),

/***/ "./src/shapes/RoundedStar.js":
/*!***********************************!*\
  !*** ./src/shapes/RoundedStar.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates an SVG path for a star shape with customizable points,\n * where both the outer tips and inner valleys are smoothly rounded.\n */\nvar RoundedStarShape = /*#__PURE__*/function (_Shape) {\n  function RoundedStarShape() {\n    _classCallCheck(this, RoundedStarShape);\n    return _callSuper(this, RoundedStarShape, arguments);\n  }\n  _inherits(RoundedStarShape, _Shape);\n  return _createClass(RoundedStarShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Ensure points is an integer\n      var rotationRad = this.rotation * Math.PI / 180;\n      var pointsInt = Math.round(this.points);\n      var angleStep = 2 * Math.PI / pointsInt;\n      var halfStep = angleStep / 2;\n      var pathParts = [];\n\n      // Calculate control point distance for smooth corners\n      // Add adaptive scaling based on point count\n      var adaptiveFactor = Math.min(1, 6 / pointsInt);\n      var outerControlDist = this.cornerRadius * Math.tan(Math.PI / 8) * adaptiveFactor;\n      var innerControlDist = this.cornerRadius * Math.tan(Math.PI / 8) * adaptiveFactor;\n      for (var i = 0; i < pointsInt; i++) {\n        // Offset the angle by -90 degrees (-/2) to start from top\n        var angle = i * angleStep - Math.PI / 2 + rotationRad;\n        var nextAngle = angle + halfStep;\n\n        // Outer point\n        var outerX = this.outerRadius * Math.cos(angle);\n        var outerY = this.outerRadius * Math.sin(angle);\n\n        // Inner point\n        var innerX = this.innerRadius * Math.cos(nextAngle);\n        var innerY = this.innerRadius * Math.sin(nextAngle);\n\n        // Calculate control points for outer to inner curve\n        var outerControlX1 = outerX - outerControlDist * Math.sin(angle);\n        var outerControlY1 = outerY + outerControlDist * Math.cos(angle);\n        var innerControlX1 = innerX + innerControlDist * Math.sin(nextAngle);\n        var innerControlY1 = innerY - innerControlDist * Math.cos(nextAngle);\n        if (i === 0) {\n          pathParts.push(\"M \".concat(outerX, \",\").concat(outerY));\n        }\n\n        // Add cubic Bezier curve to inner point\n        pathParts.push(\"C \".concat(outerControlX1, \",\").concat(outerControlY1, \" \").concat(innerControlX1, \",\").concat(innerControlY1, \" \").concat(innerX, \",\").concat(innerY));\n\n        // Calculate next outer point\n        var nextOuterAngle = angle + angleStep;\n        var nextOuterX = this.outerRadius * Math.cos(nextOuterAngle);\n        var nextOuterY = this.outerRadius * Math.sin(nextOuterAngle);\n\n        // Calculate control points for inner to outer curve\n        var innerControlX2 = innerX - innerControlDist * Math.sin(nextAngle);\n        var innerControlY2 = innerY + innerControlDist * Math.cos(nextAngle);\n        var outerControlX2 = nextOuterX + outerControlDist * Math.sin(nextOuterAngle);\n        var outerControlY2 = nextOuterY - outerControlDist * Math.cos(nextOuterAngle);\n\n        // Add cubic Bezier curve to next outer point\n        pathParts.push(\"C \".concat(innerControlX2, \",\").concat(innerControlY2, \" \").concat(outerControlX2, \",\").concat(outerControlY2, \" \").concat(nextOuterX, \",\").concat(nextOuterY));\n      }\n      pathParts.push('Z');\n      return \"<path \\n            d=\\\"\".concat(pathParts.join(' '), \"\\\"\\n            fill=\\\"white\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(RoundedStarShape, \"parameters\", {\n  outerRadius: {\n    min: 20,\n    max: 100,\n    \"default\": 100\n  },\n  innerRadius: {\n    min: 15,\n    max: 100,\n    \"default\": 50\n  },\n  points: {\n    min: 3,\n    max: 16,\n    \"default\": 6\n  },\n  cornerRadius: {\n    min: 25,\n    max: 65,\n    \"default\": 50\n  },\n  rotation: {\n    min: -180,\n    max: 180,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RoundedStarShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/RoundedStar.js?");

/***/ }),

/***/ "./src/shapes/RoundedTriangle.js":
/*!***************************************!*\
  !*** ./src/shapes/RoundedTriangle.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a rounded equilateral triangle shape with a concentric,\n * similarly rounded triangular cutout in the center, creating a frame effect.\n */\nvar RoundedTriangleShape = /*#__PURE__*/function (_Shape) {\n  function RoundedTriangleShape() {\n    _classCallCheck(this, RoundedTriangleShape);\n    return _callSuper(this, RoundedTriangleShape, arguments);\n  }\n  _inherits(RoundedTriangleShape, _Shape);\n  return _createClass(RoundedTriangleShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var size = 180;\n      var sideLength = size;\n      var height = sideLength * Math.sqrt(3) / 2;\n      var outerPoints = [[0, -height * 2 / 3],\n      // top\n      [sideLength / 2, height / 3],\n      // bottom right\n      [-sideLength / 2, height / 3] // bottom left\n      ];\n      var innerScale = this.innerRatio;\n      var innerPoints = outerPoints.map(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n          x = _ref2[0],\n          y = _ref2[1];\n        return [x * innerScale, y * innerScale];\n      });\n      var outerPath = this.createRoundedPath(outerPoints, this.cornerRadius);\n      var innerPath = this.createRoundedPath(innerPoints, this.cornerRadius * innerScale);\n      return \"<path \\n            d=\\\"\".concat(outerPath, \" \").concat(innerPath, \"\\\"\\n            fill=\\\"white\\\"\\n            fill-rule=\\\"evenodd\\\"\\n        />\");\n    }\n  }, {\n    key: \"createRoundedPath\",\n    value: function createRoundedPath(points, radius) {\n      var commands = [];\n      var len = points.length;\n      for (var i = 0; i < len; i++) {\n        var current = points[i];\n        var next = points[(i + 1) % len];\n        var prev = points[(i - 1 + len) % len];\n        var cornerRadius = Math.min(radius, this.getDistance(current, next) / 2, this.getDistance(current, prev) / 2);\n        var prevPoint = this.adjustPoint(current, prev, cornerRadius);\n        var nextPoint = this.adjustPoint(current, next, cornerRadius);\n        if (i === 0) {\n          commands.push(\"M \".concat(prevPoint[0], \" \").concat(prevPoint[1]));\n        }\n        commands.push(\"L \".concat(prevPoint[0], \" \").concat(prevPoint[1]));\n        commands.push(\"Q \".concat(current[0], \" \").concat(current[1], \" \").concat(nextPoint[0], \" \").concat(nextPoint[1]));\n      }\n      commands.push('Z');\n      return commands.join(' ');\n    }\n  }, {\n    key: \"adjustPoint\",\n    value: function adjustPoint(origin, target, radius) {\n      var vector = [target[0] - origin[0], target[1] - origin[1]];\n      var length = Math.sqrt(vector[0] * vector[0] + vector[1] * vector[1]);\n      var scale = radius / length;\n      return [origin[0] + vector[0] * scale, origin[1] + vector[1] * scale];\n    }\n  }, {\n    key: \"getDistance\",\n    value: function getDistance(p1, p2) {\n      return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(RoundedTriangleShape, \"parameters\", {\n  innerRatio: {\n    min: 0.3,\n    max: 0.9,\n    \"default\": 0.65\n  },\n  cornerRadius: {\n    min: 5,\n    max: 100,\n    \"default\": 30\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RoundedTriangleShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/RoundedTriangle.js?");

/***/ }),

/***/ "./src/shapes/RoundedTrianglesGrid.js":
/*!********************************************!*\
  !*** ./src/shapes/RoundedTrianglesGrid.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n* Generates a grid of rounded equilateral triangles.\n*/\nvar RoundedTriangleGrid = /*#__PURE__*/function (_Shape) {\n  function RoundedTriangleGrid() {\n    _classCallCheck(this, RoundedTriangleGrid);\n    return _callSuper(this, RoundedTriangleGrid, arguments);\n  }\n  _inherits(RoundedTriangleGrid, _Shape);\n  return _createClass(RoundedTriangleGrid, [{\n    key: \"calculateIntersection\",\n    value: function calculateIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {\n      var denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n      if (denominator === 0) return null;\n      var intersectionX = ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / denominator;\n      var intersectionY = ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / denominator;\n      return [intersectionX, intersectionY];\n    }\n  }, {\n    key: \"calculateRoundedCorner\",\n    value: function calculateRoundedCorner(from, via, to, radius) {\n      var fromAngle = Math.atan2(via[1] - from[1], via[0] - from[0]);\n      var toAngle = Math.atan2(to[1] - via[1], to[0] - via[0]);\n\n      // Calculate offset vectors\n      var fromOffset = {\n        dx: -Math.sin(fromAngle) * radius,\n        dy: Math.cos(fromAngle) * radius\n      };\n      var toOffset = {\n        dx: -Math.sin(toAngle) * radius,\n        dy: Math.cos(toAngle) * radius\n      };\n\n      // Calculate line intersection points\n      var x1 = from[0] + fromOffset.dx;\n      var y1 = from[1] + fromOffset.dy;\n      var x2 = via[0] + fromOffset.dx;\n      var y2 = via[1] + fromOffset.dy;\n      var x3 = via[0] + toOffset.dx;\n      var y3 = via[1] + toOffset.dy;\n      var x4 = to[0] + toOffset.dx;\n      var y4 = to[1] + toOffset.dy;\n      var intersection = this.calculateIntersection(x1, y1, x2, y2, x3, y3, x4, y4);\n      if (!intersection) return null;\n      return {\n        center: intersection,\n        startAngle: fromAngle - Math.PI / 2,\n        endAngle: toAngle - Math.PI / 2\n      };\n    }\n  }, {\n    key: \"generateRoundedTrianglePath\",\n    value: function generateRoundedTrianglePath(x, y, width, height, radius) {\n      // Define triangle points\n      var points = [[x + width / 2, y],\n      // top\n      [x + width, y + height],\n      // bottom right\n      [x, y + height] // bottom left\n      ];\n\n      // Calculate maximum possible radius based on triangle size\n      var maxRadius = Math.min(width, height) / 6;\n      var appliedRadius = radius / 100 * maxRadius;\n\n      // For zero radius, return simple triangle\n      if (appliedRadius === 0) {\n        return \"M \".concat(points[0][0], \",\").concat(points[0][1], \" \\n                    L \").concat(points[1][0], \",\").concat(points[1][1], \" \\n                    L \").concat(points[2][0], \",\").concat(points[2][1], \" Z\");\n      }\n\n      // Calculate rounded corners\n      var corners = [this.calculateRoundedCorner(points[1], points[2], points[0], appliedRadius),\n      // left\n      this.calculateRoundedCorner(points[2], points[0], points[1], appliedRadius),\n      // top\n      this.calculateRoundedCorner(points[0], points[1], points[2], appliedRadius) // right\n      ];\n\n      // Fall back to simple triangle if corner calculation fails\n      if (corners.some(function (corner) {\n        return !corner;\n      })) {\n        return \"M \".concat(points[0][0], \",\").concat(points[0][1], \" \\n                    L \").concat(points[1][0], \",\").concat(points[1][1], \" \\n                    L \").concat(points[2][0], \",\").concat(points[2][1], \" Z\");\n      }\n\n      // Calculate start point\n      var startX = corners[0].center[0] + appliedRadius * Math.cos(corners[0].startAngle);\n      var startY = corners[0].center[1] + appliedRadius * Math.sin(corners[0].startAngle);\n\n      // Generate path with rounded corners\n      return \"M \".concat(startX, \",\").concat(startY, \"\\n                A \").concat(appliedRadius, \",\").concat(appliedRadius, \" 0 0 1 \\n                  \").concat(corners[0].center[0] + appliedRadius * Math.cos(corners[0].endAngle), \",\\n                  \").concat(corners[0].center[1] + appliedRadius * Math.sin(corners[0].endAngle), \"\\n                L \").concat(corners[1].center[0] + appliedRadius * Math.cos(corners[1].startAngle), \",\\n                  \").concat(corners[1].center[1] + appliedRadius * Math.sin(corners[1].startAngle), \"\\n                A \").concat(appliedRadius, \",\").concat(appliedRadius, \" 0 0 1 \\n                  \").concat(corners[1].center[0] + appliedRadius * Math.cos(corners[1].endAngle), \",\\n                  \").concat(corners[1].center[1] + appliedRadius * Math.sin(corners[1].endAngle), \"\\n                L \").concat(corners[2].center[0] + appliedRadius * Math.cos(corners[2].startAngle), \",\\n                  \").concat(corners[2].center[1] + appliedRadius * Math.sin(corners[2].startAngle), \"\\n                A \").concat(appliedRadius, \",\").concat(appliedRadius, \" 0 0 1 \\n                  \").concat(corners[2].center[0] + appliedRadius * Math.cos(corners[2].endAngle), \",\\n                  \").concat(corners[2].center[1] + appliedRadius * Math.sin(corners[2].endAngle), \"\\n                Z\");\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var triangles = [];\n      var cellWidth = (this.width - this.spacing * (this.columns - 1)) / this.columns;\n      var cellHeight = (this.height - this.spacing * (this.rows - 1)) / this.rows;\n      var startX = -this.width / 2;\n      var startY = -this.height / 2;\n\n      // Generate grid of triangles\n      for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n          var x = startX + j * (cellWidth + this.spacing);\n          var y = startY + i * (cellHeight + this.spacing);\n          var path = this.generateRoundedTrianglePath(x, y, cellWidth, cellHeight, this.cornerRadius);\n          triangles.push(\"<path \\n                    d=\\\"\".concat(path, \"\\\"\\n                    fill=\\\"\").concat(this.mode === 'fill' ? 'white' : 'none', \"\\\"\\n                    stroke=\\\"\").concat(this.mode === 'stroke' ? 'white' : 'none', \"\\\"\\n                    stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                />\"));\n        }\n      }\n      return triangles.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(RoundedTriangleGrid, \"parameters\", {\n  width: {\n    min: 100,\n    max: 250,\n    \"default\": 220\n  },\n  height: {\n    min: 100,\n    max: 250,\n    \"default\": 200\n  },\n  rows: {\n    min: 1,\n    max: 8,\n    \"default\": 3\n  },\n  columns: {\n    min: 1,\n    max: 8,\n    \"default\": 1\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  },\n  spacing: {\n    min: 0,\n    max: 20,\n    \"default\": 0\n  },\n  cornerRadius: {\n    min: 0,\n    max: 150,\n    \"default\": 100\n  },\n  mode: {\n    options: ['stroke', 'fill'],\n    \"default\": 'fill'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RoundedTriangleGrid);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/RoundedTrianglesGrid.js?");

/***/ }),

/***/ "./src/shapes/SegmentedRingSpiral.js":
/*!*******************************************!*\
  !*** ./src/shapes/SegmentedRingSpiral.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a spiraling pattern composed of multiple concentric rings, each\n * broken into gapped arc segments with optional twisting.\n */\nvar SegmentedRingSpiral = /*#__PURE__*/function (_Shape) {\n  function SegmentedRingSpiral() {\n    _classCallCheck(this, SegmentedRingSpiral);\n    return _callSuper(this, SegmentedRingSpiral, arguments);\n  }\n  _inherits(SegmentedRingSpiral, _Shape);\n  return _createClass(SegmentedRingSpiral, [{\n    key: \"polarToCartesian\",\n    value:\n    /**\n     * Converts polar coordinates (radius, angle) to Cartesian coordinates (x, y).\n     * Angle 0 is assumed to be pointing upwards (North).\n     * @param {number} radius - The radial distance from the origin (0,0).\n     * @param {number} angleInDegrees - The angle in degrees (0 = top, 90 = right, 180 = bottom, 270 = left).\n     * @returns {object} An object {x, y} representing the Cartesian coordinates.\n     */\n    function polarToCartesian(radius, angleInDegrees) {\n      // Convert angle to radians and adjust so 0 degrees is at the top\n      var angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;\n      return {\n        x: radius * Math.cos(angleInRadians),\n        y: radius * Math.sin(angleInRadians)\n      };\n    }\n\n    /**\n     * Creates the SVG path data 'd' attribute string for a single arc segment (a piece of a ring).\n     * @param {number} innerRadius - The inner radius of the segment.\n     * @param {number} outerRadius - The outer radius of the segment.\n     * @param {number} startAngleDeg - The starting angle of the segment in degrees.\n     * @param {number} endAngleDeg - The ending angle of the segment in degrees.\n     * @returns {string} SVG path data string ('d' attribute value).\n     */\n  }, {\n    key: \"createArcSegmentPath\",\n    value: function createArcSegmentPath(innerRadius, outerRadius, startAngleDeg, endAngleDeg) {\n      // Ensure radii are non-negative\n      innerRadius = Math.max(0, innerRadius);\n      outerRadius = Math.max(0.1, outerRadius); // Ensure outer radius is slightly positive to avoid issues\n\n      // Handle cases where radii are too close or equal\n      if (outerRadius <= innerRadius) {\n        outerRadius = innerRadius + 0.1; // Ensure outer is always larger\n      }\n      var startInner = this.polarToCartesian(innerRadius, startAngleDeg);\n      var endInner = this.polarToCartesian(innerRadius, endAngleDeg);\n      var startOuter = this.polarToCartesian(outerRadius, startAngleDeg);\n      var endOuter = this.polarToCartesian(outerRadius, endAngleDeg);\n      var angleDiff = endAngleDeg - startAngleDeg;\n\n      // Handle potential full circles or negative angles (normalize angle difference if needed)\n      var normalizedAngleDiff = (angleDiff % 360 + 360) % 360;\n\n      // Avoid degenerate paths for zero-angle segments\n      if (normalizedAngleDiff < 0.01) return \"\";\n\n      // large-arc-flag is 1 if the arc spans more than 180 degrees\n      var largeArcFlag = normalizedAngleDiff <= 180 ? \"0\" : \"1\";\n      // sweep-flag is 1 for counter-clockwise arc direction\n      var sweepFlagOuter = \"1\";\n      // For the inner arc, we trace it backwards (from endInner to startInner),\n      // so the sweep direction relative to the segment is reversed.\n      var sweepFlagInner = \"0\";\n      var d = [\"M \".concat(startInner.x.toFixed(3), \" \").concat(startInner.y.toFixed(3)), // Move to start on inner radius\n      \"L \".concat(startOuter.x.toFixed(3), \" \").concat(startOuter.y.toFixed(3)), // Line to start on outer radius\n      \"A \".concat(outerRadius.toFixed(3), \" \").concat(outerRadius.toFixed(3), \" 0 \").concat(largeArcFlag, \" \").concat(sweepFlagOuter, \" \").concat(endOuter.x.toFixed(3), \" \").concat(endOuter.y.toFixed(3)), // Arc along outer radius\n      \"L \".concat(endInner.x.toFixed(3), \" \").concat(endInner.y.toFixed(3)), // Line to end on inner radius\n      \"A \".concat(innerRadius.toFixed(3), \" \").concat(innerRadius.toFixed(3), \" 0 \").concat(largeArcFlag, \" \").concat(sweepFlagInner, \" \").concat(startInner.x.toFixed(3), \" \").concat(startInner.y.toFixed(3)),\n      // Arc along inner radius (backwards)\n      \"Z\" // Close path\n      ].join(\" \");\n      return d;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Validate parameters\n      if (this.startRadius >= this.outerRadius || this.numRings < 1 || this.segmentsPerRing < 1) {\n        console.warn(\"Invalid parameters for SegmentedRingSpiral: startRadius must be less than outerRadius, and counts must be positive.\");\n        return ''; // Return empty string for invalid configurations\n      }\n      var totalAvailableSpace = this.outerRadius - this.startRadius;\n      var ringThickness = 0;\n      var gap = 0;\n\n      // Calculate thickness and gap based on the ratio and available space\n      if (this.numRings === 1) {\n        ringThickness = totalAvailableSpace;\n        gap = 0;\n      } else {\n        // Formula derived from: numRings * t + (numRings - 1) * g = totalSpace AND t = ratio * g\n        var denominator = this.numRings * this.thicknessToGapRatio + this.numRings - 1;\n        if (denominator <= 0) {\n          // Avoid division by zero or negative values if ratio is weird (though min ratio is 0.5)\n          console.warn(\"Invalid thickness/gap calculation.\");\n          return '';\n        }\n        gap = totalAvailableSpace / denominator;\n        ringThickness = gap * this.thicknessToGapRatio;\n\n        // Ensure non-negative results after calculation\n        gap = Math.max(0, gap);\n        ringThickness = Math.max(0.1, ringThickness); // Ensure thickness is at least slightly positive\n      }\n\n      // Prevent drawing if calculated thickness is effectively zero\n      if (ringThickness < 0.01) {\n        return '';\n      }\n      var paths = [];\n      var segmentAngularSizeDeg = 360 / this.segmentsPerRing;\n      var gapAngularSizeDeg = segmentAngularSizeDeg * this.segmentGap;\n      var actualSegmentAngleDeg = segmentAngularSizeDeg - gapAngularSizeDeg;\n\n      // Ensure segment angle is positive\n      if (actualSegmentAngleDeg <= 0) {\n        console.warn(\"Segment gap is too large, resulting in zero or negative segment angle.\");\n        return '';\n      }\n      for (var i = 0; i < this.numRings; i++) {\n        var currentInnerRadius = this.startRadius + i * (ringThickness + gap);\n        var currentOuterRadius = currentInnerRadius + ringThickness;\n        var baseRingAngleDeg = i * this.twistPerRing;\n        for (var j = 0; j < this.segmentsPerRing; j++) {\n          var segmentStartAngleDeg = baseRingAngleDeg + j * segmentAngularSizeDeg;\n          var segmentEndAngleDeg = segmentStartAngleDeg + actualSegmentAngleDeg;\n          var pathData = this.createArcSegmentPath(currentInnerRadius, currentOuterRadius, segmentStartAngleDeg, segmentEndAngleDeg);\n          if (pathData) {\n            // Only add path if data is valid\n            paths.push(\"<path d=\\\"\".concat(pathData, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\"));\n          }\n        }\n      }\n      return paths.join('\\n');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(SegmentedRingSpiral, \"parameters\", {\n  outerRadius: {\n    type: 'number',\n    min: 20,\n    max: 98,\n    // Keep max radius within viewBox bounds (-100 to 100)\n    step: 1,\n    \"default\": 80,\n    label: 'Outer Radius'\n  },\n  startRadius: {\n    type: 'number',\n    min: 5,\n    max: 70,\n    // Should be less than outerRadius\n    step: 1,\n    \"default\": 10,\n    label: 'Inner Radius'\n  },\n  numRings: {\n    type: 'number',\n    min: 1,\n    max: 15,\n    step: 1,\n    \"default\": 5,\n    label: 'Number of Rings'\n  },\n  segmentsPerRing: {\n    type: 'number',\n    min: 3,\n    max: 60,\n    step: 1,\n    \"default\": 24,\n    label: 'Segments per Ring'\n  },\n  twistPerRing: {\n    type: 'number',\n    min: -60,\n    max: 60,\n    step: 1,\n    \"default\": 15,\n    // Degrees\n    label: 'Twist per Ring ()'\n  },\n  segmentGap: {\n    type: 'number',\n    min: 0,\n    max: 0.8,\n    // Ratio of segment angular size\n    step: 0.05,\n    \"default\": 0.1,\n    label: 'Segment Gap Ratio'\n  },\n  thicknessToGapRatio: {\n    type: 'number',\n    min: 0.5,\n    // Min thickness relative to gap\n    max: 10,\n    step: 0.1,\n    \"default\": 3,\n    // Ring thickness is 3x the gap between rings\n    label: 'Thickness/Gap Ratio'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SegmentedRingSpiral);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/SegmentedRingSpiral.js?");

/***/ }),

/***/ "./src/shapes/SegmentedShear.js":
/*!**************************************!*\
  !*** ./src/shapes/SegmentedShear.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a stylized 'Z' or lightning bolt shape constructed from sheared and\n * segmented polygons, with adjustable gap and shear.\n */\nvar SegmentedShear = /*#__PURE__*/function (_Shape) {\n  function SegmentedShear() {\n    _classCallCheck(this, SegmentedShear);\n    return _callSuper(this, SegmentedShear, arguments);\n  }\n  _inherits(SegmentedShear, _Shape);\n  return _createClass(SegmentedShear, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var w = this.width;\n      var h = this.height;\n      var s = this.shear;\n      // Ensure gapWidth doesn't cause negative coordinates when subtracted from shear.\n      // The gap is defined at the center (y=0), so g_half is the offset from the center line.\n      var g_half = this.gapWidth / 2;\n\n      // Calculate the x-coordinates where the two parallel dividing lines intersect the top and bottom edges.\n      // These points define the vertices of the central gap.\n      // V1 & V2 are on the top edge (y=-h), V3 & V4 are on the bottom edge (y=h).\n      var V1_x = s + g_half; // Top-right corner of the gap (belongs to edge separating BL white and BR black)\n      var V1_y = -h;\n      var V2_x = s - g_half; // Top-left corner of the gap (belongs to edge separating TL black and TR white)\n      var V2_y = -h;\n      var V3_x = -s + g_half; // Bottom-left corner of the gap (belongs to edge separating TL black and TR white)\n      var V3_y = h;\n      var V4_x = -s - g_half; // Bottom-right corner of the gap (belongs to edge separating BL white and BR black)\n      var V4_y = h;\n\n      // Define points for the two quadrilateral polygons (Top-Left and Bottom-Right in the original image)\n      // Format: \"x1,y1 x2,y2 x3,y3 x4,y4\"\n      var poly_TL_points = \"\".concat(-w, \",\").concat(-h, \" \").concat(V2_x, \",\").concat(V2_y, \" \").concat(V3_x, \",\").concat(V3_y, \" \").concat(-w, \",\").concat(h);\n      var poly_BR_points = \"\".concat(w, \",\").concat(h, \" \").concat(V4_x, \",\").concat(V4_y, \" \").concat(V1_x, \",\").concat(V1_y, \" \").concat(w, \",\").concat(-h);\n\n      // Define points for the two triangular polygons (Top-Right and Bottom-Left gaps in the original image)\n      // Format: \"x1,y1 x2,y2 x3,y3\"\n      var poly_TR_points = \"\".concat(V2_x, \",\").concat(V2_y, \" \").concat(w, \",\").concat(-h, \" \").concat(V3_x, \",\").concat(V3_y);\n      var poly_BL_points = \"\".concat(V4_x, \",\").concat(V4_y, \" \").concat(-w, \",\").concat(h, \" \").concat(V1_x, \",\").concat(V1_y);\n      var filledPolygon1_points;\n      var filledPolygon2_points;\n\n      // Determine which polygons to fill based on the invertColors parameter\n      if (!this.invertColors) {\n        // Original configuration: Fill the Top-Left and Bottom-Right quadrilaterals\n        filledPolygon1_points = poly_TL_points;\n        filledPolygon2_points = poly_BR_points;\n      } else {\n        // Inverted configuration: Fill the Top-Right and Bottom-Left triangles (the gaps)\n        filledPolygon1_points = poly_TR_points;\n        filledPolygon2_points = poly_BL_points;\n      }\n\n      // Generate the SVG polygon elements\n      var polygon1 = \"<polygon points=\\\"\".concat(filledPolygon1_points, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\");\n      var polygon2 = \"<polygon points=\\\"\".concat(filledPolygon2_points, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\");\n\n      // Return the combined SVG string\n      return \"\".concat(polygon1, \"\\n\").concat(polygon2);\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(SegmentedShear, \"parameters\", {\n  width: {\n    type: 'number',\n    min: 10,\n    max: 100,\n    step: 1,\n    \"default\": 90,\n    description: 'Overall half-width'\n  },\n  height: {\n    type: 'number',\n    min: 10,\n    max: 100,\n    step: 1,\n    \"default\": 60,\n    description: 'Overall half-height'\n  },\n  shear: {\n    type: 'number',\n    min: 0,\n    max: 100,\n    step: 1,\n    \"default\": 40,\n    description: 'Horizontal offset of the diagonal cut at the top/bottom edges'\n  },\n  gapWidth: {\n    type: 'number',\n    min: 0,\n    max: 80,\n    step: 1,\n    \"default\": 15,\n    description: 'Horizontal width of the central gap at y=0'\n  },\n  invertColors: {\n    type: 'boolean',\n    \"default\": false,\n    description: 'Swap which segments are filled'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SegmentedShear);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/SegmentedShear.js?");

/***/ }),

/***/ "./src/shapes/SemicirclePattern.js":
/*!*****************************************!*\
  !*** ./src/shapes/SemicirclePattern.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a grid pattern composed of outlined semicircles.\n */\nvar SemicirclePattern = /*#__PURE__*/function (_Shape) {\n  function SemicirclePattern() {\n    _classCallCheck(this, SemicirclePattern);\n    return _callSuper(this, SemicirclePattern, arguments);\n  }\n  _inherits(SemicirclePattern, _Shape);\n  return _createClass(SemicirclePattern, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var semicircles = [];\n      var totalWidth = this.columns * (this.radius * 2 + this.spacing) - this.spacing;\n      var totalHeight = this.rows * (this.radius * 2 + this.spacing) - this.spacing;\n      var startX = -totalWidth / 2 + this.radius;\n      var startY = -totalHeight / 2.5 + this.radius;\n      for (var row = 0; row < this.rows; row++) {\n        for (var col = 0; col < this.columns; col++) {\n          var centerX = startX + col * (this.radius * 2 + this.spacing);\n          var centerY = startY + row * (this.radius * 2 + this.spacing);\n          var path = [\"M \".concat(centerX - this.radius, \" \").concat(centerY), \"A \".concat(this.radius, \" \").concat(this.radius, \" 0 0 1 \").concat(centerX + this.radius, \" \").concat(centerY)].join(' ');\n          semicircles.push(\"<path \\n                    d=\\\"\".concat(path, \"\\\"\\n                    fill=\\\"none\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                    stroke-linecap=\\\"\").concat(this.lineCap, \"\\\"\\n                />\"));\n        }\n      }\n      return semicircles.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(SemicirclePattern, \"parameters\", {\n  rows: {\n    min: 1,\n    max: 6,\n    \"default\": 3\n  },\n  columns: {\n    min: 1,\n    max: 6,\n    \"default\": 3\n  },\n  radius: {\n    min: 10,\n    max: 50,\n    \"default\": 30\n  },\n  spacing: {\n    min: 0,\n    max: 20,\n    \"default\": 0\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 4\n  },\n  lineCap: {\n    options: ['butt', 'round'],\n    \"default\": 'round'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SemicirclePattern);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/SemicirclePattern.js?");

/***/ }),

/***/ "./src/shapes/SerratedFrame.js":
/*!*************************************!*\
  !*** ./src/shapes/SerratedFrame.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a diamond-shaped frame with jagged, flame-like serrations along its\n * edges.\n */\nvar SerratedFrame = /*#__PURE__*/function (_Shape) {\n  function SerratedFrame() {\n    _classCallCheck(this, SerratedFrame);\n    return _callSuper(this, SerratedFrame, arguments);\n  }\n  _inherits(SerratedFrame, _Shape);\n  return _createClass(SerratedFrame, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var scale = 200 / 300; // Assuming viewBox is -200 -200 400 400\n      var center = {\n        x: 0,\n        y: 0\n      };\n\n      // Get parameter values\n      var baseSize = this.baseSize * scale;\n      var flameHeight = this.flameHeight * scale;\n      var flameCount = this.flameCount;\n      var flameWidth = this.flameWidth;\n      var turbulence = this.turbulence;\n\n      // Create base diamond points\n      var diamondPoints = [{\n        x: center.x,\n        y: center.y - baseSize\n      },\n      // Top\n      {\n        x: center.x + baseSize,\n        y: center.y\n      },\n      // Right\n      {\n        x: center.x,\n        y: center.y + baseSize\n      },\n      // Bottom\n      {\n        x: center.x - baseSize,\n        y: center.y\n      } // Left\n      ];\n\n      // Function to generate flame points along an edge\n      function generateFlamePoints(start, end, count) {\n        var points = [];\n        var segmentLength = Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));\n        var dx = (end.x - start.x) / count;\n        var dy = (end.y - start.y) / count;\n        for (var i = 0; i <= count; i++) {\n          var progress = i / count;\n          var baseX = start.x + dx * i;\n          var baseY = start.y + dy * i;\n          if (i > 0 && i < count) {\n            // Calculate flame tip position\n            var angle = Math.atan2(end.y - start.y, end.x - start.x) + Math.PI / 2;\n            var flameLen = flameHeight * (1 + Math.sin(progress * Math.PI) * turbulence);\n            var tipX = baseX + Math.cos(angle) * flameLen;\n            var tipY = baseY + Math.sin(angle) * flameLen;\n\n            // Add control points for curved flames\n            var ctrl1X = baseX + Math.cos(angle) * flameLen * flameWidth;\n            var ctrl1Y = baseY + Math.sin(angle) * flameLen * flameWidth;\n            points.push({\n              x: ctrl1X,\n              y: ctrl1Y\n            });\n            points.push({\n              x: tipX,\n              y: tipY\n            });\n            points.push({\n              x: baseX,\n              y: baseY\n            });\n          } else {\n            points.push({\n              x: baseX,\n              y: baseY\n            });\n          }\n        }\n        return points;\n      }\n\n      // Start the path at the first diamond point\n      var path = \"M \".concat(diamondPoints[0].x, \" \").concat(diamondPoints[0].y);\n\n      // Create flames for each edge of the diamond\n      for (var i = 0; i < 4; i++) {\n        var start = diamondPoints[i];\n        var end = diamondPoints[(i + 1) % 4];\n        var flamePoints = generateFlamePoints(start, end, flameCount);\n\n        // Draw flames using curved paths\n        for (var index = 0; index < flamePoints.length; index++) {\n          if (index % 3 === 0) {\n            path += \" L \".concat(flamePoints[index].x, \" \").concat(flamePoints[index].y);\n          } else {\n            path += \" Q \".concat(flamePoints[index - 1].x, \" \").concat(flamePoints[index - 1].y, \" \").concat(flamePoints[index].x, \" \").concat(flamePoints[index].y);\n          }\n        }\n      }\n\n      // Close the path\n      path += ' Z';\n      return \"<path d=\\\"\".concat(path, \"\\\" fill=\\\"white\\\"/>\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(SerratedFrame, \"parameters\", {\n  baseSize: {\n    min: 50,\n    max: 200,\n    \"default\": 120\n  },\n  flameHeight: {\n    min: 10,\n    max: 80,\n    \"default\": 30\n  },\n  flameCount: {\n    min: 3,\n    max: 12,\n    \"default\": 6\n  },\n  flameWidth: {\n    min: 0.1,\n    max: 0.9,\n    \"default\": 0.4\n  },\n  turbulence: {\n    min: 0,\n    max: 1,\n    \"default\": 0.3\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SerratedFrame);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/SerratedFrame.js?");

/***/ }),

/***/ "./src/shapes/Shape.js":
/*!*****************************!*\
  !*** ./src/shapes/Shape.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Shape: () => (/* binding */ Shape)\n/* harmony export */ });\n/* harmony import */ var _perlin_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../perlin.js */ \"./src/perlin.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar Shape = /*#__PURE__*/function () {\n  function Shape() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, Shape);\n    _defineProperty(this, \"distance\", function (a, b) {\n      var dx = b.x - a.x;\n      var dy = b.y - a.y;\n      return Math.sqrt(dx * dx + dy * dy);\n    });\n    var classParameters = this.constructor.parameters || {};\n    var allParameters = _objectSpread(_objectSpread({}, Shape.parameters), classParameters);\n    var defaults = Object.fromEntries(Object.entries(allParameters).map(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n        key = _ref2[0],\n        value = _ref2[1];\n      return [key, value[\"default\"]];\n    }));\n    Object.assign(this, defaults, options);\n    this.initRNG();\n  }\n  return _createClass(Shape, [{\n    key: \"initRNG\",\n    value: function initRNG() {\n      this.rng = this.createSeededRNG(this.seed);\n    }\n  }, {\n    key: \"createSeededRNG\",\n    value: function createSeededRNG(seed) {\n      return {\n        _seed: seed,\n        next: function next() {\n          this._seed = (this._seed * 9301 + 49297) % 233280;\n          return this._seed / 233280;\n        }\n      };\n    }\n  }, {\n    key: \"random\",\n    value: function random() {\n      return this.rng.next();\n    }\n  }, {\n    key: \"resetRNG\",\n    value: function resetRNG(newSeed) {\n      if (newSeed !== undefined) {\n        this.seed = newSeed;\n      }\n      this.initRNG();\n    }\n  }, {\n    key: \"getNoise\",\n    value: function getNoise(x, y) {\n      var scale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1.0;\n      return _perlin_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].noise(x * scale + this.seed, y * scale + this.seed);\n    }\n  }, {\n    key: \"vectorAdd\",\n    value: function vectorAdd(v1, v2) {\n      return {\n        x: v1.x + v2.x,\n        y: v1.y + v2.y\n      };\n    }\n  }, {\n    key: \"vectorScale\",\n    value: function vectorScale(v, scalar) {\n      return {\n        x: v.x * scalar,\n        y: v.y * scalar\n      };\n    }\n  }, {\n    key: \"rotatePoint\",\n    value: function rotatePoint(point, angle) {\n      var cos = Math.cos(angle);\n      var sin = Math.sin(angle);\n      return {\n        x: point.x * cos - point.y * sin,\n        y: point.x * sin + point.y * cos\n      };\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      throw new Error('generateShape() method must be implemented in child class');\n    }\n  }]);\n}();\n_defineProperty(Shape, \"parameters\", {\n  seed: {\n    min: 1,\n    max: 10000,\n    \"default\": 42\n  }\n});\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/Shape.js?");

/***/ }),

/***/ "./src/shapes/SierpinskiTriangle.js":
/*!******************************************!*\
  !*** ./src/shapes/SierpinskiTriangle.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a Sierpinski triangle fractal pattern using recursive subdivision,\n * drawn with outlines.\n */\nvar SierpinskiTriangle = /*#__PURE__*/function (_Shape) {\n  function SierpinskiTriangle() {\n    _classCallCheck(this, SierpinskiTriangle);\n    return _callSuper(this, SierpinskiTriangle, arguments);\n  }\n  _inherits(SierpinskiTriangle, _Shape);\n  return _createClass(SierpinskiTriangle, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var elements = [];\n\n      // Calculate initial triangle points\n      var height = this.size * Math.sqrt(3) / 2;\n      var x1 = -this.size / 2;\n      var y1 = height / 2;\n      var x2 = this.size / 2;\n      var y2 = height / 2;\n      var x3 = 0;\n      var y3 = -height / 2;\n\n      // Limit iterations to prevent stack overflow\n      var safeIterations = Math.min(5, Math.floor(this.iterations));\n\n      // Generate Sierpinski triangles recursively\n      this.drawSierpinski(elements, x1, y1, x2, y2, x3, y3, safeIterations);\n      return elements.join('');\n    }\n  }, {\n    key: \"drawSierpinski\",\n    value: function drawSierpinski(elements, x1, y1, x2, y2, x3, y3, depth) {\n      // Base case: depth is 0 or minimal area (to prevent stack overflow)\n      var area = Math.abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2);\n      if (depth <= 0 || area < 1) {\n        // Draw the triangle\n        elements.push(\"<polygon\\n        points=\\\"\".concat(x1, \",\").concat(y1, \" \").concat(x2, \",\").concat(y2, \" \").concat(x3, \",\").concat(y3, \"\\\"\\n        stroke=\\\"white\\\"\\n        stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n        fill=\\\"none\\\"\\n      />\"));\n      } else {\n        // Calculate midpoints\n        var x12 = (x1 + x2) / 2;\n        var y12 = (y1 + y2) / 2;\n        var x23 = (x2 + x3) / 2;\n        var y23 = (y2 + y3) / 2;\n        var x31 = (x3 + x1) / 2;\n        var y31 = (y3 + y1) / 2;\n\n        // Add a limit to prevent infinite recursion\n        var nextDepth = depth - 1;\n\n        // Recursively draw three smaller triangles (with reduced stack usage)\n        if (nextDepth >= 0) {\n          this.drawSierpinski(elements, x1, y1, x12, y12, x31, y31, nextDepth);\n          this.drawSierpinski(elements, x12, y12, x2, y2, x23, y23, nextDepth);\n          this.drawSierpinski(elements, x31, y31, x23, y23, x3, y3, nextDepth);\n        }\n      }\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(SierpinskiTriangle, \"parameters\", {\n  size: {\n    min: 100,\n    max: 180,\n    \"default\": 180\n  },\n  iterations: {\n    min: 1,\n    max: 5,\n    \"default\": 3\n  },\n  thickness: {\n    min: 0.5,\n    max: 5,\n    \"default\": 3\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SierpinskiTriangle);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/SierpinskiTriangle.js?");

/***/ }),

/***/ "./src/shapes/Signal.js":
/*!******************************!*\
  !*** ./src/shapes/Signal.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a signal strength indicator symbol with a central circle and two\n * pairs of flanking semi-circles.\n */\nvar Signal = /*#__PURE__*/function (_Shape) {\n  function Signal() {\n    _classCallCheck(this, Signal);\n    return _callSuper(this, Signal, arguments);\n  }\n  _inherits(Signal, _Shape);\n  return _createClass(Signal, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var R_c = this.centerRadius;\n      var R_i = this.innerRadius;\n      var R_o = this.outerRadius;\n      var G = this.gap;\n\n      // Calculate the x-coordinate of the flat edge for the inner semi-circles\n      var X_i = R_c + G;\n\n      // Calculate the x-coordinate of the flat edge for the outer semi-circles\n      var X_o = X_i + R_i + G; // Or R_c + R_i + 2*G\n\n      // Ensure radii are positive to avoid rendering issues\n      if (R_c <= 0 || R_i <= 0 || R_o <= 0) {\n        return ''; // Return empty string if radii are invalid\n      }\n\n      // 1. Central Circle\n      var centerCircle = \"<circle cx=\\\"0\\\" cy=\\\"0\\\" r=\\\"\".concat(R_c, \"\\\" fill=\\\"white\\\" />\");\n\n      // 2. Inner Semi-circles (using Path elements for semi-circles)\n      var innerLeftPathData = \"M \".concat(-X_i, \" \").concat(-R_i, \" A \").concat(R_i, \" \").concat(R_i, \" 0 0 0 \").concat(-X_i, \" \").concat(R_i, \" Z\");\n      var innerRightPathData = \"M \".concat(X_i, \" \").concat(-R_i, \" A \").concat(R_i, \" \").concat(R_i, \" 0 0 1 \").concat(X_i, \" \").concat(R_i, \" Z\");\n      var innerLeftSemiCircle = \"<path d=\\\"\".concat(innerLeftPathData, \"\\\" fill=\\\"white\\\" />\");\n      var innerRightSemiCircle = \"<path d=\\\"\".concat(innerRightPathData, \"\\\" fill=\\\"white\\\" />\");\n\n      // 3. Outer Semi-circles\n      var outerLeftPathData = \"M \".concat(-X_o, \" \").concat(-R_o, \" A \").concat(R_o, \" \").concat(R_o, \" 0 0 0 \").concat(-X_o, \" \").concat(R_o, \" Z\");\n      var outerRightPathData = \"M \".concat(X_o, \" \").concat(-R_o, \" A \").concat(R_o, \" \").concat(R_o, \" 0 0 1 \").concat(X_o, \" \").concat(R_o, \" Z\");\n      var outerLeftSemiCircle = \"<path d=\\\"\".concat(outerLeftPathData, \"\\\" fill=\\\"white\\\" />\");\n      var outerRightSemiCircle = \"<path d=\\\"\".concat(outerRightPathData, \"\\\" fill=\\\"white\\\" />\");\n\n      // Combine all SVG elements\n      return \"\\n            \".concat(centerCircle, \"\\n            \").concat(innerLeftSemiCircle, \"\\n            \").concat(innerRightSemiCircle, \"\\n            \").concat(outerLeftSemiCircle, \"\\n            \").concat(outerRightSemiCircle, \"\\n        \");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(Signal, \"parameters\", {\n  centerRadius: {\n    type: 'number',\n    min: 5,\n    max: 25,\n    // Adjusted max to prevent excessive width\n    step: 1,\n    \"default\": 15\n  },\n  innerRadius: {\n    type: 'number',\n    min: 10,\n    max: 40,\n    // Adjusted max\n    step: 1,\n    \"default\": 25\n  },\n  outerRadius: {\n    type: 'number',\n    min: 15,\n    max: 50,\n    // Adjusted max\n    step: 1,\n    \"default\": 40\n  },\n  gap: {\n    type: 'number',\n    min: 2,\n    max: 15,\n    // Adjusted max\n    step: 1,\n    \"default\": 5\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Signal);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/Signal.js?");

/***/ }),

/***/ "./src/shapes/SignalShape.js":
/*!***********************************!*\
  !*** ./src/shapes/SignalShape.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a signal strength indicator with vertical bars of increasing\n * height, with style and split options.\n */\nvar SignalShape = /*#__PURE__*/function (_Shape) {\n  function SignalShape() {\n    _classCallCheck(this, SignalShape);\n    return _callSuper(this, SignalShape, arguments);\n  }\n  _inherits(SignalShape, _Shape);\n  return _createClass(SignalShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Reset RNG for consistency\n      this.resetRNG();\n\n      // Calculate dimensions\n      var barHeights = this.calculateBarHeights();\n      var totalWidth = this.barCount * this.barWidth + (this.barCount - 1) * this.spacing;\n      var startX = -totalWidth / 2;\n\n      // Determine if we should split the signal into two groups (like in Image 2)\n      var elements = [];\n      if (this.splitStyle === 'wifi') {\n        // Create WiFi-style signal (left side square, right side rounded)\n        var leftCount = Math.ceil(this.barCount / 2);\n        var rightCount = this.barCount - leftCount;\n\n        // First group (square bars, ascending left to right)\n        for (var i = 0; i < leftCount; i++) {\n          var height = barHeights[i];\n          var x = startX + i * (this.barWidth + this.spacing);\n          var y = -height / 2;\n          elements.push(\"<rect \\n                    x=\\\"\".concat(x, \"\\\" \\n                    y=\\\"\").concat(y, \"\\\" \\n                    width=\\\"\").concat(this.barWidth, \"\\\" \\n                    height=\\\"\").concat(height, \"\\\"\\n                    fill=\\\"white\\\"\\n                />\"));\n        }\n\n        // Second group (rounded bars, ascending left to right)\n        for (var _i = 0; _i < rightCount; _i++) {\n          var idx = _i + leftCount;\n          var _height = barHeights[idx];\n          var _x = startX + idx * (this.barWidth + this.spacing);\n          var _y = -_height / 2;\n          elements.push(\"<rect \\n                    x=\\\"\".concat(_x, \"\\\" \\n                    y=\\\"\").concat(_y, \"\\\" \\n                    width=\\\"\").concat(this.barWidth, \"\\\" \\n                    height=\\\"\").concat(_height, \"\\\"\\n                    rx=\\\"\").concat(this.style === 'square' ? 0 : Math.min(this.barWidth / 2, 8), \"\\\" \\n                    ry=\\\"\").concat(this.style === 'square' ? 0 : Math.min(this.barWidth / 2, 8), \"\\\"\\n                    fill=\\\"white\\\"\\n                />\"));\n        }\n      } else {\n        // Standard signal bars (all same style, ascending left to right)\n        for (var _i2 = 0; _i2 < this.barCount; _i2++) {\n          var _height2 = barHeights[_i2];\n          var _x2 = startX + _i2 * (this.barWidth + this.spacing);\n          var _y2 = -_height2 / 2;\n          var radius = this.style === 'rounded' ? Math.min(this.cornerRadius, this.barWidth / 2) : 0;\n          elements.push(\"<rect \\n                    x=\\\"\".concat(_x2, \"\\\" \\n                    y=\\\"\").concat(_y2, \"\\\" \\n                    width=\\\"\").concat(this.barWidth, \"\\\" \\n                    height=\\\"\").concat(_height2, \"\\\"\\n                    rx=\\\"\").concat(radius, \"\\\" \\n                    ry=\\\"\").concat(radius, \"\\\"\\n                    fill=\\\"white\\\"\\n                />\"));\n        }\n      }\n      return \"<g transform=\\\"rotate(90)\\\">\".concat(elements.join(''), \"</g>\");\n    }\n  }, {\n    key: \"calculateBarHeights\",\n    value: function calculateBarHeights() {\n      var heights = [];\n      var heightDiff = this.maxHeight - this.minHeight;\n      for (var i = 0; i < this.barCount; i++) {\n        // Calculate height based on position (increasing from left to right)\n        var ratio = i / (this.barCount - 1);\n        var height = this.minHeight + heightDiff * ratio;\n        heights.push(height);\n      }\n      return heights;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(SignalShape, \"parameters\", {\n  barCount: {\n    min: 3,\n    max: 8,\n    \"default\": 5\n  },\n  spacing: {\n    min: 2,\n    max: 15,\n    \"default\": 8\n  },\n  minHeight: {\n    min: 10,\n    max: 40,\n    \"default\": 20\n  },\n  maxHeight: {\n    min: 30,\n    max: 200,\n    \"default\": 180\n  },\n  barWidth: {\n    min: 5,\n    max: 25,\n    \"default\": 15\n  },\n  cornerRadius: {\n    min: 0,\n    max: 10,\n    \"default\": 0\n  },\n  style: {\n    options: ['square', 'rounded'],\n    \"default\": 'square'\n  },\n  splitStyle: {\n    options: ['standard', 'wifi'],\n    \"default\": 'standard'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SignalShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/SignalShape.js?");

/***/ }),

/***/ "./src/shapes/SmileyStar.js":
/*!**********************************!*\
  !*** ./src/shapes/SmileyStar.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a dynamic, irregular blob shape using procedural point generation\n * and quadratic curves.\n */\nvar BlobShape = /*#__PURE__*/function (_Shape) {\n  function BlobShape() {\n    _classCallCheck(this, BlobShape);\n    return _callSuper(this, BlobShape, arguments);\n  }\n  _inherits(BlobShape, _Shape);\n  return _createClass(BlobShape, [{\n    key: \"toRad\",\n    value:\n    /**\n     * Converts degrees to radians.\n     * @param {number} deg - Angle in degrees.\n     * @returns {number} Angle in radians.\n     */\n    function toRad(deg) {\n      return deg * (Math.PI / 180.0);\n    }\n\n    /**\n     * Generates an array of angles evenly dividing 360 degrees.\n     * @param {number} count - The number of divisions (edges).\n     * @returns {number[]} An array of angles in degrees.\n     */\n  }, {\n    key: \"divide\",\n    value: function divide(count) {\n      if (count <= 0) return [];\n      var deg = 360.0 / count;\n      return Array.from({\n        length: count\n      }, function (_, i) {\n        return i * deg;\n      });\n    }\n\n    /**\n     * Calculates the radius for a point at a specific angle, incorporating randomness and wave modulation.\n     * @param {number} angleRad - The angle in radians for the point.\n     * @param {number} minRadius - The minimum possible radius.\n     * @param {number} maxRadius - The maximum possible radius.\n     * @returns {number} The calculated radius.\n     */\n  }, {\n    key: \"calculateRadius\",\n    value: function calculateRadius(angleRad, minRadius, maxRadius) {\n      // Base radius influenced by randomness\n      var baseRadius = minRadius + this.random() * (maxRadius - minRadius);\n\n      // Apply sinusoidal modulation if amplitude > 0\n      var waveModulation = 0;\n      if (this.amplitude > 0) {\n        var range = maxRadius - minRadius;\n        // Use a combination of sine waves for more complex undulation\n        var primaryWave = Math.sin(angleRad * this.frequency) * this.amplitude * range * 0.1; // Reduced multiplier\n        var secondaryWave = Math.sin(angleRad * this.frequency * 1.8) * this.amplitude * range * 0.05;\n        waveModulation = primaryWave + secondaryWave;\n      }\n\n      // Apply random offset based on randomness parameter\n      var randomOffset = (this.random() - 0.5) * (maxRadius - minRadius) * this.randomness;\n      var finalRadius = baseRadius + waveModulation + randomOffset;\n\n      // Clamp the radius to ensure it stays within the defined min/max bounds\n      finalRadius = Math.max(minRadius, Math.min(finalRadius, maxRadius));\n      return finalRadius;\n    }\n\n    /**\n     * Calculates the coordinates of a point on a circle/ellipse.\n     * @param {number} centerX - X-coordinate of the center.\n     * @param {number} centerY - Y-coordinate of the center.\n     * @param {number} radius - Distance from the center.\n     * @param {number} degree - Angle in degrees.\n     * @returns {{x: number, y: number}} The point coordinates.\n     */\n  }, {\n    key: \"point\",\n    value: function point(centerX, centerY, radius, degree) {\n      var skewRad = this.toRad(this.skew);\n      var angleRad = this.toRad(degree) + skewRad; // Apply skew to the angle\n      var x = centerX + radius * Math.cos(angleRad);\n      var y = centerY + radius * Math.sin(angleRad);\n      return {\n        x: x,\n        y: y\n      };\n    }\n\n    /**\n     * Creates the points defining the blob shape.\n     * @param {number} size - The approximate maximum diameter of the blob.\n     * @param {number} minGrowthFactor - Factor determining the minimum radius relative to the maximum.\n     * @param {number} edgesCount - The number of primary points or \"edges\".\n     * @returns {{x: number, y: number}[]} An array of points.\n     */\n  }, {\n    key: \"createPoints\",\n    value: function createPoints(size, minGrowthFactor, edgesCount) {\n      var _this = this;\n      var maxRadius = size / 2;\n      // Ensure inner radius is always less than outer radius\n      var minRadius = Math.max(1, Math.min(maxRadius * 0.9, minGrowthFactor * (maxRadius / 10)));\n      var centerX = 0;\n      var centerY = 0;\n      var slices = this.divide(edgesCount);\n\n      // Use this.random() provided by the base Shape class\n      // RNG is initialized once in the constructor based on this.seed\n      return slices.map(function (degree) {\n        var angleRad = _this.toRad(degree);\n        var radius = _this.calculateRadius(angleRad, minRadius, maxRadius);\n        return _this.point(centerX, centerY, radius, degree);\n      });\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Use a base size that fits comfortably within the -100 to +100 viewBox\n      var baseSize = 190;\n      var points = this.createPoints(baseSize, this.growth, this.edges);\n      if (points.length < 3) {\n        // Fallback for insufficient points\n        console.warn(\"BlobShape: Not enough points generated, falling back to circle.\");\n        return '<circle cx=\"0\" cy=\"0\" r=\"90\" fill=\"white\" />';\n      }\n      try {\n        // Generate path using quadratic Bezier curves for smoothness\n        var pathCommands = [];\n\n        // Start at the midpoint between the last and first point for a smooth close\n        var lastPoint = points[points.length - 1];\n        var firstPoint = points[0];\n        var startMidX = (lastPoint.x + firstPoint.x) / 2;\n        var startMidY = (lastPoint.y + firstPoint.y) / 2;\n        pathCommands.push(\"M \".concat(startMidX.toFixed(2), \" \").concat(startMidY.toFixed(2)));\n        for (var i = 0; i < points.length; i++) {\n          var p1 = points[i]; // Current point acts as the control point\n          var p2 = points[(i + 1) % points.length]; // Next point\n\n          // Calculate the midpoint to curve towards\n          var midX = (p1.x + p2.x) / 2;\n          var midY = (p1.y + p2.y) / 2;\n\n          // Use the actual point as control point (p1) and curve to the midpoint (midX, midY)\n          pathCommands.push(\"Q \".concat(p1.x.toFixed(2), \",\").concat(p1.y.toFixed(2), \" \").concat(midX.toFixed(2), \",\").concat(midY.toFixed(2)));\n        }\n        pathCommands.push('Z'); // Close the path\n\n        return \"<path d=\\\"\".concat(pathCommands.join(' '), \"\\\" fill=\\\"white\\\" />\");\n      } catch (error) {\n        console.error(\"BlobShape: Error generating path:\", error);\n        // Fallback to a circle if path generation fails unexpectedly\n        return '<circle cx=\"0\" cy=\"0\" r=\"90\" fill=\"white\" />';\n      }\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(BlobShape, \"parameters\", {\n  edges: {\n    type: 'number',\n    min: 4,\n    max: 20,\n    step: 1,\n    \"default\": 10\n  },\n  growth: {\n    type: 'number',\n    min: 2,\n    max: 8,\n    step: 0.5,\n    \"default\": 4\n  },\n  // Relative inner radius factor\n  skew: {\n    type: 'number',\n    min: -45,\n    max: 45,\n    step: 1,\n    \"default\": 0\n  },\n  // Overall rotation/skew\n  amplitude: {\n    type: 'number',\n    min: 0,\n    max: 4,\n    step: 0.1,\n    \"default\": 2\n  },\n  // Wave amplitude factor\n  frequency: {\n    type: 'number',\n    min: 0.5,\n    max: 6,\n    step: 0.1,\n    \"default\": 3\n  },\n  // Wave frequency\n  randomness: {\n    type: 'number',\n    min: 0,\n    max: 0.5,\n    step: 0.05,\n    \"default\": 0.15\n  } // Randomness added to radius\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BlobShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/SmileyStar.js?");

/***/ }),

/***/ "./src/shapes/Sparkles.js":
/*!********************************!*\
  !*** ./src/shapes/Sparkles.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a composition of two four-pointed sparkle shapes with curved sides,\n * one larger and one smaller offset secondary sparkle.\n */\nvar Sparkles = /*#__PURE__*/function (_Shape) {\n  function Sparkles() {\n    _classCallCheck(this, Sparkles);\n    return _callSuper(this, Sparkles, arguments);\n  }\n  _inherits(Sparkles, _Shape);\n  return _createClass(Sparkles, [{\n    key: \"_f\",\n    value:\n    /**\n     * Helper to format numbers for SVG paths to a fixed precision.\n     * @param {number} n - The number to format.\n     * @returns {number} The formatted number.\n     */\n    function _f(n) {\n      // Using parseFloat eliminates trailing zeros from toFixed\n      return parseFloat(n.toFixed(2));\n    }\n\n    /**\n     * Helper function to generate the SVG path data string for a single sparkle.\n     * Uses Quadratic Bezier curves to create the curved sides.\n     * @param {number} cx - Center X coordinate.\n     * @param {number} cy - Center Y coordinate.\n     * @param {number} size - The outer radius (distance from center to tips).\n     * @param {number} valleyFactor - Controls the depth of the valleys between points (relative to size).\n     * @returns {string} SVG <path> element string.\n     */\n  }, {\n    key: \"_createSparklePath\",\n    value: function _createSparklePath(cx, cy, size, valleyFactor) {\n      var f = this._f; // Alias formatter\n      var outerRadius = size;\n      // innerRadius determines how close the valley points are to the center\n      var innerRadius = size * valleyFactor;\n      var sqrt2 = Math.sqrt(2);\n\n      // Calculate outer points (tips of the star)\n      var p1 = {\n        x: f(cx + outerRadius),\n        y: f(cy)\n      }; // Right\n      var p2 = {\n        x: f(cx),\n        y: f(cy - outerRadius)\n      }; // Top\n      var p3 = {\n        x: f(cx - outerRadius),\n        y: f(cy)\n      }; // Left\n      var p4 = {\n        x: f(cx),\n        y: f(cy + outerRadius)\n      }; // Bottom\n\n      // Calculate inner points (valleys between the tips)\n      var v1 = {\n        x: f(cx + innerRadius / sqrt2),\n        y: f(cy - innerRadius / sqrt2)\n      }; // Top-right valley\n      var v2 = {\n        x: f(cx - innerRadius / sqrt2),\n        y: f(cy - innerRadius / sqrt2)\n      }; // Top-left valley\n      var v3 = {\n        x: f(cx - innerRadius / sqrt2),\n        y: f(cy + innerRadius / sqrt2)\n      }; // Bottom-left valley\n      var v4 = {\n        x: f(cx + innerRadius / sqrt2),\n        y: f(cy + innerRadius / sqrt2)\n      }; // Bottom-right valley\n\n      // Construct the path data using quadratic Bezier curves (Q)\n      // The path starts at a valley point, curves towards a tip (control point), and ends at the next valley point.\n      var d = [\"M \".concat(v1.x, \" \").concat(v1.y), // Start at top-right valley\n      \"Q \".concat(p2.x, \" \").concat(p2.y, \" \").concat(v2.x, \" \").concat(v2.y), // Curve through top tip (p2) to top-left valley (v2)\n      \"Q \".concat(p3.x, \" \").concat(p3.y, \" \").concat(v3.x, \" \").concat(v3.y), // Curve through left tip (p3) to bottom-left valley (v3)\n      \"Q \".concat(p4.x, \" \").concat(p4.y, \" \").concat(v4.x, \" \").concat(v4.y), // Curve through bottom tip (p4) to bottom-right valley (v4)\n      \"Q \".concat(p1.x, \" \").concat(p1.y, \" \").concat(v1.x, \" \").concat(v1.y),\n      // Curve through right tip (p1) back to start valley (v1)\n      'Z' // Close the path\n      ].join(' ');\n      return \"<path d=\\\"\".concat(d, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\");\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Generate the path for the main sparkle centered at (0,0)\n      var mainPath = this._createSparklePath(0, 0, this.mainSize, this.valleyFactor);\n\n      // Calculate properties for the secondary sparkle\n      var secondarySize = this.mainSize * this.secondaryScale;\n      // Generate the path for the secondary sparkle at its offset position\n      var secondaryPath = this._createSparklePath(this.secondaryOffsetX, this.secondaryOffsetY, secondarySize, this.valleyFactor);\n      return \"<g>\".concat(mainPath).concat(secondaryPath, \"</g>\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(Sparkles, \"parameters\", {\n  mainSize: {\n    type: 'number',\n    min: 50,\n    max: 100,\n    step: 1,\n    \"default\": 100,\n    label: 'Main Size'\n  },\n  secondaryScale: {\n    type: 'number',\n    min: 0.1,\n    max: 0.9,\n    step: 0.05,\n    \"default\": 0.3,\n    label: 'Secondary Scale'\n  },\n  secondaryOffsetX: {\n    type: 'number',\n    min: -50,\n    max: 50,\n    step: 1,\n    \"default\": 50,\n    label: 'Secondary Offset X'\n  },\n  secondaryOffsetY: {\n    type: 'number',\n    min: -50,\n    max: 50,\n    step: 1,\n    \"default\": -50,\n    label: 'Secondary Offset Y'\n  },\n  valleyFactor: {\n    type: 'number',\n    min: 0.1,\n    max: 0.5,\n    step: 0.05,\n    \"default\": 0.25,\n    label: 'Valley Depth (Pointiness)' // Lower = sharper points\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Sparkles);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/Sparkles.js?");

/***/ }),

/***/ "./src/shapes/Spikes.js":
/*!******************************!*\
  !*** ./src/shapes/Spikes.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n/**\n * Generates a rectangular shape with a zigzag or spiked edge along one side.\n */\nvar SpikesShape = /*#__PURE__*/function (_Shape) {\n  function SpikesShape() {\n    _classCallCheck(this, SpikesShape);\n    return _callSuper(this, SpikesShape, arguments);\n  }\n  _inherits(SpikesShape, _Shape);\n  return _createClass(SpikesShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var halfSize = this.size / 2;\n      var segmentWidth = this.size / (this.segments * 2); // Each Spikes needs 2 segments\n      var pathPoints = [];\n\n      // Calculate maximum safe skew to stay within bounds\n      var maxSkewOffset = segmentWidth / 2;\n      var skewOffset = this.skew / 45 * maxSkewOffset; // Normalize skew to max offset\n\n      // Start at top-left corner\n      pathPoints.push(\"M \".concat(-halfSize, \" \").concat(-halfSize));\n\n      // Create Spikes pattern\n      for (var i = 0; i <= this.segments * 2; i++) {\n        var baseX = -halfSize + i * segmentWidth;\n\n        // Apply skew only to peaks, keeping base points aligned\n        var isTop = i % 2 === 0;\n        var x = baseX + (isTop ? 0 : skewOffset);\n        var y = -halfSize + (isTop ? 0 : this.size);\n        pathPoints.push(\"L \".concat(x, \" \").concat(y));\n      }\n\n      // Complete the rectangle\n      pathPoints.push(\"L \".concat(halfSize, \" \").concat(halfSize));\n      pathPoints.push(\"L \".concat(-halfSize, \" \").concat(halfSize));\n      pathPoints.push('Z');\n      return \"<path \\n            d=\\\"\".concat(pathPoints.join(' '), \"\\\"\\n            fill=\\\"white\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(SpikesShape, \"parameters\", {\n  size: {\n    min: 50,\n    max: 400,\n    \"default\": 200\n  },\n  segments: {\n    min: 2,\n    max: 8,\n    \"default\": 4\n  },\n  skew: {\n    min: -90,\n    max: 90,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SpikesShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/Spikes.js?");

/***/ }),

/***/ "./src/shapes/SpiralWave.js":
/*!**********************************!*\
  !*** ./src/shapes/SpiralWave.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates multiple parallel wavy lines resembling strands or ribbons flowing\n * vertically.\n */\nvar SpiralWave = /*#__PURE__*/function (_Shape) {\n  function SpiralWave() {\n    _classCallCheck(this, SpiralWave);\n    return _callSuper(this, SpiralWave, arguments);\n  }\n  _inherits(SpiralWave, _Shape);\n  return _createClass(SpiralWave, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var viewBoxWidth = 200;\n      var viewBoxHeight = 200;\n      var padding = 0.8;\n      var effectiveWidth = viewBoxWidth - 2 * padding;\n      var effectiveHeight = viewBoxHeight - 2 * padding;\n      var scale = Math.min(effectiveWidth, effectiveHeight) / 300;\n      var xMin = -viewBoxWidth / 2 + padding;\n      var xMax = viewBoxWidth / 2 - padding;\n      var yMin = -viewBoxHeight / 2 + padding;\n      var yMax = viewBoxHeight / 2 - padding;\n      var centerX = (xMin + xMax) / 2;\n      var strands = this.strands;\n      var amplitude = this.amplitude * scale;\n      var frequency = this.frequency;\n      var phase = this.phase * (Math.PI / 180);\n      var thickness = this.thickness * scale;\n      var spread = this.spread * scale;\n      var paths = [];\n      for (var strand = 0; strand < strands; strand++) {\n        var strandOffset = strand * spread / (strands - 1);\n        var strandPhase = phase + strand * 0.5;\n        var d = \"\";\n        for (var step = 0; step <= 100; step++) {\n          var t = step / 100;\n          var baseX = centerX - spread / 2 + strandOffset;\n          var x = baseX + amplitude * Math.sin(2 * Math.PI * frequency * t + strandPhase);\n          var y = yMin + effectiveHeight * t;\n          d += step === 0 ? \"M \".concat(x, \" \").concat(y) : \" L \".concat(x, \" \").concat(y);\n        }\n        paths.push(\"<path d=\\\"\".concat(d, \"\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(thickness, \"\\\" fill=\\\"none\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\" />\"));\n      }\n      return paths.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(SpiralWave, \"parameters\", {\n  strands: {\n    min: 3,\n    max: 12,\n    \"default\": 6\n  },\n  amplitude: {\n    min: 10,\n    max: 100,\n    \"default\": 40\n  },\n  frequency: {\n    min: 1,\n    max: 8,\n    \"default\": 1\n  },\n  phase: {\n    min: -180,\n    max: 180,\n    \"default\": 0\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 4\n  },\n  spread: {\n    min: 10,\n    max: 100,\n    \"default\": 100\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SpiralWave);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/SpiralWave.js?");

/***/ }),

/***/ "./src/shapes/SpiroPetal.js":
/*!**********************************!*\
  !*** ./src/shapes/SpiroPetal.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates spirograph-like patterns resembling overlapping petals using\n * parametric equations.\n */\nvar SpiroPetal = /*#__PURE__*/function (_Shape) {\n  function SpiroPetal() {\n    _classCallCheck(this, SpiroPetal);\n    return _callSuper(this, SpiroPetal, arguments);\n  }\n  _inherits(SpiroPetal, _Shape);\n  return _createClass(SpiroPetal, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var paths = [];\n      var petalCount = parseInt(this.petals);\n      var offsetRad = this.offset * Math.PI / 180;\n\n      // Generate the points exactly like in the p5.js sketch\n      for (var k = 0; k < 2 * Math.PI; k += Math.PI / petalCount) {\n        var pathData = '';\n        var firstPoint = null;\n        for (var a = 0; a < 2 * Math.PI; a += 2 * Math.PI / 200) {\n          var s = offsetRad;\n\n          // Using the exact equations from the p5.js sketch\n          var x = Math.sin(a - s) * Math.cos(a + k - s) * this.outerRadius + (this.innerRadius + this.modulation * Math.sin(a + k + s)) * Math.sin(a + k + s);\n          var y = Math.cos(a - s) * Math.cos(a + k - s) * this.outerRadius + (this.innerRadius + this.modulation * Math.sin(a + k + s)) * Math.cos(a + k + s);\n\n          // Start the path with the first point\n          if (a === 0) {\n            pathData = \"M \".concat(x, \",\").concat(y);\n            firstPoint = {\n              x: x,\n              y: y\n            };\n          } else {\n            // Add line segments\n            pathData += \" L \".concat(x, \",\").concat(y);\n          }\n        }\n\n        // Close the path if needed\n        // pathData += ` Z`;\n\n        // Add the path to our collection\n        paths.push(\"<path \\n                d=\\\"\".concat(pathData, \"\\\" \\n                fill=\\\"none\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                stroke-linecap=\\\"round\\\"\\n                stroke-linejoin=\\\"round\\\"\\n            />\"));\n      }\n      return paths.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(SpiroPetal, \"parameters\", {\n  outerRadius: {\n    min: 50,\n    max: 100,\n    \"default\": 80\n  },\n  innerRadius: {\n    min: 10,\n    max: 50,\n    \"default\": 30\n  },\n  modulation: {\n    min: 0,\n    max: 20,\n    \"default\": 0\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 4\n  },\n  offset: {\n    min: 0,\n    max: 360,\n    \"default\": 45\n  },\n  petals: {\n    min: 1,\n    max: 2,\n    \"default\": 1\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SpiroPetal);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/SpiroPetal.js?");

/***/ }),

/***/ "./src/shapes/SpringSemicircles.js":
/*!*****************************************!*\
  !*** ./src/shapes/SpringSemicircles.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a series of nested semi-elliptical arcs resting on a baseline,\n * resembling a compressed spring toy viewed from the side.\n */\nvar SpringSemicircles = /*#__PURE__*/function (_Shape) {\n  function SpringSemicircles() {\n    _classCallCheck(this, SpringSemicircles);\n    return _callSuper(this, SpringSemicircles, arguments);\n  }\n  _inherits(SpringSemicircles, _Shape);\n  return _createClass(SpringSemicircles, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var halfWidth = this.baseWidth / 2;\n      var svgPaths = '';\n\n      // Base line - ensure it doesn't exceed viewBox boundaries\n      var clampedHalfWidth = Math.min(halfWidth, 100);\n      var clampedBaseY = Math.max(-100, Math.min(100, this.baseY));\n      svgPaths += \"<line x1=\\\"\".concat(-clampedHalfWidth, \"\\\" y1=\\\"\").concat(clampedBaseY, \"\\\" x2=\\\"\").concat(clampedHalfWidth, \"\\\" y2=\\\"\").concat(clampedBaseY, \"\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(this.strokeWidth, \"\\\" />\\n\");\n\n      // Arcs\n      if (this.numLines < 1) return svgPaths; // Should not happen with min=2, but safety check\n\n      for (var i = 0; i < this.numLines; i++) {\n        // Calculate height for this arc\n        // Progress goes from 0 for the outermost arc to nearly 1 for the innermost\n        var progress = i / this.numLines;\n        // Calculate the normalized height based on the progress and heightFactor\n        // Power function creates the compression effect\n        var normalizedHeight = Math.pow(1 - progress, this.heightFactor);\n        // Calculate the actual height, ensuring it's at least half the stroke width for visibility\n        var h_i = Math.max(this.strokeWidth / 2, this.maxHeight * normalizedHeight);\n\n        // Ensure the arc peak doesn't go beyond the top boundary\n        var clampedHeight = Math.min(h_i, clampedBaseY + 100); // Max height relative to baseY\n\n        // If calculated height is too small, skip drawing\n        if (clampedHeight < this.strokeWidth / 2) continue;\n\n        // Arc path command: M startX,startY A rx,ry x-axis-rotation large-arc-flag,sweep-flag endX,endY\n        // rx = horizontal radius = halfWidth\n        // ry = vertical radius = clampedHeight\n        // sweep-flag = 1 (draws the upper arc segment)\n        // large-arc-flag = 0 (arc is <= 180 degrees)\n        var pathData = \"M \".concat(-clampedHalfWidth, \",\").concat(clampedBaseY, \" A \").concat(clampedHalfWidth, \",\").concat(clampedHeight, \" 0 0 1 \").concat(clampedHalfWidth, \",\").concat(clampedBaseY);\n        svgPaths += \"<path d=\\\"\".concat(pathData, \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(this.strokeWidth, \"\\\" />\\n\");\n      }\n      return svgPaths.trim(); // Return all generated SVG elements\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(SpringSemicircles, \"parameters\", {\n  numLines: {\n    type: 'number',\n    min: 6,\n    max: 32,\n    step: 1,\n    \"default\": 10\n  },\n  baseWidth: {\n    type: 'number',\n    min: 50,\n    max: 150,\n    step: 1,\n    \"default\": 150\n  },\n  maxHeight: {\n    type: 'number',\n    min: 50,\n    max: 150,\n    step: 1,\n    \"default\": 150\n  },\n  baseY: {\n    type: 'number',\n    min: -95,\n    max: 95,\n    step: 1,\n    \"default\": 80\n  },\n  heightFactor: {\n    type: 'number',\n    min: 0.5,\n    max: 4,\n    step: 0.1,\n    \"default\": 1.5\n  },\n  // Controls height distribution (1=linear, >1 more compressed)\n  strokeWidth: {\n    type: 'number',\n    min: 0.5,\n    max: 5,\n    step: 0.1,\n    \"default\": 1.5\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SpringSemicircles);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/SpringSemicircles.js?");

/***/ }),

/***/ "./src/shapes/SpringShape.js":
/*!***********************************!*\
  !*** ./src/shapes/SpringShape.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a shape resembling a spring bent into a U-shape, composed of\n * zig-zag line segments.\n */\nvar SpringShape = /*#__PURE__*/function (_Shape) {\n  function SpringShape() {\n    _classCallCheck(this, SpringShape);\n    return _callSuper(this, SpringShape, arguments);\n  }\n  _inherits(SpringShape, _Shape);\n  return _createClass(SpringShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Access parameters using 'this'\n      var numZ = Math.max(2, Math.floor(this.numZigZags)); // Number of full zig-zags\n      var amp = this.amplitude;\n      var width = this.springWidth;\n      var height = this.legHeight;\n      var sw = this.strokeWidth;\n      var points = [];\n      var R = width / 2; // Radius of the central arc (can be 0)\n      var isArcPresent = R > 1e-6;\n      var isHeightPresent = height > 1e-6;\n\n      // Calculate the length of each segment of the underlying U-shape path centerline\n      var lenLeftLeg = height;\n      var lenArc = isArcPresent ? Math.PI * R : 0;\n      var lenRightLeg = height;\n      var totalLength = lenLeftLeg + lenArc + lenRightLeg;\n\n      // If total length is negligible, return empty\n      if (totalLength <= 1e-6) return '';\n\n      // Total number of points to generate (vertices of the zig-zag)\n      // N represents the number of half-zigzags (segments between peaks/troughs)\n      // We need N+1 points to define N segments\n      var N = numZ * 2;\n\n      // Calculate vertical offset to roughly center the shape in the viewBox\n      // Max Y extent approx: amp (top of legs)\n      // Min Y extent approx: -height - R - amp (bottom of arc with amplitude)\n      var maxY = amp;\n      var minY = -height - (isArcPresent ? R : 0) - amp; // Adjust based on arc presence\n      var yOffset = -(maxY + minY) / 2;\n      for (var i = 0; i <= N; i++) {\n        // Avoid division by zero if N=0 (though min numZigZags prevents this)\n        var fraction = N === 0 ? 0 : i / N;\n        var d = fraction * totalLength; // Distance along the center path\n\n        var cx_raw = void 0,\n          cy_raw = void 0; // Centerline point coordinates (raw, before vertical offset)\n        var px = void 0,\n          py = void 0; // Perpendicular vector components (normalized direction outwards)\n\n        // Determine segment and calculate centerline point and perpendicular vector\n        if (isHeightPresent && d <= lenLeftLeg) {\n          // --- Left Leg (Top to Bottom) ---\n          cx_raw = -R;\n          cy_raw = -d; // Starts at y=0, goes down\n          px = -1; // Perpendicular points outwards (left)\n          py = 0;\n        } else if (isArcPresent && (!isHeightPresent || d <= lenLeftLeg + lenArc)) {\n          // --- Bottom Arc (Left to Right) ---\n          // Distance covered along the arc path\n          var arcDist = isHeightPresent ? d - lenLeftLeg : d;\n          // Angle starts at PI (left side, -R) and increases towards 2*PI (right side, +R)\n          var angle = Math.PI + arcDist / R;\n          var arcCenterX = 0;\n          var arcCenterY = -height; // Center of the arc is below the legs\n\n          cx_raw = arcCenterX + R * Math.cos(angle);\n          cy_raw = arcCenterY + R * Math.sin(angle);\n\n          // Perpendicular vector (outwards normal to the circle)\n          px = Math.cos(angle);\n          py = Math.sin(angle);\n        } else if (isHeightPresent) {\n          // --- Right Leg (Bottom to Top) ---\n          // Calculate distance covered along this leg, accounting for whether arc existed\n          var startOfRightLeg = lenLeftLeg + lenArc; // lenArc is 0 if no arc\n          var legDist = d - startOfRightLeg;\n          cx_raw = R;\n          // Starts at y = -height, goes up towards y = 0\n          cy_raw = -height + legDist;\n          px = 1; // Perpendicular points outwards (right)\n          py = 0;\n        } else {\n          // Fallback case (should only happen if totalLength is tiny or zero, handled above)\n          cx_raw = 0;\n          cy_raw = 0;\n          px = 0;\n          py = 0;\n        }\n\n        // Determine the sign for the amplitude offset (alternating)\n        // Start outwards (positive offset relative to perpendicular vector) for i=0\n        // Since left leg px=-1, positive offset moves it further left (correct)\n        // Since right leg px=1, positive offset moves it further right (correct)\n        var sign = i % 2 === 0 ? 1 : -1;\n\n        // Calculate the final point coordinates with amplitude offset and centering adjustment\n        var finalX = cx_raw + px * sign * amp;\n        // Apply vertical offset to center the shape\n        var finalY = cy_raw + py * sign * amp + yOffset;\n\n        // Add point to the list, formatted for SVG polyline\n        points.push(\"\".concat(finalX.toFixed(2), \",\").concat(finalY.toFixed(2)));\n      }\n\n      // Ensure there are enough points to draw a line\n      if (points.length < 2) return '';\n\n      // Return the SVG polyline element with rounded corners/ends\n      return \"<polyline points=\\\"\".concat(points.join(' '), \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(sw, \"\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\"/>\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(SpringShape, \"parameters\", {\n  numZigZags: {\n    type: 'number',\n    min: 4,\n    max: 100,\n    step: 2,\n    // Prefer even numbers for symmetry\n    \"default\": 30,\n    label: 'Zig-zags'\n  },\n  amplitude: {\n    type: 'number',\n    min: 1,\n    max: 40,\n    step: 1,\n    \"default\": 10,\n    label: 'Amplitude'\n  },\n  springWidth: {\n    type: 'number',\n    min: 0,\n    // Allow zero width (straight folded spring)\n    max: 180,\n    step: 1,\n    \"default\": 80,\n    label: 'Width'\n  },\n  legHeight: {\n    type: 'number',\n    min: 0,\n    // Allow zero height (just an arc spring)\n    max: 180,\n    step: 1,\n    \"default\": 100,\n    label: 'Leg Height'\n  },\n  strokeWidth: {\n    type: 'number',\n    min: 0.5,\n    max: 10,\n    step: 0.5,\n    \"default\": 2,\n    label: 'Stroke Width'\n  }\n  // Removed rounding parameter - using stroke-linejoin/linecap instead\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SpringShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/SpringShape.js?");

/***/ }),

/***/ "./src/shapes/SprocketShape.js":
/*!*************************************!*\
  !*** ./src/shapes/SprocketShape.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a sprocket or gear shape with outer teeth, an inner hub circle, and\n * radial spokes connecting them.\n */\nvar SprocketShape = /*#__PURE__*/function (_Shape) {\n  function SprocketShape() {\n    _classCallCheck(this, SprocketShape);\n    return _callSuper(this, SprocketShape, arguments);\n  }\n  _inherits(SprocketShape, _Shape);\n  return _createClass(SprocketShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var lines = [];\n\n      // Calculate dimensions\n      var radius = 100;\n      var innerRadius = radius * (1 - this.toothDepth);\n      var hubRadius = this.hubRadius * 100;\n      this.teeth = Math.round(this.teeth);\n      this.spokesCount = Math.round(this.spokesCount);\n\n      // Generate teeth\n      for (var i = 0; i < this.teeth; i++) {\n        var angle = i * 2 * Math.PI / this.teeth;\n        var nextAngle = (i + 1) * 2 * Math.PI / this.teeth;\n        var midAngle = (angle + nextAngle) / 2;\n\n        // Outer point\n        var x1 = radius * Math.cos(angle);\n        var y1 = radius * Math.sin(angle);\n\n        // Inner point\n        var x2 = innerRadius * Math.cos(midAngle);\n        var y2 = innerRadius * Math.sin(midAngle);\n        lines.push(\"<line \\n                x1=\\\"\".concat(x1, \"\\\" \\n                y1=\\\"\").concat(y1, \"\\\" \\n                x2=\\\"\").concat(x2, \"\\\" \\n                y2=\\\"\").concat(y2, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                stroke-linecap=\\\"\").concat(this.lineCap, \"\\\"\\n            />\"));\n\n        // Connect to next tooth (including back to first tooth)\n        var nextX = radius * Math.cos(nextAngle);\n        var nextY = radius * Math.sin(nextAngle);\n        lines.push(\"<line \\n                x1=\\\"\".concat(x2, \"\\\" \\n                y1=\\\"\").concat(y2, \"\\\" \\n                x2=\\\"\").concat(nextX, \"\\\" \\n                y2=\\\"\").concat(nextY, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                stroke-linecap=\\\"\").concat(this.lineCap, \"\\\"\\n            />\"));\n      }\n\n      // Draw hub circle\n      lines.push(\"<circle \\n            cx=\\\"0\\\" \\n            cy=\\\"0\\\" \\n            r=\\\"\".concat(hubRadius, \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            fill=\\\"none\\\"\\n        />\"));\n\n      // Generate spokes\n      for (var _i = 0; _i < this.spokesCount; _i++) {\n        var _angle = _i * 2 * Math.PI / this.spokesCount;\n        var x = innerRadius * Math.cos(_angle);\n        var y = innerRadius * Math.sin(_angle);\n        lines.push(\"<line \\n                x1=\\\"\".concat(hubRadius * Math.cos(_angle), \"\\\" \\n                y1=\\\"\").concat(hubRadius * Math.sin(_angle), \"\\\" \\n                x2=\\\"\").concat(x, \"\\\" \\n                y2=\\\"\").concat(y, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                stroke-linecap=\\\"\").concat(this.lineCap, \"\\\"\\n            />\"));\n      }\n      return lines.join('\\n');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(SprocketShape, \"parameters\", {\n  teeth: {\n    min: 6,\n    max: 24,\n    \"default\": 32\n  },\n  toothDepth: {\n    min: 0.1,\n    max: 0.3,\n    \"default\": 0.2\n  },\n  hubRadius: {\n    min: 0.2,\n    max: 0.4,\n    \"default\": 0.2\n  },\n  spokesCount: {\n    min: 3,\n    max: 8,\n    \"default\": 6\n  },\n  thickness: {\n    min: 1,\n    max: 5,\n    \"default\": 4\n  },\n  lineCap: {\n    options: ['butt', 'round'],\n    \"default\": 'round'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SprocketShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/SprocketShape.js?");

/***/ }),

/***/ "./src/shapes/SquareBoxShape.js":
/*!**************************************!*\
  !*** ./src/shapes/SquareBoxShape.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a rounded square with an inner rectangular cutout that can be\n * offset horizontally.\n */\nvar SquareBoxShape = /*#__PURE__*/function (_Shape) {\n  function SquareBoxShape() {\n    _classCallCheck(this, SquareBoxShape);\n    return _callSuper(this, SquareBoxShape, arguments);\n  }\n  _inherits(SquareBoxShape, _Shape);\n  return _createClass(SquareBoxShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Calculate dimensions ensuring the inner rectangle fits\n      var innerHeight = this.size - this.padding * 2;\n\n      // Center the shapes in the viewBox\n      var offset = -this.size / 2;\n\n      // Calculate maximum x-offset to keep inner rect within bounds\n      var maxSlide = this.size - this.innerWidth - this.padding * 2;\n      var normalizedOffset = maxSlide * this.xOffset / 100; // Convert percentage to actual offset\n\n      // Generate the outer square with rounded corners\n      var outerSquare = \"<rect \\n            x=\\\"\".concat(offset, \"\\\"\\n            y=\\\"\").concat(offset, \"\\\"\\n            width=\\\"\").concat(this.size, \"\\\"\\n            height=\\\"\").concat(this.size, \"\\\"\\n            rx=\\\"\").concat(this.outerRadius, \"\\\"\\n            ry=\\\"\").concat(this.outerRadius, \"\\\"\\n            fill=\\\"white\\\"\\n        />\");\n\n      // Generate the inner rectangle with horizontal offset\n      var innerRect = \"<rect \\n            x=\\\"\".concat(offset + this.padding + normalizedOffset, \"\\\"\\n            y=\\\"\").concat(offset + this.padding, \"\\\"\\n            width=\\\"\").concat(this.innerWidth, \"\\\"\\n            height=\\\"\").concat(innerHeight, \"\\\"\\n            rx=\\\"\").concat(this.innerRadius, \"\\\"\\n            ry=\\\"\").concat(this.innerRadius, \"\\\"\\n            fill=\\\"black\\\"\\n        />\");\n      return \"\".concat(outerSquare).concat(innerRect);\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(SquareBoxShape, \"parameters\", {\n  size: {\n    min: 50,\n    max: 200,\n    \"default\": 100\n  },\n  outerRadius: {\n    min: 0,\n    max: 50,\n    \"default\": 0\n  },\n  innerRadius: {\n    min: 0,\n    max: 25,\n    \"default\": 0\n  },\n  innerWidth: {\n    min: 5,\n    max: 50,\n    \"default\": 20\n  },\n  padding: {\n    min: 5,\n    max: 30,\n    \"default\": 15\n  },\n  xOffset: {\n    min: 0,\n    max: 100,\n    \"default\": 0\n  } // New parameter for horizontal sliding\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SquareBoxShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/SquareBoxShape.js?");

/***/ }),

/***/ "./src/shapes/SquaresPyramid.js":
/*!**************************************!*\
  !*** ./src/shapes/SquaresPyramid.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a pyramid shape composed of stacked rows of squares, with fill or\n * stroke options.\n */\nvar SquaresPyramid = /*#__PURE__*/function (_Shape) {\n  function SquaresPyramid() {\n    _classCallCheck(this, SquaresPyramid);\n    return _callSuper(this, SquaresPyramid, arguments);\n  }\n  _inherits(SquaresPyramid, _Shape);\n  return _createClass(SquaresPyramid, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var squares = [];\n      var totalHeight = this.rows * (this.squareSize + this.spacing);\n      var startY = -totalHeight / 2;\n      for (var row = 0; row < this.rows; row++) {\n        var squaresInRow = row + 1;\n        var rowWidth = squaresInRow * (this.squareSize + this.spacing) - this.spacing;\n        var startX = -rowWidth / 2;\n        for (var col = 0; col < squaresInRow; col++) {\n          var x = startX + col * (this.squareSize + this.spacing);\n          var y = startY + row * (this.squareSize + this.spacing);\n          squares.push(\"<rect \\n                    x=\\\"\".concat(x, \"\\\"\\n                    y=\\\"\").concat(y, \"\\\"\\n                    width=\\\"\").concat(this.squareSize, \"\\\"\\n                    height=\\\"\").concat(this.squareSize, \"\\\"\\n                    fill=\\\"\").concat(this.fillStyle === 'fill' ? 'white' : 'none', \"\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                />\"));\n        }\n      }\n      return squares.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(SquaresPyramid, \"parameters\", {\n  rows: {\n    min: 1,\n    max: 8,\n    \"default\": 3\n  },\n  squareSize: {\n    min: 10,\n    max: 50,\n    \"default\": 50\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  },\n  spacing: {\n    min: 0,\n    max: 20,\n    \"default\": 8\n  },\n  fillStyle: {\n    options: ['stroke', 'fill'],\n    \"default\": 'fill'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SquaresPyramid);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/SquaresPyramid.js?");

/***/ }),

/***/ "./src/shapes/SquiggleShape.js":
/*!*************************************!*\
  !*** ./src/shapes/SquiggleShape.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a single wavy line with adjustable amplitude, frequency, phase,\n * tension, and noise.\n */\nvar WaveCurve = /*#__PURE__*/function (_Shape) {\n  function WaveCurve() {\n    _classCallCheck(this, WaveCurve);\n    return _callSuper(this, WaveCurve, arguments);\n  }\n  _inherits(WaveCurve, _Shape);\n  return _createClass(WaveCurve, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var points = [];\n      var segments = this.points;\n      var phaseRad = this.phase * Math.PI / 180;\n\n      // Generate base points\n      for (var i = 0; i < segments; i++) {\n        var t = i / (segments - 1);\n        var x = (t * 2 - 1) * this.radius;\n\n        // Base wave with frequency\n        var y = Math.sin(t * Math.PI * 2 * this.frequency + phaseRad) * this.amplitude;\n\n        // Add controlled noise\n        if (this.noise > 0) {\n          var noiseAmount = this.noise / 100 * this.amplitude * 0.5;\n          var noise = Math.sin(t * 12.9898 + phaseRad) * Math.sin(t * 78.233 + phaseRad) * noiseAmount;\n          y += noise;\n        }\n        points.push([x, y]);\n      }\n\n      // Create SVG path\n      var pathData = \"M \".concat(points[0][0], \",\").concat(points[0][1]);\n      var tensionFactor = 1 - this.tension / 100;\n\n      // Smooth curves with variable control points\n      for (var _i = 1; _i < points.length; _i++) {\n        var p0 = points[_i - 1];\n        var p1 = points[_i];\n\n        // Calculate control points with variable distance based on smoothness\n        var dx = p1[0] - p0[0];\n        var dy = p1[1] - p0[1];\n\n        // Control point distance affected by both smoothness and tension\n        var cp_dist = Math.min(Math.abs(dx) * 0.5, 30) * tensionFactor;\n\n        // Control points\n        var cp1 = [p0[0] + cp_dist, p0[1]];\n        var cp2 = [p1[0] - cp_dist, p1[1]];\n        pathData += \" C \".concat(cp1[0], \",\").concat(cp1[1], \" \").concat(cp2[0], \",\").concat(cp2[1], \" \").concat(p1[0], \",\").concat(p1[1]);\n      }\n      return \"<path \\n            d=\\\"\".concat(pathData, \"\\\"\\n            fill=\\\"none\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            stroke-linecap=\\\"round\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(WaveCurve, \"parameters\", {\n  points: {\n    min: 3,\n    max: 10,\n    \"default\": 8\n  },\n  // Number of control points\n  radius: {\n    min: 10,\n    max: 150,\n    \"default\": 78\n  },\n  // Overall width\n  thickness: {\n    min: 1,\n    max: 20,\n    \"default\": 15\n  },\n  // Line thickness\n  amplitude: {\n    min: 0,\n    max: 100,\n    \"default\": 56\n  },\n  // Wave height\n  frequency: {\n    min: 1,\n    max: 8,\n    \"default\": 4\n  },\n  // Wave frequency\n  phase: {\n    min: -180,\n    max: 180,\n    \"default\": 2\n  },\n  // Rotation offset\n  tension: {\n    min: 0,\n    max: 100,\n    \"default\": 50\n  },\n  // Curve tension\n  noise: {\n    min: 0,\n    max: 100,\n    \"default\": 20\n  } // Random variation amount\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WaveCurve);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/SquiggleShape.js?");

/***/ }),

/***/ "./src/shapes/Squircle.js":
/*!********************************!*\
  !*** ./src/shapes/Squircle.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a squircle (superellipse) shape with adjustable corner radius,\n * smoothness, and optional inset.\n */\nvar Squircle = /*#__PURE__*/function (_Shape) {\n  function Squircle() {\n    _classCallCheck(this, Squircle);\n    return _callSuper(this, Squircle, arguments);\n  }\n  _inherits(Squircle, _Shape);\n  return _createClass(Squircle, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Scale factors and constraints\n      var baseSize = 200;\n      var minDimension = baseSize;\n      var scaleFactor = minDimension / baseSize;\n\n      // Scale parameters with safety bounds\n      var scaledRadius = Math.min(this.cornerRadius * scaleFactor, minDimension / 3);\n      var scaledInset = Math.min(this.inset * scaleFactor, minDimension / 4);\n      var scaledSmoothFactor = scaledRadius * this.smoothness;\n      var scaledBalancedRadius = scaledRadius * this.cornerBalance;\n\n      // Calculate drawing dimensions\n      var availableSize = minDimension - scaledInset * 2;\n      var halfSize = availableSize / 2;\n      var center = 0; // Center point in our coordinate system\n\n      // Calculate key points relative to center\n      var minX = center - halfSize;\n      var maxX = center + halfSize;\n      var minY = center - halfSize;\n      var maxY = center + halfSize;\n\n      // Build SVG path\n      var path = [// Start at top-left radius point\n      \"M \".concat(minX + scaledBalancedRadius, \" \").concat(minY), // Top edge to top-right corner\n      \"L \".concat(maxX - scaledBalancedRadius, \" \").concat(minY), // Top-right corner curve\n      \"C \".concat(maxX - scaledBalancedRadius + scaledSmoothFactor, \" \").concat(minY), \"\".concat(maxX, \" \").concat(minY + scaledBalancedRadius - scaledSmoothFactor), \"\".concat(maxX, \" \").concat(minY + scaledBalancedRadius), // Right edge to bottom-right corner\n      \"L \".concat(maxX, \" \").concat(maxY - scaledBalancedRadius), // Bottom-right corner curve\n      \"C \".concat(maxX, \" \").concat(maxY - scaledBalancedRadius + scaledSmoothFactor), \"\".concat(maxX - scaledBalancedRadius + scaledSmoothFactor, \" \").concat(maxY), \"\".concat(maxX - scaledBalancedRadius, \" \").concat(maxY), // Bottom edge to bottom-left corner\n      \"L \".concat(minX + scaledBalancedRadius, \" \").concat(maxY), // Bottom-left corner curve\n      \"C \".concat(minX + scaledBalancedRadius - scaledSmoothFactor, \" \").concat(maxY), \"\".concat(minX, \" \").concat(maxY - scaledBalancedRadius + scaledSmoothFactor), \"\".concat(minX, \" \").concat(maxY - scaledBalancedRadius), // Left edge to top-left corner\n      \"L \".concat(minX, \" \").concat(minY + scaledBalancedRadius), // Top-left corner curve\n      \"C \".concat(minX, \" \").concat(minY + scaledBalancedRadius - scaledSmoothFactor), \"\".concat(minX + scaledBalancedRadius - scaledSmoothFactor, \" \").concat(minY), \"\".concat(minX + scaledBalancedRadius, \" \").concat(minY), 'Z' // Close the path\n      ].join(' ');\n      return \"<path \\n            d=\\\"\".concat(path, \"\\\"\\n            fill=\\\"white\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(Squircle, \"parameters\", {\n  cornerRadius: {\n    min: 0,\n    max: 150,\n    \"default\": 80\n  },\n  smoothness: {\n    min: 0.1,\n    max: 1.0,\n    \"default\": 0.6\n  },\n  inset: {\n    min: 0,\n    max: 100,\n    \"default\": 20\n  },\n  cornerBalance: {\n    min: 0.1,\n    max: 2.0,\n    \"default\": 1.0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Squircle);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/Squircle.js?");

/***/ }),

/***/ "./src/shapes/StackedArcs2.js":
/*!************************************!*\
  !*** ./src/shapes/StackedArcs2.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates two stacked, outlined semi-circular arc segments with adjustable\n * thickness, gap, and angle span.\n */\nvar StackedArcs2 = /*#__PURE__*/function (_Shape) {\n  function StackedArcs2() {\n    _classCallCheck(this, StackedArcs2);\n    return _callSuper(this, StackedArcs2, arguments);\n  }\n  _inherits(StackedArcs2, _Shape);\n  return _createClass(StackedArcs2, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var rO = this.outerRadius;\n      // Ensure thickness doesn't result in an inner radius less than 1\n      var thickness = Math.min(this.thickness, rO - 1);\n      var rI = rO - thickness;\n      var gap = this.gap;\n      var vOffset = this.verticalOffset;\n      var angleDeg = this.arcAngle;\n      var angleRad = angleDeg * Math.PI / 180;\n\n      // Calculate start and end angles for the arc segment.\n      // Angles are measured counter-clockwise from the positive X-axis.\n      // The arc is centered vertically (around the Y-axis).\n      var startAngle = (Math.PI - angleRad) / 2; // Angle for the right endpoint (closer to 0 radians)\n      var endAngle = Math.PI - startAngle; // Angle for the left endpoint (closer to PI radians)\n\n      // Calculate coordinates for the arc endpoints using standard math coordinates (Y positive UP)\n      // Outer arc points\n      var ox_start = rO * Math.cos(startAngle);\n      var oy_start = rO * Math.sin(startAngle);\n      var ox_end = rO * Math.cos(endAngle);\n      var oy_end = rO * Math.sin(endAngle); // sin(pi - x) = sin(x), so oy_end = oy_start\n\n      // Inner arc points\n      var ix_start = rI * Math.cos(startAngle);\n      var iy_start = rI * Math.sin(startAngle);\n      var ix_end = rI * Math.cos(endAngle);\n      var iy_end = rI * Math.sin(endAngle); // iy_end = iy_start\n\n      // SVG arc flags\n      var largeArcFlag = angleRad > Math.PI ? 1 : 0; // Will be 0 since max angle is PI (180 deg)\n      // Sweep flag 1 for counter-clockwise (positive angle direction in math)\n      // Sweep flag 0 for clockwise (negative angle direction in math)\n\n      // Build the path 'd' attribute string for a single arc segment centered at (0,0).\n      // Format coordinates to a few decimal places for cleaner output.\n      var format = function format(num) {\n        return num.toFixed(3);\n      };\n\n      // Path definition:\n      // M outer_start_x, outer_start_y  (Move to the starting point on the outer radius, right side)\n      // A outer_radius, outer_radius, x-axis-rotation, large-arc-flag, sweep-flag, outer_end_x, outer_end_y (Draw the outer arc CCW to the left side)\n      // L inner_end_x, inner_end_y (Draw a line to the corresponding point on the inner radius, left side)\n      // A inner_radius, inner_radius, x-axis-rotation, large-arc-flag, !sweep-flag, inner_start_x, inner_start_y (Draw the inner arc CW back to the right side)\n      // Z (Close the path)\n      var d = \"M \".concat(format(ox_start), \",\").concat(format(oy_start)) + \" A \".concat(format(rO), \",\").concat(format(rO), \" 0 \").concat(largeArcFlag, \" 1 \").concat(format(ox_end), \",\").concat(format(oy_end)) + \" L \".concat(format(ix_end), \",\").concat(format(iy_end)) + \" A \".concat(format(rI), \",\").concat(format(rI), \" 0 \").concat(largeArcFlag, \" 0 \").concat(format(ix_start), \",\").concat(format(iy_start)) + \" Z\";\n\n      // Calculate vertical positions (Y-coordinates) for the center of each arc\n      // In our [-100, 100] system, positive Y is UP.\n      var yTop = gap / 2 + vOffset;\n      var yBottom = -gap / 2 + vOffset;\n\n      // Generate the two SVG path elements, applying the vertical translation.\n      // The path `d` is calculated assuming center (0,0), so we translate it.\n      var topArc = \"<path d=\\\"\".concat(d, \"\\\" transform=\\\"translate(0, \").concat(format(yTop), \")\\\" fill=\\\"white\\\" />\");\n      var bottomArc = \"<path d=\\\"\".concat(d, \"\\\" transform=\\\"translate(0, \").concat(format(yBottom), \")\\\" fill=\\\"white\\\" />\");\n\n      // Combine the SVG strings for both arcs.\n      return topArc + bottomArc;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(StackedArcs2, \"parameters\", {\n  outerRadius: {\n    type: 'number',\n    min: 10,\n    max: 80,\n    // Constrained to keep arcs mostly within the viewbox with default settings\n    step: 1,\n    \"default\": 60\n  },\n  thickness: {\n    type: 'number',\n    min: 2,\n    max: 78,\n    // Max thickness must be less than min outerRadius to ensure rI > 0\n    step: 1,\n    \"default\": 25\n  },\n  gap: {\n    type: 'number',\n    min: 20,\n    // Can touch if gap is 0\n    max: 100,\n    // Controls separation between the two arcs\n    step: 1,\n    \"default\": 50\n  },\n  arcAngle: {\n    type: 'number',\n    min: 10,\n    // Minimum angle for the arc segment to be visible\n    max: 180,\n    // Maximum angle for a semi-circle\n    step: 1,\n    \"default\": 180 // Default to full semi-circles\n  },\n  verticalOffset: {\n    type: 'number',\n    min: -30,\n    // Allows shifting the pair of arcs up/down\n    max: 30,\n    step: 1,\n    \"default\": 0 // Default is centered vertically\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StackedArcs2);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/StackedArcs2.js?");

/***/ }),

/***/ "./src/shapes/StackedChevrons.js":
/*!***************************************!*\
  !*** ./src/shapes/StackedChevrons.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a vertical stack of filled chevron (V-shaped) polygons.\n */\nvar StackedChevrons = /*#__PURE__*/function (_Shape) {\n  function StackedChevrons() {\n    _classCallCheck(this, StackedChevrons);\n    return _callSuper(this, StackedChevrons, arguments);\n  }\n  _inherits(StackedChevrons, _Shape);\n  return _createClass(StackedChevrons, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var N = this.numChevrons;\n      var W = this.chevronWidth;\n      var H = this.chevronHeight;\n      // Clamp thickness to be slightly less than height to avoid division by zero or degenerate shapes\n      var T = Math.min(this.thickness, H * 0.99);\n      var S = this.spacing;\n\n      // Ensure thickness is positive\n      if (T <= 0) return '';\n      // Ensure height is positive\n      if (H <= 0) return '';\n      var paths = [];\n      var totalHeight = N * H + (N - 1) * S;\n      var startY = -totalHeight / 2; // Y-coordinate of the tip of the topmost chevron\n\n      for (var k = 0; k < N; k++) {\n        var y_tip_k = startY + k * (H + S); // Y-coordinate for the tip of the k-th chevron\n\n        // Calculate the 6 points for the chevron polygon relative to the tip (0, y_tip_k)\n        // Outer points\n        var o1_x = 0;\n        var o1_y = y_tip_k;\n        var o2_x = -W / 2;\n        var o2_y = y_tip_k + H;\n        var o3_x = W / 2;\n        var o3_y = y_tip_k + H;\n\n        // Inner points\n        // Factor for calculating inner x-coordinates based on thickness/height ratio\n        var innerXFactor = 1 - T / H;\n        var i1_x = 0;\n        var i1_y = y_tip_k + T; // Inner tip is T units below outer tip\n        var i2_x = -W / 2 * innerXFactor;\n        var i2_y = y_tip_k + H; // Inner base aligns vertically with outer base\n        var i3_x = W / 2 * innerXFactor;\n        var i3_y = y_tip_k + H; // Inner base aligns vertically with outer base\n\n        // Construct the SVG path data string for a single chevron\n        // Using L (absolute line to) commands for clarity\n        var pathData = \"M \".concat(o2_x, \",\").concat(o2_y, \" L \").concat(o1_x, \",\").concat(o1_y, \" L \").concat(o3_x, \",\").concat(o3_y, \" L \").concat(i3_x, \",\").concat(i3_y, \" L \").concat(i1_x, \",\").concat(i1_y, \" L \").concat(i2_x, \",\").concat(i2_y, \" Z\");\n\n        // Add the path element to the array\n        paths.push(\"<path d=\\\"\".concat(pathData, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\"));\n      }\n\n      // Join all path strings\n      return paths.join('\\n');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(StackedChevrons, \"parameters\", {\n  numChevrons: {\n    type: 'number',\n    min: 1,\n    max: 10,\n    step: 1,\n    \"default\": 2,\n    description: 'Number of chevrons stacked vertically.'\n  },\n  chevronWidth: {\n    type: 'number',\n    min: 20,\n    max: 180,\n    step: 1,\n    \"default\": 80,\n    description: 'The overall width of each chevron.'\n  },\n  chevronHeight: {\n    type: 'number',\n    min: 10,\n    max: 90,\n    step: 1,\n    \"default\": 30,\n    description: 'The vertical height of a single chevron.'\n  },\n  thickness: {\n    type: 'number',\n    min: 1,\n    max: 89,\n    // Should be less than chevronHeight\n    step: 1,\n    \"default\": 20,\n    description: 'The vertical thickness of the chevron stroke. Must be less than Chevron Height.'\n  },\n  spacing: {\n    type: 'number',\n    min: -20,\n    // Allow overlap\n    max: 40,\n    step: 1,\n    \"default\": 10,\n    description: 'Vertical spacing between adjacent chevrons.'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StackedChevrons);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/StackedChevrons.js?");

/***/ }),

/***/ "./src/shapes/StackedChevronsTree.js":
/*!*******************************************!*\
  !*** ./src/shapes/StackedChevronsTree.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a stylized, multi-tiered, upward-pointing chevron or tree shape\n * with notched gaps between tiers.\n */\nvar StackedChevronsTree = /*#__PURE__*/function (_Shape) {\n  function StackedChevronsTree() {\n    _classCallCheck(this, StackedChevronsTree);\n    return _callSuper(this, StackedChevronsTree, arguments);\n  }\n  _inherits(StackedChevronsTree, _Shape);\n  return _createClass(StackedChevronsTree, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Access parameters using `this`\n      var numTiers = this.numTiers;\n      var tierHeight = this.tierHeight;\n      var baseWidth = this.baseWidth;\n      var gapHeight = this.gapHeight;\n      var innerWidthReduction = this.innerWidthReduction; // May be clamped later\n\n      // Calculate overall dimensions and positioning\n      var totalHeight = numTiers * tierHeight + (numTiers > 1 ? (numTiers - 1) * gapHeight : 0);\n      var yTop = -totalHeight / 2;\n      var yBottom = totalHeight / 2;\n\n      // Avoid division by zero if baseWidth is somehow 0\n      if (baseWidth <= 0) return '';\n\n      // Calculate the slope of the outer edges (change in x per unit change in y)\n      // Slope = (baseWidth / 2) / totalHeight\n      // Inverse slope (used for calculation) = totalHeight / (baseWidth / 2)\n      var invSlope = totalHeight > 0 ? totalHeight / (baseWidth / 2) : 0;\n\n      // Clamp innerWidthReduction to prevent self-intersection or negative widths\n      if (numTiers > 1 && invSlope > 0) {\n        // Calculate the outer width at the top of the second tier (narrowest notch point)\n        var y_t1 = yTop + tierHeight + gapHeight;\n        var x_ot1 = (y_t1 - yTop) / invSlope;\n        // Ensure reduction is less than the half-width at that point, leaving some thickness\n        var maxReduction = Math.max(0, x_ot1 - 1); // Leave at least 1 unit margin\n        innerWidthReduction = Math.max(0, Math.min(this.innerWidthReduction, maxReduction));\n      } else if (numTiers <= 1) {\n        innerWidthReduction = 0; // No notches for single tier\n      }\n\n      // --- Path generation ---\n      var points = [];\n      var f = function f(num) {\n        return num.toFixed(3);\n      }; // Formatting function\n\n      // Add the top tip\n      points.push([0, yTop]);\n\n      // Generate points down the right side\n      for (var i = 0; i < numTiers; i++) {\n        var currentTierYTop = yTop + i * (tierHeight + gapHeight);\n        var currentTierYBottom = currentTierYTop + tierHeight;\n\n        // Calculate X coordinate for the outer bottom corner of this tier\n        var xOuterBottom = invSlope > 0 ? (currentTierYBottom - yTop) / invSlope : baseWidth / 2;\n        points.push([xOuterBottom, currentTierYBottom]);\n\n        // If this is not the last tier, add the notch points\n        if (i < numTiers - 1) {\n          // Inner bottom corner (start of notch cut)\n          var xInnerBottom = Math.max(0, xOuterBottom - innerWidthReduction);\n          points.push([xInnerBottom, currentTierYBottom]);\n\n          // Calculate coordinates for the top of the gap (which is the top of the next tier)\n          var nextTierYTop = currentTierYBottom + gapHeight;\n          var xNextOuterTop = invSlope > 0 ? (nextTierYTop - yTop) / invSlope : baseWidth / 2;\n          var xNextInnerTop = Math.max(0, xNextOuterTop - innerWidthReduction);\n\n          // Inner top corner (end of notch cut)\n          points.push([xNextInnerTop, nextTierYTop]);\n          // Outer top corner (start of the next tier's outer edge)\n          points.push([xNextOuterTop, nextTierYTop]);\n        }\n      }\n\n      // Generate points up the left side by mirroring (excluding the tip)\n      var numRightPoints = points.length;\n      // Add bottom left corner\n      points.push([-points[numRightPoints - 1][0], points[numRightPoints - 1][1]]);\n      // Add mirrored points in reverse order\n      for (var j = numRightPoints - 2; j > 0; j--) {\n        points.push([-points[j][0], points[j][1]]);\n      }\n\n      // Create the SVG path data string\n      var pathData = points.map(function (p, index) {\n        var command = index === 0 ? 'M' : 'L';\n        return \"\".concat(command, \" \").concat(f(p[0]), \",\").concat(f(p[1]));\n      }).join(' ') + ' Z'; // Close the path\n\n      return \"<path d=\\\"\".concat(pathData, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(StackedChevronsTree, \"parameters\", {\n  numTiers: {\n    type: 'number',\n    min: 1,\n    max: 10,\n    step: 1,\n    \"default\": 3,\n    label: 'Number of Tiers'\n  },\n  tierHeight: {\n    type: 'number',\n    min: 5,\n    max: 70,\n    step: 1,\n    \"default\": 30,\n    label: 'Tier Height'\n  },\n  baseWidth: {\n    type: 'number',\n    min: 10,\n    max: 195,\n    step: 1,\n    \"default\": 140,\n    label: 'Base Width'\n  },\n  gapHeight: {\n    type: 'number',\n    min: 0,\n    max: 40,\n    step: 1,\n    \"default\": 10,\n    label: 'Gap Between Tiers'\n  },\n  innerWidthReduction: {\n    type: 'number',\n    min: 0,\n    max: 90,\n    step: 1,\n    \"default\": 25,\n    label: 'Notch Width Reduction'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StackedChevronsTree);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/StackedChevronsTree.js?");

/***/ }),

/***/ "./src/shapes/StackedCircles.js":
/*!**************************************!*\
  !*** ./src/shapes/StackedCircles.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates multiple vertical columns of stacked circles with adjustable\n * heights, spacing, and alignment.\n */\nvar StackedCircles = /*#__PURE__*/function (_Shape) {\n  function StackedCircles() {\n    _classCallCheck(this, StackedCircles);\n    return _callSuper(this, StackedCircles, arguments);\n  }\n  _inherits(StackedCircles, _Shape);\n  return _createClass(StackedCircles, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Parse column heights string into an array of positive integers\n      var heights = this.columnHeights.split(',').map(function (h) {\n        return parseInt(h.trim(), 10);\n      }).filter(function (h) {\n        return !isNaN(h) && h > 0;\n      }) // Keep only valid positive heights\n      .slice(0, 10); // Limit to a maximum of 10 columns for performance/sanity\n\n      // If no valid columns are defined, return an empty SVG string\n      if (heights.length === 0) {\n        return '';\n      }\n      var numCols = heights.length;\n      var maxHeightCount = Math.max.apply(Math, [0].concat(_toConsumableArray(heights))); // Find the height of the tallest column\n      var currentRadius = Math.max(0.1, this.radius); // Ensure radius is positive for calculations\n      var currentSpacing = this.spacing;\n      var diameter = 2 * currentRadius;\n      // Calculate the distance between the centers of adjacent circles (vertically or horizontally)\n      var step = diameter + currentSpacing;\n\n      // Calculate the raw dimensions of the shape before any scaling\n      // Subtract spacing once if elements exist to get bounding box size\n      var rawTotalWidth = numCols * step - (numCols > 0 ? currentSpacing : 0);\n      var rawMaxHeight = maxHeightCount * step - (maxHeightCount > 0 ? currentSpacing : 0);\n\n      // Calculate scale factor to fit the shape within the viewbox (e.g., -95 to +95)\n      // Use absolute values in case spacing is negative and causes negative dimensions\n      var maxDim = Math.max(Math.abs(rawTotalWidth), Math.abs(rawMaxHeight), 1); // Avoid division by zero\n      var targetSize = 190; // Target dimension within the 200x200 viewbox, leaving a small margin\n      var scale = maxDim > targetSize ? targetSize / maxDim : 1.0;\n\n      // Calculate offsets to center the shape based on its raw (unscaled) dimensions\n      // This ensures rotation and scaling happen around the visual center\n      var offsetX = -rawTotalWidth / 2;\n      var offsetY = -rawMaxHeight / 2;\n      var circlesSvg = ''; // String builder for accumulating SVG circle elements\n\n      // Iterate through each column defined by the heights array\n      for (var c = 0; c < numCols; c++) {\n        var colHeightCount = heights[c];\n        if (colHeightCount <= 0) continue; // Skip columns with zero or negative height\n\n        // Calculate the total height of the current column stack\n        var colHeight = colHeightCount * step - currentSpacing;\n        var startY = void 0; // This will store the Y-coordinate of the center of the *topmost* circle (r=0) in the current column\n\n        // Determine the starting Y position based on the chosen vertical alignment parameter\n        switch (this.alignment) {\n          case 'top':\n            // Align the top edge of this column's bounding box with the top edge of the overall bounding box.\n            // The center of the first circle (r=0) is radius distance below the top edge.\n            startY = offsetY + currentRadius;\n            break;\n          case 'center':\n            // Align the vertical center of this column with the vertical center of the overall bounding box.\n            // Start Y is calculated relative to the overall center (offsetY + rawMaxHeight/2),\n            // adjusted by half the column height, plus one radius to get to the center of the top circle.\n            startY = offsetY + rawMaxHeight / 2 - colHeight / 2 + currentRadius;\n            break;\n          case 'bottom':\n          default:\n            // Align the bottom edge of this column's bounding box with the bottom edge of the overall bounding box.\n            var bottomOfOverallBox = offsetY + rawMaxHeight; // Y-coord of the bottom edge\n            var topOfThisColumnBottomAligned = bottomOfOverallBox - colHeight; // Y-coord of the top edge when bottom-aligned\n            // The center of the first circle (r=0) is radius distance below this top edge.\n            startY = topOfThisColumnBottomAligned + currentRadius;\n            break;\n        }\n\n        // Calculate the X coordinate for the center of all circles in this column\n        var cx = offsetX + currentRadius + c * step;\n\n        // Generate the SVG circle elements for the current column\n        for (var r = 0; r < colHeightCount; r++) {\n          // Calculate the Y coordinate for the center of the current circle (index r)\n          var cy = startY + r * step;\n          // Append the SVG circle element string with formatted coordinates and radius\n          circlesSvg += \"<circle cx=\\\"\".concat(cx.toFixed(2), \"\\\" cy=\\\"\").concat(cy.toFixed(2), \"\\\" r=\\\"\").concat(currentRadius.toFixed(2), \"\\\" fill=\\\"white\\\" />\\n\");\n        }\n      }\n\n      // Wrap the generated circles in a group element <g> to apply transformations.\n      // Apply rotation first around the center (0,0), then scaling around the center (0,0).\n      // Using toFixed(4) for scale provides better precision for fitting.\n      return \"<g transform=\\\"scale(\".concat(scale.toFixed(4), \") rotate(\").concat(this.rotation, \")\\\">\").concat(circlesSvg, \"</g>\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(StackedCircles, \"parameters\", {\n  columnHeights: {\n    type: 'text',\n    // Use text input for comma-separated list of heights\n    \"default\": '2,3',\n    label: 'Column Heights (e.g., 2,3,1)'\n  },\n  radius: {\n    type: 'number',\n    min: 1,\n    // Ensure radius is at least 1\n    max: 50,\n    // Allow larger radius, scaling will handle fitting\n    step: 1,\n    \"default\": 25,\n    label: 'Circle Radius'\n  },\n  spacing: {\n    type: 'number',\n    min: -20,\n    // Allow significant overlap\n    max: 30,\n    // Allow significant spacing\n    step: 1,\n    \"default\": 0,\n    label: 'Spacing'\n  },\n  alignment: {\n    type: 'enum',\n    options: ['bottom', 'center', 'top'],\n    \"default\": 'bottom',\n    // Matches the reference image\n    label: 'Vertical Alignment'\n  },\n  rotation: {\n    type: 'number',\n    min: -180,\n    max: 180,\n    step: 1,\n    \"default\": 0,\n    label: 'Rotation ()'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StackedCircles);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/StackedCircles.js?");

/***/ }),

/***/ "./src/shapes/StackedTrapezoids.js":
/*!*****************************************!*\
  !*** ./src/shapes/StackedTrapezoids.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a stack of vertically aligned trapezoids (or triangles) where the\n * width tapers, with biased height distribution.\n */\nvar StackedTrapezoids = /*#__PURE__*/function (_Shape) {\n  function StackedTrapezoids() {\n    _classCallCheck(this, StackedTrapezoids);\n    return _callSuper(this, StackedTrapezoids, arguments);\n  }\n  _inherits(StackedTrapezoids, _Shape);\n  return _createClass(StackedTrapezoids, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var N = Math.max(1, Math.floor(this.numShapes)); // Ensure at least 1 shape\n      var H = Math.max(1, this.totalHeight); // Ensure positive height\n      var W_top_param = Math.max(0, this.topBaseWidth);\n      var W_bot_param = Math.max(0, this.bottomBaseWidth);\n      var B = this.heightDistributionBias;\n      var heights = [];\n      if (N === 1) {\n        heights.push(H);\n      } else {\n        var weights = [];\n        var sumWeights = 0;\n        for (var i = 0; i < N; i++) {\n          var norm_i = i / (N - 1); // Normalized index [0, 1]\n          // Calculate weight based on bias B\n          // B=0.5 -> weight=1 (even distribution)\n          // B>0.5 -> weight decreases with i (top shapes taller)\n          // B<0.5 -> weight increases with i (bottom shapes taller)\n          var w_i = 1 + (B - 0.5) * 2 * (1 - 2 * norm_i);\n          w_i = Math.max(0.01, w_i); // Ensure positive weight\n          weights.push(w_i);\n          sumWeights += w_i;\n        }\n\n        // Normalize weights and calculate heights\n        if (sumWeights <= 0.01) {\n          // Prevent division by zero or tiny numbers\n          for (var _i = 0; _i < N; _i++) heights.push(H / N);\n        } else {\n          for (var _i2 = 0; _i2 < N; _i2++) {\n            heights.push(H * weights[_i2] / sumWeights);\n          }\n        }\n      }\n\n      // Width function: interpolates width based on y coordinate relative to total height H\n      var getWidth = function getWidth(y) {\n        // Map y from [-H/2, H/2] to t in [0, 1]\n        var t = (y + H / 2) / H;\n        // Clamp t to [0, 1] to handle potential floating point inaccuracies\n        var clampedT = Math.max(0, Math.min(1, t));\n        // Linear interpolation between bottom and top widths\n        return W_bot_param + (W_top_param - W_bot_param) * clampedT;\n      };\n      var svgElements = [];\n      var currentY = H / 2; // Start at the vertical center of the top edge\n\n      for (var _i3 = 0; _i3 < N; _i3++) {\n        var h_i = heights[_i3];\n        // Skip shapes with negligible height\n        if (h_i < 0.1) continue;\n        var y_top = currentY;\n        var y_bottom = currentY - h_i;\n\n        // Calculate widths at the top and bottom of the current segment\n        var width_top = Math.max(0, getWidth(y_top));\n        var width_bottom = Math.max(0, getWidth(y_bottom));\n\n        // Skip if the shape is degenerate (effectively zero width top)\n        if (width_top < 0.1) {\n          currentY = y_bottom; // Update Y for next iteration's calculation\n          continue;\n        }\n        var points = [];\n        // Use fewer decimal places for cleaner SVG output\n        var dp = 2;\n\n        // Check if the calculated bottom width is effectively zero -> Triangle\n        if (width_bottom < 0.1) {\n          var p1x = -width_top / 2;\n          var p1y = y_top;\n          var p2x = width_top / 2;\n          var p2y = y_top;\n          var p3x = 0; // Bottom point at center\n          var p3y = y_bottom;\n          // Ensure points are distinct enough to form a visible triangle\n          if (Math.abs(p1x - p3x) > 0.01 || Math.abs(p1y - p3y) > 0.01) {\n            points = [\"\".concat(p1x.toFixed(dp), \",\").concat(p1y.toFixed(dp)), \"\".concat(p2x.toFixed(dp), \",\").concat(p2y.toFixed(dp)), \"\".concat(p3x.toFixed(dp), \",\").concat(p3y.toFixed(dp))];\n          }\n        } else {\n          // Generate Trapezoid points\n          var _p1x = -width_top / 2;\n          var _p1y = y_top;\n          var _p2x = width_top / 2;\n          var _p2y = y_top;\n          var _p3x = width_bottom / 2;\n          var _p3y = y_bottom;\n          var p4x = -width_bottom / 2;\n          var p4y = y_bottom;\n          points = [\"\".concat(_p1x.toFixed(dp), \",\").concat(_p1y.toFixed(dp)), \"\".concat(_p2x.toFixed(dp), \",\").concat(_p2y.toFixed(dp)), \"\".concat(_p3x.toFixed(dp), \",\").concat(_p3y.toFixed(dp)), \"\".concat(p4x.toFixed(dp), \",\").concat(p4y.toFixed(dp))];\n        }\n\n        // Add the polygon if it has enough points to be valid\n        if (points.length >= 3) {\n          svgElements.push(\"<polygon points=\\\"\".concat(points.join(' '), \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"2\\\" />\"));\n        }\n        currentY = y_bottom; // Update Y for the next shape's top edge\n      }\n      return svgElements.join('\\n');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(StackedTrapezoids, \"parameters\", {\n  numShapes: {\n    type: 'number',\n    min: 1,\n    max: 10,\n    step: 1,\n    \"default\": 4,\n    label: 'Number of Shapes'\n  },\n  totalHeight: {\n    type: 'number',\n    min: 20,\n    max: 190,\n    step: 1,\n    \"default\": 160,\n    label: 'Total Height'\n  },\n  topBaseWidth: {\n    type: 'number',\n    min: 5,\n    max: 195,\n    step: 1,\n    \"default\": 160,\n    label: 'Top Width'\n  },\n  bottomBaseWidth: {\n    type: 'number',\n    min: 0,\n    max: 195,\n    step: 1,\n    \"default\": 20,\n    label: 'Bottom Width'\n  },\n  heightDistributionBias: {\n    type: 'number',\n    min: 0.1,\n    max: 0.9,\n    step: 0.01,\n    \"default\": 0.7,\n    label: 'Height Bias (0.5=Even)' // >0.5 Top Taller, <0.5 Bottom Taller\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StackedTrapezoids);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/StackedTrapezoids.js?");

/***/ }),

/***/ "./src/shapes/StampShape.js":
/*!**********************************!*\
  !*** ./src/shapes/StampShape.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a square shape with a border resembling stamp perforations created\n * by masked circles.\n */\nvar StampShape = /*#__PURE__*/function (_Shape) {\n  function StampShape() {\n    _classCallCheck(this, StampShape);\n    return _callSuper(this, StampShape, arguments);\n  }\n  _inherits(StampShape, _Shape);\n  return _createClass(StampShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var maskId = \"stamp-mask-\".concat(Math.random().toString(36).substr(2, 9));\n\n      // Calculate half size for positioning\n      var halfSize = this.baseSize / 2;\n\n      // Create mask definition\n      var maskDef = \"\\n            <defs>\\n                <mask id=\\\"\".concat(maskId, \"\\\">\\n                    <rect \\n                        x=\\\"\").concat(-halfSize, \"\\\"\\n                        y=\\\"\").concat(-halfSize, \"\\\"\\n                        width=\\\"\").concat(this.baseSize, \"\\\"\\n                        height=\\\"\").concat(this.baseSize, \"\\\"\\n                        fill=\\\"white\\\"\\n                    />\\n                    \").concat(this.generateCircles(), \"\\n                </mask>\\n            </defs>\\n        \");\n\n      // Create main shape with mask applied\n      var mainShape = \"\\n            <rect\\n                x=\\\"\".concat(-halfSize, \"\\\"\\n                y=\\\"\").concat(-halfSize, \"\\\"\\n                width=\\\"\").concat(this.baseSize, \"\\\"\\n                height=\\\"\").concat(this.baseSize, \"\\\"\\n                fill=\\\"white\\\"\\n                mask=\\\"url(#\").concat(maskId, \")\\\"\\n            />\\n        \");\n      return \"\".concat(maskDef).concat(mainShape);\n    }\n  }, {\n    key: \"generateCircles\",\n    value: function generateCircles() {\n      var points = [];\n      var halfSize = this.baseSize / 2;\n\n      // Generate perimeter points based on grid size\n      for (var i = 0; i < this.gridSize; i++) {\n        var t = i / (this.gridSize - 1);\n        var pos = -halfSize + this.baseSize * t;\n\n        // Add points for each side\n        points.push([pos, -halfSize],\n        // Top edge\n        [pos, halfSize],\n        // Bottom edge\n        [-halfSize, pos],\n        // Left edge\n        [halfSize, pos] // Right edge\n        );\n      }\n\n      // Remove duplicate corner points\n      var uniquePoints = points.filter(function (point, index, self) {\n        return index === self.findIndex(function (p) {\n          return p[0] === point[0] && p[1] === point[1];\n        });\n      });\n\n      // Calculate adjusted radius (animatable on hover)\n      var adjustedRadius = this.circleRadius * this.intensity;\n\n      // Generate circles as black shapes in the mask\n      return uniquePoints.map(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n          x = _ref2[0],\n          y = _ref2[1];\n        return \"\\n            <circle\\n                cx=\\\"\".concat(x, \"\\\"\\n                cy=\\\"\").concat(y, \"\\\"\\n                r=\\\"\").concat(adjustedRadius, \"\\\"\\n                fill=\\\"black\\\"\\n            />\");\n      }).join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(StampShape, \"parameters\", {\n  gridSize: {\n    min: 2,\n    max: 8,\n    \"default\": 5\n  },\n  circleRadius: {\n    min: 5,\n    max: 30,\n    \"default\": 15\n  },\n  baseSize: {\n    min: 50,\n    max: 300,\n    \"default\": 155\n  },\n  intensity: {\n    min: 0.7,\n    max: 1.3,\n    \"default\": 1\n  } // This parameter will animate on hover\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StampShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/StampShape.js?");

/***/ }),

/***/ "./src/shapes/Star.js":
/*!****************************!*\
  !*** ./src/shapes/Star.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a star shape with adjustable points, inner radius (point depth),\n * and optional rounding for inner/outer corners.\n */\nvar StarShape = /*#__PURE__*/function (_Shape) {\n  function StarShape() {\n    _classCallCheck(this, StarShape);\n    return _callSuper(this, StarShape, arguments);\n  }\n  _inherits(StarShape, _Shape);\n  return _createClass(StarShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Ensure points is an integer\n      var numPoints = Math.round(this.points);\n\n      // Convert innerSize to ratio\n      this.innerSizeRatio = this.innerSize / 100;\n\n      // Convert rotation to radians\n      var rotationRad = this.rotation * Math.PI / 180;\n\n      // Convert corner radii to half values as per original implementation\n      // Add adaptive scaling based on point count to prevent issues during interpolation\n      var adaptiveFactor = Math.min(1, 8 / numPoints);\n      this.outerCornerRadiusHalf = this.outerCornerRadius / 2 * adaptiveFactor;\n      this.innerCornerRadiusHalf = this.innerCornerRadius / 2 * adaptiveFactor;\n      var points = [];\n      var outerRadius = this.size;\n      var innerRadius = this.size * this.innerSizeRatio;\n      var angleStep = Math.PI / numPoints;\n\n      // Generate points\n      for (var i = 0; i < numPoints * 2; i++) {\n        var angle = i * angleStep + rotationRad;\n        var radius = i % 2 === 0 ? outerRadius : innerRadius;\n        points.push([Math.cos(angle) * radius, Math.sin(angle) * radius]);\n      }\n\n      // Generate path\n      var path = \"<path \\n            d=\\\"M \".concat(points[0][0], \" \").concat(points[0][1]);\n      for (var _i = 1; _i <= points.length; _i++) {\n        var curr = points[_i % points.length];\n        var prev = points[_i - 1];\n        var next = points[(_i + 1) % points.length];\n        var cornerRadius = _i % 2 === 0 ? this.outerCornerRadiusHalf : this.innerCornerRadiusHalf;\n        if (cornerRadius <= 0) {\n          path += \" L \".concat(curr[0], \" \").concat(curr[1]);\n        } else {\n          // Calculate direction vectors\n          var toPrev = [prev[0] - curr[0], prev[1] - curr[1]];\n          var toNext = [next[0] - curr[0], next[1] - curr[1]];\n\n          // Normalize vectors\n          var lenPrev = Math.sqrt(toPrev[0] * toPrev[0] + toPrev[1] * toPrev[1]);\n          var lenNext = Math.sqrt(toNext[0] * toNext[0] + toNext[1] * toNext[1]);\n\n          // Prevent division by zero\n          var normPrev = lenPrev === 0 ? [0, 0] : [toPrev[0] / lenPrev, toPrev[1] / lenPrev];\n          var normNext = lenNext === 0 ? [0, 0] : [toNext[0] / lenNext, toNext[1] / lenNext];\n\n          // Calculate control points - limit corner radius to not exceed half of segment length\n          var maxRadius = Math.min(lenPrev, lenNext) / 2;\n          var limitedRadius = Math.min(cornerRadius, maxRadius);\n          var cp1 = [curr[0] + normPrev[0] * limitedRadius, curr[1] + normPrev[1] * limitedRadius];\n          var cp2 = [curr[0] + normNext[0] * limitedRadius, curr[1] + normNext[1] * limitedRadius];\n          path += \" L \".concat(cp1[0], \" \").concat(cp1[1]);\n          path += \" Q \".concat(curr[0], \" \").concat(curr[1], \" \").concat(cp2[0], \" \").concat(cp2[1]);\n        }\n      }\n      path += ' Z\" fill=\"white\" />';\n      return path;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(StarShape, \"parameters\", {\n  points: {\n    min: 4,\n    max: 32,\n    \"default\": 8\n  },\n  size: {\n    min: 50,\n    max: 150,\n    \"default\": 100\n  },\n  innerSize: {\n    min: 1,\n    max: 99,\n    \"default\": 40\n  },\n  outerCornerRadius: {\n    min: 0,\n    max: 50,\n    \"default\": 0\n  },\n  innerCornerRadius: {\n    min: 0,\n    max: 50,\n    \"default\": 0\n  },\n  rotation: {\n    min: -180,\n    max: 180,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StarShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/Star.js?");

/***/ }),

/***/ "./src/shapes/StarCircle.js":
/*!**********************************!*\
  !*** ./src/shapes/StarCircle.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a shape combining a central circle with radiating triangular\n * blades.\n */\nvar StarCircleShape = /*#__PURE__*/function (_Shape) {\n  function StarCircleShape() {\n    _classCallCheck(this, StarCircleShape);\n    return _callSuper(this, StarCircleShape, arguments);\n  }\n  _inherits(StarCircleShape, _Shape);\n  return _createClass(StarCircleShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Ensure numBlades is an integer\n      var numBladesInt = Math.round(this.numBlades);\n\n      // Convert rotation to radians\n      var rotationRad = this.rotation * Math.PI / 180;\n\n      // Create local copies of parameters and convert percentages to actual values\n      var bladeLength = this.bladeLength / 100;\n      var circleSize = this.circleSize / 100;\n\n      // Ensure blade length is always proportionally larger than circle size\n      var adjustedBladeLength = Math.max(bladeLength, circleSize * 1.5);\n      var size = 300;\n      var halfSize = size / 2;\n\n      // Calculate dimensions\n      var radius = halfSize * adjustedBladeLength;\n      var circleRadius = halfSize * circleSize;\n      var angleStep = 2 * Math.PI / numBladesInt;\n\n      // Generate blades\n      var blades = [];\n      for (var i = 0; i < numBladesInt; i++) {\n        var angle = i * angleStep + rotationRad;\n        var midAngle = angle + angleStep / 2;\n\n        // Adaptive arc offset based on the number of blades\n        // Ensures blades don't overlap with too many points\n        var adaptiveFactor = Math.min(1, 5 / numBladesInt);\n        var arcOffset = angleStep * 0.2 * adaptiveFactor;\n\n        // Calculate blade points\n        var tip = {\n          x: Math.cos(midAngle) * radius,\n          y: Math.sin(midAngle) * radius\n        };\n\n        // Calculate connection points on circle\n        var base1 = {\n          x: Math.cos(midAngle - arcOffset) * circleRadius,\n          y: Math.sin(midAngle - arcOffset) * circleRadius\n        };\n        var base2 = {\n          x: Math.cos(midAngle + arcOffset) * circleRadius,\n          y: Math.sin(midAngle + arcOffset) * circleRadius\n        };\n\n        // Create blade path\n        var bladePath = \"M \".concat(base1.x, \" \").concat(base1.y, \" \\n                             L \").concat(tip.x, \" \").concat(tip.y, \" \\n                             L \").concat(base2.x, \" \").concat(base2.y);\n        blades.push(bladePath);\n      }\n\n      // Combine blades and circle\n      return \"\\n            \".concat(blades.map(function (blade) {\n        return \"<path d=\\\"\".concat(blade, \"\\\" fill=\\\"white\\\" />\");\n      }).join('\\n'), \"\\n            <circle cx=\\\"0\\\" cy=\\\"0\\\" r=\\\"\").concat(circleRadius, \"\\\" fill=\\\"white\\\" />\\n        \");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(StarCircleShape, \"parameters\", {\n  numBlades: {\n    min: 3,\n    max: 16,\n    \"default\": 4\n  },\n  // Number of blades\n  bladeLength: {\n    min: 20,\n    max: 100,\n    \"default\": 80\n  },\n  // Base length of blades\n  circleSize: {\n    min: 10,\n    max: 80,\n    \"default\": 30\n  },\n  // Size of center circle\n  rotation: {\n    min: -180,\n    max: 180,\n    \"default\": 0\n  } // Rotation in degrees\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StarCircleShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/StarCircle.js?");

/***/ }),

/***/ "./src/shapes/StarCluster.js":
/*!***********************************!*\
  !*** ./src/shapes/StarCluster.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a cluster of star-like nodes arranged radially, each node having\n * smaller branches.\n */\nvar StarCluster = /*#__PURE__*/function (_Shape) {\n  function StarCluster() {\n    _classCallCheck(this, StarCluster);\n    return _callSuper(this, StarCluster, arguments);\n  }\n  _inherits(StarCluster, _Shape);\n  return _createClass(StarCluster, [{\n    key: \"point\",\n    value:\n    // Helper function to calculate point from center, radius, and angle\n    function point(centerX, centerY, radius, angle) {\n      return {\n        x: centerX + radius * Math.cos(angle),\n        y: centerY + radius * Math.sin(angle)\n      };\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      // Base setup and scaling\n      var maxSize = 400;\n      var scale = 0.8;\n      var centerX = 0;\n      var centerY = 0;\n\n      // Scale parameters\n      var nodeCount = Math.round(this.nodes);\n      var branchCount = Math.round(this.branchCount);\n      var thickness = this.thickness * scale;\n      var innerScale = this.innerScale;\n\n      // Adjust radius and branch length to ensure shape fits within bounds\n      var baseRadius = this.radius * scale;\n      var baseBranchLength = this.branchLength * scale;\n\n      // Calculate maximum allowed radius to ensure shape fits in square\n      var maxRadius = maxSize / 2 - baseBranchLength;\n      var radius = Math.min(baseRadius, maxRadius);\n      var branchLength = Math.min(baseBranchLength, maxSize / 4);\n\n      // Generate paths for the star cluster\n      var paths = [];\n\n      // Generate main node points around center\n      var nodeAngles = Array.from({\n        length: nodeCount\n      }, function (_, i) {\n        return i * 2 * Math.PI / nodeCount;\n      });\n\n      // Create star-like pattern at each node\n      nodeAngles.forEach(function (baseAngle) {\n        var nodeCenter = _this.point(centerX, centerY, radius, baseAngle);\n        var angleStep = 2 * Math.PI / branchCount;\n\n        // Create petal-like shapes at each node\n        for (var i = 0; i < branchCount; i++) {\n          var startAngle = baseAngle + angleStep * i;\n\n          // Calculate outer point\n          var outerPoint = _this.point(nodeCenter.x, nodeCenter.y, branchLength, startAngle);\n          if (innerScale > 0) {\n            // Calculate inner points for petal shape\n            var innerPoint1 = _this.point(nodeCenter.x, nodeCenter.y, branchLength * innerScale, startAngle + angleStep * 0.3);\n            var innerPoint2 = _this.point(nodeCenter.x, nodeCenter.y, branchLength * innerScale, startAngle - angleStep * 0.3);\n\n            // Draw petal\n            paths.push(\"M \".concat(nodeCenter.x, \" \").concat(nodeCenter.y, \"\\n                        L \").concat(innerPoint1.x, \" \").concat(innerPoint1.y, \"\\n                        L \").concat(outerPoint.x, \" \").concat(outerPoint.y, \"\\n                        L \").concat(innerPoint2.x, \" \").concat(innerPoint2.y, \"\\n                        Z\"));\n          } else {\n            // Draw simple line for innerScale = 0\n            paths.push(\"M \".concat(nodeCenter.x, \" \").concat(nodeCenter.y, \"\\n                        L \").concat(outerPoint.x, \" \").concat(outerPoint.y));\n          }\n        }\n      });\n      return \"<path \\n            d=\\\"\".concat(paths.join(' '), \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(thickness, \"\\\"\\n            fill=\\\"none\\\"\\n            stroke-linejoin=\\\"round\\\"\\n            stroke-linecap=\\\"round\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(StarCluster, \"parameters\", {\n  nodes: {\n    min: 4,\n    max: 12,\n    \"default\": 6\n  },\n  radius: {\n    min: 40,\n    max: 80,\n    \"default\": 80\n  },\n  branchLength: {\n    min: 10,\n    max: 80,\n    \"default\": 40\n  },\n  branchCount: {\n    min: 4,\n    max: 12,\n    \"default\": 6\n  },\n  thickness: {\n    min: 2,\n    max: 10,\n    \"default\": 4\n  },\n  innerScale: {\n    min: 0.4,\n    max: 0.8,\n    \"default\": 0.5\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StarCluster);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/StarCluster.js?");

/***/ }),

/***/ "./src/shapes/StarburstRingsShape.js":
/*!*******************************************!*\
  !*** ./src/shapes/StarburstRingsShape.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a pattern of concentric outlined rings, each with randomly placed\n * gaps.\n */\nvar StarburstRingsShape = /*#__PURE__*/function (_Shape) {\n  function StarburstRingsShape() {\n    _classCallCheck(this, StarburstRingsShape);\n    return _callSuper(this, StarburstRingsShape, arguments);\n  }\n  _inherits(StarburstRingsShape, _Shape);\n  return _createClass(StarburstRingsShape, [{\n    key: \"getRandomInRange\",\n    value:\n    // These methods have been simplified to use the inherited random() method\n    function getRandomInRange(min, max) {\n      return min + this.random() * (max - min);\n    }\n  }, {\n    key: \"getRandomIntInRange\",\n    value: function getRandomIntInRange(min, max) {\n      return Math.floor(this.getRandomInRange(min, max + 1));\n    }\n  }, {\n    key: \"createArcPath\",\n    value: function createArcPath(radius, startAngle, endAngle) {\n      var startX = radius * Math.cos(startAngle);\n      var startY = radius * Math.sin(startAngle);\n      var endX = radius * Math.cos(endAngle);\n      var endY = radius * Math.sin(endAngle);\n      var largeArcFlag = endAngle - startAngle > Math.PI ? 1 : 0;\n      return \"M \".concat(startX, \",\").concat(startY, \" A \").concat(radius, \",\").concat(radius, \" 0 \").concat(largeArcFlag, \" 1 \").concat(endX, \",\").concat(endY);\n    }\n  }, {\n    key: \"generateCircleWithGaps\",\n    value: function generateCircleWithGaps(radius, gapCount, minGapAngle, maxGapAngle) {\n      var minGapRad = minGapAngle * Math.PI / 180;\n      var maxGapRad = maxGapAngle * Math.PI / 180;\n      var gaps = [];\n      var totalGapSize = 0;\n      for (var i = 0; i < gapCount; i++) {\n        var gapSize = this.getRandomInRange(minGapRad, maxGapRad);\n        var gapStart = this.getRandomInRange(0, 2 * Math.PI - gapSize);\n        gaps.push({\n          start: gapStart,\n          end: gapStart + gapSize\n        });\n        totalGapSize += gapSize;\n      }\n\n      // Ensure gaps are sorted and merged properly\n      gaps.sort(function (a, b) {\n        return a.start - b.start;\n      });\n      var mergedGaps = [];\n      var currentGap = gaps[0];\n      for (var _i = 1; _i < gaps.length; _i++) {\n        if (gaps[_i].start <= currentGap.end) {\n          currentGap.end = Math.max(currentGap.end, gaps[_i].end);\n        } else {\n          mergedGaps.push(currentGap);\n          currentGap = gaps[_i];\n        }\n      }\n      mergedGaps.push(currentGap);\n\n      // Create arcs between gaps\n      var segments = [];\n      var lastEnd = mergedGaps[mergedGaps.length - 1].end - 2 * Math.PI;\n      for (var _i2 = 0, _mergedGaps = mergedGaps; _i2 < _mergedGaps.length; _i2++) {\n        var gap = _mergedGaps[_i2];\n        if (gap.start > lastEnd) {\n          segments.push(this.createArcPath(radius, lastEnd, gap.start));\n        }\n        lastEnd = gap.end;\n      }\n      if (mergedGaps[0].start + 2 * Math.PI > lastEnd) {\n        segments.push(this.createArcPath(radius, lastEnd, mergedGaps[0].start + 2 * Math.PI));\n      }\n      return segments;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      // Reset RNG to ensure consistent results with the same seed\n      this.resetRNG();\n      this.randomizeEach = !!this.randomizeEach;\n      var paths = [];\n      var radiusStep = (this.maxRadius - this.minRadius) / (this.circleCount - 1);\n      var baseGapCount, baseMinGapAngle, baseMaxGapAngle;\n      if (!this.randomizeEach) {\n        baseGapCount = this.getRandomIntInRange(this.minGapCount, this.maxGapCount);\n        baseMinGapAngle = this.minGapAngle;\n        baseMaxGapAngle = this.maxGapAngle;\n      }\n      for (var i = 0; i < this.circleCount; i++) {\n        var radius = this.maxRadius - i * radiusStep;\n        var gapCount = void 0,\n          minGapAngle = void 0,\n          maxGapAngle = void 0;\n        if (this.randomizeEach) {\n          gapCount = this.getRandomIntInRange(this.minGapCount, this.maxGapCount);\n          minGapAngle = this.minGapAngle;\n          maxGapAngle = this.maxGapAngle;\n        } else {\n          gapCount = baseGapCount;\n          minGapAngle = baseMinGapAngle;\n          maxGapAngle = baseMaxGapAngle;\n        }\n        var segments = this.generateCircleWithGaps(radius, gapCount, minGapAngle, maxGapAngle);\n        segments.forEach(function (segment) {\n          paths.push(\"<path\\n                    d=\\\"\".concat(segment, \"\\\"\\n                    fill=\\\"none\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(_this.thickness, \"\\\"\\n                    stroke-linecap=\\\"\").concat(_this.lineCap, \"\\\"\\n                />\"));\n        });\n      }\n      return paths.join(\"\\n\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(StarburstRingsShape, \"parameters\", {\n  circleCount: {\n    min: 3,\n    max: 12,\n    \"default\": 6\n  },\n  minRadius: {\n    min: 5,\n    max: 40,\n    \"default\": 20\n  },\n  maxRadius: {\n    min: 70,\n    max: 100,\n    \"default\": 100\n  },\n  thickness: {\n    min: 1,\n    max: 8,\n    \"default\": 3\n  },\n  minGapCount: {\n    min: 1,\n    max: 8,\n    \"default\": 1\n  },\n  maxGapCount: {\n    min: 2,\n    max: 12,\n    \"default\": 6\n  },\n  minGapAngle: {\n    min: 5,\n    max: 90,\n    \"default\": 25\n  },\n  maxGapAngle: {\n    min: 15,\n    max: 90,\n    \"default\": 90\n  },\n  randomizeEach: {\n    options: [true, false],\n    \"default\": true\n  },\n  lineCap: {\n    options: [\"butt\", \"round\"],\n    \"default\": \"round\"\n  }\n  // seed parameter is now inherited from Shape class\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StarburstRingsShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/StarburstRingsShape.js?");

/***/ }),

/***/ "./src/shapes/StarburstShape.js":
/*!**************************************!*\
  !*** ./src/shapes/StarburstShape.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a starburst shape by creating zigzag spikes along the edges of a\n * base square.\n */\nvar StarburstShape = /*#__PURE__*/function (_Shape) {\n  function StarburstShape() {\n    _classCallCheck(this, StarburstShape);\n    return _callSuper(this, StarburstShape, arguments);\n  }\n  _inherits(StarburstShape, _Shape);\n  return _createClass(StarburstShape, [{\n    key: \"rotatePoint\",\n    value:\n    // Helper function to rotate a point around a center point\n    function rotatePoint(point, center, angle) {\n      var dx = point.x - center.x;\n      var dy = point.y - center.y;\n      var cos = Math.cos(angle);\n      var sin = Math.sin(angle);\n      return {\n        x: dx * cos - dy * sin + center.x,\n        y: dx * sin + dy * cos + center.y\n      };\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      // Calculate dimensions\n      var size = 200;\n\n      // Get parameter values and ensure proper types\n      var spikeDepth = this.spikeDepth;\n      var spikeWidth = this.spikeWidth;\n      var spikesPerSide = Math.round(this.spikesPerSide);\n      var innerPadding = this.innerPadding;\n\n      // Calculate effective dimensions\n      var effectiveSize = size - innerPadding * 2;\n      var halfSize = effectiveSize / 2;\n\n      // Array to store all path commands\n      var pathCommands = [];\n\n      // Create spikes for each side\n      var _loop = function _loop() {\n        var rotation = side * Math.PI / 2;\n\n        // Calculate spikes for current side\n        for (var spikeIndex = 0; spikeIndex < spikesPerSide; spikeIndex++) {\n          var spikeSpacing = effectiveSize / spikesPerSide;\n          var spikeOffset = spikeSpacing * spikeIndex - (halfSize - spikeSpacing / 2);\n\n          // Create base spike points before rotation\n          var basePoints = [{\n            x: spikeOffset - spikeWidth / 2,\n            y: halfSize\n          },\n          // Left point\n          {\n            x: spikeOffset,\n            y: halfSize - spikeDepth\n          },\n          // Tip point\n          {\n            x: spikeOffset + spikeWidth / 2,\n            y: halfSize\n          } // Right point\n          ];\n\n          // Rotate and translate points\n          var points = basePoints.map(function (point) {\n            return _this.rotatePoint(point, {\n              x: 0,\n              y: 0\n            }, rotation);\n          });\n\n          // Add to path commands\n          if (pathCommands.length === 0) {\n            pathCommands.push(\"M \".concat(points[0].x, \" \").concat(points[0].y));\n          } else {\n            pathCommands.push(\"L \".concat(points[0].x, \" \").concat(points[0].y));\n          }\n          pathCommands.push(\"L \".concat(points[1].x, \" \").concat(points[1].y));\n          pathCommands.push(\"L \".concat(points[2].x, \" \").concat(points[2].y));\n        }\n      };\n      for (var side = 0; side < 4; side++) {\n        _loop();\n      }\n\n      // Close the path\n      pathCommands.push('Z');\n      return \"<path \\n            d=\\\"\".concat(pathCommands.join(' '), \"\\\"\\n            fill=\\\"white\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(StarburstShape, \"parameters\", {\n  spikeDepth: {\n    min: 10,\n    max: 100,\n    \"default\": 40\n  },\n  spikeWidth: {\n    min: 10,\n    max: 100,\n    \"default\": 30\n  },\n  spikesPerSide: {\n    min: 1,\n    max: 5,\n    \"default\": 2\n  },\n  innerPadding: {\n    min: 0,\n    max: 50,\n    \"default\": 20\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StarburstShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/StarburstShape.js?");

/***/ }),

/***/ "./src/shapes/SteppedStructure.js":
/*!****************************************!*\
  !*** ./src/shapes/SteppedStructure.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a white stepped structure resembling a vertically symmetrical shape\n * whose width varies elliptically, defined by horizontal steps.\n * The overall shape is contained within an implicit bounding ellipse.\n */\nvar SteppedStructure = /*#__PURE__*/function (_Shape) {\n  function SteppedStructure() {\n    _classCallCheck(this, SteppedStructure);\n    return _callSuper(this, SteppedStructure, arguments);\n  }\n  _inherits(SteppedStructure, _Shape);\n  return _createClass(SteppedStructure, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var height = this.height;\n      var maxWidth = this.maxWidth;\n      var baseWidth = this.baseWidth;\n      // Ensure numStepsPerSide is at least 1 and an integer\n      var numStepsPerSide = Math.max(1, Math.round(this.numStepsPerSide));\n\n      // Clamp baseWidth to be no larger than maxWidth\n      if (baseWidth > maxWidth) {\n        baseWidth = maxWidth;\n      }\n      var ry = height / 2;\n      // cx is the horizontal distance from center to the edge at the very top/bottom\n      var cx = baseWidth / 2;\n      // rx_side defines the curvature; it's the horizontal 'radius' component added to cx\n      // to reach the maximum width at the equator.\n      var rx_side = maxWidth / 2 - cx;\n\n      // Ensure derived radius is non-negative\n      if (rx_side < 0) {\n        rx_side = 0;\n      }\n\n      // Total number of vertical segments along the entire height\n      var numVerticalSegments = 2 * numStepsPerSide;\n      // Height of each individual vertical step segment\n      var h = height / numVerticalSegments;\n\n      // Prevent issues with zero or very small dimensions\n      if (ry <= 1e-6 || h <= 1e-6) {\n        var halfMaxWidth = maxWidth / 2;\n        // Fallback to a simple rectangle covering the max dimensions\n        return \"<rect x=\\\"\".concat(-halfMaxWidth, \"\\\" y=\\\"\").concat(-ry, \"\\\" width=\\\"\").concat(maxWidth, \"\\\" height=\\\"\").concat(height, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\");\n      }\n      var yCoords = [];\n      var xCoords = []; // Stores the absolute x-coordinate for the right side edge at each y level\n\n      var fmt = function fmt(n) {\n        return parseFloat(n.toFixed(3));\n      };\n\n      // Calculate the y-coordinates and corresponding x-coordinates for each level boundary\n      for (var k = 0; k <= numVerticalSegments; k++) {\n        var y_k = -ry + k * h;\n        yCoords.push(fmt(y_k));\n\n        // Calculate the x-coordinate based on the ellipse equation: x(y) = cx + rx_side * sqrt(1 - (y/ry)^2)\n        // This gives the horizontal extent at height y_k.\n        var yRatioSquared = y_k / ry * (y_k / ry);\n        // Ensure the value inside sqrt is not negative due to floating point errors\n        var radicand = Math.max(0, 1 - yRatioSquared);\n        var x_k = cx + rx_side * Math.sqrt(radicand);\n        xCoords.push(fmt(x_k));\n      }\n\n      // Start building the SVG path data string\n      // Start at the bottom-left corner: (-cx, -ry) which corresponds to (-xCoords[0], yCoords[0])\n      var pathData = \"M \".concat(-xCoords[0], \" \").concat(yCoords[0]);\n\n      // Draw the left side upwards using steps\n      for (var _k = 0; _k < numVerticalSegments; _k++) {\n        // Vertical line upwards to the next y level (yCoords[k+1]), maintaining the current x (-xCoords[k])\n        pathData += \" L \".concat(-xCoords[_k], \" \").concat(yCoords[_k + 1]);\n        // Horizontal line step outwards/inwards to the new x (-xCoords[k+1]) at the current y level (yCoords[k+1])\n        pathData += \" L \".concat(-xCoords[_k + 1], \" \").concat(yCoords[_k + 1]);\n      }\n      // Path is now at the top-left corner: (-xCoords[numVerticalSegments], yCoords[numVerticalSegments]) == (-cx, ry)\n\n      // Draw the top horizontal line across to the top-right corner (cx, ry)\n      pathData += \" L \".concat(xCoords[numVerticalSegments], \" \").concat(yCoords[numVerticalSegments]);\n      // Path is now at the top-right corner: (xCoords[numVerticalSegments], yCoords[numVerticalSegments]) == (cx, ry)\n\n      // Draw the right side downwards using steps\n      for (var _k2 = numVerticalSegments - 1; _k2 >= 0; _k2--) {\n        // Horizontal line step outwards/inwards. From (current_x=X_{k+1}, current_y=Y_{k+1}) to (X_{k+1}, Y_k)\n        // Need to use the X coord from the level above (k+1) at the y level below (k)\n        pathData += \" L \".concat(xCoords[_k2 + 1], \" \").concat(yCoords[_k2]);\n        // Vertical line downwards. From (X_{k+1}, Y_k) to (X_k, Y_k)\n        // Need to use the X coord for the current level (k) at the current y level (k)\n        pathData += \" L \".concat(xCoords[_k2], \" \").concat(yCoords[_k2]);\n      }\n      // Path is now at the bottom-right corner: (xCoords[0], yCoords[0]) == (cx, -ry)\n\n      // Close the path to form a closed shape, drawing a line back to the start M (-cx, -ry)\n      pathData += \" Z\";\n\n      // Return the final SVG path element, filled white\n      return \"<path d=\\\"\".concat(pathData, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(SteppedStructure, \"parameters\", {\n  height: {\n    type: 'number',\n    min: 20,\n    max: 200,\n    step: 1,\n    \"default\": 180,\n    label: 'Height'\n  },\n  maxWidth: {\n    type: 'number',\n    min: 10,\n    max: 200,\n    step: 1,\n    \"default\": 120,\n    label: 'Max Width'\n  },\n  baseWidth: {\n    type: 'number',\n    min: 0,\n    // Allow pinching at top/bottom\n    max: 200,\n    // Will be clamped to maxWidth if larger\n    step: 1,\n    \"default\": 40,\n    label: 'Base Width (Top/Bottom)'\n  },\n  numStepsPerSide: {\n    type: 'number',\n    min: 1,\n    max: 20,\n    // More steps create a smoother curve approximation\n    step: 1,\n    \"default\": 5,\n    label: 'Steps per Side' // Number of steps in top/bottom half\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SteppedStructure);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/SteppedStructure.js?");

/***/ }),

/***/ "./src/shapes/StitchPattern.js":
/*!*************************************!*\
  !*** ./src/shapes/StitchPattern.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a grid pattern resembling stitches, alternating horizontal and\n * vertical dashed lines.\n */\nvar StitchPattern = /*#__PURE__*/function (_Shape) {\n  function StitchPattern() {\n    _classCallCheck(this, StitchPattern);\n    return _callSuper(this, StitchPattern, arguments);\n  }\n  _inherits(StitchPattern, _Shape);\n  return _createClass(StitchPattern, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var elements = [];\n\n      // Calculate total width and height based on the number of spaces between elements\n      var totalWidth = (this.columns - 1) * this.spacing;\n      var totalHeight = (this.rows - 1) * this.spacing;\n\n      // Calculate starting positions to center the pattern\n      var startX = -totalWidth / 2;\n      var startY = -totalHeight / 2;\n\n      // Generate all dashes in a grid pattern\n      for (var row = 0; row < this.rows; row++) {\n        for (var col = 0; col < this.columns; col++) {\n          var x = startX + col * this.spacing;\n          var y = startY + row * this.spacing;\n\n          // Alternate between horizontal and vertical dashes\n          // Even rows, odd columns: vertical dash\n          // Odd rows, even columns: vertical dash\n          // All other positions: horizontal dash\n          var isVertical = row % 2 === 0 && col % 2 === 1 || row % 2 === 1 && col % 2 === 0;\n          if (isVertical) {\n            // Add vertical dash\n            elements.push(\"<rect \\n            x=\\\"\".concat(x - this.dashHeight / 2, \"\\\" \\n            y=\\\"\").concat(y - this.dashWidth / 2, \"\\\" \\n            width=\\\"\").concat(this.dashHeight, \"\\\" \\n            height=\\\"\").concat(this.dashWidth, \"\\\" \\n            rx=\\\"\").concat(this.cornerRadius, \"\\\"\\n            ry=\\\"\").concat(this.cornerRadius, \"\\\"\\n            fill=\\\"white\\\"\\n          />\"));\n          } else {\n            // Add horizontal dash\n            elements.push(\"<rect \\n            x=\\\"\".concat(x - this.dashWidth / 2, \"\\\" \\n            y=\\\"\").concat(y - this.dashHeight / 2, \"\\\" \\n            width=\\\"\").concat(this.dashWidth, \"\\\" \\n            height=\\\"\").concat(this.dashHeight, \"\\\" \\n            rx=\\\"\").concat(this.cornerRadius, \"\\\"\\n            ry=\\\"\").concat(this.cornerRadius, \"\\\"\\n            fill=\\\"white\\\"\\n          />\"));\n          }\n        }\n      }\n      return elements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(StitchPattern, \"parameters\", {\n  size: {\n    min: 100,\n    max: 200,\n    \"default\": 200\n  },\n  rows: {\n    min: 3,\n    max: 12,\n    \"default\": 6\n  },\n  columns: {\n    min: 3,\n    max: 12,\n    \"default\": 6\n  },\n  dashWidth: {\n    min: 10,\n    max: 40,\n    \"default\": 25\n  },\n  dashHeight: {\n    min: 3,\n    max: 12,\n    \"default\": 6\n  },\n  spacing: {\n    min: 10,\n    max: 40,\n    \"default\": 25\n  },\n  cornerRadius: {\n    min: 0,\n    max: 10,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StitchPattern);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/StitchPattern.js?");

/***/ }),

/***/ "./src/shapes/StitchedFrame.js":
/*!*************************************!*\
  !*** ./src/shapes/StitchedFrame.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a square frame with zigzag edges resembling stitching.\n */\nvar StitchedFrame = /*#__PURE__*/function (_Shape) {\n  function StitchedFrame() {\n    _classCallCheck(this, StitchedFrame);\n    return _callSuper(this, StitchedFrame, arguments);\n  }\n  _inherits(StitchedFrame, _Shape);\n  return _createClass(StitchedFrame, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Setup base parameters with scaling\n      var viewBoxSize = 200;\n      var scale = 0.8;\n      var zigzagDepth = this.zigzagDepth * scale;\n      var zigzagCount = Math.round(this.zigzagCount);\n      var thickness = this.thickness * scale;\n\n      // Calculate base square size to ensure shape stays within bounds\n      var baseSize = viewBoxSize - zigzagDepth * 2 - thickness * 2;\n      var halfSize = baseSize / 2;\n      var center = {\n        x: 0,\n        y: 0\n      };\n      var pathPoints = [];\n\n      // Create points for each side\n      for (var side = 0; side < 4; side++) {\n        var startAngle = side * Math.PI / 2;\n        var startPoint = {\n          x: center.x + Math.cos(startAngle) * halfSize,\n          y: center.y + Math.sin(startAngle) * halfSize\n        };\n        var endAngle = (side + 1) * Math.PI / 2;\n        var endPoint = {\n          x: center.x + Math.cos(endAngle) * halfSize,\n          y: center.y + Math.sin(endAngle) * halfSize\n        };\n\n        // Calculate zigzag points\n        var segmentLength = this.distance(startPoint, endPoint);\n        var zigzagSegmentLength = segmentLength / zigzagCount;\n        var direction = {\n          x: (endPoint.x - startPoint.x) / segmentLength,\n          y: (endPoint.y - startPoint.y) / segmentLength\n        };\n        var perpDirection = {\n          x: -direction.y,\n          y: direction.x\n        };\n\n        // Draw zigzags\n        for (var i = 0; i < zigzagCount; i++) {\n          var segmentStart = {\n            x: startPoint.x + direction.x * zigzagSegmentLength * i,\n            y: startPoint.y + direction.y * zigzagSegmentLength * i\n          };\n          var zigzagPoint = {\n            x: segmentStart.x + direction.x * (zigzagSegmentLength / 2) + perpDirection.x * zigzagDepth,\n            y: segmentStart.y + direction.y * (zigzagSegmentLength / 2) + perpDirection.y * zigzagDepth\n          };\n          if (i === 0 && side === 0) {\n            pathPoints.push(['M', segmentStart.x, segmentStart.y]);\n          }\n          pathPoints.push(['L', zigzagPoint.x, zigzagPoint.y]);\n          if (i < zigzagCount - 1 || side < 3) {\n            var nextPoint = {\n              x: startPoint.x + direction.x * zigzagSegmentLength * (i + 1),\n              y: startPoint.y + direction.y * zigzagSegmentLength * (i + 1)\n            };\n            pathPoints.push(['L', nextPoint.x, nextPoint.y]);\n          }\n        }\n      }\n      pathPoints.push(['Z']);\n\n      // Generate the SVG path\n      var pathData = pathPoints.map(function (point) {\n        return point.join(' ');\n      }).join(' ');\n\n      // Return SVG with path element\n      return \"<path \\n            d=\\\"\".concat(pathData, \"\\\"\\n            fill=\\\"white\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(StitchedFrame, \"parameters\", {\n  zigzagDepth: {\n    min: 5,\n    max: 40,\n    \"default\": 13\n  },\n  zigzagCount: {\n    min: 3,\n    max: 12,\n    \"default\": 6\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StitchedFrame);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/StitchedFrame.js?");

/***/ }),

/***/ "./src/shapes/StylizedAperture.js":
/*!****************************************!*\
  !*** ./src/shapes/StylizedAperture.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a stylized aperture or vortex shape with four curved blades\n * converging towards a central oval cutout.\n */\nvar StylizedAperture = /*#__PURE__*/function (_Shape) {\n  function StylizedAperture() {\n    _classCallCheck(this, StylizedAperture);\n    return _callSuper(this, StylizedAperture, arguments);\n  }\n  _inherits(StylizedAperture, _Shape);\n  return _createClass(StylizedAperture, [{\n    key: \"generateBladePath\",\n    value: function generateBladePath(i) {\n      var boxSize = this.boxSize;\n      var ovalRx = boxSize * this.ovalSizeRatio;\n      // Ensure ovalRy is not zero if ovalAspect is zero\n      var ovalAspect = Math.max(0.01, this.ovalAspect);\n      var ovalRy = ovalRx * ovalAspect;\n      // Ensure edgeOffset doesn't exceed boxSize to avoid inverted corners\n      var edgeOffset = boxSize * Math.min(0.99, this.edgeRatio);\n      var innerControlLen = boxSize * this.innerControlRatio;\n      var outerControlLen = boxSize * this.outerControlRatio;\n      var ovalAngleOffset = this.ovalAngleOffset;\n\n      // Base angle for the quadrant\n      var angle = i * Math.PI / 2;\n\n      // Calculate corner P1 coordinates\n      var P1;\n      if (i === 0) P1 = {\n        x: boxSize,\n        y: -boxSize\n      }; // Top-Right Corner\n      else if (i === 1) P1 = {\n        x: boxSize,\n        y: boxSize\n      }; // Bottom-Right Corner\n      else if (i === 2) P1 = {\n        x: -boxSize,\n        y: boxSize\n      }; // Bottom-Left Corner\n      else P1 = {\n        x: -boxSize,\n        y: -boxSize\n      }; // Top-Left Corner\n\n      // Calculate edge points P2 (Inner Start) and P3 (Outer End) based on quadrant\n      var P2, P3;\n      if (i === 0) {\n        // Top Right Quad\n        P2 = {\n          x: boxSize,\n          y: -boxSize + edgeOffset\n        }; // Inner Start on Right Edge\n        P3 = {\n          x: boxSize - edgeOffset,\n          y: -boxSize\n        }; // Outer End on Top Edge\n      } else if (i === 1) {\n        // Bottom Right Quad\n        P2 = {\n          x: boxSize - edgeOffset,\n          y: boxSize\n        }; // Inner Start on Bottom Edge\n        P3 = {\n          x: boxSize,\n          y: boxSize - edgeOffset\n        }; // Outer End on Right Edge\n      } else if (i === 2) {\n        // Bottom Left Quad\n        P2 = {\n          x: -boxSize,\n          y: boxSize - edgeOffset\n        }; // Inner Start on Left Edge\n        P3 = {\n          x: -boxSize + edgeOffset,\n          y: boxSize\n        }; // Outer End on Bottom Edge\n      } else {\n        // Top Left Quad\n        P2 = {\n          x: -boxSize + edgeOffset,\n          y: -boxSize\n        }; // Inner Start on Top Edge\n        P3 = {\n          x: -boxSize,\n          y: -boxSize + edgeOffset\n        }; // Outer End on Left Edge\n      }\n\n      // Calculate Oval points P4 (Inner End) and P5 (Outer Start)\n      // Angles relative to positive x-axis, adjusted for quadrant and offset\n      var theta4 = angle + Math.PI / 4 + ovalAngleOffset; // Inner curve ends here\n      var theta5 = angle + 3 * Math.PI / 4 - ovalAngleOffset; // Outer curve starts here\n      var P4 = {\n        x: ovalRx * Math.cos(theta4),\n        y: ovalRy * Math.sin(theta4)\n      };\n      var P5 = {\n        x: ovalRx * Math.cos(theta5),\n        y: ovalRy * Math.sin(theta5)\n      };\n\n      // Calculate Control Points using tangent directions\n      var C1, C2, C3, C4;\n      var innerLen = innerControlLen;\n      var outerLen = outerControlLen;\n\n      // C1 & C4: Tangents perpendicular to the box edges P2/P3 lie on\n      if (i === 0) {\n        // Top Right Quad\n        C1 = {\n          x: P2.x - innerLen,\n          y: P2.y\n        }; // Tangent Left from Right Edge\n        C4 = {\n          x: P3.x,\n          y: P3.y + outerLen\n        }; // Tangent Down from Top Edge\n      } else if (i === 1) {\n        // Bottom Right Quad\n        C1 = {\n          x: P2.x - innerLen,\n          y: P2.y\n        }; // Tangent Left from Bottom Edge\n        C4 = {\n          x: P3.x,\n          y: P3.y - outerLen\n        }; // Tangent Up from Right Edge\n      } else if (i === 2) {\n        // Bottom Left Quad\n        C1 = {\n          x: P2.x + innerLen,\n          y: P2.y\n        }; // Tangent Right from Left Edge\n        C4 = {\n          x: P3.x,\n          y: P3.y - outerLen\n        }; // Tangent Up from Bottom Edge\n      } else {\n        // Top Left Quad\n        C1 = {\n          x: P2.x + innerLen,\n          y: P2.y\n        }; // Tangent Right from Top Edge\n        C4 = {\n          x: P3.x,\n          y: P3.y + outerLen\n        }; // Tangent Down from Left Edge\n      }\n\n      // C2 & C3: Based on tangents to the oval at P4 and P5\n      // Tangent angle at oval point `t` is `t + PI/2`\n      var tangentAngle4 = theta4 + Math.PI / 2;\n      C2 = {\n        // Control point near P4 (end of inner curve)\n        x: P4.x - Math.cos(tangentAngle4) * innerLen,\n        // Pulling back from P4 along tangent\n        y: P4.y - Math.sin(tangentAngle4) * innerLen\n      };\n      var tangentAngle5 = theta5 + Math.PI / 2;\n      C3 = {\n        // Control point near P5 (start of outer curve)\n        x: P5.x + Math.cos(tangentAngle5) * outerLen,\n        // Pushing forward from P5 along tangent\n        y: P5.y + Math.sin(tangentAngle5) * outerLen\n      };\n\n      // Assemble path data string for the blade\n      // M P1 -> L P2 -> C C1 C2 P4 -> L P5 -> C C3 C4 P3 -> Z\n      var pathData = \"\\n            M \".concat(P1.x.toFixed(2), \",\").concat(P1.y.toFixed(2), \"\\n            L \").concat(P2.x.toFixed(2), \",\").concat(P2.y.toFixed(2), \"\\n            C \").concat(C1.x.toFixed(2), \",\").concat(C1.y.toFixed(2), \" \").concat(C2.x.toFixed(2), \",\").concat(C2.y.toFixed(2), \" \").concat(P4.x.toFixed(2), \",\").concat(P4.y.toFixed(2), \"\\n            L \").concat(P5.x.toFixed(2), \",\").concat(P5.y.toFixed(2), \"\\n            C \").concat(C3.x.toFixed(2), \",\").concat(C3.y.toFixed(2), \" \").concat(C4.x.toFixed(2), \",\").concat(C4.y.toFixed(2), \" \").concat(P3.x.toFixed(2), \",\").concat(P3.y.toFixed(2), \"\\n            Z\\n        \");\n      // The L P5 creates the segment that forms the inner edge along the oval boundary.\n\n      return pathData.replace(/\\s+/g, ' ').trim(); // Clean up whitespace\n    }\n\n    /**\n     * Generates the SVG elements for the StylizedAperture shape.\n     * @returns {string} SVG string containing path elements.\n     */\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var svgPaths = '';\n      var numBlades = 4; // Fixed at 4 for this specific shape design\n\n      for (var i = 0; i < numBlades; i++) {\n        var bladePathData = this.generateBladePath(i);\n        svgPaths += \"<path d=\\\"\".concat(bladePathData, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\\n\");\n      }\n      return svgPaths;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(StylizedAperture, \"parameters\", {\n  boxSize: {\n    type: 'number',\n    min: 50,\n    max: 100,\n    step: 1,\n    \"default\": 95,\n    description: \"Half-size of the bounding box (max radius)\"\n  },\n  ovalSizeRatio: {\n    type: 'number',\n    min: 0.05,\n    max: 0.5,\n    step: 0.01,\n    \"default\": 0.2,\n    description: \"Size of central oval radius (fraction of boxSize)\"\n  },\n  ovalAspect: {\n    type: 'number',\n    min: 0.3,\n    max: 1.5,\n    step: 0.05,\n    \"default\": 0.6,\n    description: \"Aspect ratio (height/width) of the central oval\"\n  },\n  edgeRatio: {\n    type: 'number',\n    min: 0.05,\n    max: 0.95,\n    step: 0.05,\n    \"default\": 0.6,\n    description: \"Ratio of straight edge length along the box side\"\n  },\n  innerControlRatio: {\n    type: 'number',\n    min: 0.1,\n    max: 1.5,\n    step: 0.05,\n    \"default\": 0.8,\n    description: \"Length factor for inner curve control points (relative to boxSize)\"\n  },\n  outerControlRatio: {\n    type: 'number',\n    min: 0.1,\n    max: 1.5,\n    step: 0.05,\n    \"default\": 0.8,\n    description: \"Length factor for outer curve control points (relative to boxSize)\"\n  },\n  ovalAngleOffset: {\n    type: 'number',\n    min: -0.5,\n    max: 0.5,\n    step: 0.02,\n    \"default\": 0.15,\n    description: \"Angular offset (radians) for where curves meet oval\"\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StylizedAperture);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/StylizedAperture.js?");

/***/ }),

/***/ "./src/shapes/StylizedComet.js":
/*!*************************************!*\
  !*** ./src/shapes/StylizedComet.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a smooth, elongated comet-like shape with adjustable roundness,\n * taper, and a curved cutout at the back.\n */\nvar StylizedComet = /*#__PURE__*/function (_Shape) {\n  function StylizedComet() {\n    _classCallCheck(this, StylizedComet);\n    return _callSuper(this, StylizedComet, arguments);\n  }\n  _inherits(StylizedComet, _Shape);\n  return _createClass(StylizedComet, [{\n    key: \"_clamp\",\n    value: /** Helper to clamp values */\n    function _clamp(val, min, max) {\n      return Math.max(min, Math.min(max, val));\n    }\n\n    /** Helper function to rotate a point */\n  }, {\n    key: \"_rotatePoint\",\n    value: function _rotatePoint(x, y, angleDeg) {\n      var angleRad = angleDeg * Math.PI / 180;\n      var cosA = Math.cos(angleRad);\n      var sinA = Math.sin(angleRad);\n      return {\n        x: x * cosA - y * sinA,\n        y: x * sinA + y * cosA\n      };\n    }\n\n    /**\n     * Generates the SVG path string for the StylizedComet using Cubic Bezier curves.\n     */\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      // --- 1. Calculate Dimensions (Unrotated) ---\n      var len = this.length;\n      var maxWidth = len * this.widthRatio;\n      var backWidth = maxWidth * this.backWidthRatio;\n      var cutoutDepthAbs = len * this.cutoutDepthRatio;\n\n      // Define key points along the x-axis (0 = center)\n      var leadX = len / 2;\n      var backX = -len / 2;\n      var cutoutApexX = backX + cutoutDepthAbs;\n\n      // Define key anchor points (unrotated)\n      var pLead = {\n        x: leadX,\n        y: 0\n      };\n      var pTrailTop = {\n        x: backX,\n        y: backWidth / 2\n      };\n      var pTrailBottom = {\n        x: backX,\n        y: -backWidth / 2\n      };\n      var pCutoutApex = {\n        x: cutoutApexX,\n        y: 0\n      };\n\n      // --- 2. Calculate Control Points (Unrotated) ---\n\n      // Control points for the main smooth curves (Lead -> Trail Points)\n      // Adjust control point distances based on parameters\n      var frontHandleLength = len * 0.5 * this.frontRoundness;\n      var backHandleLength = len * 0.3 * this.backTaperSharpness;\n      var sideHandleOffsetY = maxWidth * 0.5; // Handles move outwards to create width\n\n      var ctrlLeadOutTop = {\n        x: leadX - frontHandleLength * 0.5,\n        y: sideHandleOffsetY * this.frontRoundness\n      };\n      var ctrlTrailInTop = {\n        x: backX + backHandleLength,\n        y: pTrailTop.y + (sideHandleOffsetY - pTrailTop.y) * (1 - this.backTaperSharpness)\n      };\n      var ctrlLeadOutBottom = {\n        x: leadX - frontHandleLength * 0.5,\n        y: -sideHandleOffsetY * this.frontRoundness\n      };\n      var ctrlTrailInBottom = {\n        x: backX + backHandleLength,\n        y: pTrailBottom.y - (sideHandleOffsetY + pTrailBottom.y) * (1 - this.backTaperSharpness)\n      };\n\n      // Control points for the cutout curves (Trail Points -> Cutout Apex)\n      // Place handles along the line connecting points, scaled by sharpness\n      var cutoutHandleLength = cutoutDepthAbs * this.cutoutSharpness;\n      var cutoutSideHandleOffsetY = backWidth / 2 * (1 - this.cutoutSharpness); // Pulls handles inward/outward\n\n      var ctrlTrailOutTop = {\n        x: pTrailTop.x + cutoutHandleLength * 0.6,\n        y: pTrailTop.y - cutoutSideHandleOffsetY\n      };\n      var ctrlCutApexInTop = {\n        x: pCutoutApex.x + cutoutHandleLength * 0.4,\n        y: pCutoutApex.y + pTrailTop.y * 0.5 * this.cutoutSharpness\n      }; // Pull towards TrailTop Y\n\n      var ctrlTrailOutBottom = {\n        x: pTrailBottom.x + cutoutHandleLength * 0.6,\n        y: pTrailBottom.y + cutoutSideHandleOffsetY\n      };\n      var ctrlCutApexInBottom = {\n        x: pCutoutApex.x + cutoutHandleLength * 0.4,\n        y: pCutoutApex.y + pTrailBottom.y * 0.5 * this.cutoutSharpness\n      }; // Pull towards TrailBottom Y\n\n      // --- 3. Rotate all points ---\n      var angle = this.rotation;\n      var pointsToRotate = [pLead, pTrailTop, pTrailBottom, pCutoutApex, ctrlLeadOutTop, ctrlTrailInTop, ctrlLeadOutBottom, ctrlTrailInBottom, ctrlTrailOutTop, ctrlCutApexInTop, ctrlTrailOutBottom, ctrlCutApexInBottom];\n      var rPoints = pointsToRotate.map(function (p) {\n        return _this._rotatePoint(p.x, p.y, angle);\n      });\n\n      // Assign rotated points back for clarity\n      var _rPoints = _slicedToArray(rPoints, 12),\n        rLead = _rPoints[0],\n        rTrailTop = _rPoints[1],\n        rTrailBottom = _rPoints[2],\n        rCutoutApex = _rPoints[3],\n        rCtrlLeadOutTop = _rPoints[4],\n        rCtrlTrailInTop = _rPoints[5],\n        rCtrlLeadOutBottom = _rPoints[6],\n        rCtrlTrailInBottom = _rPoints[7],\n        rCtrlTrailOutTop = _rPoints[8],\n        rCtrlCutApexInTop = _rPoints[9],\n        rCtrlTrailOutBottom = _rPoints[10],\n        rCtrlCutApexInBottom = _rPoints[11];\n\n      // --- 4. Build the SVG Path String using Cubic Beziers (C) ---\n      var pathData = \"\\n            M \".concat(rLead.x.toFixed(2), \",\").concat(rLead.y.toFixed(2), \"\\n            C \").concat(rCtrlLeadOutTop.x.toFixed(2), \",\").concat(rCtrlLeadOutTop.y.toFixed(2), \"\\n              \").concat(rCtrlTrailInTop.x.toFixed(2), \",\").concat(rCtrlTrailInTop.y.toFixed(2), \"\\n              \").concat(rTrailTop.x.toFixed(2), \",\").concat(rTrailTop.y.toFixed(2), \"\\n            C \").concat(rCtrlTrailOutTop.x.toFixed(2), \",\").concat(rCtrlTrailOutTop.y.toFixed(2), \"\\n              \").concat(rCtrlCutApexInTop.x.toFixed(2), \",\").concat(rCtrlCutApexInTop.y.toFixed(2), \"\\n              \").concat(rCutoutApex.x.toFixed(2), \",\").concat(rCutoutApex.y.toFixed(2), \"\\n            C \").concat(rCtrlCutApexInBottom.x.toFixed(2), \",\").concat(rCtrlCutApexInBottom.y.toFixed(2), \"\\n              \").concat(rCtrlTrailOutBottom.x.toFixed(2), \",\").concat(rCtrlTrailOutBottom.y.toFixed(2), \"\\n              \").concat(rTrailBottom.x.toFixed(2), \",\").concat(rTrailBottom.y.toFixed(2), \"\\n            C \").concat(rCtrlTrailInBottom.x.toFixed(2), \",\").concat(rCtrlTrailInBottom.y.toFixed(2), \"\\n              \").concat(rCtrlLeadOutBottom.x.toFixed(2), \",\").concat(rCtrlLeadOutBottom.y.toFixed(2), \"\\n              \").concat(rLead.x.toFixed(2), \",\").concat(rLead.y.toFixed(2), \"\\n            Z\\n        \");\n\n      // Clamp coordinates post-rotation if necessary (optional, but safer)\n      // For this shape, the points are defined relative to 0,0 and rotation keeps it centered.\n      // Max extent is roughly len/2 + width/2. For len=195, width=0.8*195=156, max extent ~ 97.5 + 78 = 175.5.\n      // This can exceed the -100 to +100 range. Add a scaling factor.\n      var maxDimension = Math.max(len / 2, maxWidth / 2) * 1.1; // Estimate max deviation from center\n      var scale = maxDimension > 99 ? 99 / maxDimension : 1;\n      return \"<path d=\\\"\".concat(pathData, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" transform=\\\"scale(\").concat(scale.toFixed(3), \")\\\"/>\");\n      // Resetting scale as per strict rules. Ensure parameters stay within reason.\n      // return `<path d=\"${pathData}\" fill=\"white\" stroke=\"none\" />`;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(StylizedComet, \"parameters\", {\n  length: {\n    type: 'number',\n    min: 80,\n    max: 195,\n    step: 1,\n    \"default\": 160,\n    label: 'Length'\n  },\n  widthRatio: {\n    type: 'number',\n    min: 0.2,\n    // Width relative to length\n    max: 0.8,\n    step: 0.01,\n    \"default\": 0.45,\n    label: 'Width Ratio'\n  },\n  backWidthRatio: {\n    type: 'number',\n    min: 0.1,\n    // Width at the back cutout opening, relative to max width\n    max: 1.0,\n    step: 0.01,\n    \"default\": 0.6,\n    label: 'Back Width Ratio'\n  },\n  cutoutDepthRatio: {\n    type: 'number',\n    min: 0.1,\n    // Depth of the cutout relative to length\n    max: 0.7,\n    step: 0.01,\n    \"default\": 0.3,\n    label: 'Cutout Depth Ratio'\n  },\n  cutoutSharpness: {\n    type: 'number',\n    min: 0.1,\n    // Controls the inward curve sharpness\n    max: 1.5,\n    step: 0.05,\n    \"default\": 0.6,\n    label: 'Cutout Sharpness'\n  },\n  frontRoundness: {\n    type: 'number',\n    min: 0.1,\n    // Controls the curve tension at the front\n    max: 1.0,\n    step: 0.05,\n    \"default\": 0.8,\n    label: 'Front Roundness'\n  },\n  backTaperSharpness: {\n    type: 'number',\n    min: 0.1,\n    // Controls how sharply the body tapers towards the back points\n    max: 1.5,\n    step: 0.05,\n    \"default\": 0.6,\n    label: 'Back Taper Sharpness'\n  },\n  rotation: {\n    type: 'number',\n    min: 0,\n    max: 360,\n    step: 1,\n    \"default\": -45,\n    // Default rotation similar to reference\n    label: 'Rotation'\n  },\n  seed: {\n    // Inherited, but override default if needed\n    type: 'number',\n    min: 1,\n    max: 10000,\n    \"default\": 101\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StylizedComet);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/StylizedComet.js?");

/***/ }),

/***/ "./src/shapes/StylizedOShape.js":
/*!**************************************!*\
  !*** ./src/shapes/StylizedOShape.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a shape resembling a stylized 'O' or capsule with a rectangular\n * cutout in the center.\n */\nvar StylizedOShape = /*#__PURE__*/function (_Shape) {\n  function StylizedOShape() {\n    _classCallCheck(this, StylizedOShape);\n    return _callSuper(this, StylizedOShape, arguments);\n  }\n  _inherits(StylizedOShape, _Shape);\n  return _createClass(StylizedOShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Setup base parameters with scaling\n      var scale = 1;\n      var width = this.width * scale;\n      var height = this.height * scale;\n      var cutoutHeight = this.cutoutHeight * scale;\n      var cornerRadius = this.cornerRadius * scale;\n      var sideWidth = this.sideWidth * scale;\n\n      // Calculate cutout dimensions\n      var cutoutWidth = width - sideWidth * 2;\n\n      // Generate paths for outer rectangle and inner cutout\n      var outerPath = this.roundedRectPath(-width / 2,\n      // x\n      -height / 2,\n      // y\n      width,\n      // width\n      height,\n      // height\n      cornerRadius // radius\n      );\n      var innerPath = this.roundedRectPath(-cutoutWidth / 2,\n      // x\n      -cutoutHeight / 2,\n      // y\n      cutoutWidth,\n      // width\n      cutoutHeight,\n      // height\n      cornerRadius // radius\n      );\n\n      // Create unique IDs for the mask\n      var maskId = \"mask-\".concat(Math.random().toString(36).substr(2, 9));\n\n      // Return SVG with mask and path\n      return \"\\n            <defs>\\n                <mask id=\\\"\".concat(maskId, \"\\\">\\n                    <path \\n                        d=\\\"\").concat(outerPath, \"\\\"\\n                        fill=\\\"white\\\"\\n                    />\\n                    <path \\n                        d=\\\"\").concat(innerPath, \"\\\"\\n                        fill=\\\"black\\\"\\n                    />\\n                </mask>\\n            </defs>\\n            <rect \\n                x=\\\"\").concat(-width / 2, \"\\\"\\n                y=\\\"\").concat(-height / 2, \"\\\"\\n                width=\\\"\").concat(width, \"\\\"\\n                height=\\\"\").concat(height, \"\\\"\\n                fill=\\\"white\\\"\\n                mask=\\\"url(#\").concat(maskId, \")\\\"\\n            />\");\n    }\n  }, {\n    key: \"roundedRectPath\",\n    value: function roundedRectPath(x, y, width, height, radius) {\n      // Ensure radius doesn't exceed half of width or height\n      var r = Math.min(radius, Math.min(width / 2, height / 2));\n\n      // Start path at top-left corner after the radius\n      return \"M\".concat(x + r, \",\").concat(y, \"\\n            h\").concat(width - 2 * r, \"\\n            a\").concat(r, \",\").concat(r, \" 0 0 1 \").concat(r, \",\").concat(r, \"\\n            v\").concat(height - 2 * r, \"\\n            a\").concat(r, \",\").concat(r, \" 0 0 1 -\").concat(r, \",\").concat(r, \"\\n            h-\").concat(width - 2 * r, \"\\n            a\").concat(r, \",\").concat(r, \" 0 0 1 -\").concat(r, \",-\").concat(r, \"\\n            v-\").concat(height - 2 * r, \"\\n            a\").concat(r, \",\").concat(r, \" 0 0 1 \").concat(r, \",-\").concat(r, \"\\n            z\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(StylizedOShape, \"parameters\", {\n  width: {\n    min: 50,\n    max: 200,\n    \"default\": 120\n  },\n  height: {\n    min: 80,\n    max: 250,\n    \"default\": 160\n  },\n  cutoutHeight: {\n    min: 10,\n    max: 60,\n    \"default\": 30\n  },\n  cornerRadius: {\n    min: 0,\n    max: 40,\n    \"default\": 20\n  },\n  sideWidth: {\n    min: 20,\n    max: 80,\n    \"default\": 40\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StylizedOShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/StylizedOShape.js?");

/***/ }),

/***/ "./src/shapes/SubwayNetwork.js":
/*!*************************************!*\
  !*** ./src/shapes/SubwayNetwork.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a subway-map-like network with nodes on a grid connected by\n * orthogonal or straight lines based on a Minimum Spanning Tree.\n */\nvar SubwayNetwork = /*#__PURE__*/function (_Shape) {\n  function SubwayNetwork() {\n    _classCallCheck(this, SubwayNetwork);\n    return _callSuper(this, SubwayNetwork, arguments);\n  }\n  _inherits(SubwayNetwork, _Shape);\n  return _createClass(SubwayNetwork, [{\n    key: \"generateShape\",\n    value:\n    /**\n     * Generates the SVG elements for the SubwayNetwork shape.\n     * Accesses parameters via `this.parameterName`.\n     * @param {object} params - Parameter values (available on `this`).\n     * @returns {string} SVG string containing grid lines, connection lines, and node circles.\n     */\n    function generateShape(params) {\n      var _this = this;\n      var gridDivisions = this.gridDivisions,\n        radiusRatio = this.radiusRatio,\n        placementMode = this.placementMode,\n        showGrid = this.showGrid,\n        gridStrokeWidth = this.gridStrokeWidth,\n        connectionStrokeWidth = this.connectionStrokeWidth,\n        connectionStyle = this.connectionStyle;\n      var viewBoxSize = 200;\n      var minCoord = -viewBoxSize / 2;\n      var maxCoord = viewBoxSize / 2;\n      var gridStep = viewBoxSize / gridDivisions;\n      var halfGridStep = gridStep / 2;\n\n      // Calculate actual node radius\n      var radius = Math.min(radiusRatio, 1.0) * halfGridStep;\n\n      // Format numbers function\n      var fmt = function fmt(n) {\n        return parseFloat(n.toFixed(3));\n      };\n      var svgElements = '';\n\n      // --- 1. Generate Grid Lines (if requested) ---\n      if (showGrid && gridDivisions > 0) {\n        var gridPathData = '';\n        // Vertical lines\n        for (var i = 0; i <= gridDivisions; i++) {\n          var x = minCoord + i * gridStep;\n          gridPathData += \"M \".concat(fmt(x), \",\").concat(fmt(minCoord), \" L \").concat(fmt(x), \",\").concat(fmt(maxCoord), \" \");\n        }\n        // Horizontal lines\n        for (var _i = 0; _i <= gridDivisions; _i++) {\n          var y = minCoord + _i * gridStep;\n          gridPathData += \"M \".concat(fmt(minCoord), \",\").concat(fmt(y), \" L \").concat(fmt(maxCoord), \",\").concat(fmt(y), \" \");\n        }\n        svgElements += \"<path d=\\\"\".concat(gridPathData.trim(), \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(fmt(gridStrokeWidth), \"\\\" opacity=\\\"0.5\\\" />\\n\"); // Added opacity\n      }\n\n      // --- 2. Generate Potential Node Coordinates ---\n      var potentialCoords = [];\n      if (placementMode === 'cell') {\n        var startOffset = minCoord + halfGridStep;\n        for (var row = 0; row < gridDivisions; row++) {\n          for (var col = 0; col < gridDivisions; col++) {\n            potentialCoords.push({\n              id: potentialCoords.length,\n              x: startOffset + col * gridStep,\n              y: startOffset + row * gridStep\n            });\n          }\n        }\n      } else {\n        // placementMode === 'intersection'\n        for (var _row = 0; _row <= gridDivisions; _row++) {\n          for (var _col = 0; _col <= gridDivisions; _col++) {\n            potentialCoords.push({\n              id: potentialCoords.length,\n              x: minCoord + _col * gridStep,\n              y: minCoord + _row * gridStep\n            });\n          }\n        }\n      }\n\n      // --- 3. Select Node Coordinates Randomly ---\n      this.shuffleArray(potentialCoords);\n      var actualNumNodes = Math.min(this.numNodes, potentialCoords.length);\n      if (actualNumNodes < 2) return svgElements; // Need at least 2 nodes for connections\n\n      var selectedNodes = potentialCoords.slice(0, actualNumNodes);\n\n      // --- 4. Calculate Minimum Spanning Tree (MST) using Prim's Algorithm ---\n      var mstEdges = this.calculateMST(selectedNodes);\n\n      // --- 5. Generate Connection Lines SVG ---\n      var connectionPaths = '';\n      mstEdges.forEach(function (edge) {\n        var node1 = selectedNodes.find(function (n) {\n          return n.id === edge.u;\n        });\n        var node2 = selectedNodes.find(function (n) {\n          return n.id === edge.v;\n        });\n        var x1 = fmt(node1.x);\n        var y1 = fmt(node1.y);\n        var x2 = fmt(node2.x);\n        var y2 = fmt(node2.y);\n        if (connectionStyle === 'orthogonal') {\n          // Randomly choose vertical-first or horizontal-first bend\n          if (_this.random() > 0.5) {\n            // Vertical first: (x1, y1) -> (x1, y2) -> (x2, y2)\n            connectionPaths += \"<polyline points=\\\"\".concat(x1, \",\").concat(y1, \" \").concat(x1, \",\").concat(y2, \" \").concat(x2, \",\").concat(y2, \"\\\" />\\n\");\n          } else {\n            // Horizontal first: (x1, y1) -> (x2, y1) -> (x2, y2)\n            connectionPaths += \"<polyline points=\\\"\".concat(x1, \",\").concat(y1, \" \").concat(x2, \",\").concat(y1, \" \").concat(x2, \",\").concat(y2, \"\\\" />\\n\");\n          }\n        } else {\n          // 'straight'\n          connectionPaths += \"<line x1=\\\"\".concat(x1, \"\\\" y1=\\\"\").concat(y1, \"\\\" x2=\\\"\").concat(x2, \"\\\" y2=\\\"\").concat(y2, \"\\\" />\\n\");\n        }\n      });\n\n      // Add connection paths group behind circles\n      svgElements += \"<g fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"\".concat(fmt(connectionStrokeWidth), \"\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\">\\n\").concat(connectionPaths, \"</g>\\n\");\n\n      // --- 6. Generate Node Circles SVG ---\n      selectedNodes.forEach(function (node) {\n        svgElements += \"<circle cx=\\\"\".concat(fmt(node.x), \"\\\" cy=\\\"\").concat(fmt(node.y), \"\\\" r=\\\"\").concat(fmt(radius), \"\\\" fill=\\\"white\\\" />\\n\");\n      });\n      return svgElements.trim();\n    }\n\n    /**\n     * Calculates the Minimum Spanning Tree (MST) for a set of nodes using Prim's algorithm.\n     * @param {Array<object>} nodes - Array of node objects, each with {id, x, y}.\n     * @returns {Array<object>} Array of edge objects {u, v, weight} representing the MST.\n     */\n  }, {\n    key: \"calculateMST\",\n    value: function calculateMST(nodes) {\n      var _this2 = this;\n      if (nodes.length < 2) return [];\n      var mstEdges = [];\n      var visited = new Set();\n      var distance = function distance(n1, n2) {\n        return Math.sqrt(Math.pow(n1.x - n2.x, 2) + Math.pow(n1.y - n2.y, 2));\n      };\n\n      // Min-priority queue simulation (simple array scan for minimum)\n      // Stores { u, v, weight } where u is visited, v is not\n      var edgeQueue = [];\n\n      // Start with the first node\n      visited.add(nodes[0].id);\n      var _loop = function _loop() {\n          var lastVisitedNodeId = Array.from(visited).pop(); // Inefficient, but ok for small N\n          var lastVisitedNode = nodes.find(function (n) {\n            return n.id === lastVisitedNodeId;\n          });\n\n          // Add edges from the newly visited node to all unvisited nodes\n          nodes.forEach(function (neighbor) {\n            if (!visited.has(neighbor.id)) {\n              edgeQueue.push({\n                u: lastVisitedNode.id,\n                v: neighbor.id,\n                weight: distance(lastVisitedNode, neighbor)\n              });\n            }\n          });\n\n          // Find the minimum weight edge from the queue connecting a visited node to an unvisited one\n          var minEdge = null;\n          var minEdgeIndex = -1;\n          for (var i = edgeQueue.length - 1; i >= 0; i--) {\n            var edge = edgeQueue[i];\n            // Ensure the target node 'v' is not already visited (important if queue isn't strictly managed)\n            if (visited.has(edge.u) && !visited.has(edge.v)) {\n              if (!minEdge || edge.weight < minEdge.weight || edge.weight === minEdge.weight && _this2.random() > 0.5) {\n                // Use random for tie-breaking\n                minEdge = edge;\n                minEdgeIndex = i;\n              }\n            } else if (visited.has(edge.v)) {\n              // Remove edges where both nodes are now visited (optional cleanup)\n              edgeQueue.splice(i, 1);\n            }\n          }\n          if (minEdge) {\n            // Add the best edge to the MST\n            mstEdges.push(minEdge);\n            // Mark the newly connected node as visited\n            visited.add(minEdge.v);\n            // Remove the used edge from the queue\n            if (minEdgeIndex !== -1) {\n              edgeQueue.splice(minEdgeIndex, 1);\n            }\n          } else if (edgeQueue.length === 0 && visited.size < nodes.length) {\n            // Should not happen in a connected graph, but handles disjoint cases\n            // Find any unvisited node and start a new component search (though MST is typically for connected)\n            var nextNode = nodes.find(function (n) {\n              return !visited.has(n.id);\n            });\n            if (nextNode) {\n              visited.add(nextNode.id);\n            } else {\n              return 0; // break\n              // All nodes processed or unreachable\n            }\n          } else {\n            return 0; // break\n            // No more valid edges found\n          }\n        },\n        _ret;\n      while (visited.size < nodes.length) {\n        _ret = _loop();\n        if (_ret === 0) break;\n      }\n      return mstEdges;\n    }\n\n    /**\n     * Shuffles an array in place using the Fisher-Yates algorithm and the seeded RNG.\n     * @param {Array} array - The array to shuffle.\n     */\n  }, {\n    key: \"shuffleArray\",\n    value: function shuffleArray(array) {\n      for (var i = array.length - 1; i > 0; i--) {\n        var j = Math.floor(this.random() * (i + 1));\n        var _ref = [array[j], array[i]];\n        array[i] = _ref[0];\n        array[j] = _ref[1];\n      }\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(SubwayNetwork, \"parameters\", {\n  gridDivisions: {\n    type: 'number',\n    min: 3,\n    // Minimum grid size for meaningful connections\n    max: 15,\n    step: 1,\n    \"default\": 8,\n    label: 'Grid Divisions'\n  },\n  numNodes: {\n    type: 'number',\n    min: 2,\n    // Need at least two nodes to connect\n    max: 50,\n    // Limit node count for performance/clarity\n    step: 1,\n    \"default\": 12,\n    label: 'Number of Nodes'\n  },\n  radiusRatio: {\n    type: 'number',\n    min: 0.1,\n    max: 1.0,\n    // Relative to half grid step\n    step: 0.05,\n    \"default\": 0.5,\n    label: 'Node Radius Ratio'\n  },\n  placementMode: {\n    type: 'enum',\n    options: ['cell', 'intersection'],\n    \"default\": 'intersection',\n    label: 'Node Placement'\n  },\n  connectionStyle: {\n    type: 'enum',\n    options: ['orthogonal', 'straight'],\n    \"default\": 'orthogonal',\n    label: 'Connection Style'\n  },\n  showGrid: {\n    type: 'boolean',\n    \"default\": true,\n    label: 'Show Grid Lines'\n  },\n  connectionStrokeWidth: {\n    type: 'number',\n    min: 0.2,\n    max: 8,\n    step: 0.1,\n    \"default\": 1.5,\n    label: 'Connection Width'\n  },\n  gridStrokeWidth: {\n    type: 'number',\n    min: 0.1,\n    max: 5,\n    step: 0.1,\n    \"default\": 0.5,\n    label: 'Grid Line Width'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SubwayNetwork);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/SubwayNetwork.js?");

/***/ }),

/***/ "./src/shapes/SunBurstShape.js":
/*!*************************************!*\
  !*** ./src/shapes/SunBurstShape.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a sunburst pattern with triangular blades radiating from an inner\n * radius, allowing twist/skew.\n */\nvar SunBurstShape = /*#__PURE__*/function (_Shape) {\n  function SunBurstShape() {\n    _classCallCheck(this, SunBurstShape);\n    return _callSuper(this, SunBurstShape, arguments);\n  }\n  _inherits(SunBurstShape, _Shape);\n  return _createClass(SunBurstShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var segments = [];\n      var angleStep = 2 * Math.PI / this.segmentCount;\n      var bladeWidthRad = this.bladeWidth * Math.PI / 180;\n      var twistRad = this.twist * Math.PI / 180;\n      for (var i = 0; i < this.segmentCount; i++) {\n        var baseAngle = i * angleStep;\n\n        // Calculate blade points\n        var tipAngle = baseAngle + twistRad;\n        var leftAngle = baseAngle - bladeWidthRad / 2;\n        var rightAngle = baseAngle + bladeWidthRad / 2;\n\n        // Inner points\n        var innerX1 = this.innerRadius * Math.cos(leftAngle);\n        var innerY1 = this.innerRadius * Math.sin(leftAngle);\n        var innerX2 = this.innerRadius * Math.cos(rightAngle);\n        var innerY2 = this.innerRadius * Math.sin(rightAngle);\n\n        // Outer tip point\n        var tipX = this.outerRadius * Math.cos(tipAngle);\n        var tipY = this.outerRadius * Math.sin(tipAngle);\n\n        // Create the blade segment\n        var path = \"\\n                M \".concat(innerX1, \" \").concat(innerY1, \"\\n                L \").concat(tipX, \" \").concat(tipY, \"\\n                L \").concat(innerX2, \" \").concat(innerY2, \"\\n                A \").concat(this.innerRadius, \" \").concat(this.innerRadius, \" 0 0 0 \").concat(innerX1, \" \").concat(innerY1, \"\\n                Z\\n            \");\n        segments.push(\"<path d=\\\"\".concat(path, \"\\\" fill=\\\"white\\\"/>\"));\n      }\n      return segments.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(SunBurstShape, \"parameters\", {\n  segmentCount: {\n    min: 3,\n    max: 24,\n    \"default\": 12\n  },\n  innerRadius: {\n    min: 2,\n    max: 100,\n    \"default\": 30\n  },\n  outerRadius: {\n    min: 50,\n    max: 150,\n    \"default\": 90\n  },\n  bladeWidth: {\n    min: 1,\n    max: 90,\n    \"default\": 45\n  },\n  // Angular width in degrees\n  twist: {\n    min: -90,\n    max: 90,\n    \"default\": 0\n  } // Rotation of blade tips\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SunBurstShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/SunBurstShape.js?");

/***/ }),

/***/ "./src/shapes/SwirlingVortex.js":
/*!**************************************!*\
  !*** ./src/shapes/SwirlingVortex.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a vortex or spiral pattern composed of multiple swirling arms.\n */\nvar SwirlingVortex = /*#__PURE__*/function (_Shape) {\n  function SwirlingVortex() {\n    _classCallCheck(this, SwirlingVortex);\n    return _callSuper(this, SwirlingVortex, arguments);\n  }\n  _inherits(SwirlingVortex, _Shape);\n  return _createClass(SwirlingVortex, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Reset RNG for consistent results\n      this.resetRNG();\n      var paths = [];\n      var maxRadius = 100;\n      var rotationRad = this.rotation * Math.PI / 180;\n\n      // Generate each spiral arm\n      for (var i = 0; i < this.arms; i++) {\n        var baseAngle = i * 2 * Math.PI / this.arms + rotationRad;\n\n        // Create spiral path with logarithmic function for smoother result\n        var pathData = this.generateSpiralPath(baseAngle, maxRadius);\n        paths.push(\"<path \\n                d=\\\"\".concat(pathData, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                fill=\\\"none\\\"\\n                stroke-linecap=\\\"round\\\"\\n                stroke-linejoin=\\\"round\\\"\\n            />\"));\n      }\n      return paths.join('');\n    }\n  }, {\n    key: \"generateSpiralPath\",\n    value: function generateSpiralPath(baseAngle, maxRadius) {\n      // Use more points for smoother curve\n      var numPoints = 200;\n      var points = [];\n\n      // Generate a logarithmic spiral\n      for (var i = 0; i <= numPoints; i++) {\n        var t = i / numPoints;\n\n        // Logarithmic spiral function\n        var angle = baseAngle + this.turns * 2 * Math.PI * t;\n        var radius = maxRadius * t;\n\n        // Convert to cartesian coordinates\n        var x = radius * Math.cos(angle);\n        var y = radius * Math.sin(angle);\n        points.push([x, y]);\n      }\n\n      // Create a simple path connecting points directly - for clean spirals\n      var pathData = \"M \".concat(points[0][0], \",\").concat(points[0][1]);\n      for (var _i = 1; _i < points.length; _i++) {\n        pathData += \" L \".concat(points[_i][0], \",\").concat(points[_i][1]);\n      }\n      return pathData;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(SwirlingVortex, \"parameters\", {\n  arms: {\n    min: 1,\n    max: 8,\n    \"default\": 3\n  },\n  rotation: {\n    min: -180,\n    max: 180,\n    \"default\": 0\n  },\n  turns: {\n    min: 1,\n    max: 5,\n    \"default\": 2.5\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 3\n  },\n  variation: {\n    min: 0,\n    max: 1,\n    \"default\": 0.2\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SwirlingVortex);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/SwirlingVortex.js?");

/***/ }),

/***/ "./src/shapes/SymmetricAbstractForm.js":
/*!*********************************************!*\
  !*** ./src/shapes/SymmetricAbstractForm.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a symmetrical abstract shape with a central lens and outer 'bowl'\n * sections, creating teardrop-like negative space.\n */\nvar SymmetricAbstractForm = /*#__PURE__*/function (_Shape) {\n  function SymmetricAbstractForm() {\n    _classCallCheck(this, SymmetricAbstractForm);\n    return _callSuper(this, SymmetricAbstractForm, arguments);\n  }\n  _inherits(SymmetricAbstractForm, _Shape);\n  return _createClass(SymmetricAbstractForm, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // --- Parameter Access ---\n      var halfW = this.width / 2;\n      var lensY = this.lensHeight / 2; // Half-height of the lens\n      var gap = this.gap;\n      var bowlH = this.bowlHeight;\n      var curvatureOffset = this.bowlCurvature; // How much the control point is offset from the inner edge\n\n      // --- Calculations ---\n      // Y-coordinate for the inner edge of the bowls (closest to the center)\n      var bowlInnerY = lensY + gap;\n      // Y-coordinate for the outer edge of the bowls\n      var bowlOuterY = bowlInnerY + bowlH;\n      // Y-coordinate for the quadratic Bezier control point for the top bowl's curve\n      // A larger value makes the curve bulge more upwards (sharper teardrop)\n      var topControlY = bowlInnerY + curvatureOffset;\n      // Mirrored control point for the bottom bowl\n      var bottomControlY = -bowlInnerY - curvatureOffset;\n\n      // Ensure the total height doesn't exceed the viewbox boundaries easily\n      var scaleFactor = Math.min(1, 98 / bowlOuterY); // Use 98 to leave a small margin\n      var scaledHalfW = halfW * scaleFactor;\n      var scaledLensY = lensY * scaleFactor;\n      var scaledBowlInnerY = bowlInnerY * scaleFactor;\n      var scaledBowlOuterY = bowlOuterY * scaleFactor;\n      var scaledTopControlY = topControlY * scaleFactor;\n      var scaledBottomControlY = bottomControlY * scaleFactor;\n\n      // --- SVG Path Construction ---\n\n      // Central Lens Path (using elliptical arcs)\n      // M -> Move to start (-halfW, 0)\n      // A -> Elliptical Arc: rx ry x-axis-rotation large-arc-flag sweep-flag x y\n      // First arc (top half): rx=halfW, ry=lensY, rotation=0, large-arc=0, sweep=1 (clockwise), to (halfW, 0)\n      // Second arc (bottom half): same radii, rotation=0, large-arc=0, sweep=1 (clockwise), back to (-halfW, 0)\n      // Z -> Close path\n      var lensPath = \"\\n            M \".concat(-scaledHalfW, \" 0\\n            A \").concat(scaledHalfW, \" \").concat(scaledLensY, \" 0 0 1 \").concat(scaledHalfW, \" 0\\n            A \").concat(scaledHalfW, \" \").concat(scaledLensY, \" 0 0 1 \").concat(-scaledHalfW, \" 0\\n            Z\\n        \");\n\n      // Top Bowl Path\n      // M -> Move to top-left corner\n      // L -> Line to top-right corner\n      // L -> Line down to inner edge (right side)\n      // Q -> Quadratic Bezier Curve: controlX controlY endX endY\n      //      Control point (0, topControlY) pulls the curve upwards\n      //      End point is inner edge (left side)\n      // Z -> Close path\n      var topBowlPath = \"\\n            M \".concat(-scaledHalfW, \" \").concat(scaledBowlOuterY, \"\\n            L \").concat(scaledHalfW, \" \").concat(scaledBowlOuterY, \"\\n            L \").concat(scaledHalfW, \" \").concat(scaledBowlInnerY, \"\\n            Q 0 \").concat(scaledTopControlY, \" \").concat(-scaledHalfW, \" \").concat(scaledBowlInnerY, \"\\n            Z\\n        \");\n\n      // Bottom Bowl Path (mirrored version of the top bowl)\n      // M -> Move to bottom-left corner\n      // L -> Line to bottom-right corner\n      // L -> Line up to inner edge (right side)\n      // Q -> Quadratic Bezier Curve: controlX controlY endX endY\n      //      Control point (0, bottomControlY) pulls the curve downwards\n      //      End point is inner edge (left side)\n      // Z -> Close path\n      var bottomBowlPath = \"\\n            M \".concat(-scaledHalfW, \" \").concat(-scaledBowlOuterY, \"\\n            L \").concat(scaledHalfW, \" \").concat(-scaledBowlOuterY, \"\\n            L \").concat(scaledHalfW, \" \").concat(-scaledBowlInnerY, \"\\n            Q 0 \").concat(scaledBottomControlY, \" \").concat(-scaledHalfW, \" \").concat(-scaledBowlInnerY, \"\\n            Z\\n        \");\n\n      // --- Combine Paths ---\n      return \"\\n            <path d=\\\"\".concat(lensPath, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\\n            <path d=\\\"\").concat(topBowlPath, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\\n            <path d=\\\"\").concat(bottomBowlPath, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\\n        \");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(SymmetricAbstractForm, \"parameters\", {\n  width: {\n    type: 'number',\n    min: 40,\n    max: 198,\n    step: 2,\n    \"default\": 160,\n    description: \"Overall width of the shape\"\n  },\n  lensHeight: {\n    type: 'number',\n    min: 10,\n    max: 80,\n    step: 1,\n    \"default\": 40,\n    description: \"Height of the central horizontal lens\"\n  },\n  gap: {\n    type: 'number',\n    min: 0,\n    max: 40,\n    step: 1,\n    \"default\": 10,\n    description: \"Vertical gap between lens and bowls\"\n  },\n  bowlHeight: {\n    type: 'number',\n    min: 10,\n    max: 80,\n    step: 1,\n    \"default\": 50,\n    description: \"Height of the top/bottom bowl sections\"\n  },\n  bowlCurvature: {\n    type: 'number',\n    min: 5,\n    max: 60,\n    step: 1,\n    \"default\": 25,\n    description: \"Controls the bulge of the bowl's inner curve (affects teardrop shape)\"\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SymmetricAbstractForm);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/SymmetricAbstractForm.js?");

/***/ }),

/***/ "./src/shapes/SymmetricGridPattern.js":
/*!********************************************!*\
  !*** ./src/shapes/SymmetricGridPattern.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a symmetrical pattern by creating lines within one quadrant and\n * reflecting or rotating it to the other three.\n */\nvar SymmetricGridPattern = /*#__PURE__*/function (_Shape) {\n  function SymmetricGridPattern() {\n    _classCallCheck(this, SymmetricGridPattern);\n    return _callSuper(this, SymmetricGridPattern, arguments);\n  }\n  _inherits(SymmetricGridPattern, _Shape);\n  return _createClass(SymmetricGridPattern, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      var paths = [];\n      var rotationRad = this.rotation * Math.PI / 180;\n\n      // Generate one quadrant of lines\n      var generateQuadrant = function generateQuadrant(baseAngle) {\n        var lines = [];\n        var angleStep = Math.PI / 2 / (_this.lines - 1);\n        for (var i = 0; i < _this.lines; i++) {\n          var angle = baseAngle + i * angleStep;\n          var startX = 0;\n          var startY = 0;\n          var endX = _this.radius * Math.cos(angle);\n          var endY = _this.radius * Math.sin(angle);\n\n          // Add cross lines\n          for (var j = 0; j <= _this.lines; j++) {\n            var t = j / _this.lines;\n            var x1 = startX + (endX - startX) * t;\n            var y1 = startY + (endY - startY) * t;\n            var perpAngle = angle + Math.PI / 2;\n            var gridSpacing = _this.spacing * (1 - t); // Spacing decreases towards the center\n\n            var x2 = x1 + gridSpacing * Math.cos(perpAngle);\n            var y2 = y1 + gridSpacing * Math.sin(perpAngle);\n            lines.push(\"\\n                        <line \\n                            x1=\\\"\".concat(x1, \"\\\" \\n                            y1=\\\"\").concat(y1, \"\\\" \\n                            x2=\\\"\").concat(x2, \"\\\" \\n                            y2=\\\"\").concat(y2, \"\\\"\\n                            stroke=\\\"white\\\"\\n                            stroke-width=\\\"\").concat(_this.thickness, \"\\\"\\n                            stroke-linecap=\\\"round\\\"\\n                        />\\n                    \"));\n          }\n        }\n        return lines;\n      };\n\n      // Generate all four quadrants\n      for (var quadrant = 0; quadrant < 4; quadrant++) {\n        var baseAngle = quadrant * Math.PI / 2 + rotationRad;\n        var quadrantLines = generateQuadrant(baseAngle);\n        paths.push.apply(paths, _toConsumableArray(quadrantLines));\n      }\n      return paths.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(SymmetricGridPattern, \"parameters\", {\n  lines: {\n    min: 6,\n    max: 24,\n    \"default\": 6\n  },\n  spacing: {\n    min: 6,\n    max: 20,\n    \"default\": 12\n  },\n  radius: {\n    min: 40,\n    max: 120,\n    \"default\": 80\n  },\n  rotation: {\n    min: -180,\n    max: 180,\n    \"default\": 45\n  },\n  thickness: {\n    min: 1,\n    max: 6,\n    \"default\": 4\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SymmetricGridPattern);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/SymmetricGridPattern.js?");

/***/ }),

/***/ "./src/shapes/SymmetricLines.js":
/*!**************************************!*\
  !*** ./src/shapes/SymmetricLines.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a pattern of vertically symmetrical lines with heights decreasing\n * away from the center.\n */\nvar SymmetricLines = /*#__PURE__*/function (_Shape) {\n  function SymmetricLines() {\n    _classCallCheck(this, SymmetricLines);\n    return _callSuper(this, SymmetricLines, arguments);\n  }\n  _inherits(SymmetricLines, _Shape);\n  return _createClass(SymmetricLines, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      this.viewportSize = 150;\n      var lines = [];\n      var totalWidth = this.spacing * (this.count - 1);\n\n      // Calculate scale to fit within viewport\n      var scale = Math.min(1, this.viewportSize * 2 / totalWidth);\n      var scaledSpacing = this.spacing * scale;\n      var startX = -totalWidth * scale / 2;\n\n      // Calculate middle point for symmetry\n      var middleIndex = (this.count - 1) / 2;\n\n      // Generate lines\n      for (var i = 0; i < this.count; i++) {\n        var x = startX + i * scaledSpacing;\n\n        // Calculate height based on distance from center\n        var distanceFromCenter = Math.abs(i - middleIndex) / middleIndex;\n        var variationFactor = this.variation / 100;\n\n        // Create symmetrical height variation\n        var heightFactor = 1 - distanceFromCenter * variationFactor;\n        var height = this.minHeight + (this.maxHeight - this.minHeight) * heightFactor;\n        var scaledHeight = height * scale;\n        var halfHeight = scaledHeight / 2;\n        lines.push(\"<line \\n                x1=\\\"\".concat(x, \"\\\"\\n                y1=\\\"\").concat(-halfHeight, \"\\\"\\n                x2=\\\"\").concat(x, \"\\\"\\n                y2=\\\"\").concat(halfHeight, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness * scale, \"\\\"\\n                stroke-linecap=\\\"\").concat(this.lineCap, \"\\\"\\n            />\"));\n      }\n      return \"<g>\".concat(lines.join(''), \"</g>\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(SymmetricLines, \"parameters\", {\n  count: {\n    min: 3,\n    max: 16,\n    \"default\": 7\n  },\n  spacing: {\n    min: 10,\n    max: 50,\n    \"default\": 22\n  },\n  minHeight: {\n    min: 20,\n    max: 200,\n    \"default\": 20\n  },\n  maxHeight: {\n    min: 50,\n    max: 250,\n    \"default\": 166\n  },\n  thickness: {\n    min: 2,\n    max: 30,\n    \"default\": 8\n  },\n  variation: {\n    min: 0,\n    max: 100,\n    \"default\": 100\n  },\n  lineCap: {\n    options: ['butt', 'round', 'square'],\n    \"default\": 'square'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SymmetricLines);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/SymmetricLines.js?");

/***/ }),

/***/ "./src/shapes/SymmetricTotem.js":
/*!**************************************!*\
  !*** ./src/shapes/SymmetricTotem.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a totem-like shape combining a central rounded rectangle with\n * semi-circular caps at the top and bottom.\n */\nvar SymmetricTotem = /*#__PURE__*/function (_Shape) {\n  function SymmetricTotem() {\n    _classCallCheck(this, SymmetricTotem);\n    return _callSuper(this, SymmetricTotem, arguments);\n  }\n  _inherits(SymmetricTotem, _Shape);\n  return _createClass(SymmetricTotem, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var scale = 0.5;\n\n      // Get scaled parameters\n      var rectHeight = this.rectangleHeight * scale;\n      var rectWidth = this.rectangleWidth * scale;\n      var arcRadius = this.arcRadius * scale;\n      var cornerRadius = this.cornerRadius * scale;\n\n      // Calculate rectangle bounds\n      var rectX = -rectWidth / 2;\n      var rectY = -rectHeight / 2;\n\n      // Create path for the rounded rectangle\n      var path = [];\n      if (cornerRadius > 0) {\n        // Top-left corner\n        path.push(\"M \".concat(rectX + cornerRadius, \" \").concat(rectY));\n        // Top edge\n        path.push(\"L \".concat(rectX + rectWidth - cornerRadius, \" \").concat(rectY));\n        // Top-right corner\n        path.push(\"A \".concat(cornerRadius, \" \").concat(cornerRadius, \" 0 0 1 \").concat(rectX + rectWidth, \" \").concat(rectY + cornerRadius));\n        // Right edge\n        path.push(\"L \".concat(rectX + rectWidth, \" \").concat(rectY + rectHeight - cornerRadius));\n        // Bottom-right corner\n        path.push(\"A \".concat(cornerRadius, \" \").concat(cornerRadius, \" 0 0 1 \").concat(rectX + rectWidth - cornerRadius, \" \").concat(rectY + rectHeight));\n        // Bottom edge\n        path.push(\"L \".concat(rectX + cornerRadius, \" \").concat(rectY + rectHeight));\n        // Bottom-left corner\n        path.push(\"A \".concat(cornerRadius, \" \").concat(cornerRadius, \" 0 0 1 \").concat(rectX, \" \").concat(rectY + rectHeight - cornerRadius));\n        // Left edge\n        path.push(\"L \".concat(rectX, \" \").concat(rectY + cornerRadius));\n        // Top-left corner completion\n        path.push(\"A \".concat(cornerRadius, \" \").concat(cornerRadius, \" 0 0 1 \").concat(rectX + cornerRadius, \" \").concat(rectY));\n      } else {\n        // Simple rectangle without rounded corners\n        path.push(\"M \".concat(rectX, \" \").concat(rectY));\n        path.push(\"L \".concat(rectX + rectWidth, \" \").concat(rectY));\n        path.push(\"L \".concat(rectX + rectWidth, \" \").concat(rectY + rectHeight));\n        path.push(\"L \".concat(rectX, \" \").concat(rectY + rectHeight));\n        path.push('Z');\n      }\n\n      // Add top semicircle\n      path.push(\"M \".concat(-arcRadius, \" \").concat(rectY));\n      path.push(\"A \".concat(arcRadius, \" \").concat(arcRadius, \" 0 0 1 \").concat(arcRadius, \" \").concat(rectY));\n\n      // Add bottom semicircle\n      path.push(\"M \".concat(arcRadius, \" \").concat(rectY + rectHeight));\n      path.push(\"A \".concat(arcRadius, \" \").concat(arcRadius, \" 0 0 1 \").concat(-arcRadius, \" \").concat(rectY + rectHeight));\n      return \"<path \\n            d=\\\"\".concat(path.join(' '), \"\\\"\\n            fill=\\\"white\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(SymmetricTotem, \"parameters\", {\n  rectangleHeight: {\n    min: 20,\n    max: 200,\n    \"default\": 100\n  },\n  rectangleWidth: {\n    min: 20,\n    max: 200,\n    \"default\": 120\n  },\n  arcRadius: {\n    min: 10,\n    max: 100,\n    \"default\": 60\n  },\n  cornerRadius: {\n    min: 0,\n    max: 20,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SymmetricTotem);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/SymmetricTotem.js?");

/***/ }),

/***/ "./src/shapes/SymmetricalPattern.js":
/*!******************************************!*\
  !*** ./src/shapes/SymmetricalPattern.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a symmetrical pattern composed of connected line segments.\n * A random path is generated within one quadrant, and then mirrored (reflection)\n * or rotated to fill the other three quadrants, creating four-fold symmetry.\n */\nvar SymmetricalPattern = /*#__PURE__*/function (_Shape) {\n  function SymmetricalPattern() {\n    _classCallCheck(this, SymmetricalPattern);\n    return _callSuper(this, SymmetricalPattern, arguments);\n  }\n  _inherits(SymmetricalPattern, _Shape);\n  return _createClass(SymmetricalPattern, [{\n    key: \"generatePoints\",\n    value: function generatePoints() {\n      var points = [[1, 1]];\n      var grid = 2;\n      var maxEdges = Math.min(this.edgesMax, this.edgesAttempts);\n      for (var i = 0; i < maxEdges; i++) {\n        var lastPoint = points[points.length - 1];\n        var _lastPoint = _slicedToArray(lastPoint, 2),\n          lastX = _lastPoint[0],\n          lastY = _lastPoint[1];\n        var validMove = false;\n        var attempts = 0;\n        while (!validMove && attempts < this.edgesAttempts) {\n          var dx = Math.floor(this.random() * 3) - 1;\n          var dy = Math.floor(this.random() * 3) - 1;\n          var newX = lastX + dx;\n          var newY = lastY + dy;\n          if (newX >= 0 && newX <= grid && newY >= 0 && newY <= grid && !(dx === 0 && dy === 0)) {\n            points.push([newX, newY]);\n            validMove = true;\n          }\n          attempts++;\n        }\n        if (!validMove) break;\n      }\n      return points;\n    }\n  }, {\n    key: \"generateQuadrant\",\n    value: function generateQuadrant(points, size) {\n      var _this = this;\n      var step = size / 2;\n      var lines = points.map(function (point, i) {\n        if (i === 0) return '';\n        var prevPoint = points[i - 1];\n        if (!prevPoint || !point) return '';\n        var _prevPoint = _slicedToArray(prevPoint, 2),\n          x1 = _prevPoint[0],\n          y1 = _prevPoint[1];\n        var _point = _slicedToArray(point, 2),\n          x2 = _point[0],\n          y2 = _point[1];\n        return \"<line\\n                x1=\\\"\".concat(-size + x1 * step, \"\\\"\\n                y1=\\\"\").concat(-size + y1 * step, \"\\\"\\n                x2=\\\"\").concat(-size + x2 * step, \"\\\"\\n                y2=\\\"\").concat(-size + y2 * step, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(_this.strokeWidth, \"\\\"\\n                stroke-linecap=\\\"round\\\"\\n            />\");\n      });\n      return lines.join('');\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Reset RNG to ensure consistent results with the same seed\n      this.resetRNG();\n      var totalSize = 200;\n      var padding = totalSize * 0.2;\n      var usableSize = (totalSize - padding * 2) / 2;\n      var points = this.generatePoints();\n      var quadrant = this.generateQuadrant(points, usableSize);\n      if (this.symmetry === 'reflect') {\n        return \"\\n                <g>\\n                    \".concat(quadrant, \"\\n                    <g transform=\\\"scale(1, -1)\\\">\").concat(quadrant, \"</g>\\n                    <g transform=\\\"scale(-1, 1)\\\">\").concat(quadrant, \"</g>\\n                    <g transform=\\\"scale(-1, -1)\\\">\").concat(quadrant, \"</g>\\n                </g>\\n            \");\n      } else {\n        return \"\\n                <g>\\n                    \".concat(quadrant, \"\\n                    <g transform=\\\"rotate(90, 0, 0)\\\">\").concat(quadrant, \"</g>\\n                    <g transform=\\\"rotate(180, 0, 0)\\\">\").concat(quadrant, \"</g>\\n                    <g transform=\\\"rotate(270, 0, 0)\\\">\").concat(quadrant, \"</g>\\n                </g>\\n            \");\n      }\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(SymmetricalPattern, \"parameters\", {\n  edgesMax: {\n    min: 5,\n    max: 20,\n    \"default\": 12\n  },\n  edgesAttempts: {\n    min: 5,\n    max: 30,\n    \"default\": 25\n  },\n  strokeWidth: {\n    min: 1,\n    max: 5,\n    \"default\": 3\n  },\n  symmetry: {\n    options: ['reflect', 'rotate'],\n    \"default\": 'rotate'\n  }\n  // seed parameter is now inherited from Shape class\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SymmetricalPattern);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/SymmetricalPattern.js?");

/***/ }),

/***/ "./src/shapes/TechnoGrid.js":
/*!**********************************!*\
  !*** ./src/shapes/TechnoGrid.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a techno grid pattern composed of vertically segmented bars.\n * Each segment within a bar can shift left or right, creating dynamic patterns.\n */\nvar TechnoGrid = /*#__PURE__*/function (_Shape) {\n  function TechnoGrid() {\n    _classCallCheck(this, TechnoGrid);\n    return _callSuper(this, TechnoGrid, arguments);\n  }\n  _inherits(TechnoGrid, _Shape);\n  return _createClass(TechnoGrid, [{\n    key: \"generateShape\",\n    value:\n    /**\n     * Generates the SVG elements for the TechnoGrid shape.\n     * @param {object} params - Parameter values (accessed via `this`).\n     * @returns {string} SVG string containing multiple <rect> elements.\n     */\n    function generateShape(params) {\n      var gridWidth = this.gridWidth,\n        gridHeight = this.gridHeight,\n        numColumns = this.numColumns,\n        numRows = this.numRows,\n        splitOffset = this.splitOffset,\n        shiftFrequency = this.shiftFrequency,\n        gapProbability = this.gapProbability,\n        initialDirection = this.initialDirection;\n      var colWidth = gridWidth / numColumns;\n      var rowHeight = gridHeight / numRows;\n      var startX = -gridWidth / 2;\n      var startY = -gridHeight / 2;\n      var svgString = '';\n      for (var i = 0; i < numColumns; i++) {\n        var currentOffsetSign = void 0;\n        // Determine initial direction for this column\n        switch (initialDirection) {\n          case 'Random':\n            currentOffsetSign = this.random() > 0.5 ? 1 : -1;\n            break;\n          case 'Left':\n            currentOffsetSign = -1;\n            break;\n          case 'Right':\n            currentOffsetSign = 1;\n            break;\n          case 'Alternating':\n          default:\n            currentOffsetSign = i % 2 === 0 ? -1 : 1;\n            break;\n        }\n        var columnBaseX = startX + i * colWidth;\n        var segmentWidth = colWidth / 2; // Segments are half the column width\n\n        for (var j = 0; j < numRows; j++) {\n          // Chance to flip the offset direction\n          if (this.random() < shiftFrequency) {\n            currentOffsetSign *= -1;\n          }\n\n          // Chance to leave a gap\n          if (this.random() < gapProbability) {\n            continue; // Skip this segment\n          }\n\n          // Calculate segment position and size\n          var segmentY = startY + j * rowHeight;\n\n          // Calculate the horizontal offset from the column center\n          // Offset range is [-colWidth/4 * splitOffset, +colWidth/4 * splitOffset]\n          var actualOffset = colWidth / 4 * splitOffset * currentOffsetSign;\n\n          // Calculate segment X position: start at column center, apply offset, then shift left by half segment width\n          var segmentX = columnBaseX + colWidth / 2 + actualOffset - segmentWidth / 2;\n\n          // Ensure segment stays visually within its conceptual column boundaries (optional, for clarity)\n          // const clampedSegmentX = Math.max(columnBaseX, Math.min(segmentX, columnBaseX + colWidth - segmentWidth));\n\n          // Use precise values for SVG\n          var xPos = segmentX.toFixed(3);\n          var yPos = segmentY.toFixed(3);\n          var w = segmentWidth.toFixed(3);\n          var h = rowHeight.toFixed(3);\n          svgString += \"<rect x=\\\"\".concat(xPos, \"\\\" y=\\\"\").concat(yPos, \"\\\" width=\\\"\").concat(w, \"\\\" height=\\\"\").concat(h, \"\\\" fill=\\\"white\\\" />\\n\");\n        }\n      }\n\n      // Wrap in a group if needed, but returning raw rects is fine\n      return svgString;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(TechnoGrid, \"parameters\", {\n  gridWidth: {\n    type: 'number',\n    min: 20,\n    max: 190,\n    step: 1,\n    \"default\": 180,\n    label: 'Grid Width'\n  },\n  gridHeight: {\n    type: 'number',\n    min: 20,\n    max: 190,\n    step: 1,\n    \"default\": 160,\n    label: 'Grid Height'\n  },\n  numColumns: {\n    type: 'number',\n    min: 2,\n    max: 30,\n    step: 1,\n    \"default\": 8,\n    label: 'Columns'\n  },\n  numRows: {\n    type: 'number',\n    min: 2,\n    max: 40,\n    step: 1,\n    \"default\": 12,\n    label: 'Rows (Segments)'\n  },\n  splitOffset: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    step: 0.05,\n    \"default\": 1,\n    label: 'Split Offset' // 0=centered, 1=touch edge\n  },\n  shiftFrequency: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    step: 0.05,\n    \"default\": 0.1,\n    label: 'Shift Frequency' // Chance per row to flip side\n  },\n  gapProbability: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    step: 0.05,\n    \"default\": 0.1,\n    label: 'Gap Probability' // Chance a segment is missing\n  },\n  initialDirection: {\n    type: 'enum',\n    options: ['Alternating', 'Random', 'Left', 'Right'],\n    \"default\": 'Alternating',\n    label: 'Initial Shift'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TechnoGrid);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/TechnoGrid.js?");

/***/ }),

/***/ "./src/shapes/TerrainWireframe.js":
/*!****************************************!*\
  !*** ./src/shapes/TerrainWireframe.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates an isometric, wireframe terrain mesh based on a noise function.\n * The terrain surface is triangulated, and vertical lines drop from each grid point.\n * Uses the instance seed for deterministic noise generation.\n */\nvar TerrainWireframe = /*#__PURE__*/function (_Shape) {\n  function TerrainWireframe() {\n    _classCallCheck(this, TerrainWireframe);\n    return _callSuper(this, TerrainWireframe, arguments);\n  }\n  _inherits(TerrainWireframe, _Shape);\n  return _createClass(TerrainWireframe, [{\n    key: \"_noise\",\n    value:\n    // Note: No constructor needed here, base class handles parameter assignment including 'seed'.\n\n    // Simple deterministic noise function using sine waves and the instance's seed\n    function _noise(x, y) {\n      var scale = this.noiseScale * 5;\n      var total = 0;\n      var frequency = scale;\n      var currentAmplitude = 1;\n      var maxValue = 0;\n\n      // Use this.seed provided by the base class\n      var seedValue = this.seed || 42; // Fallback just in case, though base class should provide it\n\n      for (var i = 0; i < 3; i++) {\n        var angleX = frequency * x / this.gridSize + seedValue * (i + 1) * 10.13;\n        var angleY = frequency * y / this.gridSize + seedValue * (i + 1) * 20.27;\n        var nX = Math.floor(x * frequency * 0.1) + seedValue * (i + 1) * 10;\n        var nY = Math.floor(y * frequency * 0.1) + seedValue * (i + 1) * 20;\n        var n = nX * 12.9898 + nY * 78.233 + seedValue * 123.45 * (i + 1);\n        var stableRand = Math.sin(n) * 43758.5453;\n        var randVal = stableRand - Math.floor(stableRand);\n        total += (Math.sin(angleX) + Math.cos(angleY) + (randVal - 0.5) * 1.5) * currentAmplitude;\n        maxValue += currentAmplitude * 1.75;\n        currentAmplitude *= 0.5;\n        frequency *= 2;\n      }\n      return maxValue === 0 ? 0 : total / maxValue;\n    }\n  }, {\n    key: \"getHeight\",\n    value: function getHeight(ix, iy) {\n      // Access parameters via 'this'\n      return this._noise(ix, iy) * this.amplitude;\n    }\n  }, {\n    key: \"project\",\n    value: function project(ix, iy) {\n      var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      // Access parameters via 'this'\n      var scaleFactor = 115 / Math.max(1, this.gridSize);\n      var worldX = (ix - this.gridSize / 2) * scaleFactor;\n      var worldY = (iy - this.gridSize / 2) * scaleFactor;\n      var cos30 = 0.866;\n      var sin30 = 0.5;\n      var screenX = (worldX - worldY) * cos30;\n      var screenY = (worldX + worldY) * sin30 - z;\n      return {\n        x: screenX,\n        y: screenY\n      };\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Access parameters via 'this'\n      var gridSize = Math.max(1, Math.floor(this.gridSize));\n      var amplitude = this.amplitude;\n      var depthFactor = this.depth;\n      var pathData = '';\n      var strokeWidth = 0.75;\n      var heights = [];\n      var minHeight = Infinity;\n      var maxHeight = -Infinity;\n      for (var iy = 0; iy <= gridSize; iy++) {\n        heights[iy] = [];\n        for (var ix = 0; ix <= gridSize; ix++) {\n          // Call getHeight which uses this.amplitude and this._noise (using this.seed)\n          var h = this.getHeight(ix, iy);\n          heights[iy][ix] = h;\n          if (h < minHeight) minHeight = h;\n          if (h > maxHeight) maxHeight = h;\n        }\n      }\n\n      // Base level Z depends on min height, amplitude and depthFactor\n      var baseLevelZ = minHeight - depthFactor * amplitude;\n      var projectedPoints = [];\n      var minY = Infinity,\n        maxY = -Infinity;\n      for (var _iy = 0; _iy <= gridSize; _iy++) {\n        projectedPoints[_iy] = [];\n        for (var _ix = 0; _ix <= gridSize; _ix++) {\n          // Call project which uses this.gridSize\n          var p = this.project(_ix, _iy, heights[_iy][_ix]);\n          var b = this.project(_ix, _iy, baseLevelZ);\n          projectedPoints[_iy][_ix] = {\n            P: p,\n            B: b\n          };\n          if (p.y < minY) minY = p.y;\n          if (p.y > maxY) maxY = p.y;\n          // Only include base points in bounding box calculation if depth is positive\n          if (depthFactor > 0) {\n            if (b.y < minY) minY = b.y;\n            if (b.y > maxY) maxY = b.y;\n          }\n        }\n      }\n      var offsetY = -(minY + maxY) / 2; // Calculate centering offset\n\n      // Helper to add lines, applying offset\n      var addLine = function addLine(p1, p2) {\n        if (Math.abs(p1.x - p2.x) > 1e-3 || Math.abs(p1.y - p2.y) > 1e-3) {\n          pathData += \"M \".concat(p1.x.toFixed(2), \",\").concat((p1.y + offsetY).toFixed(2), \" L \").concat(p2.x.toFixed(2), \",\").concat((p2.y + offsetY).toFixed(2), \" \");\n        }\n      };\n\n      // Build Path Data: Top surface grid\n      for (var _iy2 = 0; _iy2 < gridSize; _iy2++) {\n        for (var _ix2 = 0; _ix2 < gridSize; _ix2++) {\n          var p00 = projectedPoints[_iy2][_ix2].P;\n          var p10 = projectedPoints[_iy2][_ix2 + 1].P;\n          var p01 = projectedPoints[_iy2 + 1][_ix2].P;\n          var p11 = projectedPoints[_iy2 + 1][_ix2 + 1].P;\n          addLine(p00, p10);\n          addLine(p00, p01);\n          addLine(p10, p01); // Diagonal\n\n          if (_ix2 === gridSize - 1) addLine(p10, p11);\n          if (_iy2 === gridSize - 1) addLine(p01, p11);\n        }\n      }\n\n      // Build Path Data: Vertical lines if depth > 0\n      if (depthFactor > 0) {\n        for (var _iy3 = 0; _iy3 <= gridSize; _iy3++) {\n          for (var _ix3 = 0; _ix3 <= gridSize; _ix3++) {\n            var current = projectedPoints[_iy3][_ix3];\n            addLine(current.P, current.B);\n          }\n        }\n      }\n      return \"<path d=\\\"\".concat(pathData.trim(), \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(strokeWidth, \"\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\" />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(TerrainWireframe, \"parameters\", {\n  gridSize: {\n    type: 'number',\n    min: 4,\n    max: 32,\n    step: 1,\n    \"default\": 28,\n    label: 'Grid Density'\n  },\n  noiseScale: {\n    type: 'number',\n    min: 0.05,\n    max: 1.5,\n    step: 0.05,\n    \"default\": 0.3,\n    label: 'Feature Scale'\n  },\n  amplitude: {\n    type: 'number',\n    min: 0,\n    max: 80,\n    step: 1,\n    \"default\": 40,\n    label: 'Height Variation'\n  },\n  depth: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    step: 0.1,\n    \"default\": 1,\n    label: 'Vertical Extension'\n  }\n  // Inherits 'seed' parameter from the base Shape class implicitly\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TerrainWireframe);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/TerrainWireframe.js?");

/***/ }),

/***/ "./src/shapes/ThreadedShape.js":
/*!*************************************!*\
  !*** ./src/shapes/ThreadedShape.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a pattern resembling thread wrapped around pins (circles) arranged\n * in a grid, using tangent lines and arcs.\n */\nvar ThreadedShape = /*#__PURE__*/function (_Shape) {\n  function ThreadedShape() {\n    _classCallCheck(this, ThreadedShape);\n    return _callSuper(this, ThreadedShape, arguments);\n  }\n  _inherits(ThreadedShape, _Shape);\n  return _createClass(ThreadedShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Create grid of circles\n      var grid = this.createCircleGrid();\n\n      // Default fallback path in case of errors\n      var finalPath = 'M 0,0 L 0,0 Z';\n      try {\n        // Select pins from the grid (subset of circles to be used as wrapping points)\n        var pins = this.selectPins(grid);\n\n        // Set pin order - important for natural thread flow\n        var orderedPins = this.optimizePinSequence(pins);\n\n        // Calculate pin orientation (clockwise/counterclockwise)\n        var orientations = this.determinePinOrientations(orderedPins);\n\n        // Generate the tangent paths between pins\n        var tangentPaths = this.calculateTangentPaths(orderedPins, orientations);\n\n        // Create the final thread path\n        finalPath = this.generateThreadPath(orderedPins, tangentPaths);\n      } catch (error) {\n        console.error('Error generating threaded shape:', error);\n      }\n\n      // Create SVG elements\n      var svg = '';\n\n      // Add the thread path first (beneath the pins)\n      svg += \"<path d=\\\"\".concat(finalPath, \"\\\" fill=\\\"white\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(this.strokeWidth, \"\\\" />\");\n\n      // Add the grid circles if showGrid is true\n      if (this.showGrid) {\n        grid.forEach(function (circle) {\n          svg += \"<circle cx=\\\"\".concat(circle.x, \"\\\" cy=\\\"\").concat(circle.y, \"\\\" r=\\\"\").concat(circle.radius, \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"1\\\" />\");\n        });\n      }\n      return svg;\n    }\n  }, {\n    key: \"createCircleGrid\",\n    value: function createCircleGrid() {\n      var grid = [];\n      var rows = Math.floor(this.gridRows);\n      var cols = Math.floor(this.gridCols);\n\n      // Calculate spacing to distribute circles evenly in the viewport\n      var spacing = 200 / Math.max(rows, cols);\n      var offsetX = -((cols - 1) * spacing) / 2;\n      var offsetY = -((rows - 1) * spacing) / 2;\n\n      // Create grid of circles\n      for (var row = 0; row < rows; row++) {\n        for (var col = 0; col < cols; col++) {\n          grid.push({\n            x: offsetX + col * spacing,\n            y: offsetY + row * spacing,\n            radius: this.circleRadius,\n            row: row,\n            col: col\n          });\n        }\n      }\n      return grid;\n    }\n  }, {\n    key: \"selectPins\",\n    value: function selectPins(grid) {\n      // For a better shape, we might want to select pins to create a more interesting boundary\n      // This is where more sophisticated pin selection algorithms could be implemented\n      var pinCount = Math.min(Math.floor(this.pinCount), grid.length);\n\n      // For now, let's select random pins, but ensure we get a mix from different areas\n      var selectedPins = [];\n      var availablePins = _toConsumableArray(grid);\n\n      // Create a uniform random distribution by shuffling\n      for (var i = availablePins.length - 1; i > 0; i--) {\n        var j = Math.floor(this.random() * (i + 1));\n        var _ref = [availablePins[j], availablePins[i]];\n        availablePins[i] = _ref[0];\n        availablePins[j] = _ref[1];\n      }\n\n      // Take the first pinCount pins from the shuffled array\n      for (var _i = 0; _i < pinCount; _i++) {\n        if (availablePins.length > 0) {\n          var pin = availablePins.pop();\n          selectedPins.push(pin);\n        }\n      }\n      return selectedPins;\n    }\n  }, {\n    key: \"optimizePinSequence\",\n    value: function optimizePinSequence(pins) {\n      if (pins.length <= 3) return pins;\n\n      // For better winding patterns, we want to order pins in a way that creates\n      // a roughly convex hull or boundary around the shape\n      // This is a simplified approach - more advanced algorithms could be used\n\n      // Start with the leftmost pin\n      var leftmostPin = pins.reduce(function (current, pin) {\n        return pin.x < current.x ? pin : current;\n      });\n\n      // Order remaining pins by angle from the center point\n      var center = {\n        x: pins.reduce(function (sum, pin) {\n          return sum + pin.x;\n        }, 0) / pins.length,\n        y: pins.reduce(function (sum, pin) {\n          return sum + pin.y;\n        }, 0) / pins.length\n      };\n\n      // Sort pins by angle around the center\n      var orderedPins = _toConsumableArray(pins).sort(function (a, b) {\n        var angleA = Math.atan2(a.y - center.y, a.x - center.x);\n        var angleB = Math.atan2(b.y - center.y, b.x - center.x);\n        return angleA - angleB;\n      });\n      return orderedPins;\n    }\n  }, {\n    key: \"determinePinOrientations\",\n    value: function determinePinOrientations(pins) {\n      // For each pin, determine if thread should go clockwise or counterclockwise\n      var orientations = [];\n      for (var i = 0; i < pins.length; i++) {\n        var prev = pins[(i - 1 + pins.length) % pins.length];\n        var current = pins[i];\n        var next = pins[(i + 1) % pins.length];\n\n        // Calculate determinant to determine orientation\n        var det = (current.x - prev.x) * (next.y - current.y) - (current.y - prev.y) * (next.x - current.x);\n\n        // In browser coordinates (y points down), positive determinant means clockwise\n        orientations.push(det > 0 ? 'clockwise' : 'counterclockwise');\n      }\n      return orientations;\n    }\n  }, {\n    key: \"calculateTangentPaths\",\n    value: function calculateTangentPaths(pins, orientations) {\n      var tangentPaths = [];\n      for (var i = 0; i < pins.length; i++) {\n        var currentPin = pins[i];\n        var nextPin = pins[(i + 1) % pins.length];\n        var currentOrientation = orientations[i];\n        var nextOrientation = orientations[(i + 1) % pins.length];\n\n        // Calculate the tangent points between these pins\n        var tangentPoints = this.calculateTangentPoints(currentPin, nextPin, currentOrientation, nextOrientation);\n\n        // Create the path segment for this tangent\n        tangentPaths.push({\n          startPin: currentPin,\n          endPin: nextPin,\n          startPoint: tangentPoints.start,\n          endPoint: tangentPoints.end\n        });\n      }\n      return tangentPaths;\n    }\n  }, {\n    key: \"calculateTangentPoints\",\n    value: function calculateTangentPoints(pin1, pin2, orientation1, orientation2) {\n      var c1 = {\n        x: pin1.x,\n        y: pin1.y\n      };\n      var c2 = {\n        x: pin2.x,\n        y: pin2.y\n      };\n      var r1 = pin1.radius;\n      var r2 = pin2.radius;\n\n      // Calculate vector from c1 to c2\n      var dx = c2.x - c1.x;\n      var dy = c2.y - c1.y;\n      var distance = Math.sqrt(dx * dx + dy * dy);\n\n      // If circles are too close or overlapping, adjust the calculation\n      if (distance < r1 + r2) {\n        // Simple fallback for overlapping circles\n        var angle = Math.atan2(dy, dx);\n        return {\n          start: {\n            x: c1.x + Math.cos(angle) * r1,\n            y: c1.y + Math.sin(angle) * r1\n          },\n          end: {\n            x: c2.x - Math.cos(angle) * r2,\n            y: c2.y - Math.sin(angle) * r2\n          }\n        };\n      }\n\n      // Normalized direction vector\n      var ux = dx / distance;\n      var uy = dy / distance;\n\n      // Perpendicular vectors (90 rotations of the unit vector)\n      var perpCW = {\n        x: uy,\n        y: -ux\n      }; // Clockwise rotation\n      var perpCCW = {\n        x: -uy,\n        y: ux\n      }; // Counter-clockwise rotation\n\n      // Decide which tangent to use based on orientations\n      var startPerp, endPerp;\n\n      // If both pins have the same orientation, use the same tangent type\n      if (orientation1 === orientation2) {\n        startPerp = orientation1 === 'clockwise' ? perpCW : perpCCW;\n        endPerp = orientation2 === 'clockwise' ? perpCW : perpCCW;\n      } else {\n        // If orientations differ, we need to decide which tangent to use\n        // This is a simplification - a more sophisticated algorithm could make better choices\n        startPerp = orientation1 === 'clockwise' ? perpCW : perpCCW;\n        endPerp = orientation2 === 'clockwise' ? perpCW : perpCCW;\n      }\n\n      // Calculate tangent points\n      return {\n        start: {\n          x: c1.x + startPerp.x * r1,\n          y: c1.y + startPerp.y * r1\n        },\n        end: {\n          x: c2.x + endPerp.x * r2,\n          y: c2.y + endPerp.y * r2\n        }\n      };\n    }\n  }, {\n    key: \"generateThreadPath\",\n    value: function generateThreadPath(pins, tangentPaths) {\n      if (pins.length < 3 || tangentPaths.length < 3) {\n        return 'M 0,0 L 0,0 Z'; // Empty or invalid path\n      }\n\n      // Build the path data string\n      var pathData = '';\n\n      // Start at the first tangent point\n      var firstTangent = tangentPaths[0];\n      pathData = \"M \".concat(firstTangent.startPoint.x, \",\").concat(firstTangent.startPoint.y);\n\n      // For each pin pair, add the tangent line and the arc around the end pin\n      for (var i = 0; i < tangentPaths.length; i++) {\n        var currentTangent = tangentPaths[i];\n        var nextTangent = tangentPaths[(i + 1) % tangentPaths.length];\n\n        // Add tangent line from start to end point\n        pathData += \" L \".concat(currentTangent.endPoint.x, \",\").concat(currentTangent.endPoint.y);\n\n        // Add arc around the end pin to the start of the next tangent\n        pathData += this.createArcSegment(currentTangent.endPoint, nextTangent.startPoint, currentTangent.endPin);\n      }\n\n      // Close the path\n      pathData += ' Z';\n      return pathData;\n    }\n  }, {\n    key: \"createArcSegment\",\n    value: function createArcSegment(from, to, pin) {\n      // Calculate the center of the pin\n      var center = {\n        x: pin.x,\n        y: pin.y\n      };\n      var radius = pin.radius;\n\n      // Calculate angles from center to points\n      var angleFrom = Math.atan2(from.y - center.y, from.x - center.x);\n      var angleTo = Math.atan2(to.y - center.y, to.x - center.x);\n\n      // Calculate the angle difference\n      var angleDiff = angleTo - angleFrom;\n\n      // Normalize angle to range [-PI, PI]\n      if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;\n      if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;\n\n      // Determine flags for SVG arc command\n      // largeArcFlag: 0 for arc <= 180 degrees, 1 for arc > 180 degrees\n      // sweepFlag: 0 for counter-clockwise, 1 for clockwise\n      var largeArcFlag = Math.abs(angleDiff) > Math.PI ? 1 : 0;\n      var sweepFlag = angleDiff > 0 ? 1 : 0; // In SVG, positive angle is clockwise\n\n      // Create arc command\n      return \" A \".concat(radius, \" \").concat(radius, \" 0 \").concat(largeArcFlag, \" \").concat(sweepFlag, \" \").concat(to.x, \" \").concat(to.y);\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(ThreadedShape, \"parameters\", {\n  gridRows: {\n    min: 2,\n    max: 6,\n    \"default\": 4\n  },\n  gridCols: {\n    min: 2,\n    max: 6,\n    \"default\": 4\n  },\n  circleRadius: {\n    min: 0,\n    max: 10,\n    \"default\": 10\n  },\n  pinCount: {\n    min: 3,\n    max: 24,\n    \"default\": 18\n  },\n  threadWidth: {\n    min: 1,\n    max: 20,\n    \"default\": 8\n  },\n  showGrid: {\n    \"default\": false\n  },\n  strokeWidth: {\n    min: 0,\n    max: 5,\n    \"default\": 1\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ThreadedShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/ThreadedShape.js?");

/***/ }),

/***/ "./src/shapes/Tornado.js":
/*!*******************************!*\
  !*** ./src/shapes/Tornado.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a shape resembling a stylized tornado or vortex, wider at the\n * bottom and narrowing towards the top with twists.\n */\nvar Tornado = /*#__PURE__*/function (_Shape) {\n  function Tornado() {\n    _classCallCheck(this, Tornado);\n    return _callSuper(this, Tornado, arguments);\n  }\n  _inherits(Tornado, _Shape);\n  return _createClass(Tornado, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var scale = 0.9;\n\n      // Scale parameters\n      var height = this.height * scale;\n      var topWidth = this.topWidth * scale;\n      var bottomWidth = this.bottomWidth * scale;\n      var turbulence = this.turbulence * scale;\n\n      // Generate points with higher resolution for smoother curves\n      var controlPoints = this.segments * 4;\n      var leftPoints = [];\n      var rightPoints = [];\n\n      // Start with flat top edge\n      var topY = -height / 2;\n      leftPoints.push({\n        x: -topWidth / 2,\n        y: topY\n      });\n      rightPoints.push({\n        x: topWidth / 2,\n        y: topY\n      });\n\n      // Generate middle points with turbulence\n      for (var i = 1; i < controlPoints; i++) {\n        var progress = i / controlPoints;\n\n        // Smooth width interpolation using cosine\n        var widthProgress = (1 - Math.cos(progress * Math.PI)) / 2;\n        var width = topWidth + (bottomWidth - topWidth) * widthProgress;\n\n        // Create smooth wave effect using multiple sine waves\n        var baseWave = Math.sin(progress * this.twistCount * 2 * Math.PI);\n        var secondaryWave = Math.sin(progress * (this.twistCount + 1) * 2 * Math.PI) * 0.3;\n        var combinedWave = (baseWave + secondaryWave) * turbulence;\n\n        // Gradually reduce displacement near endpoints\n        var endpointDamping = Math.sin(progress * Math.PI);\n        var displacement = combinedWave * endpointDamping;\n\n        // Calculate points with smooth displacement\n        var y = -height / 2 + height * progress;\n        var leftX = -width / 2 + displacement;\n        var rightX = width / 2 + displacement;\n        leftPoints.push({\n          x: leftX,\n          y: y\n        });\n        rightPoints.push({\n          x: rightX,\n          y: y\n        });\n      }\n\n      // End with flat bottom edge\n      var bottomY = height / 2;\n      leftPoints.push({\n        x: -bottomWidth / 2,\n        y: bottomY\n      });\n      rightPoints.push({\n        x: bottomWidth / 2,\n        y: bottomY\n      });\n\n      // Build SVG path\n      var pathData = [];\n\n      // Start path at first left point\n      pathData.push(\"M \".concat(leftPoints[0].x, \" \").concat(leftPoints[0].y));\n\n      // Draw left side with quadratic curves\n      for (var _i = 1; _i < leftPoints.length - 2; _i++) {\n        var p0 = leftPoints[_i];\n        var p1 = leftPoints[_i + 1];\n        var midPoint = {\n          x: (p0.x + p1.x) / 2,\n          y: (p0.y + p1.y) / 2\n        };\n        pathData.push(\"Q \".concat(p0.x, \" \").concat(p0.y, \" \").concat(midPoint.x, \" \").concat(midPoint.y));\n      }\n\n      // Connect to bottom edge\n      pathData.push(\"L \".concat(leftPoints[leftPoints.length - 1].x, \" \").concat(bottomY));\n      pathData.push(\"L \".concat(rightPoints[rightPoints.length - 1].x, \" \").concat(bottomY));\n\n      // Draw right side with quadratic curves\n      for (var _i2 = rightPoints.length - 2; _i2 > 1; _i2--) {\n        var _p = rightPoints[_i2];\n        var _p2 = rightPoints[_i2 - 1];\n        var _midPoint = {\n          x: (_p.x + _p2.x) / 2,\n          y: (_p.y + _p2.y) / 2\n        };\n        pathData.push(\"Q \".concat(_p.x, \" \").concat(_p.y, \" \").concat(_midPoint.x, \" \").concat(_midPoint.y));\n      }\n\n      // Connect back to top edge and close\n      pathData.push(\"L \".concat(rightPoints[0].x, \" \").concat(topY));\n      pathData.push(\"L \".concat(leftPoints[0].x, \" \").concat(topY));\n      pathData.push('Z');\n      return \"<path \\n            d=\\\"\".concat(pathData.join(' '), \"\\\"\\n            fill=\\\"white\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(Tornado, \"parameters\", {\n  height: {\n    min: 100,\n    max: 300,\n    \"default\": 200\n  },\n  topWidth: {\n    min: 20,\n    max: 100,\n    \"default\": 40\n  },\n  bottomWidth: {\n    min: 50,\n    max: 150,\n    \"default\": 100\n  },\n  twistCount: {\n    min: 1,\n    max: 6,\n    \"default\": 3\n  },\n  segments: {\n    min: 8,\n    max: 24,\n    \"default\": 16\n  },\n  turbulence: {\n    min: 0,\n    max: 30,\n    \"default\": 15\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Tornado);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/Tornado.js?");

/***/ }),

/***/ "./src/shapes/TorusShape.js":
/*!**********************************!*\
  !*** ./src/shapes/TorusShape.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a 3D wireframe representation of a torus (donut shape) with\n * adjustable segments, rings, and rotation.\n */\nvar TorusShape = /*#__PURE__*/function (_Shape) {\n  function TorusShape() {\n    _classCallCheck(this, TorusShape);\n    return _callSuper(this, TorusShape, arguments);\n  }\n  _inherits(TorusShape, _Shape);\n  return _createClass(TorusShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Convert rotation values from degrees to radians\n      var rotX = this.rotationX * Math.PI / 180;\n      var rotY = this.rotationY * Math.PI / 180;\n\n      // Ensure parameters are valid integers to prevent interpolation issues\n      var segments = Math.max(3, Math.round(this.segments));\n      var rings = Math.max(3, Math.round(this.rings));\n      var layers = Math.max(1, Math.round(this.layers));\n      var renderMode = Math.round(this.renderMode) % 2; // Ensure 0 or 1\n\n      // Store all lines for depth sorting\n      var lines = [];\n\n      // Calculate all layers\n      for (var layer = 0; layer < layers; layer++) {\n        var currentRadius = this.minorRadius - layer * this.layerSpacing;\n        if (currentRadius <= 0) continue;\n\n        // Generate torus points for current layer\n        var points = [];\n\n        // Generate points for each segment around major radius\n        for (var i = 0; i <= segments; i++) {\n          var theta = i * 2 * Math.PI / segments;\n          var cosTheta = Math.cos(theta);\n          var sinTheta = Math.sin(theta);\n\n          // Generate points for each ring around minor radius\n          for (var j = 0; j <= rings; j++) {\n            var phi = j * 2 * Math.PI / rings;\n            var cosPhi = Math.cos(phi);\n            var sinPhi = Math.sin(phi);\n\n            // Calculate 3D coordinates of point on torus\n            var x = (this.majorRadius + currentRadius * cosPhi) * cosTheta;\n            var y = (this.majorRadius + currentRadius * cosPhi) * sinTheta;\n            var z = currentRadius * sinPhi;\n\n            // Store the 3D point\n            points.push({\n              x: x,\n              y: y,\n              z: z\n            });\n          }\n        }\n\n        // Create the wireframe lines based on the render mode\n        for (var _i = 0; _i < segments; _i++) {\n          for (var _j = 0; _j < rings; _j++) {\n            // Calculate indices with bounds checking\n            var ringStep = rings + 1;\n            var p1Index = _i * ringStep + _j;\n            var p2Index = _i * ringStep + (_j + 1);\n            var p3Index = (_i + 1) % segments * ringStep + _j;\n\n            // Safely get points (with bounds checking)\n            var p1 = points[p1Index] || {\n              x: 0,\n              y: 0,\n              z: 0\n            };\n            var p2 = points[p2Index] || {\n              x: 0,\n              y: 0,\n              z: 0\n            };\n            var p3 = points[p3Index] || {\n              x: 0,\n              y: 0,\n              z: 0\n            };\n            if (renderMode === 0) {\n              // Segments only (around major radius)\n              lines.push(this.createLine(p1, p3, rotX, rotY));\n            } else {\n              // Rings only (around minor radius)\n              lines.push(this.createLine(p1, p2, rotX, rotY));\n            }\n          }\n        }\n      }\n\n      // Sort lines by z-depth for proper rendering (back to front)\n      lines.sort(function (a, b) {\n        return b.z - a.z;\n      });\n\n      // Generate SVG elements from sorted lines\n      var elements = [];\n      for (var _i2 = 0, _lines = lines; _i2 < _lines.length; _i2++) {\n        var line = _lines[_i2];\n        elements.push(\"<line \\n        x1=\\\"\".concat(line.x1, \"\\\" \\n        y1=\\\"\").concat(line.y1, \"\\\" \\n        x2=\\\"\").concat(line.x2, \"\\\" \\n        y2=\\\"\").concat(line.y2, \"\\\" \\n        stroke=\\\"white\\\" \\n        stroke-width=\\\"\").concat(this.thickness, \"\\\" \\n      />\"));\n      }\n      return elements.join('');\n    }\n  }, {\n    key: \"createLine\",\n    value: function createLine(p1, p2, rotX, rotY) {\n      // Apply 3D rotation to both points\n      var p1Rotated = this.rotate3D(p1.x, p1.y, p1.z, rotX, rotY);\n      var p2Rotated = this.rotate3D(p2.x, p2.y, p2.z, rotX, rotY);\n\n      // Calculate average z for depth sorting\n      var avgZ = (p1Rotated.z + p2Rotated.z) / 2;\n      return {\n        x1: p1Rotated.x,\n        y1: p1Rotated.y,\n        x2: p2Rotated.x,\n        y2: p2Rotated.y,\n        z: avgZ\n      };\n    }\n  }, {\n    key: \"rotate3D\",\n    value: function rotate3D(x, y, z, rotX, rotY) {\n      // Step 1: Rotate around X axis\n      var y1 = y * Math.cos(rotX) - z * Math.sin(rotX);\n      var z1 = y * Math.sin(rotX) + z * Math.cos(rotX);\n\n      // Step 2: Rotate around Y axis\n      var x2 = x * Math.cos(rotY) + z1 * Math.sin(rotY);\n      var z2 = -x * Math.sin(rotY) + z1 * Math.cos(rotY);\n      return {\n        x: x2,\n        y: y1,\n        z: z2\n      };\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(TorusShape, \"parameters\", {\n  majorRadius: {\n    min: 50,\n    max: 50,\n    \"default\": 50\n  },\n  minorRadius: {\n    min: 10,\n    max: 50,\n    \"default\": 50\n  },\n  segments: {\n    min: 3,\n    max: 16,\n    \"default\": 16\n  },\n  rings: {\n    min: 3,\n    max: 64,\n    \"default\": 32\n  },\n  layers: {\n    min: 1,\n    max: 10,\n    \"default\": 1\n  },\n  layerSpacing: {\n    min: 1,\n    max: 20,\n    \"default\": 0\n  },\n  renderMode: {\n    min: 0,\n    max: 1,\n    \"default\": 1\n  },\n  // 0 = segments only, 1 = rings only\n  rotationX: {\n    min: -180,\n    max: 180,\n    \"default\": 0\n  },\n  rotationY: {\n    min: -180,\n    max: 180,\n    \"default\": 45\n  },\n  thickness: {\n    min: 0.5,\n    max: 5,\n    \"default\": 2\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TorusShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/TorusShape.js?");

/***/ }),

/***/ "./src/shapes/TotemSymbol.js":
/*!***********************************!*\
  !*** ./src/shapes/TotemSymbol.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generative symmetrical totem like symbol shape with geometric elements.\n */\nvar TotemSymbol = /*#__PURE__*/function (_Shape) {\n  function TotemSymbol() {\n    _classCallCheck(this, TotemSymbol);\n    return _callSuper(this, TotemSymbol, arguments);\n  }\n  _inherits(TotemSymbol, _Shape);\n  return _createClass(TotemSymbol, [{\n    key: \"_generateOuterPath\",\n    value:\n    /**\n     * Generates the outer jagged ellipse path (clockwise winding).\n     * @returns {string} SVG path data string for the outer boundary.\n     */\n    function _generateOuterPath() {\n      var a = this.outerWidth / 2; // Semi-major axis (width)\n      var b = this.outerHeight / 2; // Semi-minor axis (height)\n      var depth = this.spikeDepth;\n      // Ensure inner radius dimensions are positive\n      var a_inner = Math.max(1, a - depth);\n      var b_inner = Math.max(1, b - depth);\n      var numPoints = this.numSpikes * 2; // Total points for peaks and valleys\n      var d = \"\";\n      for (var i = 0; i < numPoints; i++) {\n        var angle = i * Math.PI / this.numSpikes; // Angle progresses around the ellipse\n        var cosA = Math.cos(angle);\n        var sinA = Math.sin(angle);\n        var x = void 0,\n          y = void 0;\n        if (i % 2 === 0) {\n          // Peak point (on the outer ellipse)\n          x = a * cosA;\n          y = b * sinA;\n        } else {\n          // Valley point (on the inner ellipse)\n          x = a_inner * cosA;\n          y = b_inner * sinA;\n        }\n\n        // Format point coordinates\n        var cmd = i === 0 ? 'M' : 'L';\n        d += \" \".concat(cmd, \" \").concat(x.toFixed(3), \" \").concat(y.toFixed(3));\n      }\n      d += \" Z\"; // Close the path\n      return d.trim(); // Return the path data string\n    }\n\n    /**\n     * Generates the path data for a rounded rectangle hole (counter-clockwise winding).\n     * @param {number} cx - Center X coordinate.\n     * @param {number} cy - Center Y coordinate.\n     * @param {number} w - Width of the rectangle.\n     * @param {number} h - Height of the rectangle.\n     * @param {number} r - Corner rounding radius.\n     * @returns {string} SVG path data string for the rounded rectangle hole.\n     */\n  }, {\n    key: \"_createRoundedRectHole\",\n    value: function _createRoundedRectHole(cx, cy, w, h, r) {\n      // Adjust radius to not exceed half width/height\n      r = Math.min(r, w / 2, h / 2);\n      // Calculate corner coordinates\n      var x1 = cx - w / 2;\n      var x2 = cx + w / 2;\n      var y1 = cy - h / 2;\n      var y2 = cy + h / 2; // y1=bottom, y2=top in our coordinate system\n\n      // Construct path counter-clockwise for fill-rule hole\n      var d = \"M \".concat(x1 + r, \" \").concat(y1); // Start on bottom edge, after corner\n      d += \" L \".concat(x2 - r, \" \").concat(y1); // Line to before bottom-right corner\n      d += \" A \".concat(r, \" \").concat(r, \" 0 0 0 \").concat(x2, \" \").concat(y1 + r); // Bottom-right corner arc\n      d += \" L \".concat(x2, \" \").concat(y2 - r); // Line to before top-right corner\n      d += \" A \".concat(r, \" \").concat(r, \" 0 0 0 \").concat(x2 - r, \" \").concat(y2); // Top-right corner arc\n      d += \" L \".concat(x1 + r, \" \").concat(y2); // Line to before top-left corner\n      d += \" A \".concat(r, \" \").concat(r, \" 0 0 0 \").concat(x1, \" \").concat(y2 - r); // Top-left corner arc\n      d += \" L \".concat(x1, \" \").concat(y1 + r); // Line to before bottom-left corner\n      d += \" A \".concat(r, \" \").concat(r, \" 0 0 0 \").concat(x1 + r, \" \").concat(y1); // Bottom-left corner arc\n      d += \" Z\";\n      return d;\n    }\n\n    /**\n     * Generates the combined path data for all inner holes (counter-clockwise winding).\n     * @returns {string} SVG path data string for all holes.\n     */\n  }, {\n    key: \"_generateInnerHolesPath\",\n    value: function _generateInnerHolesPath() {\n      var dHoles = \"\";\n      var thick = this.structureThickness;\n      var a = this.outerWidth / 2;\n      var b = this.outerHeight / 2;\n\n      // --- Define Key Vertical Positions (relative to center 0) ---\n      // These proportions are estimates based on the reference image\n      var headTopY = b * 0.85;\n      var headBottomY = b * 0.65;\n      var shoulderY = b * 0.55; // Approx vertical position for upper windows\n      var hTopY = this.hGapHeight / 2;\n      var hBottomY = -this.hGapHeight / 2;\n      var hipY = -b * 0.55; // Approx vertical position for lower windows\n      var feetTopY = -b * 0.65;\n      var feetBottomY = -b * 0.85;\n\n      // --- Define Key Horizontal Positions ---\n      var hGapHalfW = this.hGapWidth / 2;\n      var hBarHalfH = this.hBarGapHeight / 2;\n      var windowW = this.windowWidth;\n      var windowH = this.windowHeight;\n      var windowRound = this.windowRounding;\n\n      // Estimate horizontal placement for side elements\n      // Assume central vertical structure has width `thick`\n      var innerStructureEdgeX = thick / 2;\n      // Estimate where the main structure body ends before the spikes\n      var outerStructureEdgeX = Math.max(innerStructureEdgeX + windowW, a - this.spikeDepth - thick / 2);\n      // Place windows roughly in the middle of the side bands\n      var windowCenterX = (innerStructureEdgeX + outerStructureEdgeX) / 2;\n\n      // --- 1. Central H-shaped Hole (Counter-Clockwise) ---\n      var h_x1 = -hGapHalfW;\n      var h_x2 = -thick / 2;\n      var h_x3 = thick / 2;\n      var h_x4 = hGapHalfW;\n      var h_y1 = hTopY;\n      var h_y2 = hBarHalfH;\n      var h_y3 = -hBarHalfH;\n      var h_y4 = hBottomY;\n\n      // Draw path counter-clockwise for fill-rule\n      dHoles += \" M \".concat(h_x1, \" \").concat(h_y1); // Top-Left\n      dHoles += \" L \".concat(h_x1, \" \").concat(h_y2); // Inner Top-Left 1\n      dHoles += \" L \".concat(h_x2, \" \").concat(h_y2); // Inner Top-Left 2\n      dHoles += \" L \".concat(h_x2, \" \").concat(h_y3); // Inner Bottom-Left 2\n      dHoles += \" L \".concat(h_x1, \" \").concat(h_y3); // Inner Bottom-Left 1\n      dHoles += \" L \".concat(h_x1, \" \").concat(h_y4); // Bottom-Left\n      dHoles += \" L \".concat(h_x4, \" \").concat(h_y4); // Bottom-Right\n      dHoles += \" L \".concat(h_x4, \" \").concat(h_y3); // Inner Bottom-Right 1\n      dHoles += \" L \".concat(h_x3, \" \").concat(h_y3); // Inner Bottom-Right 2\n      dHoles += \" L \".concat(h_x3, \" \").concat(h_y2); // Inner Top-Right 2\n      dHoles += \" L \".concat(h_x4, \" \").concat(h_y2); // Inner Top-Right 1\n      dHoles += \" L \".concat(h_x4, \" \").concat(h_y1); // Top-Right\n      dHoles += \" Z\";\n\n      // --- 2. Top \"Head\" Hole (Counter-Clockwise) ---\n      // Use a rounded rectangle for approximation\n      var headW = hGapHalfW * 1.5; // Adjust width as needed\n      var headH = headTopY - headBottomY;\n      var headCurve = Math.min(headW / 2, headH / 2); // Rounding radius\n      dHoles += \" \" + this._createRoundedRectHole(0, (headTopY + headBottomY) / 2, headW * 2, headH, headCurve);\n\n      // --- 3. Bottom \"Feet\" Hole (Counter-Clockwise) ---\n      // Similar to top hole, potentially different proportions\n      var feetW = headW; // Same width as head or adjust (e.g., headW * 1.2)\n      var feetH = feetTopY - feetBottomY; // Height (Y values are negative)\n      var feetCurve = Math.min(feetW / 2, feetH / 2);\n      dHoles += \" \" + this._createRoundedRectHole(0, (feetTopY + feetBottomY) / 2, feetW * 2, feetH, feetCurve);\n\n      // --- 4. Side Window Holes (4 total, 2 mirrored pairs, Counter-Clockwise) ---\n      var upperWindowY = (shoulderY + hTopY) / 2; // Center Y for upper windows\n      var lowerWindowY = (hipY + hBottomY) / 2; // Center Y for lower windows\n\n      // Ensure window centers are calculated correctly\n      var safeWindowCenterX = Math.max(windowW / 2 + thick / 2 + 1, windowCenterX); // Ensure windows don't overlap center bar\n\n      // Right Upper Window\n      dHoles += \" \" + this._createRoundedRectHole(safeWindowCenterX, upperWindowY, windowW, windowH, windowRound);\n      // Left Upper Window (mirrored X)\n      dHoles += \" \" + this._createRoundedRectHole(-safeWindowCenterX, upperWindowY, windowW, windowH, windowRound);\n      // Right Lower Window\n      dHoles += \" \" + this._createRoundedRectHole(safeWindowCenterX, lowerWindowY, windowW, windowH, windowRound);\n      // Left Lower Window (mirrored X)\n      dHoles += \" \" + this._createRoundedRectHole(-safeWindowCenterX, lowerWindowY, windowW, windowH, windowRound);\n      return dHoles.trim(); // Return combined path data for all holes\n    }\n\n    /**\n     * Generates the SVG elements for the TotemSymbol shape.\n     * Uses fill-rule=\"evenodd\" with an outer path and inner hole paths\n     * to create the final cut-out appearance.\n     * @returns {string} SVG string containing a single <path> element.\n     */\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Generate the outer boundary path (clockwise)\n      var dOuter = this._generateOuterPath();\n      // Generate the inner hole paths (counter-clockwise)\n      var dHoles = this._generateInnerHolesPath();\n\n      // Combine the outer path and the hole paths into a single 'd' attribute\n      // Using fill-rule=\"evenodd\" ensures the counter-clockwise holes are cut out\n      var finalPathData = dOuter + \" \" + dHoles;\n\n      // Return the final path element\n      return \"<path d=\\\"\".concat(finalPathData, \"\\\" fill=\\\"white\\\" fill-rule=\\\"evenodd\\\" stroke=\\\"none\\\" />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(TotemSymbol, \"parameters\", {\n  outerWidth: {\n    type: 'number',\n    min: 20,\n    max: 100,\n    step: 1,\n    \"default\": 75,\n    label: 'Outer Width'\n  },\n  outerHeight: {\n    type: 'number',\n    min: 30,\n    max: 100,\n    step: 1,\n    \"default\": 95,\n    label: 'Outer Height'\n  },\n  numSpikes: {\n    type: 'number',\n    min: 4,\n    max: 60,\n    step: 1,\n    \"default\": 28,\n    label: 'Num Spikes'\n  },\n  spikeDepth: {\n    type: 'number',\n    min: 1,\n    max: 30,\n    step: 1,\n    \"default\": 8,\n    label: 'Spike Depth'\n  },\n  structureThickness: {\n    type: 'number',\n    min: 1,\n    max: 20,\n    step: 0.5,\n    \"default\": 7,\n    label: 'Structure Thickness'\n  },\n  hGapWidth: {\n    type: 'number',\n    min: 1,\n    max: 50,\n    step: 1,\n    \"default\": 16,\n    label: 'H-Gap Width'\n  },\n  hGapHeight: {\n    type: 'number',\n    min: 1,\n    max: 50,\n    step: 1,\n    \"default\": 12,\n    label: 'H-Gap Height'\n  },\n  hBarGapHeight: {\n    type: 'number',\n    min: 1,\n    max: 20,\n    step: 0.5,\n    \"default\": 5,\n    label: 'H-Bar Gap Height'\n  },\n  windowWidth: {\n    type: 'number',\n    min: 1,\n    max: 30,\n    step: 0.5,\n    \"default\": 8,\n    label: 'Window Width'\n  },\n  windowHeight: {\n    type: 'number',\n    min: 1,\n    max: 30,\n    step: 0.5,\n    \"default\": 10,\n    label: 'Window Height'\n  },\n  windowRounding: {\n    type: 'number',\n    min: 0,\n    max: 15,\n    step: 0.5,\n    \"default\": 3,\n    label: 'Window Rounding'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TotemSymbol);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/TotemSymbol.js?");

/***/ }),

/***/ "./src/shapes/TriGearStructure.js":
/*!****************************************!*\
  !*** ./src/shapes/TriGearStructure.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a structure of three outer rings of circles arranged in a triangle,\n * connected by tangent lines, with an optional central gear.\n */\nvar TriGearStructure = /*#__PURE__*/function (_Shape) {\n  function TriGearStructure() {\n    _classCallCheck(this, TriGearStructure);\n    return _callSuper(this, TriGearStructure, arguments);\n  }\n  _inherits(TriGearStructure, _Shape);\n  return _createClass(TriGearStructure, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      var svgElements = [];\n      var r = this.outerRingRadius; // Radius of the large ring imaginary boundary\n      var small_r = this.outerCircleRadius; // Radius of the small circles\n      var stroke = this.strokeWidth;\n\n      // Calculate centers of the three outer rings, forming an equilateral triangle centered at (0,0)\n      var scale = this.arrangementScale;\n      // Place top center slightly above origin for visual balance\n      var cTop = {\n        x: 0,\n        y: scale\n      };\n      // Calculate bottom centers based on equilateral triangle geometry relative to cTop\n      var cBl = {\n        x: -scale * Math.sqrt(3) / 2,\n        y: -scale / 2\n      };\n      var cBr = {\n        x: scale * Math.sqrt(3) / 2,\n        y: -scale / 2\n      };\n      var centers = [cTop, cBl, cBr];\n\n      // Generate outer rings of circles\n      centers.forEach(function (center) {\n        var centerCircleGroup = [];\n        for (var i = 0; i < _this.numCirclesOuter; i++) {\n          var angle = i / _this.numCirclesOuter * 2 * Math.PI;\n          // Place small circles centered ON the radius `r`\n          var x = center.x + r * Math.cos(angle);\n          var y = center.y + r * Math.sin(angle);\n          centerCircleGroup.push(\"<circle cx=\\\"\".concat(x.toFixed(2), \"\\\" cy=\\\"\").concat(y.toFixed(2), \"\\\" r=\\\"\").concat(small_r, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\"));\n        }\n        svgElements.push.apply(svgElements, centerCircleGroup);\n      });\n\n      // Generate connecting tangent lines\n      // The lines are tangent to the main ring radius `r`\n      if (this.showLines && r > 0) {\n        // Define which specific tangents we need based on the visual structure\n        var lines = [\n        // Outer Belt Path (tangents between circles of radius r)\n        this.calculateTangentLine(cTop, cBl, r, r, 'outer_cw'),\n        // Top-Left side (CW around cTop)\n        this.calculateTangentLine(cTop, cBr, r, r, 'outer_ccw'),\n        // Top-Right side (CCW around cTop)\n        this.calculateTangentLine(cBl, cBr, r, r, 'outer_cw'),\n        // Bottom side (CW around cBl)\n\n        // Inner Cross Path (tangents between circles of radius r)\n        this.calculateTangentLine(cTop, cBl, r, r, 'inner_1'),\n        // Top to BL cross (using inner_1 type)\n        this.calculateTangentLine(cTop, cBr, r, r, 'inner_1') // Top to BR cross (using inner_1 type - geometry makes it the correct cross)\n        ];\n        lines.forEach(function (line) {\n          if (line) {\n            // Check if tangent calculation was successful\n            svgElements.push(\"<line x1=\\\"\".concat(line.x1.toFixed(2), \"\\\" y1=\\\"\").concat(line.y1.toFixed(2), \"\\\" x2=\\\"\").concat(line.x2.toFixed(2), \"\\\" y2=\\\"\").concat(line.y2.toFixed(2), \"\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(stroke, \"\\\" fill=\\\"none\\\" />\"));\n          }\n        });\n      }\n\n      // Generate central gear shape\n      if (this.showCenterGear && this.centerGearRadius > 0 && this.numGearTeeth > 0) {\n        var gearPoints = [];\n        var numSegments = Math.max(60, this.numGearTeeth * 10); // Increase segments for smoother teeth\n        var baseRadius = this.centerGearRadius;\n        var toothHeight = this.gearToothDepth;\n        for (var i = 0; i <= numSegments; i++) {\n          var angle = i / numSegments * 2 * Math.PI;\n          // Modulate radius: average radius is 'baseRadius', depth is 'toothHeight'\n          var currentRadius = baseRadius - toothHeight / 2 + toothHeight / 2 * Math.cos(this.numGearTeeth * angle);\n          var x = currentRadius * Math.cos(angle);\n          var y = currentRadius * Math.sin(angle);\n          gearPoints.push(\"\".concat(x.toFixed(2), \",\").concat(y.toFixed(2)));\n        }\n        var pathData = \"M \".concat(gearPoints[0], \" L \").concat(gearPoints.slice(1).join(' '), \" Z\");\n        svgElements.push(\"<path d=\\\"\".concat(pathData, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\"));\n      }\n      return svgElements.join('\\n');\n    }\n\n    /**\n     * Calculates the start and end points of a tangent line between two circles c1 and c2\n     * with radii r1 and r2.\n     * @param {{x: number, y: number}} c1 - Center of circle 1.\n     * @param {{x: number, y: number}} c2 - Center of circle 2.\n     * @param {number} r1 - Radius of circle 1.\n     * @param {number} r2 - Radius of circle 2.\n     * @param {'outer_ccw'|'outer_cw'|'inner_1'|'inner_2'} type - Type of tangent.\n     *        'outer_ccw': Tangent corresponding to counter-clockwise rotation around c1.\n     *        'outer_cw': Tangent corresponding to clockwise rotation around c1.\n     *        'inner_1', 'inner_2': The two distinct inner tangents.\n     * @returns {{x1: number, y1: number, x2: number, y2: number} | null} Line coordinates or null if tangent doesn't exist.\n     */\n  }, {\n    key: \"calculateTangentLine\",\n    value: function calculateTangentLine(c1, c2, r1, r2, type) {\n      var dx = c2.x - c1.x;\n      var dy = c2.y - c1.y;\n      var d_sq = dx * dx + dy * dy;\n      var epsilon = 1e-6; // Small value for floating point comparisons\n\n      if (d_sq < epsilon) return null; // Circles coincide\n\n      var d = Math.sqrt(d_sq);\n      var vx = dx / d; // Unit vector from c1 to c2\n      var vy = dy / d;\n      var A,\n        B,\n        sign,\n        r2_eff = r2;\n      var conditionMet = false;\n      switch (type) {\n        case 'outer_ccw': // Corresponds to sign = 1 in the formula using CCW normal n=(-vy,vx)\n        case 'outer_cw':\n          // Corresponds to sign = -1\n          if (d >= Math.abs(r1 - r2) - epsilon) {\n            // Check if distance allows outer tangents\n            A = (r1 - r2) / d;\n            sign = type === 'outer_ccw' ? 1 : -1;\n            conditionMet = true;\n          }\n          break;\n        case 'inner_1': // Arbitrarily assign sign = 1\n        case 'inner_2':\n          // Arbitrarily assign sign = -1\n          if (d >= r1 + r2 - epsilon) {\n            // Check if distance allows inner tangents\n            A = (r1 + r2) / d;\n            r2_eff = -r2; // Effective radius for inner tangent point calculation on C2\n            sign = type === 'inner_1' ? 1 : -1;\n            conditionMet = true;\n          }\n          break;\n        default:\n          return null;\n        // Invalid type\n      }\n      if (!conditionMet) return null; // Tangent not possible for geometric reasons\n\n      // Clamp A*A to be <= 1 to avoid floating point issues with Math.sqrt\n      var A_sq = A * A;\n      // Ensure B_sq is non-negative before taking sqrt\n      var B_sq = Math.max(0, 1.0 - A_sq);\n      B = Math.sqrt(B_sq);\n\n      // Calculate tangent points P1 on C1 and P2 on C2\n      // The formula uses the vector 'v' (from c1 to c2) and its CCW perpendicular 'n' = (-vy, vx)\n      // P = Center + r * ( A*v + sign*B*n )\n      var P1 = {\n        x: c1.x + r1 * (A * vx - sign * B * vy),\n        y: c1.y + r1 * (A * vy + sign * B * vx)\n      };\n      var P2 = {\n        x: c2.x + r2_eff * (A * vx - sign * B * vy),\n        // Use r2_eff which might be -r2 for inner tangents\n        y: c2.y + r2_eff * (A * vy + sign * B * vx)\n      };\n      return {\n        x1: P1.x,\n        y1: P1.y,\n        x2: P2.x,\n        y2: P2.y\n      };\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(TriGearStructure, \"parameters\", {\n  numCirclesOuter: {\n    type: 'number',\n    min: 3,\n    max: 20,\n    step: 1,\n    \"default\": 10,\n    label: 'Outer Circles per Ring'\n  },\n  outerRingRadius: {\n    type: 'number',\n    min: 10,\n    max: 50,\n    step: 1,\n    \"default\": 25,\n    label: 'Outer Ring Radius'\n  },\n  outerCircleRadius: {\n    type: 'number',\n    min: 1,\n    max: 15,\n    step: 0.5,\n    \"default\": 5,\n    label: 'Outer Circle Radius'\n  },\n  centerGearRadius: {\n    type: 'number',\n    min: 5,\n    max: 50,\n    step: 1,\n    \"default\": 25,\n    label: 'Center Gear Radius'\n  },\n  numGearTeeth: {\n    type: 'number',\n    min: 3,\n    max: 20,\n    step: 1,\n    \"default\": 8,\n    label: 'Gear Teeth'\n  },\n  gearToothDepth: {\n    type: 'number',\n    min: 0,\n    max: 15,\n    step: 0.5,\n    \"default\": 5,\n    label: 'Gear Tooth Depth'\n  },\n  arrangementScale: {\n    type: 'number',\n    min: 30,\n    max: 90,\n    step: 1,\n    \"default\": 65,\n    label: 'Arrangement Scale'\n  },\n  showLines: {\n    type: 'boolean',\n    \"default\": true,\n    label: 'Show Connecting Lines'\n  },\n  showCenterGear: {\n    type: 'boolean',\n    \"default\": true,\n    label: 'Show Center Gear'\n  },\n  strokeWidth: {\n    type: 'number',\n    min: 0.5,\n    max: 5,\n    step: 0.5,\n    \"default\": 1,\n    label: 'Line Stroke Width'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TriGearStructure);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/TriGearStructure.js?");

/***/ }),

/***/ "./src/shapes/TriLobeBlob.js":
/*!***********************************!*\
  !*** ./src/shapes/TriLobeBlob.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a smooth, three-lobed blob shape using Bezier curves with\n * adjustable inner/outer radii and smoothness.\n */\nvar TriLobeBlob = /*#__PURE__*/function (_Shape) {\n  function TriLobeBlob() {\n    _classCallCheck(this, TriLobeBlob);\n    return _callSuper(this, TriLobeBlob, arguments);\n  }\n  _inherits(TriLobeBlob, _Shape);\n  return _createClass(TriLobeBlob, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var points = []; // Stores {x, y} coordinates of anchor points\n      var angles = []; // Stores angles of anchor points (radians)\n      var radii = []; // Stores radii of anchor points\n      var numLobes = 3;\n      var angleStep = 2 * Math.PI / numLobes; // Angle between lobe centers (120 deg or 2*PI/3)\n      var segmentAngle = angleStep / 2; // Angle between a lobe and an adjacent indent (60 deg or PI/3)\n\n      // Use parameter values from `this`, ensuring innerRadius is not greater than outerRadius\n      var outerR = this.outerRadius;\n      // Clamp innerRadius to be less than outerRadius to prevent inversion\n      var innerR = Math.min(this.innerRadius, outerR - 1);\n\n      // Calculate the 6 anchor points (3 lobes, 3 indents) using polar coordinates\n      for (var i = 0; i < numLobes; i++) {\n        // Lobe point (starts at top: 90 degrees or PI/2)\n        var lobeAngle = Math.PI / 2 + i * angleStep;\n        angles.push(lobeAngle);\n        radii.push(outerR);\n        points.push({\n          x: outerR * Math.cos(lobeAngle),\n          y: outerR * Math.sin(lobeAngle) // Positive Y is down in SVG, but use standard math coords here\n        });\n\n        // Indent point (midway between lobes)\n        var indentAngle = lobeAngle + segmentAngle;\n        angles.push(indentAngle);\n        radii.push(innerR);\n        points.push({\n          x: innerR * Math.cos(indentAngle),\n          y: innerR * Math.sin(indentAngle)\n        });\n      }\n\n      // Start building the SVG path data string from the first lobe point\n      var d = \"M \".concat(points[0].x.toFixed(2), \" \").concat(points[0].y.toFixed(2));\n\n      // Factor for Bezier handle length based on smoothness parameter\n      var k = this.smoothness;\n\n      // Loop through the 6 segments connecting the anchor points\n      for (var _i = 0; _i < points.length; _i++) {\n        var p1 = points[_i]; // Start point of the current Bezier curve segment\n        var p2 = points[(_i + 1) % points.length]; // End point of the segment (wraps around using modulo)\n        var angle1 = angles[_i]; // Angle of p1\n        var angle2 = angles[(_i + 1) % points.length]; // Angle of p2\n        var radius1 = radii[_i]; // Radius of p1\n        var radius2 = radii[(_i + 1) % points.length]; // Radius of p2\n\n        // The angle difference between adjacent points is constant (segmentAngle = PI/3)\n        var angleDiff = segmentAngle;\n\n        // Calculate Handle 1 (control point outgoing from p1)\n        // Tangent direction at p1 (perpendicular to the radius vector, pointing counter-clockwise for increasing angle)\n        var tangent1x = -Math.sin(angle1);\n        var tangent1y = Math.cos(angle1);\n        // Scale handle length: proportional to the radius at p1, the angle segment covers, and the smoothness factor\n        var length1 = radius1 * angleDiff * k;\n        var cp1x = p1.x + tangent1x * length1;\n        var cp1y = p1.y + tangent1y * length1;\n\n        // Calculate Handle 2 (control point incoming to p2)\n        // Tangent direction at p2\n        var tangent2x = -Math.sin(angle2);\n        var tangent2y = Math.cos(angle2);\n        // Scale handle length similarly for p2\n        var length2 = radius2 * angleDiff * k;\n        // The control point needs to point back along the tangent relative to the curve direction from p1 to p2\n        var cp2x = p2.x - tangent2x * length2;\n        var cp2y = p2.y - tangent2y * length2;\n\n        // Append the Cubic Bezier curve segment (C command) to the path data string\n        // Format: C cp1x,cp1y cp2x,cp2y p2x,p2y\n        d += \" C \".concat(cp1x.toFixed(2), \",\").concat(cp1y.toFixed(2), \" \").concat(cp2x.toFixed(2), \",\").concat(cp2y.toFixed(2), \" \").concat(p2.x.toFixed(2), \",\").concat(p2.y.toFixed(2));\n      }\n      d += ' Z'; // Close the path ('Z') to create a filled shape\n\n      // Return the complete SVG path element string with fill and no stroke\n      return \"<path d=\\\"\".concat(d, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(TriLobeBlob, \"parameters\", {\n  outerRadius: {\n    type: 'number',\n    min: 10,\n    max: 95,\n    step: 1,\n    \"default\": 80,\n    description: 'Maximum distance from center to the tip of the lobes.'\n  },\n  innerRadius: {\n    type: 'number',\n    min: 5,\n    max: 90,\n    step: 1,\n    \"default\": 45,\n    description: 'Minimum distance from center to the indentations between lobes (clamped <= outerRadius).'\n  },\n  smoothness: {\n    type: 'number',\n    min: 0.1,\n    max: 1.2,\n    // Allows for slightly sharper or rounder curves\n    step: 0.05,\n    \"default\": 0.65,\n    // Controls the curvature/handle length of the Bezier segments.\n    description: 'Factor controlling the curve smoothness (length of Bezier handles).'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TriLobeBlob);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/TriLobeBlob.js?");

/***/ }),

/***/ "./src/shapes/TriangleRays.js":
/*!************************************!*\
  !*** ./src/shapes/TriangleRays.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a pattern of triangular rays pointing downwards from a common top\n * vertex, with adjustable tilt.\n */\nvar TriangleRaysShape = /*#__PURE__*/function (_Shape) {\n  function TriangleRaysShape() {\n    _classCallCheck(this, TriangleRaysShape);\n    return _callSuper(this, TriangleRaysShape, arguments);\n  }\n  _inherits(TriangleRaysShape, _Shape);\n  return _createClass(TriangleRaysShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var triangles = [];\n\n      // Calculate basic dimensions\n      var topPoint = {\n        x: 0,\n        y: -this.height / 2\n      };\n\n      // Calculate gaps and ray widths\n      var gap = Math.max(2, this.thickness * 0.2);\n      var totalGapSpace = gap * (this.rayCount - 1);\n      var totalRayWidth = this.baseWidth - totalGapSpace;\n      var rayWidth = totalRayWidth / this.rayCount;\n\n      // Calculate starting point to center the pattern\n      var patternTotalWidth = totalRayWidth + totalGapSpace;\n      var startX = -patternTotalWidth / 2;\n\n      // Generate triangular rays\n      for (var i = 0; i < this.rayCount; i++) {\n        // Calculate base points from centered start position\n        var leftX = startX + i * (rayWidth + gap);\n        var rightX = leftX + rayWidth;\n\n        // Apply tilt to the base points\n        var tiltRad = this.tilt * Math.PI / 180;\n        var centerX = (leftX + rightX) / 2;\n        var tiltOffsetLeft = Math.sin(tiltRad) * centerX;\n        var tiltOffsetRight = Math.sin(tiltRad) * centerX;\n        var leftBaseX = leftX + tiltOffsetLeft;\n        var rightBaseX = rightX + tiltOffsetRight;\n\n        // Create triangular path\n        triangles.push(\"<path \\n                d=\\\"M \".concat(topPoint.x, \" \").concat(topPoint.y, \" \\n                   L \").concat(leftBaseX, \" \").concat(-topPoint.y, \" \\n                   L \").concat(rightBaseX, \" \").concat(-topPoint.y, \" Z\\\"\\n                fill=\\\"white\\\"\\n            />\"));\n      }\n      return triangles.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(TriangleRaysShape, \"parameters\", {\n  rayCount: {\n    min: 3,\n    max: 12,\n    \"default\": 4\n  },\n  height: {\n    min: 20,\n    max: 200,\n    \"default\": 118\n  },\n  baseWidth: {\n    min: 20,\n    max: 200,\n    \"default\": 133\n  },\n  tilt: {\n    min: 0,\n    max: 45,\n    \"default\": 10\n  },\n  thickness: {\n    min: 1,\n    max: 100,\n    \"default\": 30\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TriangleRaysShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/TriangleRays.js?");

/***/ }),

/***/ "./src/shapes/TriangularPortal.js":
/*!****************************************!*\
  !*** ./src/shapes/TriangularPortal.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a triangular frame shape by cutting a smaller, offset triangle from\n * a larger one.\n */\nvar TriangularPortal = /*#__PURE__*/function (_Shape) {\n  function TriangularPortal() {\n    _classCallCheck(this, TriangularPortal);\n    return _callSuper(this, TriangularPortal, arguments);\n  }\n  _inherits(TriangularPortal, _Shape);\n  return _createClass(TriangularPortal, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Calculate center point (origin in our SVG coordinate system)\n      var center = {\n        x: 0,\n        y: 0\n      };\n\n      // Scale values to fit SVG viewBox (-200 -200 400 400)\n      var scale = 1.0;\n      var height = this.height * scale;\n      var baseWidth = this.baseWidth * scale;\n      var innerScale = this.innerScale;\n\n      // Calculate points for outer triangle\n      var topPoint = {\n        x: center.x,\n        y: center.y - height / 2\n      };\n      var bottomLeft = {\n        x: center.x - baseWidth / 2,\n        y: center.y + height / 2\n      };\n      var bottomRight = {\n        x: center.x + baseWidth / 2,\n        y: center.y + height / 2\n      };\n\n      // Calculate points for inner triangle\n      var innerHeight = height * innerScale;\n      var innerBaseWidth = baseWidth * (innerScale + 0.1); // Slightly wider base\n      var verticalOffset = (height - innerHeight) * 0.9;\n      var innerTopPoint = {\n        x: center.x,\n        y: center.y - height / 2 + verticalOffset\n      };\n      var innerBottomLeft = {\n        x: center.x - innerBaseWidth / 2,\n        y: center.y + height / 2\n      };\n      var innerBottomRight = {\n        x: center.x + innerBaseWidth / 2,\n        y: center.y + height / 2\n      };\n\n      // Create SVG path for both triangles\n      // Using fill-rule=\"evenodd\" to create the cutout effect\n      var pathData = \"\\n            M \".concat(topPoint.x, \" \").concat(topPoint.y, \"\\n            L \").concat(bottomLeft.x, \" \").concat(bottomLeft.y, \"\\n            L \").concat(bottomRight.x, \" \").concat(bottomRight.y, \"\\n            Z\\n            M \").concat(innerTopPoint.x, \" \").concat(innerTopPoint.y, \"\\n            L \").concat(innerBottomLeft.x, \" \").concat(innerBottomLeft.y, \"\\n            L \").concat(innerBottomRight.x, \" \").concat(innerBottomRight.y, \"\\n            Z\\n        \");\n      return \"<path \\n            d=\\\"\".concat(pathData, \"\\\"\\n            fill=\\\"white\\\"\\n            fill-rule=\\\"evenodd\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"2\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(TriangularPortal, \"parameters\", {\n  height: {\n    min: 50,\n    max: 200,\n    \"default\": 120\n  },\n  baseWidth: {\n    min: 20,\n    max: 200,\n    \"default\": 120\n  },\n  innerScale: {\n    min: 0.1,\n    max: 0.9,\n    \"default\": 0.4\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TriangularPortal);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/TriangularPortal.js?");

/***/ }),

/***/ "./src/shapes/TribalArrow.js":
/*!***********************************!*\
  !*** ./src/shapes/TribalArrow.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a stylized tribal arrow or spearhead shape.\n */\nvar TribalArrow = /*#__PURE__*/function (_Shape) {\n  function TribalArrow() {\n    _classCallCheck(this, TribalArrow);\n    return _callSuper(this, TribalArrow, arguments);\n  }\n  _inherits(TribalArrow, _Shape);\n  return _createClass(TribalArrow, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Center point (origin in SVG coordinate system)\n      var center = {\n        x: 0,\n        y: 0\n      };\n\n      // Scale values to fit SVG viewBox (-200 -200 400 400)\n      var scale = 1.2;\n      var width = this.width * scale;\n      var height = this.height * scale;\n      var pointDepth = this.pointDepth;\n      var wingSpread = this.wingSpread;\n\n      // Calculate key points\n      var top = center.y - height / 2;\n      var bottom = center.y + height / 2;\n      var left = center.x - width / 2;\n      var right = center.x + width / 2;\n\n      // Build path data\n      var pathData = [// Start at top center\n      \"M \".concat(center.x, \" \").concat(top), // Right side\n      \"L \".concat(right, \" \").concat(top + height * pointDepth), \"L \".concat(center.x + width * wingSpread / 2, \" \").concat(center.y), \"L \".concat(right, \" \").concat(bottom - height * pointDepth), \"L \".concat(center.x, \" \").concat(bottom), // Left side\n      \"L \".concat(left, \" \").concat(bottom - height * pointDepth), \"L \".concat(center.x - width * wingSpread / 2, \" \").concat(center.y), \"L \".concat(left, \" \").concat(top + height * pointDepth),\n      // Close path\n      'Z'].join(' ');\n      return \"<path \\n            d=\\\"\".concat(pathData, \"\\\"\\n            fill=\\\"white\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"2\\\"\\n            stroke-linejoin=\\\"round\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(TribalArrow, \"parameters\", {\n  width: {\n    min: 50,\n    max: 200,\n    \"default\": 100\n  },\n  height: {\n    min: 50,\n    max: 200,\n    \"default\": 120\n  },\n  pointDepth: {\n    min: 0.1,\n    max: 0.5,\n    \"default\": 0.3\n  },\n  wingSpread: {\n    min: 0.3,\n    max: 1.0,\n    \"default\": 0.7\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TribalArrow);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/TribalArrow.js?");

/***/ }),

/***/ "./src/shapes/TripleRoundedShape.js":
/*!******************************************!*\
  !*** ./src/shapes/TripleRoundedShape.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a shape consisting of multiple horizontally aligned, rounded\n * rectangles (capsules) with adjustable spacing.\n */\nvar TripleRoundedShape = /*#__PURE__*/function (_Shape) {\n  function TripleRoundedShape() {\n    _classCallCheck(this, TripleRoundedShape);\n    return _callSuper(this, TripleRoundedShape, arguments);\n  }\n  _inherits(TripleRoundedShape, _Shape);\n  return _createClass(TripleRoundedShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var scale = 0.8;\n      var segments = Math.round(this.segments);\n      var cornerRadius = this.cornerRadius * scale;\n      var spacing = this.spacing * scale;\n      var aspectRatio = this.aspectRatio;\n\n      // Calculate available space in the 400x400 viewBox\n      var totalWidth = 200; // Leave some margin\n      var adjustedWidth = totalWidth - spacing * (segments - 1);\n      var segmentWidth = adjustedWidth / segments;\n      var segmentHeight = segmentWidth * aspectRatio;\n\n      // Generate rectangles\n      var rects = [];\n      for (var i = 0; i < segments; i++) {\n        var xOffset = -totalWidth / 2 + (segmentWidth + spacing) * i;\n        var yOffset = -segmentHeight / 2;\n        rects.push(\"<rect \\n                x=\\\"\".concat(xOffset, \"\\\"\\n                y=\\\"\").concat(yOffset, \"\\\"\\n                width=\\\"\").concat(segmentWidth, \"\\\"\\n                height=\\\"\").concat(segmentHeight, \"\\\"\\n                rx=\\\"\").concat(cornerRadius, \"\\\"\\n                ry=\\\"\").concat(cornerRadius, \"\\\"\\n                fill=\\\"white\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"2\\\"\\n            />\"));\n      }\n      return rects.join('\\n');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(TripleRoundedShape, \"parameters\", {\n  segments: {\n    min: 2,\n    max: 5,\n    \"default\": 3\n  },\n  cornerRadius: {\n    min: 20,\n    max: 100,\n    \"default\": 60\n  },\n  spacing: {\n    min: -20,\n    max: 20,\n    \"default\": -5\n  },\n  aspectRatio: {\n    min: 0.5,\n    max: 2.0,\n    \"default\": 1.0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TripleRoundedShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/TripleRoundedShape.js?");

/***/ }),

/***/ "./src/shapes/TruchetPattern.js":
/*!**************************************!*\
  !*** ./src/shapes/TruchetPattern.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a Truchet tile pattern using diagonal triangular tiles rotated\n * based on a noise field.\n */\nvar TruchetPattern = /*#__PURE__*/function (_Shape) {\n  function TruchetPattern() {\n    _classCallCheck(this, TruchetPattern);\n    return _callSuper(this, TruchetPattern, arguments);\n  }\n  _inherits(TruchetPattern, _Shape);\n  return _createClass(TruchetPattern, [{\n    key: \"adaptSize\",\n    value:\n    // Determine appropriate tile size to fit within 80% of 400x400 viewport\n    function adaptSize() {\n      var maxDimension = 400 * 0.9;\n      var calculatedTileSize = maxDimension / this.gridSize;\n      this.tileSize = Math.min(this.tileSize, calculatedTileSize);\n    }\n\n    // Deterministic pseudorandom number generator\n  }, {\n    key: \"getPseudoRandom\",\n    value: function getPseudoRandom(x, y) {\n      var value = Math.sin(x * 12.9898 + y * 78.233 + this.seed) * 43758.5453;\n      return value - Math.floor(value);\n    }\n  }, {\n    key: \"createNoiseField\",\n    value: function createNoiseField() {\n      var _this = this;\n      // Create deterministic grid based on coordinates\n      this.grid = Array(this.gridSize).fill().map(function (_, y) {\n        return Array(_this.gridSize).fill().map(function (_, x) {\n          return _this.getPseudoRandom(x, y);\n        });\n      });\n\n      // Apply flow smoothing\n      var smoothedGrid = Array(this.gridSize).fill().map(function () {\n        return Array(_this.gridSize).fill(0);\n      });\n      for (var y = 0; y < this.gridSize; y++) {\n        for (var x = 0; x < this.gridSize; x++) {\n          var avg = this.grid[y][x];\n          var count = 1;\n\n          // Calculate average of neighboring cells\n          for (var dy = -1; dy <= 1; dy++) {\n            for (var dx = -1; dx <= 1; dx++) {\n              if (dx === 0 && dy === 0) continue;\n              var nx = x + dx;\n              var ny = y + dy;\n              if (nx >= 0 && nx < this.gridSize && ny >= 0 && ny < this.gridSize) {\n                avg += this.grid[ny][nx];\n                count++;\n              }\n            }\n          }\n\n          // Apply flow intensity\n          avg /= count;\n          smoothedGrid[y][x] = avg * this.flowIntensity + this.grid[y][x] * (1 - this.flowIntensity);\n\n          // Apply contrast\n          if (this.contrast > 0) {\n            smoothedGrid[y][x] = Math.pow(smoothedGrid[y][x], 1 + this.contrast * 2);\n          }\n        }\n      }\n      this.grid = smoothedGrid;\n    }\n  }, {\n    key: \"getRotation\",\n    value: function getRotation(x, y) {\n      var noiseValue = this.grid[y][x];\n      var baseRotation = Math.floor(noiseValue * 4) * 90;\n\n      // Apply pattern balance deterministically\n      var balanceValue = this.getPseudoRandom(x + 100, y + 100);\n      if (balanceValue > this.patternBalance) {\n        var rotIndex = Math.floor(this.getPseudoRandom(x + 200, y + 200) * 4);\n        return this.patterns[rotIndex];\n      }\n      return baseRotation;\n    }\n  }, {\n    key: \"createTile\",\n    value: function createTile(rotation, x, y) {\n      // Calculate position within grid\n      var xPos = x * this.tileSize;\n      var yPos = y * this.tileSize;\n\n      // Create transform for tile rotation\n      var transform = \"translate(\".concat(xPos, \",\").concat(yPos, \") rotate(\").concat(rotation, \", \").concat(this.tileSize / 2, \", \").concat(this.tileSize / 2, \")\");\n\n      // Create triangular tile with white fill\n      return \"<g transform=\\\"\".concat(transform, \"\\\">\\n            <path d=\\\"M 0 0 L \").concat(this.tileSize, \" 0 L 0 \").concat(this.tileSize, \" Z\\\" \\n                  fill=\\\"white\\\"\\n                  stroke=\\\"none\\\" />\\n        </g>\");\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Convert percentage values to decimals\n      this.flowIntensity = this.flowIntensity / 100;\n      this.patternBalance = this.patternBalance / 100;\n      this.contrast = this.contrast / 100;\n\n      // Initialize pattern rotations\n      this.patterns = [0, 90, 180, 270];\n\n      // Generate a stable seed for the pattern\n      this.seed = 12345;\n\n      // Adaptive sizing\n      this.adaptSize();\n      // Generate noise field for pattern\n      this.createNoiseField();\n\n      // Adaptive sizing and centering\n      this.adaptSize();\n      var totalWidth = this.gridSize * this.tileSize;\n      var offset = -totalWidth / 2;\n\n      // Create container group with centering transform\n      var shapes = [\"<g transform=\\\"translate(\".concat(offset, \",\").concat(offset, \")\\\">\")];\n\n      // Generate all tiles\n      for (var y = 0; y < this.gridSize; y++) {\n        for (var x = 0; x < this.gridSize; x++) {\n          var rotation = this.getRotation(x, y);\n          shapes.push(this.createTile(rotation, x, y));\n        }\n      }\n      shapes.push('</g>');\n      return shapes.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(TruchetPattern, \"parameters\", {\n  gridSize: {\n    min: 2,\n    max: 4,\n    \"default\": 2\n  },\n  tileSize: {\n    min: 25,\n    max: 59,\n    \"default\": 50\n  },\n  flowIntensity: {\n    min: 0,\n    max: 100,\n    \"default\": 100\n  },\n  patternBalance: {\n    min: 0,\n    max: 100,\n    \"default\": 100\n  },\n  contrast: {\n    min: 0,\n    max: 100,\n    \"default\": 50\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TruchetPattern);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/TruchetPattern.js?");

/***/ }),

/***/ "./src/shapes/TruchetSmooth.js":
/*!*************************************!*\
  !*** ./src/shapes/TruchetSmooth.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a Truchet tile pattern using quarter-circle arc tiles rotated based\n * on a noise field, creating smooth connections.\n */\nvar TruchetSmooth = /*#__PURE__*/function (_Shape) {\n  function TruchetSmooth() {\n    _classCallCheck(this, TruchetSmooth);\n    return _callSuper(this, TruchetSmooth, arguments);\n  }\n  _inherits(TruchetSmooth, _Shape);\n  return _createClass(TruchetSmooth, [{\n    key: \"adaptSize\",\n    value: function adaptSize() {\n      var maxDimension = 400 * 0.9;\n      var calculatedTileSize = maxDimension / this.gridSize;\n      this.tileSize = Math.min(this.tileSize, calculatedTileSize);\n    }\n  }, {\n    key: \"getPseudoRandom\",\n    value: function getPseudoRandom(x, y) {\n      var value = Math.sin(x * 12.9898 + y * 78.233 + this.seed) * 43758.5453;\n      return value - Math.floor(value);\n    }\n  }, {\n    key: \"createNoiseField\",\n    value: function createNoiseField() {\n      var _this = this;\n      this.grid = Array(this.gridSize).fill().map(function (_, y) {\n        return Array(_this.gridSize).fill().map(function (_, x) {\n          return _this.getPseudoRandom(x, y);\n        });\n      });\n      var smoothedGrid = Array(this.gridSize).fill().map(function () {\n        return Array(_this.gridSize).fill(0);\n      });\n      for (var y = 0; y < this.gridSize; y++) {\n        for (var x = 0; x < this.gridSize; x++) {\n          var avg = this.grid[y][x];\n          var count = 1;\n          for (var dy = -1; dy <= 1; dy++) {\n            for (var dx = -1; dx <= 1; dx++) {\n              if (dx === 0 && dy === 0) continue;\n              var nx = x + dx;\n              var ny = y + dy;\n              if (nx >= 0 && nx < this.gridSize && ny >= 0 && ny < this.gridSize) {\n                avg += this.grid[ny][nx];\n                count++;\n              }\n            }\n          }\n          avg /= count;\n          smoothedGrid[y][x] = avg * this.flowIntensity + this.grid[y][x] * (1 - this.flowIntensity);\n          if (this.contrast > 0) {\n            smoothedGrid[y][x] = Math.pow(smoothedGrid[y][x], 1 + this.contrast * 2);\n          }\n        }\n      }\n      this.grid = smoothedGrid;\n    }\n  }, {\n    key: \"getRotation\",\n    value: function getRotation(x, y) {\n      var noiseValue = this.grid[y][x];\n      var baseRotation = Math.floor(noiseValue * 4) * 90;\n      var balanceValue = this.getPseudoRandom(x + 100, y + 100);\n      if (balanceValue > this.patternBalance) {\n        var rotIndex = Math.floor(this.getPseudoRandom(x + 200, y + 200) * 4);\n        return this.patterns[rotIndex];\n      }\n      return baseRotation;\n    }\n  }, {\n    key: \"createTile\",\n    value: function createTile(rotation, x, y) {\n      var xPos = x * this.tileSize;\n      var yPos = y * this.tileSize;\n      var size = this.tileSize;\n      var transform = \"translate(\".concat(xPos, \",\").concat(yPos, \") rotate(\").concat(rotation, \", \").concat(size / 2, \", \").concat(size / 2, \")\");\n      return \"<g transform=\\\"\".concat(transform, \"\\\">\\n            <path d=\\\"M 0 0 A \").concat(size, \" \").concat(size, \" 0 0 1 \").concat(size, \" \").concat(size, \" L 0 \").concat(size, \" Z\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\\n        </g>\");\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      this.flowIntensity = this.flowIntensity / 100;\n      this.patternBalance = this.patternBalance / 100;\n      this.contrast = this.contrast / 100;\n      this.patterns = [0, 90, 180, 270];\n      this.seed = 12345;\n      this.adaptSize();\n      this.createNoiseField();\n      this.adaptSize();\n      var totalWidth = this.gridSize * this.tileSize;\n      var offset = -totalWidth / 2;\n      var shapes = [\"<g transform=\\\"translate(\".concat(offset, \",\").concat(offset, \")\\\">\")];\n      for (var y = 0; y < this.gridSize; y++) {\n        for (var x = 0; x < this.gridSize; x++) {\n          var rotation = this.getRotation(x, y);\n          shapes.push(this.createTile(rotation, x, y));\n        }\n      }\n      shapes.push('</g>');\n      return shapes.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(TruchetSmooth, \"parameters\", {\n  gridSize: {\n    min: 2,\n    max: 10,\n    \"default\": 2\n  },\n  tileSize: {\n    min: 25,\n    max: 100,\n    \"default\": 90\n  },\n  flowIntensity: {\n    min: 0,\n    max: 100,\n    \"default\": 50\n  },\n  patternBalance: {\n    min: 0,\n    max: 100,\n    \"default\": 100\n  },\n  contrast: {\n    min: 0,\n    max: 100,\n    \"default\": 50\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TruchetSmooth);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/TruchetSmooth.js?");

/***/ }),

/***/ "./src/shapes/TwistedCubeShape.js":
/*!****************************************!*\
  !*** ./src/shapes/TwistedCubeShape.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a 3D wireframe cube that twists along its depth, with adjustable\n * rotation and segments.\n */\nvar TwistedCubeShape = /*#__PURE__*/function (_Shape) {\n  function TwistedCubeShape() {\n    _classCallCheck(this, TwistedCubeShape);\n    return _callSuper(this, TwistedCubeShape, arguments);\n  }\n  _inherits(TwistedCubeShape, _Shape);\n  return _createClass(TwistedCubeShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var size = this.size;\n      var twist = this.twist;\n      var depth = this.depth / 10;\n      var segments = Math.floor(this.segments);\n      var thickness = this.thickness;\n      var rx = this.rotateX * Math.PI / 180;\n      var ry = this.rotateY * Math.PI / 180;\n      var rz = this.rotateZ * Math.PI / 180;\n      var vertices = [];\n      var edges = [];\n\n      // Generate base vertices at each segment\n      for (var i = 0; i <= segments; i++) {\n        var factor = i / segments;\n        var angleOffset = factor * twist * Math.PI;\n        for (var j = 0; j < 4; j++) {\n          var angle = j * Math.PI / 2 + angleOffset;\n          var x = size * Math.cos(angle);\n          var y = size * Math.sin(angle);\n          var z = (factor - 0.5) * size * depth;\n\n          // Apply 3D rotations\n          var _this$rotate3D = this.rotate3D(x, y, z, rx, ry, rz),\n            _this$rotate3D2 = _slicedToArray(_this$rotate3D, 3),\n            rx1 = _this$rotate3D2[0],\n            ry1 = _this$rotate3D2[1],\n            rz1 = _this$rotate3D2[2];\n          vertices.push([rx1, ry1, rz1]);\n        }\n      }\n\n      // Connect vertices with edges\n      for (var _i = 0; _i < segments; _i++) {\n        var baseIndex = _i * 4;\n\n        // Connect to next segment\n        for (var _j = 0; _j < 4; _j++) {\n          edges.push([baseIndex + _j, baseIndex + 4 + _j]);\n        }\n\n        // Connect within segment (square)\n        for (var _j2 = 0; _j2 < 4; _j2++) {\n          edges.push([baseIndex + _j2, baseIndex + (_j2 + 1) % 4]);\n        }\n\n        // Connect within next segment (square)\n        for (var _j3 = 0; _j3 < 4; _j3++) {\n          edges.push([baseIndex + 4 + _j3, baseIndex + 4 + (_j3 + 1) % 4]);\n        }\n      }\n\n      // Render edges as SVG lines\n      var lines = edges.map(function (edge) {\n        var _vertices$edge$ = _slicedToArray(vertices[edge[0]], 2),\n          x1 = _vertices$edge$[0],\n          y1 = _vertices$edge$[1];\n        var _vertices$edge$2 = _slicedToArray(vertices[edge[1]], 2),\n          x2 = _vertices$edge$2[0],\n          y2 = _vertices$edge$2[1];\n        return \"<line x1=\\\"\".concat(x1, \"\\\" y1=\\\"\").concat(y1, \"\\\" x2=\\\"\").concat(x2, \"\\\" y2=\\\"\").concat(y2, \"\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(thickness, \"\\\" />\");\n      });\n      return \"<g>\".concat(lines.join(''), \"</g>\");\n    }\n  }, {\n    key: \"rotate3D\",\n    value: function rotate3D(x, y, z, rx, ry, rz) {\n      // Rotate around X axis\n      var y1 = y * Math.cos(rx) - z * Math.sin(rx);\n      var z1 = y * Math.sin(rx) + z * Math.cos(rx);\n\n      // Rotate around Y axis\n      var x2 = x * Math.cos(ry) + z1 * Math.sin(ry);\n      var z2 = -x * Math.sin(ry) + z1 * Math.cos(ry);\n\n      // Rotate around Z axis\n      var x3 = x2 * Math.cos(rz) - y1 * Math.sin(rz);\n      var y3 = x2 * Math.sin(rz) + y1 * Math.cos(rz);\n      return [x3, y3, z2];\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(TwistedCubeShape, \"parameters\", {\n  size: {\n    min: 10,\n    max: 100,\n    \"default\": 100\n  },\n  twist: {\n    min: 0,\n    max: 2,\n    \"default\": 0.5\n  },\n  depth: {\n    min: 1,\n    max: 25,\n    \"default\": 10\n  },\n  segments: {\n    min: 2,\n    max: 12,\n    \"default\": 6\n  },\n  thickness: {\n    min: 0.5,\n    max: 5,\n    \"default\": 1.5\n  },\n  rotateX: {\n    min: 0,\n    max: 360,\n    \"default\": 0\n  },\n  rotateY: {\n    min: 0,\n    max: 360,\n    \"default\": 45\n  },\n  rotateZ: {\n    min: 0,\n    max: 360,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TwistedCubeShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/TwistedCubeShape.js?");

/***/ }),

/***/ "./src/shapes/TwistedStems.js":
/*!************************************!*\
  !*** ./src/shapes/TwistedStems.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a fractal pattern resembling twisted stems or branches radiating\n * from the center, using quadratic curves.\n */\nvar TwistedStems = /*#__PURE__*/function (_Shape) {\n  function TwistedStems() {\n    _classCallCheck(this, TwistedStems);\n    return _callSuper(this, TwistedStems, arguments);\n  }\n  _inherits(TwistedStems, _Shape);\n  return _createClass(TwistedStems, [{\n    key: \"drawBranch\",\n    value: function drawBranch(start, angle, length, depth, pathParts) {\n      // Calculate end point\n      var end = {\n        x: start.x + length * Math.cos(angle),\n        y: start.y + length * Math.sin(angle)\n      };\n\n      // Calculate control point with scaled curvature\n      var curveScale = Math.min(0.5, (this.curvature - 60) / 120); // Scale curvature effect\n      var curveOffset = length * curveScale;\n      var control = {\n        x: start.x + length * 0.5 * Math.cos(angle) - curveOffset * Math.sin(angle),\n        y: start.y + length * 0.5 * Math.sin(angle) + curveOffset * Math.cos(angle)\n      };\n\n      // Add current branch\n      pathParts.push(\"M \".concat(start.x, \" \").concat(start.y));\n      pathParts.push(\"Q \".concat(control.x, \" \").concat(control.y, \", \").concat(end.x, \" \").concat(end.y));\n\n      // Recursively draw sub-branches if we haven't reached max depth\n      if (depth > 1) {\n        var subLength = length * 0.6; // Reduce length for sub-branches\n        var spreadAngle = Math.PI / 6; // 30 degrees spread\n\n        // Draw left sub-branch\n        this.drawBranch(end, angle - spreadAngle, subLength, depth - 1, pathParts);\n\n        // Draw right sub-branch\n        this.drawBranch(end, angle + spreadAngle, subLength, depth - 1, pathParts);\n      }\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Scale factors to fit within viewBox\n      var scale = 200 / (this.spread * (this.depth + 1));\n      var baseLength = this.spread * scale;\n      var pathParts = [];\n\n      // Calculate angle step for main branches\n      var branches = Math.round(this.branches);\n      var angleStep = 2 * Math.PI / branches;\n\n      // Start point at center\n      var center = {\n        x: 0,\n        y: 0\n      };\n\n      // Draw each main branch\n      for (var i = 0; i < branches; i++) {\n        var angle = i * angleStep;\n        this.drawBranch(center, angle, baseLength, Math.round(this.depth), pathParts);\n      }\n      return \"<path \\n            d=\\\"\".concat(pathParts.join(' '), \"\\\"\\n            fill=\\\"none\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            stroke-linecap=\\\"round\\\"\\n            stroke-linejoin=\\\"round\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(TwistedStems, \"parameters\", {\n  branches: {\n    min: 4,\n    max: 8,\n    \"default\": 6\n  },\n  depth: {\n    min: 2,\n    max: 6,\n    \"default\": 3\n  },\n  spread: {\n    min: 30,\n    max: 100,\n    \"default\": 60\n  },\n  curvature: {\n    min: 60,\n    max: 120,\n    \"default\": 60\n  },\n  thickness: {\n    min: 1,\n    max: 6,\n    \"default\": 3\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TwistedStems);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/TwistedStems.js?");

/***/ }),

/***/ "./src/shapes/Vase.js":
/*!****************************!*\
  !*** ./src/shapes/Vase.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a symmetrical vase or vessel profile with modulated width and\n * optional rounding.\n */\nvar VaseShape = /*#__PURE__*/function (_Shape) {\n  function VaseShape() {\n    _classCallCheck(this, VaseShape);\n    return _callSuper(this, VaseShape, arguments);\n  }\n  _inherits(VaseShape, _Shape);\n  return _createClass(VaseShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var points = [];\n      var phaseRad = this.phase * Math.PI / 180;\n      var steps = this.segments * 2 + 1;\n\n      // Generate right side points\n      for (var i = 0; i < steps; i++) {\n        var t = i / (steps - 1);\n        var y = (t - 0.5) * this.height;\n\n        // Calculate waist modulation effect\n        var waistPos = this.waistPos / 100;\n        var waistModIntensity = this.waistMod / 100;\n        var waistEffect = Math.exp(-Math.pow((t - waistPos) * 4, 2)) * waistModIntensity;\n\n        // Apply base width with waist narrowing\n        var baseWidth = this.width * (1 - waistEffect * 0.7);\n\n        // Calculate side modulation\n        var modAmt = this.modulation / 100 * this.width * 0.3;\n        var mod = Math.sin(t * Math.PI * this.segments * 2 + phaseRad) * modAmt;\n        var x = baseWidth + mod;\n        points.push([x, y]);\n      }\n\n      // Create SVG path\n      var roundingRadius = this.rounding / 100 * 30;\n      if (roundingRadius > 0) {\n        var pathData = '';\n\n        // Helper functions\n        var distance = function distance(p1, p2) {\n          var dx = p2[0] - p1[0];\n          var dy = p2[1] - p1[1];\n          return Math.sqrt(dx * dx + dy * dy);\n        };\n        var getDirection = function getDirection(p1, p2) {\n          var dx = p2[0] - p1[0];\n          var dy = p2[1] - p1[1];\n          var len = Math.sqrt(dx * dx + dy * dy);\n          return [dx / len, dy / len];\n        };\n\n        // Generate right side path\n        pathData = \"M \".concat(points[0][0], \",\").concat(points[0][1]);\n        for (var _i = 1; _i < points.length - 1; _i++) {\n          var prev = points[_i - 1];\n          var curr = points[_i];\n          var next = points[_i + 1];\n          var d1 = distance(prev, curr);\n          var d2 = distance(curr, next);\n          var radius = Math.min(roundingRadius, d1 * 0.49, d2 * 0.49);\n          var _getDirection = getDirection(prev, curr),\n            _getDirection2 = _slicedToArray(_getDirection, 2),\n            dir1x = _getDirection2[0],\n            dir1y = _getDirection2[1];\n          var _getDirection3 = getDirection(curr, next),\n            _getDirection4 = _slicedToArray(_getDirection3, 2),\n            dir2x = _getDirection4[0],\n            dir2y = _getDirection4[1];\n          var p1x = curr[0] - dir1x * radius;\n          var p1y = curr[1] - dir1y * radius;\n          var p2x = curr[0] + dir2x * radius;\n          var p2y = curr[1] + dir2y * radius;\n          pathData += \" L \".concat(p1x, \",\").concat(p1y, \" Q \").concat(curr[0], \",\").concat(curr[1], \" \").concat(p2x, \",\").concat(p2y);\n        }\n\n        // Add final line to last point\n        pathData += \" L \".concat(points[points.length - 1][0], \",\").concat(points[points.length - 1][1]);\n\n        // Generate left side path (mirrored)\n        pathData += \" L \".concat(-points[points.length - 1][0], \",\").concat(points[points.length - 1][1]);\n        for (var _i2 = points.length - 2; _i2 > 0; _i2--) {\n          var _next = points[_i2 - 1];\n          var _curr = points[_i2];\n          var _prev = points[_i2 + 1];\n          var _d = distance(_prev, _curr);\n          var _d2 = distance(_curr, _next);\n          var _radius = Math.min(roundingRadius, _d * 0.49, _d2 * 0.49);\n          var _getDirection5 = getDirection(_prev, _curr),\n            _getDirection6 = _slicedToArray(_getDirection5, 2),\n            _dir1x = _getDirection6[0],\n            _dir1y = _getDirection6[1];\n          var _getDirection7 = getDirection(_curr, _next),\n            _getDirection8 = _slicedToArray(_getDirection7, 2),\n            _dir2x = _getDirection8[0],\n            _dir2y = _getDirection8[1];\n          var _p1x = -(_curr[0] - _dir1x * _radius);\n          var _p1y = _curr[1] - _dir1y * _radius;\n          var _p2x = -(_curr[0] + _dir2x * _radius);\n          var _p2y = _curr[1] + _dir2y * _radius;\n          pathData += \" L \".concat(_p1x, \",\").concat(_p1y, \" Q \").concat(-_curr[0], \",\").concat(_curr[1], \" \").concat(_p2x, \",\").concat(_p2y);\n        }\n\n        // Close the path\n        pathData += \" L \".concat(-points[0][0], \",\").concat(points[0][1], \" Z\");\n        return \"<path d=\\\"\".concat(pathData, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\"/>\");\n      } else {\n        // Simple polygonal path without rounding\n        var _pathData = \"M \".concat(points[0][0], \",\").concat(points[0][1]);\n        for (var _i3 = 1; _i3 < points.length; _i3++) {\n          _pathData += \" L \".concat(points[_i3][0], \",\").concat(points[_i3][1]);\n        }\n        for (var _i4 = points.length - 1; _i4 >= 0; _i4--) {\n          _pathData += \" L \".concat(-points[_i4][0], \",\").concat(points[_i4][1]);\n        }\n        _pathData += ' Z';\n        return \"<g transform=\\\"scale(\".concat(this.scale, \")\\\">\\n        <path d=\\\"\").concat(_pathData, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\"/>\\n    </g>\");\n      }\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(VaseShape, \"parameters\", {\n  segments: {\n    min: 2,\n    max: 8,\n    \"default\": 4\n  },\n  height: {\n    min: 100,\n    max: 200,\n    \"default\": 120\n  },\n  width: {\n    min: 20,\n    max: 100,\n    \"default\": 42\n  },\n  modulation: {\n    min: 10,\n    max: 100,\n    \"default\": 82\n  },\n  phase: {\n    min: -180,\n    max: 180,\n    \"default\": 90\n  },\n  rounding: {\n    min: 0,\n    max: 100,\n    \"default\": 100\n  },\n  waistMod: {\n    min: 0,\n    max: 100,\n    \"default\": 50\n  },\n  waistPos: {\n    min: 0,\n    max: 100,\n    \"default\": 50\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (VaseShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/Vase.js?");

/***/ }),

/***/ "./src/shapes/VoronoiShape.js":
/*!************************************!*\
  !*** ./src/shapes/VoronoiShape.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a Voronoi diagram pattern clipped within a circle, based on\n * randomly placed points.\n */\nvar VoronoiShape = /*#__PURE__*/function (_Shape) {\n  function VoronoiShape() {\n    _classCallCheck(this, VoronoiShape);\n    return _callSuper(this, VoronoiShape, arguments);\n  }\n  _inherits(VoronoiShape, _Shape);\n  return _createClass(VoronoiShape, [{\n    key: \"generatePoints\",\n    value: function generatePoints() {\n      this.resetRNG();\n      var points = [];\n      points.push([0, 0]);\n      var boundaryPointCount = Math.max(12, Math.floor(this.pointCount / 3));\n      for (var i = 0; i < boundaryPointCount; i++) {\n        var angle = i * 2 * Math.PI / boundaryPointCount;\n        var r = this.radius * 0.95;\n        points.push([r * Math.cos(angle), r * Math.sin(angle)]);\n      }\n      var minDist = this.radius * 0.5 / Math.sqrt(this.pointCount);\n      var attempts = 0;\n      var maxAttempts = this.pointCount * 20;\n      while (points.length < this.pointCount + boundaryPointCount && attempts < maxAttempts) {\n        attempts++;\n        var _angle = this.random() * Math.PI * 2;\n        var _r = this.radius * 0.9 * Math.sqrt(this.random());\n        var x = _r * Math.cos(_angle);\n        var y = _r * Math.sin(_angle);\n        var distFromCenter = Math.hypot(x, y);\n        var jitterScale = 1 - distFromCenter / this.radius;\n        var scaledJitter = this.jitter * jitterScale;\n        if (scaledJitter > 0) {\n          var jitterAngle = this.random() * Math.PI * 2;\n          var jitterAmount = this.random() * scaledJitter;\n          x += jitterAmount * Math.cos(jitterAngle);\n          y += jitterAmount * Math.sin(jitterAngle);\n        }\n        var tooClose = false;\n        var _iterator = _createForOfIteratorHelper(points),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var point = _step.value;\n            var dist = Math.hypot(x - point[0], y - point[1]);\n            if (dist < minDist) {\n              tooClose = true;\n              break;\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        if (!tooClose && Math.hypot(x, y) <= this.radius * 0.95) {\n          points.push([x, y]);\n        }\n      }\n      return points;\n    }\n  }, {\n    key: \"delaunayTriangulate\",\n    value: function delaunayTriangulate(points) {\n      var circumcircle = function circumcircle(a, b, c) {\n        var ax = a[0],\n          ay = a[1];\n        var bx = b[0],\n          by = b[1];\n        var cx = c[0],\n          cy = c[1];\n        var d = 2 * (ax * (by - cy) + bx * (cy - ay) + cx * (ay - by));\n        if (Math.abs(d) < 1e-10) return {\n          x: 0,\n          y: 0,\n          radius: Infinity\n        };\n        var aSq = ax * ax + ay * ay;\n        var bSq = bx * bx + by * by;\n        var cSq = cx * cx + cy * cy;\n        var x = (aSq * (by - cy) + bSq * (cy - ay) + cSq * (ay - by)) / d;\n        var y = (aSq * (cx - bx) + bSq * (ax - cx) + cSq * (bx - ax)) / d;\n        var radius = Math.hypot(x - ax, y - ay);\n        return {\n          x: x,\n          y: y,\n          radius: radius\n        };\n      };\n      var inCircumcircle = function inCircumcircle(point, triangle, circle) {\n        return Math.hypot(point[0] - circle.x, point[1] - circle.y) < circle.radius;\n      };\n      var maxRadius = this.radius * 2;\n      var superTriangle = [[-maxRadius, -maxRadius], [0, maxRadius * 2], [maxRadius * 2, -maxRadius]];\n      var triangles = [{\n        vertices: [0, 1, 2],\n        points: superTriangle\n      }];\n      var _loop = function _loop() {\n        var point = points[i];\n        var edges = [];\n        triangles = triangles.filter(function (triangle) {\n          var circle = circumcircle(triangle.points[0], triangle.points[1], triangle.points[2]);\n          var contained = inCircumcircle(point, triangle, circle);\n          if (contained) {\n            edges.push([triangle.vertices[0], triangle.vertices[1]]);\n            edges.push([triangle.vertices[1], triangle.vertices[2]]);\n            edges.push([triangle.vertices[2], triangle.vertices[0]]);\n          }\n          return !contained;\n        });\n        var uniqueEdges = [];\n        for (var _i = 0, _edges = edges; _i < _edges.length; _i++) {\n          var edge = _edges[_i];\n          var isUnique = true;\n          var _iterator2 = _createForOfIteratorHelper(edges),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var otherEdge = _step2.value;\n              if (edge !== otherEdge) {\n                if (edge[0] === otherEdge[1] && edge[1] === otherEdge[0] || edge[0] === otherEdge[0] && edge[1] === otherEdge[1]) {\n                  isUnique = false;\n                  break;\n                }\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n          if (isUnique) {\n            uniqueEdges.push(edge);\n          }\n        }\n        for (var _i2 = 0, _uniqueEdges = uniqueEdges; _i2 < _uniqueEdges.length; _i2++) {\n          var _edge = _uniqueEdges[_i2];\n          triangles.push({\n            vertices: [_edge[0], _edge[1], i + 3],\n            points: [_edge[0] < 3 ? superTriangle[_edge[0]] : points[_edge[0] - 3], _edge[1] < 3 ? superTriangle[_edge[1]] : points[_edge[1] - 3], point]\n          });\n        }\n      };\n      for (var i = 0; i < points.length; i++) {\n        _loop();\n      }\n      triangles = triangles.filter(function (triangle) {\n        return !(triangle.vertices[0] < 3 || triangle.vertices[1] < 3 || triangle.vertices[2] < 3);\n      });\n      return triangles.map(function (t) {\n        return {\n          indices: t.vertices.map(function (v) {\n            return v - 3;\n          }),\n          points: t.points\n        };\n      });\n    }\n  }, {\n    key: \"computeVoronoiCells\",\n    value: function computeVoronoiCells(points, triangles) {\n      var _this = this;\n      var cells = new Array(points.length).fill(0).map(function () {\n        return [];\n      });\n      triangles.forEach(function (triangle) {\n        var indices = triangle.indices,\n          triPoints = triangle.points;\n        var _triPoints = _slicedToArray(triPoints, 3),\n          a = _triPoints[0],\n          b = _triPoints[1],\n          c = _triPoints[2];\n        var d = 2 * (a[0] * (b[1] - c[1]) + b[0] * (c[1] - a[1]) + c[0] * (a[1] - b[1]));\n        if (Math.abs(d) < 1e-10) return;\n        var aSq = a[0] * a[0] + a[1] * a[1];\n        var bSq = b[0] * b[0] + b[1] * b[1];\n        var cSq = c[0] * c[0] + c[1] * c[1];\n        var circumcenterX = (aSq * (b[1] - c[1]) + bSq * (c[1] - a[1]) + cSq * (a[1] - b[1])) / d;\n        var circumcenterY = (aSq * (c[0] - b[0]) + bSq * (a[0] - c[0]) + cSq * (b[0] - a[0])) / d;\n        var voronoiVertex = [circumcenterX, circumcenterY];\n        indices.forEach(function (index) {\n          if (index >= 0 && index < points.length) {\n            cells[index].push(voronoiVertex);\n          }\n        });\n      });\n      return cells.map(function (vertices, i) {\n        if (vertices.length < 3) return null;\n        var center = points[i];\n        var sortedVertices = vertices.sort(function (a, b) {\n          var angleA = Math.atan2(a[1] - center[1], a[0] - center[0]);\n          var angleB = Math.atan2(b[1] - center[1], b[0] - center[0]);\n          return angleA - angleB;\n        });\n        return _this.clipCellToCircle(sortedVertices, center);\n      }).filter(function (cell) {\n        return cell !== null;\n      });\n    }\n  }, {\n    key: \"clipCellToCircle\",\n    value: function clipCellToCircle(vertices, center) {\n      if (vertices.length < 3) return null;\n      var result = [];\n      var r = this.radius;\n      var _loop2 = function _loop2() {\n        var current = vertices[i];\n        var next = vertices[(i + 1) % vertices.length];\n        if (Math.hypot(current[0], current[1]) <= r) {\n          result.push(current);\n        }\n        var dx = next[0] - current[0];\n        var dy = next[1] - current[1];\n        var a = dx * dx + dy * dy;\n        var b = 2 * (dx * current[0] + dy * current[1]);\n        var c = current[0] * current[0] + current[1] * current[1] - r * r;\n        var discriminant = b * b - 4 * a * c;\n        if (discriminant >= 0) {\n          var t1 = (-b + Math.sqrt(discriminant)) / (2 * a);\n          var t2 = (-b - Math.sqrt(discriminant)) / (2 * a);\n          [t1, t2].forEach(function (t) {\n            if (t >= 0 && t <= 1) {\n              var intersectX = current[0] + t * dx;\n              var intersectY = current[1] + t * dy;\n              result.push([intersectX, intersectY]);\n            }\n          });\n        }\n      };\n      for (var i = 0; i < vertices.length; i++) {\n        _loop2();\n      }\n      return result.length >= 3 ? result : null;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this2 = this;\n      var points = this.generatePoints();\n      var triangles = this.delaunayTriangulate(points);\n      var cells = this.computeVoronoiCells(points, triangles);\n      var svgContent = \"<circle \\n            cx=\\\"0\\\" \\n            cy=\\\"0\\\" \\n            r=\\\"\".concat(this.radius, \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.borderThickness, \"\\\"\\n            fill=\\\"none\\\"\\n        />\");\n      cells.forEach(function (cell) {\n        if (cell && cell.length >= 3) {\n          var pathData = \"M \".concat(cell[0][0], \" \").concat(cell[0][1]);\n          for (var i = 1; i < cell.length; i++) {\n            pathData += \" L \".concat(cell[i][0], \" \").concat(cell[i][1]);\n          }\n          pathData += ' Z';\n          svgContent += \"<path \\n                    d=\\\"\".concat(pathData, \"\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(_this2.cellLineThickness, \"\\\"\\n                    fill=\\\"none\\\"\\n                />\");\n        }\n      });\n      return svgContent;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(VoronoiShape, \"parameters\", {\n  radius: {\n    min: 50,\n    max: 150,\n    \"default\": 100\n  },\n  pointCount: {\n    min: 5,\n    max: 100,\n    \"default\": 30\n  },\n  borderThickness: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  },\n  cellLineThickness: {\n    min: 1,\n    max: 5,\n    \"default\": 2\n  },\n  jitter: {\n    min: 0,\n    max: 30,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (VoronoiShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/VoronoiShape.js?");

/***/ }),

/***/ "./src/shapes/Wave.js":
/*!****************************!*\
  !*** ./src/shapes/Wave.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a smooth, horizontal wave-like path using cubic Bezier curves.\n */\nvar WaveShape = /*#__PURE__*/function (_Shape) {\n  function WaveShape() {\n    _classCallCheck(this, WaveShape);\n    return _callSuper(this, WaveShape, arguments);\n  }\n  _inherits(WaveShape, _Shape);\n  return _createClass(WaveShape, [{\n    key: \"getControlPoints\",\n    value: function getControlPoints(x1, y1, x2, y2, smoothing) {\n      var dx = x2 - x1;\n      var tension = 1 - Math.max(0.1, Math.min(0.9, smoothing));\n      return {\n        cp1x: x1 + dx * tension,\n        cp1y: y1,\n        cp2x: x2 - dx * tension,\n        cp2y: y2\n      };\n    }\n  }, {\n    key: \"generateWavePoints\",\n    value: function generateWavePoints() {\n      var width = 160;\n      var segments = this.frequency * 2; // 2 points per wave cycle\n      var points = [];\n      var phaseRad = this.phase * Math.PI / 180;\n      for (var i = 0; i <= segments; i++) {\n        var t = i / segments;\n        var x = -width / 2 + width * t;\n        var y = 0;\n        y = Math.sin(t * Math.PI * 2 * this.frequency + phaseRad);\n        points.push([x, y * this.amplitude]);\n      }\n      return points;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var points = this.generateWavePoints();\n      var d = \"M \".concat(points[0][0], \" \").concat(points[0][1]);\n      for (var i = 1; i < points.length; i++) {\n        var curr = points[i];\n        var prev = points[i - 1];\n        var cp = this.getControlPoints(prev[0], prev[1], curr[0], curr[1], this.waveType === 'square' ? 0.1 : this.smoothness);\n        d += \" C \".concat(cp.cp1x, \" \").concat(cp.cp1y, \" \").concat(cp.cp2x, \" \").concat(cp.cp2y, \" \").concat(curr[0], \" \").concat(curr[1]);\n      }\n      return \"<path \\n            d=\\\"\".concat(d, \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            fill=\\\"none\\\"\\n            stroke-linecap=\\\"round\\\"\\n            stroke-linejoin=\\\"round\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(WaveShape, \"parameters\", {\n  amplitude: {\n    min: 10,\n    max: 150,\n    \"default\": 72\n  },\n  frequency: {\n    min: 1,\n    max: 8,\n    \"default\": 3\n  },\n  phase: {\n    min: -180,\n    max: 180,\n    \"default\": 30\n  },\n  thickness: {\n    min: 1,\n    max: 16,\n    \"default\": 6\n  },\n  smoothness: {\n    min: 0.1,\n    max: 1,\n    \"default\": 0.1\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WaveShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/Wave.js?");

/***/ }),

/***/ "./src/shapes/WaveField.js":
/*!*********************************!*\
  !*** ./src/shapes/WaveField.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a field of parallel wavy lines with adjustable count, amplitude,\n * frequency, and spacing.\n */\nvar WaveField = /*#__PURE__*/function (_Shape) {\n  function WaveField() {\n    _classCallCheck(this, WaveField);\n    return _callSuper(this, WaveField, arguments);\n  }\n  _inherits(WaveField, _Shape);\n  return _createClass(WaveField, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Convert parameters to proper scales and units\n      var waves = Math.round(this.waves);\n      var phase = this.phase * (Math.PI / 180); // Convert degrees to radians\n      var scale = 0.8; // Scale factor for the viewBox size\n      var spacing = this.layerSpacing * scale;\n\n      // Calculate safe bounds for the wave field\n      var padding = this.thickness * 2;\n      var width = 200 - padding * 2; // Based on viewBox size\n      var height = 200 - padding * 2;\n      var startX = -100 + padding;\n      var startY = -100 + padding;\n\n      // Calculate maximum safe amplitude to prevent out-of-bounds\n      var totalWaveHeight = (waves - 1) * spacing;\n      var maxAmplitude = (height - totalWaveHeight) / 2;\n      var amplitude = Math.min(this.amplitude * scale, maxAmplitude);\n\n      // Calculate vertical center position\n      var centerY = 0; // Center of viewBox\n      var waveStartY = centerY - totalWaveHeight / 2;\n      var steps = 60;\n      var lines = [];\n\n      // Generate each wave\n      for (var wave = 0; wave < waves; wave++) {\n        var wavePhase = phase + wave * Math.PI / 2;\n        var baseY = waveStartY + wave * spacing;\n        var points = [];\n\n        // Calculate points for this wave\n        for (var step = 0; step <= steps; step++) {\n          var progress = step / steps;\n          var x = startX + width * progress;\n          var y = baseY;\n          if (this.frequency > 0) {\n            // Standard sine wave\n            y += amplitude * Math.sin(2 * Math.PI * this.frequency * progress + wavePhase);\n          } else {\n            // Special case for frequency = 0: gentle slope\n            var slope = Math.sin(wavePhase);\n            var normalizedProgress = 2 * progress - 1; // -1 to 1\n            y += amplitude * slope * (1 - normalizedProgress * normalizedProgress);\n          }\n\n          // Ensure point stays within bounds\n          y = Math.max(startY, Math.min(y, startY + height));\n          points.push(\"\".concat(x, \",\").concat(y));\n        }\n\n        // Create polyline for this wave\n        if (points.length > 0) {\n          lines.push(\"<polyline \\n                    points=\\\"\".concat(points.join(' '), \"\\\"\\n                    fill=\\\"none\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                    stroke-linecap=\\\"round\\\"\\n                    stroke-linejoin=\\\"round\\\"\\n                />\"));\n        }\n      }\n      return lines.join('\\n');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(WaveField, \"parameters\", {\n  waves: {\n    min: 3,\n    max: 6,\n    \"default\": 4\n  },\n  amplitude: {\n    min: 25,\n    max: 85,\n    \"default\": 40\n  },\n  frequency: {\n    min: 1,\n    max: 4,\n    \"default\": 2\n  },\n  phase: {\n    min: -180,\n    max: 180,\n    \"default\": 0\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  },\n  layerSpacing: {\n    min: 10,\n    max: 50,\n    \"default\": 20\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WaveField);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/WaveField.js?");

/***/ }),

/***/ "./src/shapes/WaveFlower.js":
/*!**********************************!*\
  !*** ./src/shapes/WaveFlower.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a flower-like pattern composed of multiple concentric rings with\n * wavy edges.\n */\nvar WaveFlower = /*#__PURE__*/function (_Shape) {\n  function WaveFlower() {\n    _classCallCheck(this, WaveFlower);\n    return _callSuper(this, WaveFlower, arguments);\n  }\n  _inherits(WaveFlower, _Shape);\n  return _createClass(WaveFlower, [{\n    key: \"getRadius\",\n    value: function getRadius(angle, baseRadius, waveFreq, phase, amplitude) {\n      // Convert phase to radians and calculate wave pattern\n      var wavePattern = Math.cos(angle * waveFreq + phase * Math.PI / 180);\n      return baseRadius + amplitude * wavePattern;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Scale parameters to fit within viewBox (-200 -200 400 400)\n      var scale = 0.8; // Scale to fit viewBox\n      var maxRadius = 100 - this.thickness * scale;\n\n      // Scale the parameters\n      var baseRadius = this.radius * scale * 0.5;\n      var thickness = this.thickness * scale;\n      var spacing = this.spacing * scale * 0.5;\n      var waveAmplitude = this.waveAmplitude * scale * 0.5;\n      var paths = [];\n\n      // Generate each ring\n      for (var i = 0; i < this.ringCount; i++) {\n        var ringProgress = i / Math.max(1, this.ringCount - 1);\n        var computedRingRadius = baseRadius + spacing * i;\n        var ringRadius = Math.min(computedRingRadius, maxRadius - waveAmplitude);\n\n        // Generate points for the ring\n        var numPoints = 360; // High resolution for smooth curves\n        var angleStep = 2 * Math.PI / numPoints;\n        var ringPoints = [];\n        for (var p = 0; p <= numPoints; p++) {\n          var angle = p * angleStep;\n          var currentRadius = this.getRadius(angle, ringRadius, this.waveFrequency, this.phase + ringProgress * 180, waveAmplitude);\n          var x = currentRadius * Math.cos(angle);\n          var y = currentRadius * Math.sin(angle);\n          if (p === 0) {\n            ringPoints.push(\"M \".concat(x, \" \").concat(y));\n          } else {\n            ringPoints.push(\"L \".concat(x, \" \").concat(y));\n          }\n        }\n\n        // Close the path\n        ringPoints.push('Z');\n\n        // Add the ring to our collection\n        paths.push(\"<path \\n                d=\\\"\".concat(ringPoints.join(' '), \"\\\"\\n                fill=\\\"none\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(thickness, \"\\\"\\n                stroke-linecap=\\\"round\\\"\\n                stroke-linejoin=\\\"round\\\"\\n            />\"));\n      }\n\n      // Return all paths as a single string\n      return paths.join('\\n');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(WaveFlower, \"parameters\", {\n  ringCount: {\n    min: 4,\n    max: 12,\n    \"default\": 6\n  },\n  radius: {\n    min: 50,\n    max: 150,\n    \"default\": 40\n  },\n  thickness: {\n    min: 1,\n    max: 8,\n    \"default\": 5\n  },\n  spacing: {\n    min: 10,\n    max: 50,\n    \"default\": 30\n  },\n  phase: {\n    min: -180,\n    max: 180,\n    \"default\": 45\n  },\n  waveAmplitude: {\n    min: 0,\n    max: 50,\n    \"default\": 20\n  },\n  waveFrequency: {\n    min: 5,\n    max: 10,\n    \"default\": 6\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WaveFlower);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/WaveFlower.js?");

/***/ }),

/***/ "./src/shapes/WaveFrame.js":
/*!*********************************!*\
  !*** ./src/shapes/WaveFrame.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n/**\n * Generates a regular polygon shape where each edge is replaced by a wavy line.\n */\nvar WaveFrame = /*#__PURE__*/function (_Shape) {\n  function WaveFrame() {\n    _classCallCheck(this, WaveFrame);\n    return _callSuper(this, WaveFrame, arguments);\n  }\n  _inherits(WaveFrame, _Shape);\n  return _createClass(WaveFrame, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      this.sides = Math.round(this.sides);\n      this.phaseRad = this.phase * Math.PI / 180;\n      this.freq2Pi = this.frequency * 2 * Math.PI;\n      this.startPhase = Math.PI / 2;\n\n      // Limit maximum curve complexity\n      var maxCurves = Math.min(this.frequency * 2, 12);\n      var curvesPerEdge = Math.max(4, maxCurves);\n\n      // Pre-calculate sine and cosine values for vertices\n      var angleStep = 2 * Math.PI / this.sides;\n      var radius = this.size / 2;\n\n      // Generate vertices\n      var vertices = [];\n      for (var i = 0; i <= this.sides; i++) {\n        var angle = i % this.sides * angleStep;\n        var x = radius * Math.cos(angle);\n        var y = radius * Math.sin(angle);\n        vertices.push([x, y]);\n      }\n\n      // Build path\n      var path = '';\n      for (var _i = 0; _i < this.sides; _i++) {\n        // Make sure both vertices exist before calling generateWaveEdge\n        if (vertices[_i] && vertices[_i + 1]) {\n          path += this.generateWaveEdge(vertices[_i], vertices[_i + 1], curvesPerEdge);\n        }\n      }\n      return \"<path d=\\\"\".concat(path, \" Z\\\" fill=\\\"white\\\"/>\");\n    }\n  }, {\n    key: \"generateWaveEdge\",\n    value: function generateWaveEdge(start, end, curveCount) {\n      var _this = this;\n      // Ensure we have valid start and end points\n      if (!start || !end || !Array.isArray(start) || !Array.isArray(end) || start.length < 2 || end.length < 2) {\n        return '';\n      }\n\n      // Pre-calculate edge vectors\n      var dx = end[0] - start[0];\n      var dy = end[1] - start[1];\n      var edgeLength = Math.sqrt(dx * dx + dy * dy);\n\n      // Early exit for very small edges\n      if (edgeLength < 1) return '';\n\n      // Cache normalized vectors\n      var invLength = 1 / edgeLength;\n      var normal = [-dy * invLength, dx * invLength];\n      var tangent = [dx * invLength, dy * invLength];\n\n      // Pre-calculate control point distance\n      var controlDist = edgeLength / curveCount * this.smoothness;\n      var path = '';\n\n      // Use a more efficient wave calculation\n      var calculateWavePoint = function calculateWavePoint(t) {\n        var waveT = _this.startPhase + t * _this.freq2Pi + _this.phaseRad;\n        var sinT = Math.sin(waveT);\n        var cosT = Math.cos(waveT);\n        var offset = sinT * _this.amplitude;\n        var derivative = cosT * _this.amplitude * _this.freq2Pi;\n\n        // Base point\n        var x = start[0] + dx * t;\n        var y = start[1] + dy * t;\n\n        // Offset point\n        var px = x + normal[0] * offset;\n        var py = y + normal[1] * offset;\n\n        // Tangent vector (optimized calculation)\n        var tx = tangent[0] - normal[0] * derivative * invLength;\n        var ty = tangent[1] - normal[1] * derivative * invLength;\n        return {\n          point: [px, py],\n          tangent: [tx, ty]\n        };\n      };\n\n      // Generate curve segments\n      for (var i = 0; i < curveCount; i++) {\n        var t0 = i / curveCount;\n        var t1 = (i + 1) / curveCount;\n        var p0 = calculateWavePoint(t0);\n        var p1 = calculateWavePoint(t1);\n\n        // Calculate control points\n        var cp1x = p0.point[0] + p0.tangent[0] * controlDist;\n        var cp1y = p0.point[1] + p0.tangent[1] * controlDist;\n        var cp2x = p1.point[0] - p1.tangent[0] * controlDist;\n        var cp2y = p1.point[1] - p1.tangent[1] * controlDist;\n        if (i === 0) {\n          path = \"M \".concat(p0.point[0], \",\").concat(p0.point[1]);\n        }\n        path += \" C \".concat(cp1x, \",\").concat(cp1y, \" \").concat(cp2x, \",\").concat(cp2y, \" \").concat(p1.point[0], \",\").concat(p1.point[1]);\n      }\n      return path;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(WaveFrame, \"parameters\", {\n  size: {\n    min: 50,\n    max: 150,\n    \"default\": 150\n  },\n  sides: {\n    min: 3,\n    max: 12,\n    \"default\": 6\n  },\n  amplitude: {\n    min: 1,\n    max: 50,\n    \"default\": 20\n  },\n  frequency: {\n    min: 1,\n    max: 20,\n    \"default\": 2\n  },\n  phase: {\n    min: -180,\n    max: 180,\n    \"default\": 0\n  },\n  smoothness: {\n    min: 0.1,\n    max: 1,\n    \"default\": 1.0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WaveFrame);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/WaveFrame.js?");

/***/ }),

/***/ "./src/shapes/WavePattern.js":
/*!***********************************!*\
  !*** ./src/shapes/WavePattern.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a pattern of stacked horizontal zigzag (wave) lines.\n */\nvar WavePattern = /*#__PURE__*/function (_Shape) {\n  function WavePattern() {\n    _classCallCheck(this, WavePattern);\n    return _callSuper(this, WavePattern, arguments);\n  }\n  _inherits(WavePattern, _Shape);\n  return _createClass(WavePattern, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var waves = [];\n      var segmentHeight = this.segmentWidth; // Maintain 45-degree angles\n\n      // Calculate total dimensions\n      var totalWidth = this.columns * this.segmentWidth;\n      var totalHeight = (this.rows - 1) * this.rowSpacing;\n\n      // Center the pattern\n      var startX = -totalWidth / 2;\n      var startY = -totalHeight / 2;\n\n      // Generate each row\n      for (var row = 0; row < this.rows; row++) {\n        var y = startY + row * this.rowSpacing;\n        var points = [];\n\n        // Generate points based on column count\n        for (var i = 0; i <= this.columns; i++) {\n          var x = startX + i * this.segmentWidth;\n          var yOffset = i % 2 === 0 ? 0 : segmentHeight;\n          points.push(\"\".concat(x, \",\").concat(y + yOffset));\n        }\n        waves.push(\"<polyline \\n                points=\\\"\".concat(points.join(' '), \"\\\"\\n                fill=\\\"none\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                stroke-linecap=\\\"square\\\"\\n                stroke-linejoin=\\\"miter\\\"\\n            />\"));\n      }\n      return waves.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(WavePattern, \"parameters\", {\n  rows: {\n    min: 1,\n    max: 6,\n    \"default\": 4\n  },\n  columns: {\n    min: 2,\n    max: 8,\n    \"default\": 6\n  },\n  segmentWidth: {\n    min: 20,\n    max: 60,\n    \"default\": 25\n  },\n  thickness: {\n    min: 4,\n    max: 20,\n    \"default\": 10\n  },\n  rowSpacing: {\n    min: 20,\n    max: 80,\n    \"default\": 35\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WavePattern);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/WavePattern.js?");

/***/ }),

/***/ "./src/shapes/WavingRibbonsShape.js":
/*!******************************************!*\
  !*** ./src/shapes/WavingRibbonsShape.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a pattern of parallel, wavy ribbons flowing horizontally.\n */\nvar WavingRibbonsShape = /*#__PURE__*/function (_Shape) {\n  function WavingRibbonsShape() {\n    _classCallCheck(this, WavingRibbonsShape);\n    return _callSuper(this, WavingRibbonsShape, arguments);\n  }\n  _inherits(WavingRibbonsShape, _Shape);\n  return _createClass(WavingRibbonsShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var size = 200; // Fixed 200x200 size\n      var elements = [];\n\n      // Calculate the actual width based on horizontal scale\n      var width = size * this.horizontalScale;\n\n      // Calculate spacing for lines\n      var lineSpacing = size / (this.lineCount + 1);\n\n      // Generate each flow curve\n      var allPaths = [];\n      for (var i = 0; i < this.lineCount; i++) {\n        // Y position of current line\n        var y = -size / 2 + lineSpacing * (i + 1);\n\n        // Alternate curve direction for each line\n        var isEven = i % 2 === 0;\n\n        // Generate clean, precise S-curve\n        var path = this.createPreciseCurve(y, width, isEven);\n        allPaths.push(path);\n      }\n\n      // Combine all paths into a single white filled shape\n      elements.push(\"<path d=\\\"\".concat(allPaths.join(' '), \"\\\" fill=\\\"white\\\" />\"));\n      return elements.join('');\n    }\n  }, {\n    key: \"createPreciseCurve\",\n    value: function createPreciseCurve(centerY, width, isEven) {\n      // Calculate dimensions\n      var halfWidth = width / 2;\n      var halfThickness = this.thickness / 2;\n\n      // Calculate curve control point offset based on curve amount\n      var curveOffset = halfWidth * this.curveAmount;\n\n      // The direction of the curve depends on whether the line is even or odd\n      var direction = isEven ? 1 : -1;\n\n      // Start with top-left corner\n      var path = \"M \".concat(-halfWidth, \",\").concat(centerY - halfThickness);\n\n      // Create the top curved edge with precise control points\n      path += \" C \".concat(-halfWidth / 3, \",\").concat(centerY - halfThickness - direction * curveOffset);\n      path += \" \".concat(halfWidth / 3, \",\").concat(centerY - halfThickness + direction * curveOffset);\n      path += \" \".concat(halfWidth, \",\").concat(centerY - halfThickness);\n\n      // Connect to top-right to bottom-right\n      path += \" L \".concat(halfWidth, \",\").concat(centerY + halfThickness);\n\n      // Create the bottom curved edge (reversed)\n      path += \" C \".concat(halfWidth / 3, \",\").concat(centerY + halfThickness + direction * curveOffset);\n      path += \" \".concat(-halfWidth / 3, \",\").concat(centerY + halfThickness - direction * curveOffset);\n      path += \" \".concat(-halfWidth, \",\").concat(centerY + halfThickness);\n\n      // Close the path\n      path += \" Z\";\n      return path;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(WavingRibbonsShape, \"parameters\", {\n  lineCount: {\n    min: 2,\n    max: 5,\n    \"default\": 3\n  },\n  thickness: {\n    min: 15,\n    max: 35,\n    \"default\": 25\n  },\n  curveAmount: {\n    min: 0.2,\n    max: 0.6,\n    \"default\": 0.4\n  },\n  horizontalScale: {\n    min: 0.6,\n    max: 0.9,\n    \"default\": 0.85\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WavingRibbonsShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/WavingRibbonsShape.js?");

/***/ }),

/***/ "./src/shapes/WavyBars.js":
/*!********************************!*\
  !*** ./src/shapes/WavyBars.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a stack of horizontal bars where the top and bottom edges\n * follow a shared sine wave pattern, creating a wavy effect.\n*/\nvar WavyBars = /*#__PURE__*/function (_Shape) {\n  function WavyBars() {\n    _classCallCheck(this, WavyBars);\n    return _callSuper(this, WavyBars, arguments);\n  }\n  _inherits(WavyBars, _Shape);\n  return _createClass(WavyBars, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var numBars = Math.floor(this.numBars); // Ensure integer\n      var barHeight = this.barHeight;\n      var gap = this.gap;\n      var amplitude = this.amplitude;\n      var frequency = this.frequency;\n      // Map phaseShift (-100 to 100) to a radian range (e.g., -PI to PI)\n      var phaseRad = this.phaseShift / 100 * Math.PI;\n      var totalItemHeight = barHeight + gap;\n      var totalHeight = numBars * barHeight + Math.max(0, numBars - 1) * gap;\n      var startY = -totalHeight / 2;\n      var width = 200; // Viewbox width (-100 to 100)\n      var steps = 50; // Number of points along the curve for approximation\n\n      var svgPaths = '';\n\n      // Wave function: y offset based on x position\n      var wave = function wave(x) {\n        // (x + 100) maps x from [-100, 100] to [0, 200]\n        // / width normalizes to [0, 1]\n        // * 2 * PI scales for a full cycle\n        // * frequency adjusts cycles across width\n        // + phaseRad shifts the wave\n        return amplitude * Math.sin((x + 100) / width * 2 * Math.PI * frequency + phaseRad);\n      };\n      for (var i = 0; i < numBars; i++) {\n        var yTop = startY + i * totalItemHeight;\n        var yBottom = yTop + barHeight;\n        var topPoints = [];\n        var bottomPoints = [];\n\n        // Generate points for the top edge (left to right)\n        for (var j = 0; j <= steps; j++) {\n          var x = -100 + width * j / steps;\n          var y = yTop + wave(x);\n          // Clamp y values to prevent extreme spikes going too far off screen\n          var clampedY = Math.max(-100, Math.min(100, y));\n          // Use toFixed(2) for cleaner SVG path data\n          topPoints.push(\"\".concat(x.toFixed(2), \",\").concat(clampedY.toFixed(2)));\n        }\n\n        // Generate points for the bottom edge (right to left for path continuity)\n        for (var _j = steps; _j >= 0; _j--) {\n          var _x = -100 + width * _j / steps;\n          var _y = yBottom + wave(_x);\n          // Clamp y values\n          var _clampedY = Math.max(-100, Math.min(100, _y));\n          // Use toFixed(2) for cleaner SVG path data\n          bottomPoints.push(\"\".concat(_x.toFixed(2), \",\").concat(_clampedY.toFixed(2)));\n        }\n\n        // Construct the path data string for one bar\n        var pathData = \"M \".concat(topPoints[0], \" L \").concat(topPoints.slice(1).join(' L '), \" L \").concat(bottomPoints.join(' L '), \" Z\");\n\n        // Add the path element to the SVG string\n        svgPaths += \"<path d=\\\"\".concat(pathData, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\\n\");\n      }\n      return svgPaths;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(WavyBars, \"parameters\", {\n  numBars: {\n    type: 'number',\n    min: 1,\n    max: 10,\n    step: 1,\n    \"default\": 5,\n    label: 'Number of Bars'\n  },\n  barHeight: {\n    type: 'number',\n    min: 5,\n    max: 50,\n    step: 1,\n    \"default\": 20,\n    label: 'Bar Height'\n  },\n  gap: {\n    type: 'number',\n    min: 0,\n    max: 30,\n    step: 1,\n    \"default\": 10,\n    label: 'Gap Between Bars'\n  },\n  amplitude: {\n    type: 'number',\n    min: 0,\n    max: 35,\n    // Adjusted to prevent excessive overlap with defaults\n    step: 1,\n    \"default\": 10,\n    label: 'Wave Amplitude'\n  },\n  frequency: {\n    type: 'number',\n    min: 0.25,\n    max: 4,\n    step: 0.05,\n    \"default\": 1,\n    label: 'Wave Frequency'\n  },\n  phaseShift: {\n    type: 'number',\n    min: -100,\n    max: 100,\n    step: 5,\n    \"default\": 0,\n    label: 'Wave Phase Shift'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WavyBars);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/WavyBars.js?");

/***/ }),

/***/ "./src/shapes/WavyHourglass.js":
/*!*************************************!*\
  !*** ./src/shapes/WavyHourglass.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a symmetrical hourglass/infinity shape using two intersecting,\n * filled wavy curves with modulated thickness.\n */\nvar WavyHourglass = /*#__PURE__*/function (_Shape) {\n  function WavyHourglass() {\n    _classCallCheck(this, WavyHourglass);\n    return _callSuper(this, WavyHourglass, arguments);\n  }\n  _inherits(WavyHourglass, _Shape);\n  return _createClass(WavyHourglass, [{\n    key: \"_calculateCenterlinePoints\",\n    value: function _calculateCenterlinePoints(P0, P3, numPoints, waviness, waveFreq, ctrlFactorTop, ctrlFactorBottom, flipWave) {\n      var Mid = {\n        x: 0,\n        y: 0\n      };\n      var points = [];\n      var epsilon = 1 / (numPoints * 10); // Small step for tangent calculation\n\n      // Define base control points for the Cubic Bezier curve (similar logic to previous Quadratic)\n      // CP1 pulls from P0 towards Mid, CP2 pulls from Mid towards P3\n      // For Cubic (P0, CP1, CP2, P3):\n      var baseCP1 = {\n        x: P0.x * (1 - ctrlFactorTop),\n        y: P0.y * (1 - ctrlFactorTop)\n      };\n      var baseCP2 = {\n        x: P3.x * ctrlFactorBottom,\n        y: P3.y * ctrlFactorBottom // Adjust based on desired curve shape towards the end\n      };\n\n      // Calculate point on the base Cubic Bezier curve\n      var getBezierPoint = function getBezierPoint(t, p0, cp1, cp2, p3) {\n        var mt = 1 - t;\n        var mt2 = mt * mt;\n        var t2 = t * t;\n        var mt3 = mt2 * mt;\n        var t3 = t2 * t;\n        var x = mt3 * p0.x + 3 * mt2 * t * cp1.x + 3 * mt * t2 * cp2.x + t3 * p3.x;\n        var y = mt3 * p0.y + 3 * mt2 * t * cp1.y + 3 * mt * t2 * cp2.y + t3 * p3.y;\n        return {\n          x: x,\n          y: y\n        };\n      };\n      for (var i = 0; i <= numPoints; i++) {\n        var t = i / numPoints;\n\n        // Point on the base smooth curve\n        var basePt = getBezierPoint(t, P0, baseCP1, baseCP2, P3);\n\n        // Calculate direction vector (approx tangent) of the base curve for perpendicular offset\n        var basePtAhead = getBezierPoint(Math.min(1, t + epsilon), P0, baseCP1, baseCP2, P3);\n        var basePtBehind = getBezierPoint(Math.max(0, t - epsilon), P0, baseCP1, baseCP2, P3);\n        var baseTangentX = basePtAhead.x - basePtBehind.x;\n        var baseTangentY = basePtAhead.y - basePtBehind.y;\n        var baseTangentLen = Math.sqrt(baseTangentX * baseTangentX + baseTangentY * baseTangentY);\n        var baseNormalX = baseTangentLen === 0 ? 0 : -baseTangentY / baseTangentLen;\n        var baseNormalY = baseTangentLen === 0 ? 1 : baseTangentX / baseTangentLen;\n\n        // Add waviness perpendicular to the base curve direction\n        var waveOffset = waviness * Math.sin(t * waveFreq * Math.PI);\n        var waveSign = flipWave ? -1 : 1;\n        var ptX = basePt.x + waveSign * waveOffset * baseNormalX;\n        var ptY = basePt.y + waveSign * waveOffset * baseNormalY;\n\n        // Calculate tangent of the final wavy curve using numerical differentiation\n        var ptAhead = this._getWavyPoint(Math.min(1, t + epsilon), P0, P3, baseCP1, baseCP2, waviness, waveFreq, waveSign, baseNormalX, baseNormalY);\n        var ptBehind = this._getWavyPoint(Math.max(0, t - epsilon), P0, P3, baseCP1, baseCP2, waviness, waveFreq, waveSign, baseNormalX, baseNormalY);\n        var tangentX = ptAhead.x - ptBehind.x;\n        var tangentY = ptAhead.y - ptBehind.y;\n        var tangentLen = Math.sqrt(tangentX * tangentX + tangentY * tangentY);\n        points.push({\n          x: ptX,\n          y: ptY,\n          t: t,\n          // Parameter 't' represents progress along the curve (0=top, 1=bottom)\n          tangent: {\n            x: tangentLen === 0 ? 1 : tangentX / tangentLen,\n            y: tangentLen === 0 ? 0 : tangentY / tangentLen\n          }\n        });\n      }\n      return points;\n    }\n\n    // Helper to get a single wavy point for tangent calculation\n  }, {\n    key: \"_getWavyPoint\",\n    value: function _getWavyPoint(t, P0, P3, baseCP1, baseCP2, waviness, waveFreq, waveSign, normalX, normalY) {\n      var getBezierPoint = function getBezierPoint(tt, p0, cp1, cp2, p3) {\n        // Duplicated for scope\n        var mt = 1 - tt;\n        var mt2 = mt * mt;\n        var t2 = tt * tt;\n        var mt3 = mt2 * mt;\n        var t3 = t2 * tt;\n        var x = mt3 * p0.x + 3 * mt2 * tt * cp1.x + 3 * mt * t2 * cp2.x + t3 * p3.x;\n        var y = mt3 * p0.y + 3 * mt2 * tt * cp1.y + 3 * mt * t2 * cp2.y + t3 * p3.y;\n        return {\n          x: x,\n          y: y\n        };\n      };\n      var basePt = getBezierPoint(t, P0, baseCP1, baseCP2, P3);\n      // NOTE: Using the normal calculated at the central 't' for nearby points - approximation\n      var waveOffset = waviness * Math.sin(t * waveFreq * Math.PI);\n      var ptX = basePt.x + waveSign * waveOffset * normalX;\n      var ptY = basePt.y + waveSign * waveOffset * normalY;\n      return {\n        x: ptX,\n        y: ptY\n      };\n    }\n  }, {\n    key: \"_getThickness\",\n    value: function _getThickness(t) {\n      var progress = Math.pow(t, this.thicknessPower);\n      return this.minThickness + (this.maxThickness - this.minThickness) * progress;\n    }\n  }, {\n    key: \"_createSmoothOutlinePath\",\n    value: function _createSmoothOutlinePath(leftPoints, rightPoints) {\n      if (!leftPoints || leftPoints.length < 2 || !rightPoints || rightPoints.length < 2) return '';\n\n      // Helper to generate smooth curve segments (simplified version)\n      var createCurve = function createCurve(points) {\n        if (!points || points.length < 2) return '';\n        var d = '';\n        var tension = 0.3; // Adjust for smoother/tighter curves\n        for (var i = 0; i < points.length - 1; i++) {\n          var p1 = points[i];\n          var p2 = points[i + 1];\n          var p0 = points[Math.max(0, i - 1)];\n          var p3 = points[Math.min(points.length - 1, i + 2)];\n\n          // Catmull-Rom style control points (simplified)\n          var cp1x = p1.x + (p2.x - p0.x) * tension / 3;\n          var cp1y = p1.y + (p2.y - p0.y) * tension / 3;\n          var cp2x = p2.x - (p3.x - p1.x) * tension / 3;\n          var cp2y = p2.y - (p3.y - p1.y) * tension / 3;\n          d += \" C \".concat(cp1x.toFixed(3), \",\").concat(cp1y.toFixed(3), \" \").concat(cp2x.toFixed(3), \",\").concat(cp2y.toFixed(3), \" \").concat(p2.x.toFixed(3), \",\").concat(p2.y.toFixed(3));\n        }\n        return d;\n      };\n\n      // Path: Move to start of left, curve along left, Line/Curve to start of right (reversed), curve along right (reversed), Close\n      var leftCurve = createCurve(leftPoints);\n      var rightCurveReversed = createCurve(rightPoints.slice().reverse()); // Create curve from reversed points\n\n      var M = \"M \".concat(leftPoints[0].x.toFixed(3), \",\").concat(leftPoints[0].y.toFixed(3));\n      var L_EndCap = \" L \".concat(rightPoints[rightPoints.length - 1].x.toFixed(3), \",\").concat(rightPoints[rightPoints.length - 1].y.toFixed(3)); // Connect end of left to end of right\n      var L_StartCap = \" L \".concat(leftPoints[0].x.toFixed(3), \",\").concat(leftPoints[0].y.toFixed(3)); // Connect start of right (reversed) back to start of left\n\n      // Combine segments\n      // M left_start | Curve Left | Line to right_end | M right_end | Curve Right Reversed | Line to left_start | Z\n      // Correct combination:\n      var pathData = M + leftCurve; // M p0 C ... pN (left)\n      pathData += L_EndCap; // L right_end\n      // Start the right curve segment from the current point (right_end)\n      pathData += rightCurveReversed; // C ... p0 (right reversed)\n      pathData += L_StartCap; // L left_start\n      pathData += ' Z';\n      return pathData.replace(/\\s+/g, ' '); // Clean up whitespace\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      // Define key points for the two centerlines\n      var P0_1 = {\n        x: -this.topX,\n        y: this.topY\n      }; // Top-Left start\n      var P3_1 = {\n        x: this.bottomWidth,\n        y: -this.bottomY\n      }; // Bottom-Right end\n      var P0_2 = {\n        x: this.topX,\n        y: this.topY\n      }; // Top-Right start\n      var P3_2 = {\n        x: -this.bottomWidth,\n        y: -this.bottomY\n      }; // Bottom-Left end\n\n      var numPoints = this.numPoints;\n\n      // Calculate centerline points for both curves\n      var centerline1 = this._calculateCenterlinePoints(P0_1, P3_1, numPoints, this.waviness, this.waveFreq, this.ctrlFactorTop, this.ctrlFactorBottom, false);\n      var centerline2 = this._calculateCenterlinePoints(P0_2, P3_2, numPoints, this.waviness, this.waveFreq, this.ctrlFactorTop, this.ctrlFactorBottom, true); // Flip wave\n\n      var svgElements = [];\n\n      // Generate filled paths for each centerline\n      [centerline1, centerline2].forEach(function (centerline) {\n        if (centerline.length < 2) return;\n        var leftPoints = [];\n        var rightPoints = [];\n\n        // Calculate offset points\n        var _iterator = _createForOfIteratorHelper(centerline),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var point = _step.value;\n            var thickness = _this._getThickness(point.t);\n            var tangent = point.tangent;\n            // Normal vector: (-ty, tx)\n            var normalX = -tangent.y;\n            var normalY = tangent.x;\n            var halfThickness = thickness / 2;\n            leftPoints.push({\n              x: point.x + normalX * halfThickness,\n              y: point.y + normalY * halfThickness\n            });\n            rightPoints.push({\n              x: point.x - normalX * halfThickness,\n              y: point.y - normalY * halfThickness\n            });\n          }\n\n          // Create the smooth outline path\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        var pathData = _this._createSmoothOutlinePath(leftPoints, rightPoints);\n        if (pathData) {\n          svgElements.push(\"<path d=\\\"\".concat(pathData, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\"/>\"));\n        }\n      });\n      return svgElements.join('\\n');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(WavyHourglass, \"parameters\", {\n  topY: {\n    type: 'number',\n    min: 5,\n    max: 95,\n    step: 1,\n    \"default\": 55,\n    label: 'Top Y Extent'\n  },\n  topX: {\n    type: 'number',\n    min: 5,\n    max: 95,\n    step: 1,\n    \"default\": 35,\n    label: 'Top X Width (Half)'\n  },\n  bottomY: {\n    type: 'number',\n    min: 5,\n    max: 95,\n    step: 1,\n    \"default\": 60,\n    label: 'Bottom Y Extent'\n  },\n  bottomWidth: {\n    type: 'number',\n    min: 5,\n    max: 95,\n    step: 1,\n    \"default\": 80,\n    label: 'Bottom Width (Half)'\n  },\n  minThickness: {\n    type: 'number',\n    min: 0.5,\n    max: 15,\n    step: 0.1,\n    \"default\": 1,\n    label: 'Min Thickness (Top)'\n  },\n  maxThickness: {\n    type: 'number',\n    min: 1,\n    max: 30,\n    step: 0.1,\n    \"default\": 15,\n    label: 'Max Thickness (Bottom)'\n  },\n  thicknessPower: {\n    type: 'number',\n    min: 0.5,\n    max: 4,\n    step: 0.1,\n    \"default\": 1.5,\n    label: 'Thickness Distribution Power'\n  },\n  waviness: {\n    type: 'number',\n    min: 0,\n    max: 30,\n    step: 1,\n    \"default\": 8,\n    label: 'Waviness Amplitude'\n  },\n  waveFreq: {\n    type: 'number',\n    min: 0,\n    max: 8,\n    step: 0.1,\n    \"default\": 1.5,\n    label: 'Wave Frequency'\n  },\n  ctrlFactorTop: {\n    type: 'number',\n    min: 0.1,\n    max: 1.5,\n    step: 0.05,\n    \"default\": 0.8,\n    label: 'Top Control Point Factor'\n  },\n  ctrlFactorBottom: {\n    type: 'number',\n    min: 0.1,\n    max: 1.5,\n    step: 0.05,\n    \"default\": 0.7,\n    label: 'Bottom Control Point Factor'\n  },\n  numPoints: {\n    type: 'number',\n    min: 10,\n    max: 100,\n    step: 1,\n    \"default\": 50,\n    label: 'Curve Points'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WavyHourglass);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/WavyHourglass.js?");

/***/ }),

/***/ "./src/shapes/WavyLine.js":
/*!********************************!*\
  !*** ./src/shapes/WavyLine.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates an extruded 3D wavy line shape with perspective and rotation.\n */\nvar WavyLine = /*#__PURE__*/function (_Shape) {\n  function WavyLine() {\n    _classCallCheck(this, WavyLine);\n    return _callSuper(this, WavyLine, arguments);\n  }\n  _inherits(WavyLine, _Shape);\n  return _createClass(WavyLine, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      // Convert rotation values from degrees to radians\n      var rotX = this.rotationX * Math.PI / 180;\n      var rotY = this.rotationY * Math.PI / 180;\n      var rotZ = this.rotationZ * Math.PI / 180;\n\n      // Generate the two waves with extrusion\n      var path = this.generateExtrudedWave();\n\n      // Rotate all points for 3D effect\n      var rotatedPath = path.map(function (point) {\n        return _this.rotate3D(point.x, point.y, point.z, rotX, rotY, rotZ);\n      });\n\n      // Create SVG path from the rotated points\n      var pathData = this.pointsToSvgPath(rotatedPath);\n      return \"<path d=\\\"\".concat(pathData, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\");\n    }\n  }, {\n    key: \"generateExtrudedWave\",\n    value: function generateExtrudedWave() {\n      var points = [];\n      var totalWidth = this.wavelength * this.segments;\n      var startX = -totalWidth / 2;\n      var endX = totalWidth / 2;\n\n      // Number of points for smooth curves - increase for better quality\n      var numPoints = Math.max(100, this.segments * 50);\n\n      // Front face (top wave)\n      for (var i = 0; i < numPoints; i++) {\n        var t = i / (numPoints - 1);\n        var x = startX + t * (endX - startX);\n        var y = Math.sin(t * Math.PI * this.segments) * this.amplitude;\n        var z = this.depth / 2; // Front face\n\n        points.push({\n          x: x,\n          y: y,\n          z: z\n        });\n      }\n\n      // Right side connection - add extra points for smooth connection\n      var rightFront = points[points.length - 1];\n      var rightBack = {\n        x: rightFront.x,\n        y: rightFront.y,\n        z: -this.depth / 2\n      };\n\n      // Add the corner point\n      points.push(rightBack);\n\n      // Back face (bottom wave) - in reverse order for proper path construction\n      for (var _i = numPoints - 1; _i >= 0; _i--) {\n        var _t = _i / (numPoints - 1);\n        var _x = startX + _t * (endX - startX);\n        var _y = Math.sin(_t * Math.PI * this.segments) * this.amplitude;\n        var _z = -this.depth / 2; // Back face\n\n        points.push({\n          x: _x,\n          y: _y,\n          z: _z\n        });\n      }\n\n      // Left side connection - add the final corner point to close the shape\n      var leftBack = points[points.length - 1];\n      var leftFront = {\n        x: leftBack.x,\n        y: leftBack.y,\n        z: this.depth / 2\n      };\n\n      // Add the corner point to complete the loop\n      points.push(leftFront);\n      return points;\n    }\n  }, {\n    key: \"pointsToSvgPath\",\n    value: function pointsToSvgPath(points) {\n      if (points.length < 3) return '';\n      var pathData = \"M \".concat(points[0].x, \",\").concat(points[0].y);\n\n      // Draw the entire shape using simple line segments for a clean look\n      for (var i = 1; i < points.length; i++) {\n        pathData += \" L \".concat(points[i].x, \",\").concat(points[i].y);\n      }\n\n      // Close the path\n      pathData += ' Z';\n      return pathData;\n    }\n  }, {\n    key: \"rotate3D\",\n    value: function rotate3D(x, y, z, rotX, rotY, rotZ) {\n      // Rotate around Z axis\n      var x1 = x * Math.cos(rotZ) - y * Math.sin(rotZ);\n      var y1 = x * Math.sin(rotZ) + y * Math.cos(rotZ);\n\n      // Rotate around X axis\n      var y2 = y1 * Math.cos(rotX) - z * Math.sin(rotX);\n      var z2 = y1 * Math.sin(rotX) + z * Math.cos(rotX);\n\n      // Rotate around Y axis\n      var x3 = x1 * Math.cos(rotY) + z2 * Math.sin(rotY);\n      var z3 = -x1 * Math.sin(rotY) + z2 * Math.cos(rotY);\n      return {\n        x: x3,\n        y: y2,\n        z: z3\n      };\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(WavyLine, \"parameters\", {\n  wavelength: {\n    min: 50,\n    max: 100,\n    \"default\": 100\n  },\n  amplitude: {\n    min: 10,\n    max: 100,\n    \"default\": 80\n  },\n  segments: {\n    min: 1,\n    max: 5,\n    \"default\": 2\n  },\n  depth: {\n    min: 10,\n    max: 100,\n    \"default\": 60\n  },\n  rotationX: {\n    min: -180,\n    max: 180,\n    \"default\": -45\n  },\n  rotationY: {\n    min: -180,\n    max: 180,\n    \"default\": 0\n  },\n  rotationZ: {\n    min: -180,\n    max: 180,\n    \"default\": -90\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WavyLine);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/WavyLine.js?");

/***/ }),

/***/ "./src/shapes/WavyLine3D.js":
/*!**********************************!*\
  !*** ./src/shapes/WavyLine3D.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates multiple parallel wavy lines in 3D space with noise, perspective,\n * and rotation.\n */\nvar WavyLine3D = /*#__PURE__*/function (_Shape) {\n  function WavyLine3D() {\n    _classCallCheck(this, WavyLine3D);\n    return _callSuper(this, WavyLine3D, arguments);\n  }\n  _inherits(WavyLine3D, _Shape);\n  return _createClass(WavyLine3D, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      var rotX = this.rotationX * Math.PI / 180;\n      var rotY = this.rotationY * Math.PI / 180;\n      var rotZ = this.rotationZ * Math.PI / 180;\n      var paths = [];\n      var center = {\n        x: 0,\n        y: 0,\n        z: 0\n      };\n      for (var l = 0; l < this.lines; l++) {\n        var lineRatio = l / (this.lines - 1);\n        var yOffset = (lineRatio - 0.5) * this.amplitude * 2;\n        var pathPoints = this.generateHorizontalPath(lineRatio, yOffset);\n        paths.push(pathPoints);\n      }\n      var rotatedPaths = paths.map(function (path) {\n        return path.map(function (point) {\n          return _objectSpread(_objectSpread({}, point), {}, {\n            rotated: _this.rotate3D(point.x - center.x, point.y - center.y, point.z - center.z, rotX, rotY, rotZ)\n          });\n        });\n      });\n      var pathsWithDepth = rotatedPaths.map(function (path) {\n        var avgZ = path.reduce(function (sum, p) {\n          return sum + p.rotated.z;\n        }, 0) / path.length;\n        return {\n          path: path,\n          avgZ: avgZ\n        };\n      });\n      pathsWithDepth.sort(function (a, b) {\n        return b.avgZ - a.avgZ;\n      });\n      var elements = [];\n      var _iterator = _createForOfIteratorHelper(pathsWithDepth),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var path = _step.value.path;\n          var pathData = this.pointsToSvgPath(path);\n\n          // Calculate line thickness based on z-depth instead of opacity\n          var avgZ = path.reduce(function (sum, p) {\n            return sum + p.rotated.z;\n          }, 0) / path.length;\n          var zFactor = (avgZ + 50) / 100;\n          var scaledThickness = (this.thickness * (0.5 + zFactor)).toFixed(2);\n          elements.push(\"<path\\n        d=\\\"\".concat(pathData, \"\\\"\\n        stroke=\\\"white\\\"\\n        stroke-width=\\\"\").concat(scaledThickness, \"\\\"\\n        fill=\\\"none\\\"\\n        stroke-linejoin=\\\"round\\\"\\n        stroke-linecap=\\\"round\\\"\\n      />\"));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return elements.join('');\n    }\n  }, {\n    key: \"generateHorizontalPath\",\n    value: function generateHorizontalPath(lineRatio, yOffset) {\n      var points = [];\n      var totalWidth = this.wavelength * this.segments;\n      var startX = -totalWidth / 2;\n      var endX = totalWidth / 2;\n      var numPoints = this.segments * 16 + 1;\n      for (var i = 0; i < numPoints; i++) {\n        var t = i / (numPoints - 1);\n        var x = startX + t * (endX - startX);\n        var phase = lineRatio * 0.2;\n        var smoothT = t * t * (3 - 2 * t);\n        var baseY = Math.sin((smoothT + phase) * Math.PI * this.segments) * this.amplitude;\n        var noise = this.getNoise(smoothT * 3, lineRatio * 2, this.seed / 500) * this.noiseStrength;\n        var noiseInfluence = noise * (0.3 + 0.4 * Math.sin(lineRatio * Math.PI));\n        var zFactor = 0.8 - 0.4 * Math.abs(lineRatio - 0.5) * 2;\n        var zBase = Math.cos((smoothT + phase) * Math.PI * this.segments) * this.depth * 0.5 * zFactor;\n        var zNoise = this.getNoise(smoothT * 2, lineRatio * 1.5, this.seed / 400) * this.noiseStrength * 0.3;\n        var z = zBase + zNoise;\n        var xNoise = this.getNoise(smoothT * 2, lineRatio, this.seed / 300) * this.noiseStrength * 0.2;\n        var y = baseY + noiseInfluence + yOffset;\n        points.push({\n          x: x + xNoise,\n          y: y,\n          z: z\n        });\n      }\n      return points;\n    }\n  }, {\n    key: \"pointsToSvgPath\",\n    value: function pointsToSvgPath(points) {\n      if (points.length < 2) return '';\n      var pathData = \"M \".concat(points[0].rotated.x, \",\").concat(points[0].rotated.y);\n      if (points.length <= 3) {\n        for (var i = 0; i < points.length - 1; i++) {\n          var current = points[i].rotated;\n          var next = points[i + 1].rotated;\n          var dx = next.x - current.x;\n          var dy = next.y - current.y;\n          var ctrlFactor = this.curvature * 0.4;\n          var cp1x = current.x + dx * ctrlFactor;\n          var cp1y = current.y + dy * ctrlFactor;\n          var cp2x = next.x - dx * ctrlFactor;\n          var cp2y = next.y - dy * ctrlFactor;\n          pathData += \" C \".concat(cp1x, \",\").concat(cp1y, \" \").concat(cp2x, \",\").concat(cp2y, \" \").concat(next.x, \",\").concat(next.y);\n        }\n      } else {\n        for (var _i = 0; _i < points.length - 1; _i++) {\n          var p0 = points[Math.max(0, _i - 1)].rotated;\n          var p1 = points[_i].rotated;\n          var p2 = points[_i + 1].rotated;\n          var p3 = points[Math.min(points.length - 1, _i + 2)].rotated;\n          var tension = 1 - this.curvature * 0.8;\n          var _cp1x = p1.x + (p2.x - p0.x) / 6 * tension;\n          var _cp1y = p1.y + (p2.y - p0.y) / 6 * tension;\n          var _cp2x = p2.x - (p3.x - p1.x) / 6 * tension;\n          var _cp2y = p2.y - (p3.y - p1.y) / 6 * tension;\n          pathData += \" C \".concat(_cp1x, \",\").concat(_cp1y, \" \").concat(_cp2x, \",\").concat(_cp2y, \" \").concat(p2.x, \",\").concat(p2.y);\n        }\n      }\n      return pathData;\n    }\n  }, {\n    key: \"rotate3D\",\n    value: function rotate3D(x, y, z, rotX, rotY, rotZ) {\n      var x1 = x * Math.cos(rotZ) - y * Math.sin(rotZ);\n      var y1 = x * Math.sin(rotZ) + y * Math.cos(rotZ);\n      var y2 = y1 * Math.cos(rotX) - z * Math.sin(rotX);\n      var z2 = y1 * Math.sin(rotX) + z * Math.cos(rotX);\n      var x3 = x1 * Math.cos(rotY) + z2 * Math.sin(rotY);\n      var z3 = -x1 * Math.sin(rotY) + z2 * Math.cos(rotY);\n      return {\n        x: x3,\n        y: y2,\n        z: z3\n      };\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(WavyLine3D, \"parameters\", {\n  thickness: {\n    min: 0.5,\n    max: 10,\n    \"default\": 1.5\n  },\n  wavelength: {\n    min: 50,\n    max: 200,\n    \"default\": 120\n  },\n  amplitude: {\n    min: 10,\n    max: 100,\n    \"default\": 50\n  },\n  segments: {\n    min: 3,\n    max: 12,\n    \"default\": 4\n  },\n  lines: {\n    min: 3,\n    max: 20,\n    \"default\": 12\n  },\n  depth: {\n    min: 10,\n    max: 100,\n    \"default\": 40\n  },\n  noiseScale: {\n    min: 0.1,\n    max: 2,\n    \"default\": 0.6\n  },\n  noiseStrength: {\n    min: 0,\n    max: 100,\n    \"default\": 15\n  },\n  curvature: {\n    min: 0.1,\n    max: 1,\n    \"default\": 0.8\n  },\n  rotationX: {\n    min: -180,\n    max: 180,\n    \"default\": 20\n  },\n  rotationY: {\n    min: -180,\n    max: 180,\n    \"default\": 10\n  },\n  rotationZ: {\n    min: -180,\n    max: 180,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WavyLine3D);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/WavyLine3D.js?");

/***/ }),

/***/ "./src/shapes/WovenBars.js":
/*!*********************************!*\
  !*** ./src/shapes/WovenBars.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a pattern of interwoven vertical bars, resembling a woven structure.\n * Alternating columns are either full-height bars or segmented bars,\n * creating an overlapping visual effect.\n */\nvar WovenBars = /*#__PURE__*/function (_Shape) {\n  function WovenBars() {\n    _classCallCheck(this, WovenBars);\n    return _callSuper(this, WovenBars, arguments);\n  }\n  _inherits(WovenBars, _Shape);\n  return _createClass(WovenBars, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var backgroundRects = [];\n      var foregroundRects = [];\n\n      // --- Calculate Dimensions ---\n      var columnWidth = this.totalWidth / this.numColumns;\n      var barWidth = columnWidth * this.barWidthRatio;\n      var gapWidth = columnWidth - barWidth; // Horizontal gap\n\n      // Calculate vertical units based on segment rows and gaps around them\n      // There are numSegmentRows segments and (numSegmentRows + 1) gaps\n      var totalVerticalUnits = this.numSegmentRows * this.rowHeightRatio + (this.numSegmentRows + 1);\n      if (totalVerticalUnits <= 0) return ''; // Avoid division by zero\n\n      var unitHeight = this.totalHeight / totalVerticalUnits;\n      var actualSegmentHeight = unitHeight * this.rowHeightRatio;\n      var actualGapHeight = unitHeight;\n      var startX = -this.totalWidth / 2;\n      var startY = -this.totalHeight / 2;\n\n      // --- Generate Rectangles ---\n      for (var j = 0; j < this.numColumns; j++) {\n        var x = startX + j * columnWidth + gapWidth / 2; // Center bar within column width\n\n        // Even columns (0, 2, ...) are background bars\n        if (j % 2 === 0) {\n          backgroundRects.push(\"<rect x=\\\"\".concat(x.toFixed(2), \"\\\" y=\\\"\").concat(startY.toFixed(2), \"\\\" width=\\\"\").concat(barWidth.toFixed(2), \"\\\" height=\\\"\").concat(this.totalHeight.toFixed(2), \"\\\" fill=\\\"white\\\" />\"));\n        }\n        // Odd columns (1, 3, ...) are foreground segments\n        else {\n          var currentY = startY;\n          for (var i = 0; i < this.numSegmentRows; i++) {\n            currentY += actualGapHeight; // Add gap height before placing the segment\n            var segmentY = currentY;\n\n            // Add segment rectangle\n            foregroundRects.push(\"<rect x=\\\"\".concat(x.toFixed(2), \"\\\" y=\\\"\").concat(segmentY.toFixed(2), \"\\\" width=\\\"\").concat(barWidth.toFixed(2), \"\\\" height=\\\"\").concat(actualSegmentHeight.toFixed(2), \"\\\" fill=\\\"white\\\" />\"));\n            currentY += actualSegmentHeight; // Advance Y position past the segment\n          }\n        }\n      }\n\n      // Return background bars first, then foreground segments on top\n      return backgroundRects.join('\\n') + '\\n' + foregroundRects.join('\\n');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(WovenBars, \"parameters\", {\n  numColumns: {\n    type: 'number',\n    min: 2,\n    max: 30,\n    step: 2,\n    // Ensure pairs for alternating pattern\n    \"default\": 8,\n    label: 'Number of Columns'\n  },\n  numSegmentRows: {\n    type: 'number',\n    min: 1,\n    max: 15,\n    step: 1,\n    \"default\": 3,\n    label: 'Number of Segment Rows'\n  },\n  barWidthRatio: {\n    type: 'number',\n    min: 0.1,\n    max: 0.95,\n    step: 0.05,\n    \"default\": 0.7,\n    label: 'Bar Width Ratio (vs Gap)'\n  },\n  rowHeightRatio: {\n    type: 'number',\n    min: 0.1,\n    max: 5.0,\n    step: 0.1,\n    \"default\": 1.0,\n    label: 'Segment Height Ratio (vs Gap)'\n  },\n  totalWidth: {\n    type: 'number',\n    min: 50,\n    max: 198,\n    step: 2,\n    \"default\": 160,\n    label: 'Total Width'\n  },\n  totalHeight: {\n    type: 'number',\n    min: 50,\n    max: 198,\n    step: 2,\n    \"default\": 180,\n    label: 'Total Height'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WovenBars);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/WovenBars.js?");

/***/ }),

/***/ "./src/shapes/ZigzagLogo.js":
/*!**********************************!*\
  !*** ./src/shapes/ZigzagLogo.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Generates a filled zigzag or lightning bolt shape with adjustable thickness,\n * amplitude, and segments, plus rotation.\n */\nvar ZigzagLogo = /*#__PURE__*/function (_Shape) {\n  function ZigzagLogo() {\n    _classCallCheck(this, ZigzagLogo);\n    return _callSuper(this, ZigzagLogo, arguments);\n  }\n  _inherits(ZigzagLogo, _Shape);\n  return _createClass(ZigzagLogo, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // --- Parameter Access ---\n      var numPoints = this.numSegments + 1; // Number of points needed to define numSegments lines\n      var angle = this.angle;\n      var thickness = this.thickness;\n      var baseAmplitude = this.amplitude;\n      // Calculate absolute variation range based on the factor\n      var ampVariationRange = this.amplitudeVariation * baseAmplitude;\n      var baseWidth = this.baseWidth;\n      var segmentLength = baseWidth / this.numSegments;\n      var halfThickness = thickness / 2;\n      var startX = -baseWidth / 2;\n\n      // --- Point Generation ---\n      var topPoints = [];\n      var bottomPoints = [];\n      for (var i = 0; i < numPoints; i++) {\n        var currentX = startX + i * segmentLength;\n\n        // Calculate the amplitude for this point, applying random variation\n        // this.random() returns [0, 1), so scale to [-0.5, 0.5) and multiply by range\n        var randomAmpOffset = ampVariationRange * (this.random() - 0.5) * 2;\n        var currentAmp = baseAmplitude + randomAmpOffset;\n\n        // Alternate centerline Y between peaks (positive) and valleys (negative)\n        // The reference image starts high-left and zigzags down-right.\n        // Before rotation, this means the first point (i=0) should correspond to a peak.\n        var centerlineY = i % 2 === 0 ? currentAmp : -currentAmp;\n\n        // Calculate the final points for the top and bottom edges by offsetting vertically\n        topPoints.push({\n          x: currentX,\n          y: centerlineY + halfThickness\n        });\n        bottomPoints.push({\n          x: currentX,\n          y: centerlineY - halfThickness\n        });\n      }\n\n      // --- SVG Path Construction ---\n      // Start at the first top point\n      var pathData = \"M \".concat(topPoints[0].x.toFixed(2), \",\").concat(topPoints[0].y.toFixed(2));\n\n      // Draw the top edge line segments\n      for (var _i = 1; _i < numPoints; _i++) {\n        pathData += \" L \".concat(topPoints[_i].x.toFixed(2), \",\").concat(topPoints[_i].y.toFixed(2));\n      }\n\n      // Draw the bottom edge line segments in reverse order\n      // This implicitly draws the right end-cap (line from topPoints[n-1] to bottomPoints[n-1])\n      for (var _i2 = numPoints - 1; _i2 >= 0; _i2--) {\n        pathData += \" L \".concat(bottomPoints[_i2].x.toFixed(2), \",\").concat(bottomPoints[_i2].y.toFixed(2));\n      }\n\n      // Close the path\n      // This implicitly draws the left end-cap (line from bottomPoints[0] to topPoints[0])\n      pathData += \" Z\";\n\n      // --- Final SVG Output ---\n      // Apply the overall rotation using a group (<g>) element\n      return \"\\n            <g transform=\\\"rotate(\".concat(angle, \")\\\">\\n                <path d=\\\"\").concat(pathData, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\\n            </g>\\n        \");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(ZigzagLogo, \"parameters\", {\n  numSegments: {\n    type: 'number',\n    min: 1,\n    max: 10,\n    step: 1,\n    \"default\": 4,\n    description: \"Number of zigzag points (peaks/valleys)\"\n  },\n  angle: {\n    type: 'number',\n    min: -90,\n    max: 90,\n    step: 1,\n    \"default\": -35,\n    description: \"Overall rotation angle (degrees)\"\n  },\n  thickness: {\n    type: 'number',\n    min: 5,\n    max: 80,\n    step: 1,\n    \"default\": 35,\n    description: \"Width/thickness of the zigzag band\"\n  },\n  amplitude: {\n    type: 'number',\n    min: 5,\n    max: 60,\n    step: 1,\n    \"default\": 25,\n    description: \"Base height of peaks/valleys from center\"\n  },\n  amplitudeVariation: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    step: 0.05,\n    \"default\": 0.4,\n    description: \"Random variation factor for amplitude (0=none, 1=max)\"\n  },\n  baseWidth: {\n    type: 'number',\n    min: 50,\n    max: 190,\n    step: 5,\n    \"default\": 160,\n    description: \"Horizontal width of the zigzag before rotation\"\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ZigzagLogo);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/ZigzagLogo.js?");

/***/ }),

/***/ "./src/shapesRegistry.js":
/*!*******************************!*\
  !*** ./src/shapesRegistry.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar shapeModules = __webpack_require__(\"./src/shapes sync ^\\\\.\\\\/(?%21Shape).*\\\\.js$\");\nvar shapeRegistry = {};\nshapeModules.keys().forEach(function (key) {\n  var module = shapeModules(key);\n  var ShapeClass = module[\"default\"] || Object.values(module)[0];\n  if (ShapeClass && ShapeClass.name) {\n    shapeRegistry[ShapeClass.name] = ShapeClass;\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (shapeRegistry);\n\n//# sourceURL=webpack://generative-shapes/./src/shapesRegistry.js?");

/***/ }),

/***/ "./src/stylePresets.js":
/*!*****************************!*\
  !*** ./src/stylePresets.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar stylePresets = {\n  // Basic styles\n  'filled': {\n    name: 'Filled',\n    fillType: 'solid',\n    fillColor: '#ffffff',\n    strokeType: 'none',\n    fillOpacity: 1.0\n  },\n  'outline': {\n    name: 'Outline',\n    fillType: 'none',\n    strokeType: 'solid',\n    strokeColor: '#FFFFFF',\n    strokeWidth: 2\n  },\n  'neon': {\n    name: 'Neon',\n    fillType: 'solid',\n    fillColor: '#111111',\n    fillOpacity: 0.8,\n    strokeType: 'solid',\n    strokeColor: '#39FF14',\n    strokeWidth: 2\n  },\n  // Gradient styles\n  'sunset': {\n    name: 'Sunset',\n    fillType: 'linearGradient',\n    fillGradientColor1: '#FF5E62',\n    fillGradientColor2: '#FF9966',\n    fillGradientAngle: 45,\n    fillOpacity: 1.0,\n    strokeType: 'none'\n  },\n  'ocean': {\n    name: 'Ocean',\n    fillType: 'linearGradient',\n    fillGradientColor1: '#2E3192',\n    fillGradientColor2: '#1BFFFF',\n    fillGradientAngle: 90,\n    fillOpacity: 1.0,\n    strokeType: 'none'\n  },\n  'blueprint': {\n    name: 'Blueprint',\n    fillType: 'none',\n    strokeType: 'solid',\n    strokeColor: '#00CCFF',\n    strokeWidth: 1.5,\n    strokeDasharray: '5,2'\n  },\n  'candy': {\n    name: 'Candy',\n    fillType: 'linearGradient',\n    fillGradientColor1: '#FF61D2',\n    fillGradientColor2: '#FE9090',\n    fillGradientAngle: 120,\n    fillOpacity: 0.9,\n    strokeType: 'solid',\n    strokeColor: '#FFFFFF',\n    strokeWidth: 1.5\n  },\n  'midnight': {\n    name: 'Midnight',\n    fillType: 'radialGradient',\n    fillGradientColor1: '#20002c',\n    fillGradientColor2: '#000000',\n    fillOpacity: 1.0,\n    strokeType: 'solid',\n    strokeColor: '#6A5ACD',\n    strokeWidth: 1\n  },\n  'monochrome': {\n    name: 'Monochrome',\n    fillType: 'solid',\n    fillColor: '#333333',\n    fillOpacity: 1.0,\n    strokeType: 'solid',\n    strokeColor: '#999999',\n    strokeWidth: 1\n  },\n  // Modern and trending styles\n  'cyberpunk': {\n    name: 'Cyberpunk',\n    fillType: 'linearGradient',\n    fillGradientColor1: '#ff00ff',\n    fillGradientColor2: '#00ffff',\n    fillGradientAngle: 130,\n    fillOpacity: 0.9,\n    strokeType: 'solid',\n    strokeColor: '#ffff00',\n    strokeWidth: 2\n  },\n  'vaporwave': {\n    name: 'Vaporwave',\n    fillType: 'linearGradient',\n    fillGradientColor1: '#ff71ce',\n    fillGradientColor2: '#b967ff',\n    fillGradientAngle: 45,\n    fillOpacity: 1.0,\n    strokeType: 'solid',\n    strokeColor: '#01cdfe',\n    strokeWidth: 1.5\n  },\n  'aurora': {\n    name: 'Aurora',\n    fillType: 'linearGradient',\n    fillGradientColor1: '#3fada8',\n    fillGradientColor2: '#5614b0',\n    fillGradientAngle: 135,\n    fillOpacity: 0.85,\n    strokeType: 'none'\n  },\n  // Nature-inspired\n  'emerald': {\n    name: 'Emerald',\n    fillType: 'linearGradient',\n    fillGradientColor1: '#43cea2',\n    fillGradientColor2: '#185a9d',\n    fillGradientAngle: 90,\n    fillOpacity: 1.0,\n    strokeType: 'none'\n  },\n  'crimson': {\n    name: 'Crimson',\n    fillType: 'solid',\n    fillColor: '#DC143C',\n    fillOpacity: 1.0,\n    strokeType: 'solid',\n    strokeColor: '#800000',\n    strokeWidth: 1.5\n  },\n  'ethereal': {\n    name: 'Ethereal',\n    fillType: 'radialGradient',\n    fillGradientColor1: '#ffffff',\n    fillGradientColor2: '#8e2de2',\n    fillOpacity: 0.8,\n    strokeType: 'none'\n  },\n  'golden': {\n    name: 'Golden',\n    fillType: 'linearGradient',\n    fillGradientColor1: '#f7971e',\n    fillGradientColor2: '#ffd200',\n    fillGradientAngle: 45,\n    fillOpacity: 1.0,\n    strokeType: 'solid',\n    strokeColor: '#ff8c00',\n    strokeWidth: 1\n  },\n  // Cosmic and space themes\n  'cosmic': {\n    name: 'Cosmic',\n    fillType: 'radialGradient',\n    fillGradientColor1: '#3A1C71',\n    fillGradientColor2: '#D76D77',\n    fillOpacity: 0.9,\n    strokeType: 'solid',\n    strokeColor: '#FFAF7B',\n    strokeWidth: 1\n  },\n  'frost': {\n    name: 'Frost',\n    fillType: 'linearGradient',\n    fillGradientColor1: '#a1c4fd',\n    fillGradientColor2: '#c2e9fb',\n    fillGradientAngle: 180,\n    fillOpacity: 0.9,\n    strokeType: 'solid',\n    strokeColor: '#ffffff',\n    strokeWidth: 0.8\n  },\n  'jungle': {\n    name: 'Jungle',\n    fillType: 'linearGradient',\n    fillGradientColor1: '#0fd850',\n    fillGradientColor2: '#00723f',\n    fillGradientAngle: 90,\n    fillOpacity: 1.0,\n    strokeType: 'none'\n  },\n  // Creative and artistic\n  'holographic': {\n    name: 'Holographic',\n    fillType: 'linearGradient',\n    fillGradientColor1: '#8A2387',\n    fillGradientColor2: '#F27121',\n    fillGradientAngle: 120,\n    fillOpacity: 0.7,\n    strokeType: 'solid',\n    strokeColor: '#C6FFDD',\n    strokeWidth: 1\n  },\n  'retro': {\n    name: 'Retro',\n    fillType: 'solid',\n    fillColor: '#fdbb2d',\n    fillOpacity: 1.0,\n    strokeType: 'solid',\n    strokeColor: '#b21f1f',\n    strokeWidth: 2\n  },\n  'pastel': {\n    name: 'Pastel',\n    fillType: 'linearGradient',\n    fillGradientColor1: '#ffdde1',\n    fillGradientColor2: '#ee9ca7',\n    fillGradientAngle: 45,\n    fillOpacity: 0.8,\n    strokeType: 'solid',\n    strokeColor: '#ffffff',\n    strokeWidth: 1\n  },\n  'electric': {\n    name: 'Electric',\n    fillType: 'linearGradient',\n    fillGradientColor1: '#0C0C0C',\n    fillGradientColor2: '#242424',\n    fillGradientAngle: 90,\n    fillOpacity: 1.0,\n    strokeType: 'solid',\n    strokeColor: '#00F2FF',\n    strokeWidth: 2\n  },\n  // Additional styles\n  'galaxy': {\n    name: 'Galaxy',\n    fillType: 'radialGradient',\n    fillGradientColor1: '#302b63',\n    fillGradientColor2: '#0f0c29',\n    fillOpacity: 0.9,\n    strokeType: 'solid',\n    strokeColor: '#24243e',\n    strokeWidth: 1\n  },\n  'bubblegum': {\n    name: 'Bubblegum',\n    fillType: 'linearGradient',\n    fillGradientColor1: '#FF0080',\n    fillGradientColor2: '#FF8C00',\n    fillGradientAngle: 45,\n    fillOpacity: 0.9,\n    strokeType: 'none'\n  },\n  'toxic': {\n    name: 'Toxic',\n    fillType: 'linearGradient',\n    fillGradientColor1: '#D3D3D3',\n    fillGradientColor2: '#4b6cb7',\n    fillGradientAngle: 60,\n    fillOpacity: 0.8,\n    strokeType: 'solid',\n    strokeColor: '#00FF00',\n    strokeWidth: 2\n  },\n  'cotton-candy': {\n    name: 'Cotton Candy',\n    fillType: 'linearGradient',\n    fillGradientColor1: '#D8B5FF',\n    fillGradientColor2: '#1EAE98',\n    fillGradientAngle: 90,\n    fillOpacity: 0.85,\n    strokeType: 'none'\n  },\n  'twilight': {\n    name: 'Twilight',\n    fillType: 'linearGradient',\n    fillGradientColor1: '#141E30',\n    fillGradientColor2: '#243B55',\n    fillGradientAngle: 180,\n    fillOpacity: 1.0,\n    strokeType: 'solid',\n    strokeColor: '#4b6cb7',\n    strokeWidth: 1\n  },\n  'coral': {\n    name: 'Coral',\n    fillType: 'solid',\n    fillColor: '#FF7F50',\n    fillOpacity: 0.9,\n    strokeType: 'solid',\n    strokeColor: '#FF6347',\n    strokeWidth: 1\n  },\n  'laser': {\n    name: 'Laser',\n    fillType: 'solid',\n    fillColor: '#000000',\n    fillOpacity: 1.0,\n    strokeType: 'solid',\n    strokeColor: '#FF0000',\n    strokeWidth: 2\n  }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stylePresets);\n\n//# sourceURL=webpack://generative-shapes/./src/stylePresets.js?");

/***/ }),

/***/ "./src/styles.css":
/*!************************!*\
  !*** ./src/styles.css ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!./styles.css */ \"./node_modules/css-loader/dist/cjs.js!./src/styles.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\noptions.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://generative-shapes/./src/styles.css?");

/***/ }),

/***/ "data:image/svg+xml;charset=UTF-8,%3csvg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 24 24%27 fill=%27none%27 stroke=%27%23999%27 stroke-width=%272%27 stroke-linecap=%27round%27 stroke-linejoin=%27round%27%3e%3cpolyline points=%276 9 12 15 18 9%27%3e%3c/polyline%3e%3c/svg%3e":
/*!****************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** data:image/svg+xml;charset=UTF-8,%3csvg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 24 24%27 fill=%27none%27 stroke=%27%23999%27 stroke-width=%272%27 stroke-linecap=%27round%27 stroke-linejoin=%27round%27%3e%3cpolyline points=%276 9 12 15 18 9%27%3e%3c/polyline%3e%3c/svg%3e ***!
  \****************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = \"data:image/svg+xml;charset=UTF-8,%3csvg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 24 24%27 fill=%27none%27 stroke=%27%23999%27 stroke-width=%272%27 stroke-linecap=%27round%27 stroke-linejoin=%27round%27%3e%3cpolyline points=%276 9 12 15 18 9%27%3e%3c/polyline%3e%3c/svg%3e\";\n\n//# sourceURL=webpack://generative-shapes/data:image/svg+xml;charset=UTF-8,%253csvg_xmlns=%2527http://www.w3.org/2000/svg%2527_viewBox=%25270_0_24_24%2527_fill=%2527none%2527_stroke=%2527%2523999%2527_stroke-width=%25272%2527_stroke-linecap=%2527round%2527_stroke-linejoin=%2527round%2527%253e%253cpolyline_points=%25276_9_12_15_18_9%2527%253e%253c/polyline%253e%253c/svg%253e?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = document.baseURI || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.js");
/******/ 	
/******/ })()
;